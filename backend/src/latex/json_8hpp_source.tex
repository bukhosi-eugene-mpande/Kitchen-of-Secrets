\hypertarget{json_8hpp_source}{}\doxysection{json.\+hpp}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{2 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{4 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{7 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{comment}{/****************************************************************************\(\backslash\)}}
\DoxyCodeLine{10 \textcolor{comment}{ * Note on documentation: The source files contain links to the online      *}}
\DoxyCodeLine{11 \textcolor{comment}{ * documentation of the public API at https://json.nlohmann.me. This URL    *}}
\DoxyCodeLine{12 \textcolor{comment}{ * contains the most recent documentation and should also be applicable to  *}}
\DoxyCodeLine{13 \textcolor{comment}{ * previous versions; documentation for deprecated functions is not         *}}
\DoxyCodeLine{14 \textcolor{comment}{ * removed, but marked deprecated. See "{}Generate documentation"{} section in  *}}
\DoxyCodeLine{15 \textcolor{comment}{ * file docs/README.md.                                                     *}}
\DoxyCodeLine{16 \textcolor{comment}{\(\backslash\)****************************************************************************/}}
\DoxyCodeLine{17 }
\DoxyCodeLine{18 \textcolor{preprocessor}{\#ifndef INCLUDE\_NLOHMANN\_JSON\_HPP\_}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#define INCLUDE\_NLOHMANN\_JSON\_HPP\_}}
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <algorithm>} \textcolor{comment}{// all\_of, find, for\_each}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// nullptr\_t, ptrdiff\_t, size\_t}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <functional>} \textcolor{comment}{// hash, less}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <initializer\_list>} \textcolor{comment}{// initializer\_list}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{26 \textcolor{preprocessor}{    \#include <iosfwd>} \textcolor{comment}{// istream, ostream}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// random\_access\_iterator\_tag}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <memory>} \textcolor{comment}{// unique\_ptr}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <numeric>} \textcolor{comment}{// accumulate}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string, stoi, to\_string}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// declval, forward, move, pair, swap}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{comment}{// \#include <nlohmann/adl\_serializer.hpp>}}
\DoxyCodeLine{36 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{37 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{38 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{39 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{40 \textcolor{comment}{//}}
\DoxyCodeLine{41 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{42 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 }
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{49 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{50 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{51 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{52 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{53 \textcolor{comment}{//}}
\DoxyCodeLine{54 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{55 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57 }
\DoxyCodeLine{58 }
\DoxyCodeLine{59 \textcolor{comment}{// This file contains all macro definitions affecting or depending on the ABI}}
\DoxyCodeLine{60 }
\DoxyCodeLine{61 \textcolor{preprocessor}{\#ifndef JSON\_SKIP\_LIBRARY\_VERSION\_CHECK}}
\DoxyCodeLine{62 \textcolor{preprocessor}{    \#if defined(NLOHMANN\_JSON\_VERSION\_MAJOR) \&\& defined(NLOHMANN\_JSON\_VERSION\_MINOR) \&\& defined(NLOHMANN\_JSON\_VERSION\_PATCH)}}
\DoxyCodeLine{63 \textcolor{preprocessor}{        \#if NLOHMANN\_JSON\_VERSION\_MAJOR != 3 || NLOHMANN\_JSON\_VERSION\_MINOR != 11 || NLOHMANN\_JSON\_VERSION\_PATCH != 2}}
\DoxyCodeLine{64 \textcolor{preprocessor}{            \#warning "{}Already included a different version of the library!"{}}}
\DoxyCodeLine{65 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{66 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{67 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_VERSION\_MAJOR 3   }\textcolor{comment}{// NOLINT(modernize-\/macro-\/to-\/enum)}}
\DoxyCodeLine{70 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_VERSION\_MINOR 11  }\textcolor{comment}{// NOLINT(modernize-\/macro-\/to-\/enum)}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_VERSION\_PATCH 2   }\textcolor{comment}{// NOLINT(modernize-\/macro-\/to-\/enum)}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{preprocessor}{\#ifndef JSON\_DIAGNOSTICS}}
\DoxyCodeLine{74 \textcolor{preprocessor}{    \#define JSON\_DIAGNOSTICS 0}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{76 }
\DoxyCodeLine{77 \textcolor{preprocessor}{\#ifndef JSON\_USE\_LEGACY\_DISCARDED\_VALUE\_COMPARISON}}
\DoxyCodeLine{78 \textcolor{preprocessor}{    \#define JSON\_USE\_LEGACY\_DISCARDED\_VALUE\_COMPARISON 0}}
\DoxyCodeLine{79 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{80 }
\DoxyCodeLine{81 \textcolor{preprocessor}{\#if JSON\_DIAGNOSTICS}}
\DoxyCodeLine{82 \textcolor{preprocessor}{    \#define NLOHMANN\_JSON\_ABI\_TAG\_DIAGNOSTICS \_diag}}
\DoxyCodeLine{83 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{84 \textcolor{preprocessor}{    \#define NLOHMANN\_JSON\_ABI\_TAG\_DIAGNOSTICS}}
\DoxyCodeLine{85 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87 \textcolor{preprocessor}{\#if JSON\_USE\_LEGACY\_DISCARDED\_VALUE\_COMPARISON}}
\DoxyCodeLine{88 \textcolor{preprocessor}{    \#define NLOHMANN\_JSON\_ABI\_TAG\_LEGACY\_DISCARDED\_VALUE\_COMPARISON \_ldvcmp}}
\DoxyCodeLine{89 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{90 \textcolor{preprocessor}{    \#define NLOHMANN\_JSON\_ABI\_TAG\_LEGACY\_DISCARDED\_VALUE\_COMPARISON}}
\DoxyCodeLine{91 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{92 }
\DoxyCodeLine{93 \textcolor{preprocessor}{\#ifndef NLOHMANN\_JSON\_NAMESPACE\_NO\_VERSION}}
\DoxyCodeLine{94 \textcolor{preprocessor}{    \#define NLOHMANN\_JSON\_NAMESPACE\_NO\_VERSION 0}}
\DoxyCodeLine{95 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{96 }
\DoxyCodeLine{97 \textcolor{comment}{// Construct the namespace ABI tags component}}
\DoxyCodeLine{98 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_ABI\_TAGS\_CONCAT\_EX(a, b) json\_abi \#\# a \#\# b}}
\DoxyCodeLine{99 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_ABI\_TAGS\_CONCAT(a, b) \(\backslash\)}}
\DoxyCodeLine{100 \textcolor{preprocessor}{    NLOHMANN\_JSON\_ABI\_TAGS\_CONCAT\_EX(a, b)}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_ABI\_TAGS                                       \(\backslash\)}}
\DoxyCodeLine{103 \textcolor{preprocessor}{    NLOHMANN\_JSON\_ABI\_TAGS\_CONCAT(                                   \(\backslash\)}}
\DoxyCodeLine{104 \textcolor{preprocessor}{            NLOHMANN\_JSON\_ABI\_TAG\_DIAGNOSTICS,                       \(\backslash\)}}
\DoxyCodeLine{105 \textcolor{preprocessor}{            NLOHMANN\_JSON\_ABI\_TAG\_LEGACY\_DISCARDED\_VALUE\_COMPARISON)}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107 \textcolor{comment}{// Construct the namespace version component}}
\DoxyCodeLine{108 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_NAMESPACE\_VERSION\_CONCAT\_EX(major, minor, patch) \(\backslash\)}}
\DoxyCodeLine{109 \textcolor{preprocessor}{    \_v \#\# major \#\# \_ \#\# minor \#\# \_ \#\# patch}}
\DoxyCodeLine{110 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_NAMESPACE\_VERSION\_CONCAT(major, minor, patch) \(\backslash\)}}
\DoxyCodeLine{111 \textcolor{preprocessor}{    NLOHMANN\_JSON\_NAMESPACE\_VERSION\_CONCAT\_EX(major, minor, patch)}}
\DoxyCodeLine{112 }
\DoxyCodeLine{113 \textcolor{preprocessor}{\#if NLOHMANN\_JSON\_NAMESPACE\_NO\_VERSION}}
\DoxyCodeLine{114 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_NAMESPACE\_VERSION}}
\DoxyCodeLine{115 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{116 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_NAMESPACE\_VERSION                                 \(\backslash\)}}
\DoxyCodeLine{117 \textcolor{preprocessor}{    NLOHMANN\_JSON\_NAMESPACE\_VERSION\_CONCAT(NLOHMANN\_JSON\_VERSION\_MAJOR, \(\backslash\)}}
\DoxyCodeLine{118 \textcolor{preprocessor}{                                           NLOHMANN\_JSON\_VERSION\_MINOR, \(\backslash\)}}
\DoxyCodeLine{119 \textcolor{preprocessor}{                                           NLOHMANN\_JSON\_VERSION\_PATCH)}}
\DoxyCodeLine{120 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122 \textcolor{comment}{// Combine namespace components}}
\DoxyCodeLine{123 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_NAMESPACE\_CONCAT\_EX(a, b) a \#\# b}}
\DoxyCodeLine{124 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_NAMESPACE\_CONCAT(a, b) \(\backslash\)}}
\DoxyCodeLine{125 \textcolor{preprocessor}{    NLOHMANN\_JSON\_NAMESPACE\_CONCAT\_EX(a, b)}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127 \textcolor{preprocessor}{\#ifndef NLOHMANN\_JSON\_NAMESPACE}}
\DoxyCodeLine{128 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_NAMESPACE               \(\backslash\)}}
\DoxyCodeLine{129 \textcolor{preprocessor}{    nlohmann::NLOHMANN\_JSON\_NAMESPACE\_CONCAT( \(\backslash\)}}
\DoxyCodeLine{130 \textcolor{preprocessor}{            NLOHMANN\_JSON\_ABI\_TAGS,           \(\backslash\)}}
\DoxyCodeLine{131 \textcolor{preprocessor}{            NLOHMANN\_JSON\_NAMESPACE\_VERSION)}}
\DoxyCodeLine{132 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{133 }
\DoxyCodeLine{134 \textcolor{preprocessor}{\#ifndef NLOHMANN\_JSON\_NAMESPACE\_BEGIN}}
\DoxyCodeLine{135 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_NAMESPACE\_BEGIN                \(\backslash\)}}
\DoxyCodeLine{136 \textcolor{preprocessor}{    namespace nlohmann                               \(\backslash\)}}
\DoxyCodeLine{137 \textcolor{preprocessor}{    \{                                                \(\backslash\)}}
\DoxyCodeLine{138 \textcolor{preprocessor}{    inline namespace NLOHMANN\_JSON\_NAMESPACE\_CONCAT( \(\backslash\)}}
\DoxyCodeLine{139 \textcolor{preprocessor}{                NLOHMANN\_JSON\_ABI\_TAGS,              \(\backslash\)}}
\DoxyCodeLine{140 \textcolor{preprocessor}{                NLOHMANN\_JSON\_NAMESPACE\_VERSION)     \(\backslash\)}}
\DoxyCodeLine{141 \textcolor{preprocessor}{    \{}}
\DoxyCodeLine{142 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 \textcolor{preprocessor}{\#ifndef NLOHMANN\_JSON\_NAMESPACE\_END}}
\DoxyCodeLine{145 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_NAMESPACE\_END                                     \(\backslash\)}}
\DoxyCodeLine{146 \textcolor{preprocessor}{    \}  }\textcolor{comment}{/* namespace (inline namespace) NOLINT(readability/namespace) */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{147 \textcolor{preprocessor}{    \}  }\textcolor{comment}{// namespace nlohmann}}
\DoxyCodeLine{148 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{149 }
\DoxyCodeLine{150 \textcolor{comment}{// \#include <nlohmann/detail/conversions/from\_json.hpp>}}
\DoxyCodeLine{151 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{152 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{153 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{154 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{155 \textcolor{comment}{//}}
\DoxyCodeLine{156 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{157 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{158 }
\DoxyCodeLine{159 }
\DoxyCodeLine{160 }
\DoxyCodeLine{161 \textcolor{preprocessor}{\#include <algorithm>} \textcolor{comment}{// transform}}
\DoxyCodeLine{162 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{163 \textcolor{preprocessor}{\#include <forward\_list>} \textcolor{comment}{// forward\_list}}
\DoxyCodeLine{164 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// inserter, front\_inserter, end}}
\DoxyCodeLine{165 \textcolor{preprocessor}{\#include <map>} \textcolor{comment}{// map}}
\DoxyCodeLine{166 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{167 \textcolor{preprocessor}{\#include <tuple>} \textcolor{comment}{// tuple, make\_tuple}}
\DoxyCodeLine{168 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// is\_arithmetic, is\_same, is\_enum, underlying\_type, is\_convertible}}
\DoxyCodeLine{169 \textcolor{preprocessor}{\#include <unordered\_map>} \textcolor{comment}{// unordered\_map}}
\DoxyCodeLine{170 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// pair, declval}}
\DoxyCodeLine{171 \textcolor{preprocessor}{\#include <valarray>} \textcolor{comment}{// valarray}}
\DoxyCodeLine{172 }
\DoxyCodeLine{173 \textcolor{comment}{// \#include <nlohmann/detail/exceptions.hpp>}}
\DoxyCodeLine{174 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{175 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{176 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{177 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{178 \textcolor{comment}{//}}
\DoxyCodeLine{179 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{180 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{181 }
\DoxyCodeLine{182 }
\DoxyCodeLine{183 }
\DoxyCodeLine{184 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// nullptr\_t}}
\DoxyCodeLine{185 \textcolor{preprocessor}{\#include <exception>} \textcolor{comment}{// exception}}
\DoxyCodeLine{186 \textcolor{preprocessor}{\#include <stdexcept>} \textcolor{comment}{// runtime\_error}}
\DoxyCodeLine{187 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// to\_string}}
\DoxyCodeLine{188 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{189 }
\DoxyCodeLine{190 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{191 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{192 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{193 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{194 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{195 \textcolor{comment}{//}}
\DoxyCodeLine{196 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{197 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{198 }
\DoxyCodeLine{199 }
\DoxyCodeLine{200 }
\DoxyCodeLine{201 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{202 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{203 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// uint8\_t}}
\DoxyCodeLine{204 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{205 }
\DoxyCodeLine{206 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{207 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{208 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{209 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{210 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{211 \textcolor{comment}{//}}
\DoxyCodeLine{212 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{213 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{214 }
\DoxyCodeLine{215 }
\DoxyCodeLine{216 }
\DoxyCodeLine{217 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// declval, pair}}
\DoxyCodeLine{218 \textcolor{comment}{// \#include <nlohmann/detail/meta/detected.hpp>}}
\DoxyCodeLine{219 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{220 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{221 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{222 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{223 \textcolor{comment}{//}}
\DoxyCodeLine{224 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{225 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{226 }
\DoxyCodeLine{227 }
\DoxyCodeLine{228 }
\DoxyCodeLine{229 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{230 }
\DoxyCodeLine{231 \textcolor{comment}{// \#include <nlohmann/detail/meta/void\_t.hpp>}}
\DoxyCodeLine{232 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{233 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{234 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{235 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{236 \textcolor{comment}{//}}
\DoxyCodeLine{237 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{238 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{239 }
\DoxyCodeLine{240 }
\DoxyCodeLine{241 }
\DoxyCodeLine{242 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{243 }
\DoxyCodeLine{244 }
\DoxyCodeLine{245 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{246 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{247 \{}
\DoxyCodeLine{248 }
\DoxyCodeLine{249 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...Ts> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1make__void}{make\_void}}}
\DoxyCodeLine{250 \{}
\DoxyCodeLine{251     \textcolor{keyword}{using }type = void;}
\DoxyCodeLine{252 \};}
\DoxyCodeLine{253 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...Ts> \textcolor{keyword}{using }void\_t = \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1make__void}{make\_void}}<Ts...>::type;}
\DoxyCodeLine{254 }
\DoxyCodeLine{255 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{256 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{257 }
\DoxyCodeLine{258 }
\DoxyCodeLine{259 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{260 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{261 \{}
\DoxyCodeLine{262 }
\DoxyCodeLine{263 \textcolor{comment}{// https://en.cppreference.com/w/cpp/experimental/is\_detected}}
\DoxyCodeLine{264 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1nonesuch}{nonesuch}}}
\DoxyCodeLine{265 \{}
\DoxyCodeLine{266     \mbox{\hyperlink{structdetail_1_1nonesuch}{nonesuch}}() = \textcolor{keyword}{delete};}
\DoxyCodeLine{267     \mbox{\hyperlink{structdetail_1_1nonesuch}{\string~nonesuch}}() = \textcolor{keyword}{delete};}
\DoxyCodeLine{268     \mbox{\hyperlink{structdetail_1_1nonesuch}{nonesuch}}(\mbox{\hyperlink{structdetail_1_1nonesuch}{nonesuch}} \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{269     \mbox{\hyperlink{structdetail_1_1nonesuch}{nonesuch}}(\mbox{\hyperlink{structdetail_1_1nonesuch}{nonesuch}} \textcolor{keyword}{const}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{270     \textcolor{keywordtype}{void} operator=(\mbox{\hyperlink{structdetail_1_1nonesuch}{nonesuch}} \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{271     \textcolor{keywordtype}{void} operator=(\mbox{\hyperlink{structdetail_1_1nonesuch}{nonesuch}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{272 \};}
\DoxyCodeLine{273 }
\DoxyCodeLine{274 \textcolor{keyword}{template}<\textcolor{keyword}{class }Default,}
\DoxyCodeLine{275          \textcolor{keyword}{class }AlwaysVoid,}
\DoxyCodeLine{276          \textcolor{keyword}{template}<\textcolor{keyword}{class}...> \textcolor{keyword}{class }Op,}
\DoxyCodeLine{277          \textcolor{keyword}{class}... Args>}
\DoxyCodeLine{278 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1detector}{detector}}}
\DoxyCodeLine{279 \{}
\DoxyCodeLine{280     \textcolor{keyword}{using }value\_t = std::false\_type;}
\DoxyCodeLine{281     \textcolor{keyword}{using }type = Default;}
\DoxyCodeLine{282 \};}
\DoxyCodeLine{283 }
\DoxyCodeLine{284 \textcolor{keyword}{template}<\textcolor{keyword}{class }Default, \textcolor{keyword}{template}<\textcolor{keyword}{class}...> \textcolor{keyword}{class }Op, \textcolor{keyword}{class}... Args>}
\DoxyCodeLine{285 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1detector}{detector}}<Default, void\_t<Op<Args...>>, Op, Args...>}
\DoxyCodeLine{286 \{}
\DoxyCodeLine{287     \textcolor{keyword}{using }value\_t = std::true\_type;}
\DoxyCodeLine{288     \textcolor{keyword}{using }type = Op<Args...>;}
\DoxyCodeLine{289 \};}
\DoxyCodeLine{290 }
\DoxyCodeLine{291 \textcolor{keyword}{template}<\textcolor{keyword}{template}<\textcolor{keyword}{class}...> \textcolor{keyword}{class }Op, \textcolor{keyword}{class}... Args>}
\DoxyCodeLine{292 \textcolor{keyword}{using }is\_detected = \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1detector}{detector}}<\mbox{\hyperlink{structdetail_1_1nonesuch}{nonesuch}}, void, Op, Args...>\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{::value\_t}};}
\DoxyCodeLine{293 }
\DoxyCodeLine{294 \textcolor{keyword}{template}<\textcolor{keyword}{template}<\textcolor{keyword}{class}...> \textcolor{keyword}{class }Op, \textcolor{keyword}{class}... Args>}
\DoxyCodeLine{295 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__detected__lazy}{is\_detected\_lazy}} : is\_detected<Op, Args...> \{ \};}
\DoxyCodeLine{296 }
\DoxyCodeLine{297 \textcolor{keyword}{template}<\textcolor{keyword}{template}<\textcolor{keyword}{class}...> \textcolor{keyword}{class }Op, \textcolor{keyword}{class}... Args>}
\DoxyCodeLine{298 \textcolor{keyword}{using }detected\_t = \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1detector}{detector}}<\mbox{\hyperlink{structdetail_1_1nonesuch}{nonesuch}}, void, Op, Args...>::type;}
\DoxyCodeLine{299 }
\DoxyCodeLine{300 \textcolor{keyword}{template}<\textcolor{keyword}{class }Default, \textcolor{keyword}{template}<\textcolor{keyword}{class}...> \textcolor{keyword}{class }Op, \textcolor{keyword}{class}... Args>}
\DoxyCodeLine{301 \textcolor{keyword}{using }\mbox{\hyperlink{structdetail_1_1detector}{detected\_or}} = \mbox{\hyperlink{structdetail_1_1detector}{detector}}<Default, void, Op, Args...>;}
\DoxyCodeLine{302 }
\DoxyCodeLine{303 \textcolor{keyword}{template}<\textcolor{keyword}{class }Default, \textcolor{keyword}{template}<\textcolor{keyword}{class}...> \textcolor{keyword}{class }Op, \textcolor{keyword}{class}... Args>}
\DoxyCodeLine{304 \textcolor{keyword}{using }detected\_or\_t = \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1detector}{detected\_or}}<Default, Op, Args...>::type;}
\DoxyCodeLine{305 }
\DoxyCodeLine{306 \textcolor{keyword}{template}<\textcolor{keyword}{class }Expected, \textcolor{keyword}{template}<\textcolor{keyword}{class}...> \textcolor{keyword}{class }Op, \textcolor{keyword}{class}... Args>}
\DoxyCodeLine{307 \textcolor{keyword}{using }is\_detected\_exact = std::is\_same<Expected, detected\_t<Op, Args...>>;}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 \textcolor{keyword}{template}<\textcolor{keyword}{class }To, \textcolor{keyword}{template}<\textcolor{keyword}{class}...> \textcolor{keyword}{class }Op, \textcolor{keyword}{class}... Args>}
\DoxyCodeLine{310 \textcolor{keyword}{using }is\_detected\_convertible =}
\DoxyCodeLine{311     std::is\_convertible<detected\_t<Op, Args...>, To>;}
\DoxyCodeLine{312 }
\DoxyCodeLine{313 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{314 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{315 }
\DoxyCodeLine{316 \textcolor{comment}{// \#include <nlohmann/thirdparty/hedley/hedley.hpp>}}
\DoxyCodeLine{317 }
\DoxyCodeLine{318 }
\DoxyCodeLine{319 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{320 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{321 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{322 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{323 \textcolor{comment}{//}}
\DoxyCodeLine{324 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{325 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2016-\/2021 Evan Nemerson <evan@nemerson.com>}}
\DoxyCodeLine{326 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{327 }
\DoxyCodeLine{328 \textcolor{comment}{/* Hedley -\/ https://nemequ.github.io/hedley}}
\DoxyCodeLine{329 \textcolor{comment}{ * Created by Evan Nemerson <evan@nemerson.com>}}
\DoxyCodeLine{330 \textcolor{comment}{ */}}
\DoxyCodeLine{331 }
\DoxyCodeLine{332 \textcolor{preprocessor}{\#if !defined(JSON\_HEDLEY\_VERSION) || (JSON\_HEDLEY\_VERSION < 15)}}
\DoxyCodeLine{333 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_VERSION)}}
\DoxyCodeLine{334 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_VERSION}}
\DoxyCodeLine{335 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{336 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_VERSION 15}}
\DoxyCodeLine{337 }
\DoxyCodeLine{338 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_STRINGIFY\_EX)}}
\DoxyCodeLine{339 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_STRINGIFY\_EX}}
\DoxyCodeLine{340 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{341 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_STRINGIFY\_EX(x) \#x}}
\DoxyCodeLine{342 }
\DoxyCodeLine{343 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_STRINGIFY)}}
\DoxyCodeLine{344 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_STRINGIFY}}
\DoxyCodeLine{345 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{346 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_STRINGIFY(x) JSON\_HEDLEY\_STRINGIFY\_EX(x)}}
\DoxyCodeLine{347 }
\DoxyCodeLine{348 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CONCAT\_EX)}}
\DoxyCodeLine{349 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CONCAT\_EX}}
\DoxyCodeLine{350 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{351 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CONCAT\_EX(a,b) a\#\#b}}
\DoxyCodeLine{352 }
\DoxyCodeLine{353 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CONCAT)}}
\DoxyCodeLine{354 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CONCAT}}
\DoxyCodeLine{355 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{356 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CONCAT(a,b) JSON\_HEDLEY\_CONCAT\_EX(a,b)}}
\DoxyCodeLine{357 }
\DoxyCodeLine{358 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CONCAT3\_EX)}}
\DoxyCodeLine{359 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CONCAT3\_EX}}
\DoxyCodeLine{360 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{361 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CONCAT3\_EX(a,b,c) a\#\#b\#\#c}}
\DoxyCodeLine{362 }
\DoxyCodeLine{363 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CONCAT3)}}
\DoxyCodeLine{364 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CONCAT3}}
\DoxyCodeLine{365 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{366 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CONCAT3(a,b,c) JSON\_HEDLEY\_CONCAT3\_EX(a,b,c)}}
\DoxyCodeLine{367 }
\DoxyCodeLine{368 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_VERSION\_ENCODE)}}
\DoxyCodeLine{369 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_VERSION\_ENCODE}}
\DoxyCodeLine{370 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{371 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_VERSION\_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))}}
\DoxyCodeLine{372 }
\DoxyCodeLine{373 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_VERSION\_DECODE\_MAJOR)}}
\DoxyCodeLine{374 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_VERSION\_DECODE\_MAJOR}}
\DoxyCodeLine{375 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{376 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_VERSION\_DECODE\_MAJOR(version) ((version) / 1000000)}}
\DoxyCodeLine{377 }
\DoxyCodeLine{378 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_VERSION\_DECODE\_MINOR)}}
\DoxyCodeLine{379 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_VERSION\_DECODE\_MINOR}}
\DoxyCodeLine{380 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{381 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_VERSION\_DECODE\_MINOR(version) (((version) \% 1000000) / 1000)}}
\DoxyCodeLine{382 }
\DoxyCodeLine{383 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_VERSION\_DECODE\_REVISION)}}
\DoxyCodeLine{384 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_VERSION\_DECODE\_REVISION}}
\DoxyCodeLine{385 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{386 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_VERSION\_DECODE\_REVISION(version) ((version) \% 1000)}}
\DoxyCodeLine{387 }
\DoxyCodeLine{388 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GNUC\_VERSION)}}
\DoxyCodeLine{389 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GNUC\_VERSION}}
\DoxyCodeLine{390 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{391 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) \&\& defined(\_\_GNUC\_PATCHLEVEL\_\_)}}
\DoxyCodeLine{392 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_GNUC\_\_, \_\_GNUC\_MINOR\_\_, \_\_GNUC\_PATCHLEVEL\_\_)}}
\DoxyCodeLine{393 \textcolor{preprocessor}{\#elif defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{394 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_GNUC\_\_, \_\_GNUC\_MINOR\_\_, 0)}}
\DoxyCodeLine{395 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{396 }
\DoxyCodeLine{397 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GNUC\_VERSION\_CHECK)}}
\DoxyCodeLine{398 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GNUC\_VERSION\_CHECK}}
\DoxyCodeLine{399 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{400 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GNUC\_VERSION)}}
\DoxyCodeLine{401 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_GNUC\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{402 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{403 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{404 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{405 }
\DoxyCodeLine{406 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_MSVC\_VERSION)}}
\DoxyCodeLine{407 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_MSVC\_VERSION}}
\DoxyCodeLine{408 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{409 \textcolor{preprocessor}{\#if defined(\_MSC\_FULL\_VER) \&\& (\_MSC\_FULL\_VER >= 140000000) \&\& !defined(\_\_ICL)}}
\DoxyCodeLine{410 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MSVC\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_MSC\_FULL\_VER / 10000000, (\_MSC\_FULL\_VER \% 10000000) / 100000, (\_MSC\_FULL\_VER \% 100000) / 100)}}
\DoxyCodeLine{411 \textcolor{preprocessor}{\#elif defined(\_MSC\_FULL\_VER) \&\& !defined(\_\_ICL)}}
\DoxyCodeLine{412 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MSVC\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_MSC\_FULL\_VER / 1000000, (\_MSC\_FULL\_VER \% 1000000) / 10000, (\_MSC\_FULL\_VER \% 10000) / 10)}}
\DoxyCodeLine{413 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER) \&\& !defined(\_\_ICL)}}
\DoxyCodeLine{414 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MSVC\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_MSC\_VER / 100, \_MSC\_VER \% 100, 0)}}
\DoxyCodeLine{415 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{416 }
\DoxyCodeLine{417 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_MSVC\_VERSION\_CHECK)}}
\DoxyCodeLine{418 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_MSVC\_VERSION\_CHECK}}
\DoxyCodeLine{419 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{420 \textcolor{preprocessor}{\#if !defined(JSON\_HEDLEY\_MSVC\_VERSION)}}
\DoxyCodeLine{421 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{422 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER) \&\& (\_MSC\_VER >= 1400)}}
\DoxyCodeLine{423 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(major,minor,patch) (\_MSC\_FULL\_VER >= ((major * 10000000) + (minor * 100000) + (patch)))}}
\DoxyCodeLine{424 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER) \&\& (\_MSC\_VER >= 1200)}}
\DoxyCodeLine{425 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(major,minor,patch) (\_MSC\_FULL\_VER >= ((major * 1000000) + (minor * 10000) + (patch)))}}
\DoxyCodeLine{426 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{427 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(major,minor,patch) (\_MSC\_VER >= ((major * 100) + (minor)))}}
\DoxyCodeLine{428 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{429 }
\DoxyCodeLine{430 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_INTEL\_VERSION)}}
\DoxyCodeLine{431 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_INTEL\_VERSION}}
\DoxyCodeLine{432 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{433 \textcolor{preprocessor}{\#if defined(\_\_INTEL\_COMPILER) \&\& defined(\_\_INTEL\_COMPILER\_UPDATE) \&\& !defined(\_\_ICL)}}
\DoxyCodeLine{434 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INTEL\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_INTEL\_COMPILER / 100, \_\_INTEL\_COMPILER \% 100, \_\_INTEL\_COMPILER\_UPDATE)}}
\DoxyCodeLine{435 \textcolor{preprocessor}{\#elif defined(\_\_INTEL\_COMPILER) \&\& !defined(\_\_ICL)}}
\DoxyCodeLine{436 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INTEL\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_INTEL\_COMPILER / 100, \_\_INTEL\_COMPILER \% 100, 0)}}
\DoxyCodeLine{437 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{438 }
\DoxyCodeLine{439 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_INTEL\_VERSION\_CHECK)}}
\DoxyCodeLine{440 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_INTEL\_VERSION\_CHECK}}
\DoxyCodeLine{441 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{442 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_INTEL\_VERSION)}}
\DoxyCodeLine{443 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_INTEL\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{444 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{445 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{446 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{447 }
\DoxyCodeLine{448 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_INTEL\_CL\_VERSION)}}
\DoxyCodeLine{449 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_INTEL\_CL\_VERSION}}
\DoxyCodeLine{450 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{451 \textcolor{preprocessor}{\#if defined(\_\_INTEL\_COMPILER) \&\& defined(\_\_INTEL\_COMPILER\_UPDATE) \&\& defined(\_\_ICL)}}
\DoxyCodeLine{452 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INTEL\_CL\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_INTEL\_COMPILER, \_\_INTEL\_COMPILER\_UPDATE, 0)}}
\DoxyCodeLine{453 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{454 }
\DoxyCodeLine{455 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK)}}
\DoxyCodeLine{456 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK}}
\DoxyCodeLine{457 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{458 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_INTEL\_CL\_VERSION)}}
\DoxyCodeLine{459 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_INTEL\_CL\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{460 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{461 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{462 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{463 }
\DoxyCodeLine{464 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PGI\_VERSION)}}
\DoxyCodeLine{465 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_PGI\_VERSION}}
\DoxyCodeLine{466 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{467 \textcolor{preprocessor}{\#if defined(\_\_PGI) \&\& defined(\_\_PGIC\_\_) \&\& defined(\_\_PGIC\_MINOR\_\_) \&\& defined(\_\_PGIC\_PATCHLEVEL\_\_)}}
\DoxyCodeLine{468 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PGI\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_PGIC\_\_, \_\_PGIC\_MINOR\_\_, \_\_PGIC\_PATCHLEVEL\_\_)}}
\DoxyCodeLine{469 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{470 }
\DoxyCodeLine{471 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PGI\_VERSION\_CHECK)}}
\DoxyCodeLine{472 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_PGI\_VERSION\_CHECK}}
\DoxyCodeLine{473 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{474 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PGI\_VERSION)}}
\DoxyCodeLine{475 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PGI\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_PGI\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{476 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{477 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PGI\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{478 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{479 }
\DoxyCodeLine{480 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_SUNPRO\_VERSION)}}
\DoxyCodeLine{481 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_SUNPRO\_VERSION}}
\DoxyCodeLine{482 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{483 \textcolor{preprocessor}{\#if defined(\_\_SUNPRO\_C) \&\& (\_\_SUNPRO\_C > 0x1000)}}
\DoxyCodeLine{484 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_SUNPRO\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE((((\_\_SUNPRO\_C >> 16) \& 0xf) * 10) + ((\_\_SUNPRO\_C >> 12) \& 0xf), (((\_\_SUNPRO\_C >> 8) \& 0xf) * 10) + ((\_\_SUNPRO\_C >> 4) \& 0xf), (\_\_SUNPRO\_C \& 0xf) * 10)}}
\DoxyCodeLine{485 \textcolor{preprocessor}{\#elif defined(\_\_SUNPRO\_C)}}
\DoxyCodeLine{486 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_SUNPRO\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE((\_\_SUNPRO\_C >> 8) \& 0xf, (\_\_SUNPRO\_C >> 4) \& 0xf, (\_\_SUNPRO\_C) \& 0xf)}}
\DoxyCodeLine{487 \textcolor{preprocessor}{\#elif defined(\_\_SUNPRO\_CC) \&\& (\_\_SUNPRO\_CC > 0x1000)}}
\DoxyCodeLine{488 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_SUNPRO\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE((((\_\_SUNPRO\_CC >> 16) \& 0xf) * 10) + ((\_\_SUNPRO\_CC >> 12) \& 0xf), (((\_\_SUNPRO\_CC >> 8) \& 0xf) * 10) + ((\_\_SUNPRO\_CC >> 4) \& 0xf), (\_\_SUNPRO\_CC \& 0xf) * 10)}}
\DoxyCodeLine{489 \textcolor{preprocessor}{\#elif defined(\_\_SUNPRO\_CC)}}
\DoxyCodeLine{490 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_SUNPRO\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE((\_\_SUNPRO\_CC >> 8) \& 0xf, (\_\_SUNPRO\_CC >> 4) \& 0xf, (\_\_SUNPRO\_CC) \& 0xf)}}
\DoxyCodeLine{491 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{492 }
\DoxyCodeLine{493 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK)}}
\DoxyCodeLine{494 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK}}
\DoxyCodeLine{495 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{496 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_SUNPRO\_VERSION)}}
\DoxyCodeLine{497 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_SUNPRO\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{498 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{499 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{500 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{501 }
\DoxyCodeLine{502 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_EMSCRIPTEN\_VERSION)}}
\DoxyCodeLine{503 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_EMSCRIPTEN\_VERSION}}
\DoxyCodeLine{504 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{505 \textcolor{preprocessor}{\#if defined(\_\_EMSCRIPTEN\_\_)}}
\DoxyCodeLine{506 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_EMSCRIPTEN\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_EMSCRIPTEN\_major\_\_, \_\_EMSCRIPTEN\_minor\_\_, \_\_EMSCRIPTEN\_tiny\_\_)}}
\DoxyCodeLine{507 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_EMSCRIPTEN\_VERSION\_CHECK)}}
\DoxyCodeLine{510 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_EMSCRIPTEN\_VERSION\_CHECK}}
\DoxyCodeLine{511 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{512 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_EMSCRIPTEN\_VERSION)}}
\DoxyCodeLine{513 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_EMSCRIPTEN\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_EMSCRIPTEN\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{514 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{515 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_EMSCRIPTEN\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{516 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{517 }
\DoxyCodeLine{518 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_ARM\_VERSION)}}
\DoxyCodeLine{519 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_ARM\_VERSION}}
\DoxyCodeLine{520 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{521 \textcolor{preprocessor}{\#if defined(\_\_CC\_ARM) \&\& defined(\_\_ARMCOMPILER\_VERSION)}}
\DoxyCodeLine{522 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_ARM\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_ARMCOMPILER\_VERSION / 1000000, (\_\_ARMCOMPILER\_VERSION \% 1000000) / 10000, (\_\_ARMCOMPILER\_VERSION \% 10000) / 100)}}
\DoxyCodeLine{523 \textcolor{preprocessor}{\#elif defined(\_\_CC\_ARM) \&\& defined(\_\_ARMCC\_VERSION)}}
\DoxyCodeLine{524 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_ARM\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_ARMCC\_VERSION / 1000000, (\_\_ARMCC\_VERSION \% 1000000) / 10000, (\_\_ARMCC\_VERSION \% 10000) / 100)}}
\DoxyCodeLine{525 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{526 }
\DoxyCodeLine{527 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_ARM\_VERSION\_CHECK)}}
\DoxyCodeLine{528 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_ARM\_VERSION\_CHECK}}
\DoxyCodeLine{529 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{530 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_ARM\_VERSION)}}
\DoxyCodeLine{531 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_ARM\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_ARM\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{532 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{533 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_ARM\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{534 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{535 }
\DoxyCodeLine{536 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_IBM\_VERSION)}}
\DoxyCodeLine{537 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_IBM\_VERSION}}
\DoxyCodeLine{538 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{539 \textcolor{preprocessor}{\#if defined(\_\_ibmxl\_\_)}}
\DoxyCodeLine{540 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IBM\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_ibmxl\_version\_\_, \_\_ibmxl\_release\_\_, \_\_ibmxl\_modification\_\_)}}
\DoxyCodeLine{541 \textcolor{preprocessor}{\#elif defined(\_\_xlC\_\_) \&\& defined(\_\_xlC\_ver\_\_)}}
\DoxyCodeLine{542 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IBM\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_xlC\_\_ >> 8, \_\_xlC\_\_ \& 0xff, (\_\_xlC\_ver\_\_ >> 8) \& 0xff)}}
\DoxyCodeLine{543 \textcolor{preprocessor}{\#elif defined(\_\_xlC\_\_)}}
\DoxyCodeLine{544 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IBM\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_xlC\_\_ >> 8, \_\_xlC\_\_ \& 0xff, 0)}}
\DoxyCodeLine{545 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{546 }
\DoxyCodeLine{547 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_IBM\_VERSION\_CHECK)}}
\DoxyCodeLine{548 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_IBM\_VERSION\_CHECK}}
\DoxyCodeLine{549 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{550 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_IBM\_VERSION)}}
\DoxyCodeLine{551 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IBM\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_IBM\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{552 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{553 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IBM\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{554 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{555 }
\DoxyCodeLine{556 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_VERSION)}}
\DoxyCodeLine{557 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_VERSION}}
\DoxyCodeLine{558 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{559 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{560 \textcolor{preprocessor}{    defined(\_\_TI\_COMPILER\_VERSION\_\_) \&\& \(\backslash\)}}
\DoxyCodeLine{561 \textcolor{preprocessor}{    ( \(\backslash\)}}
\DoxyCodeLine{562 \textcolor{preprocessor}{      defined(\_\_TMS470\_\_) || defined(\_\_TI\_ARM\_\_) || \(\backslash\)}}
\DoxyCodeLine{563 \textcolor{preprocessor}{      defined(\_\_MSP430\_\_) || \(\backslash\)}}
\DoxyCodeLine{564 \textcolor{preprocessor}{      defined(\_\_TMS320C2000\_\_) \(\backslash\)}}
\DoxyCodeLine{565 \textcolor{preprocessor}{    )}}
\DoxyCodeLine{566 \textcolor{preprocessor}{\#if (\_\_TI\_COMPILER\_VERSION\_\_ >= 16000000)}}
\DoxyCodeLine{567 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_TI\_COMPILER\_VERSION\_\_ / 1000000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000000) / 1000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000))}}
\DoxyCodeLine{568 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{569 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{570 }
\DoxyCodeLine{571 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_VERSION\_CHECK)}}
\DoxyCodeLine{572 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_VERSION\_CHECK}}
\DoxyCodeLine{573 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{574 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_VERSION)}}
\DoxyCodeLine{575 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_TI\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{576 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{577 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{578 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{579 }
\DoxyCodeLine{580 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL2000\_VERSION)}}
\DoxyCodeLine{581 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_CL2000\_VERSION}}
\DoxyCodeLine{582 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{583 \textcolor{preprocessor}{\#if defined(\_\_TI\_COMPILER\_VERSION\_\_) \&\& defined(\_\_TMS320C2000\_\_)}}
\DoxyCodeLine{584 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL2000\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_TI\_COMPILER\_VERSION\_\_ / 1000000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000000) / 1000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000))}}
\DoxyCodeLine{585 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{586 }
\DoxyCodeLine{587 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK)}}
\DoxyCodeLine{588 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK}}
\DoxyCodeLine{589 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{590 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL2000\_VERSION)}}
\DoxyCodeLine{591 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_TI\_CL2000\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{592 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{593 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{594 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{595 }
\DoxyCodeLine{596 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL430\_VERSION)}}
\DoxyCodeLine{597 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_CL430\_VERSION}}
\DoxyCodeLine{598 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{599 \textcolor{preprocessor}{\#if defined(\_\_TI\_COMPILER\_VERSION\_\_) \&\& defined(\_\_MSP430\_\_)}}
\DoxyCodeLine{600 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL430\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_TI\_COMPILER\_VERSION\_\_ / 1000000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000000) / 1000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000))}}
\DoxyCodeLine{601 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{602 }
\DoxyCodeLine{603 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK)}}
\DoxyCodeLine{604 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK}}
\DoxyCodeLine{605 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{606 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL430\_VERSION)}}
\DoxyCodeLine{607 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_TI\_CL430\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{608 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{609 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{610 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{611 }
\DoxyCodeLine{612 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_ARMCL\_VERSION)}}
\DoxyCodeLine{613 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_ARMCL\_VERSION}}
\DoxyCodeLine{614 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{615 \textcolor{preprocessor}{\#if defined(\_\_TI\_COMPILER\_VERSION\_\_) \&\& (defined(\_\_TMS470\_\_) || defined(\_\_TI\_ARM\_\_))}}
\DoxyCodeLine{616 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_ARMCL\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_TI\_COMPILER\_VERSION\_\_ / 1000000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000000) / 1000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000))}}
\DoxyCodeLine{617 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{618 }
\DoxyCodeLine{619 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK)}}
\DoxyCodeLine{620 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK}}
\DoxyCodeLine{621 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{622 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_ARMCL\_VERSION)}}
\DoxyCodeLine{623 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_TI\_ARMCL\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{624 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{625 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{626 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{627 }
\DoxyCodeLine{628 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL6X\_VERSION)}}
\DoxyCodeLine{629 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_CL6X\_VERSION}}
\DoxyCodeLine{630 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{631 \textcolor{preprocessor}{\#if defined(\_\_TI\_COMPILER\_VERSION\_\_) \&\& defined(\_\_TMS320C6X\_\_)}}
\DoxyCodeLine{632 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL6X\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_TI\_COMPILER\_VERSION\_\_ / 1000000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000000) / 1000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000))}}
\DoxyCodeLine{633 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{634 }
\DoxyCodeLine{635 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK)}}
\DoxyCodeLine{636 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK}}
\DoxyCodeLine{637 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{638 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL6X\_VERSION)}}
\DoxyCodeLine{639 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_TI\_CL6X\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{640 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{641 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{642 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{643 }
\DoxyCodeLine{644 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL7X\_VERSION)}}
\DoxyCodeLine{645 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_CL7X\_VERSION}}
\DoxyCodeLine{646 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{647 \textcolor{preprocessor}{\#if defined(\_\_TI\_COMPILER\_VERSION\_\_) \&\& defined(\_\_C7000\_\_)}}
\DoxyCodeLine{648 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL7X\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_TI\_COMPILER\_VERSION\_\_ / 1000000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000000) / 1000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000))}}
\DoxyCodeLine{649 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{650 }
\DoxyCodeLine{651 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK)}}
\DoxyCodeLine{652 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK}}
\DoxyCodeLine{653 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{654 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CL7X\_VERSION)}}
\DoxyCodeLine{655 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_TI\_CL7X\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{656 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{657 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{658 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{659 }
\DoxyCodeLine{660 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CLPRU\_VERSION)}}
\DoxyCodeLine{661 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_CLPRU\_VERSION}}
\DoxyCodeLine{662 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{663 \textcolor{preprocessor}{\#if defined(\_\_TI\_COMPILER\_VERSION\_\_) \&\& defined(\_\_PRU\_\_)}}
\DoxyCodeLine{664 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CLPRU\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_TI\_COMPILER\_VERSION\_\_ / 1000000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000000) / 1000, (\_\_TI\_COMPILER\_VERSION\_\_ \% 1000))}}
\DoxyCodeLine{665 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{666 }
\DoxyCodeLine{667 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK)}}
\DoxyCodeLine{668 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK}}
\DoxyCodeLine{669 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{670 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TI\_CLPRU\_VERSION)}}
\DoxyCodeLine{671 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_TI\_CLPRU\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{672 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{673 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{674 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{675 }
\DoxyCodeLine{676 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CRAY\_VERSION)}}
\DoxyCodeLine{677 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CRAY\_VERSION}}
\DoxyCodeLine{678 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{679 \textcolor{preprocessor}{\#if defined(\_CRAYC)}}
\DoxyCodeLine{680 \textcolor{preprocessor}{    \#if defined(\_RELEASE\_PATCHLEVEL)}}
\DoxyCodeLine{681 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_CRAY\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_RELEASE\_MAJOR, \_RELEASE\_MINOR, \_RELEASE\_PATCHLEVEL)}}
\DoxyCodeLine{682 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{683 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_CRAY\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_RELEASE\_MAJOR, \_RELEASE\_MINOR, 0)}}
\DoxyCodeLine{684 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{685 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{686 }
\DoxyCodeLine{687 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CRAY\_VERSION\_CHECK)}}
\DoxyCodeLine{688 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CRAY\_VERSION\_CHECK}}
\DoxyCodeLine{689 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{690 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CRAY\_VERSION)}}
\DoxyCodeLine{691 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_CRAY\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_CRAY\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{692 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{693 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_CRAY\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{694 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{695 }
\DoxyCodeLine{696 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_IAR\_VERSION)}}
\DoxyCodeLine{697 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_IAR\_VERSION}}
\DoxyCodeLine{698 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{699 \textcolor{preprocessor}{\#if defined(\_\_IAR\_SYSTEMS\_ICC\_\_)}}
\DoxyCodeLine{700 \textcolor{preprocessor}{    \#if \_\_VER\_\_ > 1000}}
\DoxyCodeLine{701 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_IAR\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE((\_\_VER\_\_ / 1000000), ((\_\_VER\_\_ / 1000) \% 1000), (\_\_VER\_\_ \% 1000))}}
\DoxyCodeLine{702 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{703 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_IAR\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_VER\_\_ / 100, \_\_VER\_\_ \% 100, 0)}}
\DoxyCodeLine{704 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{705 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{706 }
\DoxyCodeLine{707 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_IAR\_VERSION\_CHECK)}}
\DoxyCodeLine{708 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_IAR\_VERSION\_CHECK}}
\DoxyCodeLine{709 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{710 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_IAR\_VERSION)}}
\DoxyCodeLine{711 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IAR\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_IAR\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{712 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{713 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IAR\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{714 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{715 }
\DoxyCodeLine{716 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TINYC\_VERSION)}}
\DoxyCodeLine{717 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TINYC\_VERSION}}
\DoxyCodeLine{718 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{719 \textcolor{preprocessor}{\#if defined(\_\_TINYC\_\_)}}
\DoxyCodeLine{720 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TINYC\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_TINYC\_\_ / 1000, (\_\_TINYC\_\_ / 100) \% 10, \_\_TINYC\_\_ \% 100)}}
\DoxyCodeLine{721 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{722 }
\DoxyCodeLine{723 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TINYC\_VERSION\_CHECK)}}
\DoxyCodeLine{724 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_TINYC\_VERSION\_CHECK}}
\DoxyCodeLine{725 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{726 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_TINYC\_VERSION)}}
\DoxyCodeLine{727 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TINYC\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_TINYC\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{728 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{729 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_TINYC\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{730 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{731 }
\DoxyCodeLine{732 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DMC\_VERSION)}}
\DoxyCodeLine{733 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DMC\_VERSION}}
\DoxyCodeLine{734 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{735 \textcolor{preprocessor}{\#if defined(\_\_DMC\_\_)}}
\DoxyCodeLine{736 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DMC\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_DMC\_\_ >> 8, (\_\_DMC\_\_ >> 4) \& 0xf, \_\_DMC\_\_ \& 0xf)}}
\DoxyCodeLine{737 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{738 }
\DoxyCodeLine{739 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DMC\_VERSION\_CHECK)}}
\DoxyCodeLine{740 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DMC\_VERSION\_CHECK}}
\DoxyCodeLine{741 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{742 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DMC\_VERSION)}}
\DoxyCodeLine{743 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DMC\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_DMC\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{744 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{745 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DMC\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{746 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{747 }
\DoxyCodeLine{748 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_COMPCERT\_VERSION)}}
\DoxyCodeLine{749 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_COMPCERT\_VERSION}}
\DoxyCodeLine{750 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{751 \textcolor{preprocessor}{\#if defined(\_\_COMPCERT\_VERSION\_\_)}}
\DoxyCodeLine{752 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_COMPCERT\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_COMPCERT\_VERSION\_\_ / 10000, (\_\_COMPCERT\_VERSION\_\_ / 100) \% 100, \_\_COMPCERT\_VERSION\_\_ \% 100)}}
\DoxyCodeLine{753 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{754 }
\DoxyCodeLine{755 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_COMPCERT\_VERSION\_CHECK)}}
\DoxyCodeLine{756 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_COMPCERT\_VERSION\_CHECK}}
\DoxyCodeLine{757 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{758 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_COMPCERT\_VERSION)}}
\DoxyCodeLine{759 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_COMPCERT\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_COMPCERT\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{760 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{761 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_COMPCERT\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{762 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{763 }
\DoxyCodeLine{764 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PELLES\_VERSION)}}
\DoxyCodeLine{765 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_PELLES\_VERSION}}
\DoxyCodeLine{766 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{767 \textcolor{preprocessor}{\#if defined(\_\_POCC\_\_)}}
\DoxyCodeLine{768 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PELLES\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_POCC\_\_ / 100, \_\_POCC\_\_ \% 100, 0)}}
\DoxyCodeLine{769 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{770 }
\DoxyCodeLine{771 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PELLES\_VERSION\_CHECK)}}
\DoxyCodeLine{772 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_PELLES\_VERSION\_CHECK}}
\DoxyCodeLine{773 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{774 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PELLES\_VERSION)}}
\DoxyCodeLine{775 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PELLES\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_PELLES\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{776 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{777 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PELLES\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{778 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{779 }
\DoxyCodeLine{780 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_MCST\_LCC\_VERSION)}}
\DoxyCodeLine{781 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_MCST\_LCC\_VERSION}}
\DoxyCodeLine{782 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{783 \textcolor{preprocessor}{\#if defined(\_\_LCC\_\_) \&\& defined(\_\_LCC\_MINOR\_\_)}}
\DoxyCodeLine{784 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MCST\_LCC\_VERSION JSON\_HEDLEY\_VERSION\_ENCODE(\_\_LCC\_\_ / 100, \_\_LCC\_\_ \% 100, \_\_LCC\_MINOR\_\_)}}
\DoxyCodeLine{785 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{786 }
\DoxyCodeLine{787 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK)}}
\DoxyCodeLine{788 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK}}
\DoxyCodeLine{789 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{790 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_MCST\_LCC\_VERSION)}}
\DoxyCodeLine{791 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_MCST\_LCC\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{792 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{793 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{794 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{795 }
\DoxyCodeLine{796 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_VERSION)}}
\DoxyCodeLine{797 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GCC\_VERSION}}
\DoxyCodeLine{798 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{799 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{800 \textcolor{preprocessor}{    defined(JSON\_HEDLEY\_GNUC\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{801 \textcolor{preprocessor}{    !defined(\_\_clang\_\_) \&\& \(\backslash\)}}
\DoxyCodeLine{802 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_INTEL\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{803 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_PGI\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{804 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_ARM\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{805 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_CRAY\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{806 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_TI\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{807 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_TI\_ARMCL\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{808 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_TI\_CL430\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{809 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_TI\_CL2000\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{810 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_TI\_CL6X\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{811 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_TI\_CL7X\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{812 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_TI\_CLPRU\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{813 \textcolor{preprocessor}{    !defined(\_\_COMPCERT\_\_) \&\& \(\backslash\)}}
\DoxyCodeLine{814 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_MCST\_LCC\_VERSION)}}
\DoxyCodeLine{815 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_VERSION JSON\_HEDLEY\_GNUC\_VERSION}}
\DoxyCodeLine{816 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{817 }
\DoxyCodeLine{818 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_VERSION\_CHECK)}}
\DoxyCodeLine{819 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GCC\_VERSION\_CHECK}}
\DoxyCodeLine{820 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{821 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_VERSION)}}
\DoxyCodeLine{822 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_VERSION\_CHECK(major,minor,patch) (JSON\_HEDLEY\_GCC\_VERSION >= JSON\_HEDLEY\_VERSION\_ENCODE(major, minor, patch))}}
\DoxyCodeLine{823 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{824 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{825 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{826 }
\DoxyCodeLine{827 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_HAS\_ATTRIBUTE)}}
\DoxyCodeLine{828 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_HAS\_ATTRIBUTE}}
\DoxyCodeLine{829 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{830 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{831 \textcolor{preprocessor}{  defined(\_\_has\_attribute) \&\& \(\backslash\)}}
\DoxyCodeLine{832 \textcolor{preprocessor}{  ( \(\backslash\)}}
\DoxyCodeLine{833 \textcolor{preprocessor}{    (!defined(JSON\_HEDLEY\_IAR\_VERSION) || JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,5,9)) \(\backslash\)}}
\DoxyCodeLine{834 \textcolor{preprocessor}{  )}}
\DoxyCodeLine{835 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_HAS\_ATTRIBUTE(attribute) \_\_has\_attribute(attribute)}}
\DoxyCodeLine{836 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{837 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_HAS\_ATTRIBUTE(attribute) (0)}}
\DoxyCodeLine{838 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{839 }
\DoxyCodeLine{840 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GNUC\_HAS\_ATTRIBUTE)}}
\DoxyCodeLine{841 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GNUC\_HAS\_ATTRIBUTE}}
\DoxyCodeLine{842 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{843 \textcolor{preprocessor}{\#if defined(\_\_has\_attribute)}}
\DoxyCodeLine{844 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_ATTRIBUTE(attribute,major,minor,patch) JSON\_HEDLEY\_HAS\_ATTRIBUTE(attribute)}}
\DoxyCodeLine{845 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{846 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_ATTRIBUTE(attribute,major,minor,patch) JSON\_HEDLEY\_GNUC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{847 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{848 }
\DoxyCodeLine{849 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_HAS\_ATTRIBUTE)}}
\DoxyCodeLine{850 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GCC\_HAS\_ATTRIBUTE}}
\DoxyCodeLine{851 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{852 \textcolor{preprocessor}{\#if defined(\_\_has\_attribute)}}
\DoxyCodeLine{853 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_ATTRIBUTE(attribute,major,minor,patch) JSON\_HEDLEY\_HAS\_ATTRIBUTE(attribute)}}
\DoxyCodeLine{854 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{855 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_ATTRIBUTE(attribute,major,minor,patch) JSON\_HEDLEY\_GCC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{856 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{857 }
\DoxyCodeLine{858 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE)}}
\DoxyCodeLine{859 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE}}
\DoxyCodeLine{860 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{861 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{862 \textcolor{preprocessor}{    defined(\_\_has\_cpp\_attribute) \&\& \(\backslash\)}}
\DoxyCodeLine{863 \textcolor{preprocessor}{    defined(\_\_cplusplus) \&\& \(\backslash\)}}
\DoxyCodeLine{864 \textcolor{preprocessor}{    (!defined(JSON\_HEDLEY\_SUNPRO\_VERSION) || JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,15,0))}}
\DoxyCodeLine{865 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE(attribute) \_\_has\_cpp\_attribute(attribute)}}
\DoxyCodeLine{866 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{867 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE(attribute) (0)}}
\DoxyCodeLine{868 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{869 }
\DoxyCodeLine{870 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE\_NS)}}
\DoxyCodeLine{871 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE\_NS}}
\DoxyCodeLine{872 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{873 \textcolor{preprocessor}{\#if !defined(\_\_cplusplus) || !defined(\_\_has\_cpp\_attribute)}}
\DoxyCodeLine{874 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE\_NS(ns,attribute) (0)}}
\DoxyCodeLine{875 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{876 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_PGI\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{877 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_IAR\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{878 \textcolor{preprocessor}{    (!defined(JSON\_HEDLEY\_SUNPRO\_VERSION) || JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,15,0)) \&\& \(\backslash\)}}
\DoxyCodeLine{879 \textcolor{preprocessor}{    (!defined(JSON\_HEDLEY\_MSVC\_VERSION) || JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(19,20,0))}}
\DoxyCodeLine{880 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE\_NS(ns,attribute) JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE(ns::attribute)}}
\DoxyCodeLine{881 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{882 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE\_NS(ns,attribute) (0)}}
\DoxyCodeLine{883 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{884 }
\DoxyCodeLine{885 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GNUC\_HAS\_CPP\_ATTRIBUTE)}}
\DoxyCodeLine{886 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GNUC\_HAS\_CPP\_ATTRIBUTE}}
\DoxyCodeLine{887 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{888 \textcolor{preprocessor}{\#if defined(\_\_has\_cpp\_attribute) \&\& defined(\_\_cplusplus)}}
\DoxyCodeLine{889 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_CPP\_ATTRIBUTE(attribute,major,minor,patch) \_\_has\_cpp\_attribute(attribute)}}
\DoxyCodeLine{890 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{891 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_CPP\_ATTRIBUTE(attribute,major,minor,patch) JSON\_HEDLEY\_GNUC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{892 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{893 }
\DoxyCodeLine{894 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_HAS\_CPP\_ATTRIBUTE)}}
\DoxyCodeLine{895 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GCC\_HAS\_CPP\_ATTRIBUTE}}
\DoxyCodeLine{896 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{897 \textcolor{preprocessor}{\#if defined(\_\_has\_cpp\_attribute) \&\& defined(\_\_cplusplus)}}
\DoxyCodeLine{898 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_CPP\_ATTRIBUTE(attribute,major,minor,patch) \_\_has\_cpp\_attribute(attribute)}}
\DoxyCodeLine{899 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{900 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_CPP\_ATTRIBUTE(attribute,major,minor,patch) JSON\_HEDLEY\_GCC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{901 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{902 }
\DoxyCodeLine{903 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_HAS\_BUILTIN)}}
\DoxyCodeLine{904 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_HAS\_BUILTIN}}
\DoxyCodeLine{905 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{906 \textcolor{preprocessor}{\#if defined(\_\_has\_builtin)}}
\DoxyCodeLine{907 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_BUILTIN(builtin) \_\_has\_builtin(builtin)}}
\DoxyCodeLine{908 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{909 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_BUILTIN(builtin) (0)}}
\DoxyCodeLine{910 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{911 }
\DoxyCodeLine{912 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GNUC\_HAS\_BUILTIN)}}
\DoxyCodeLine{913 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GNUC\_HAS\_BUILTIN}}
\DoxyCodeLine{914 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{915 \textcolor{preprocessor}{\#if defined(\_\_has\_builtin)}}
\DoxyCodeLine{916 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_BUILTIN(builtin,major,minor,patch) \_\_has\_builtin(builtin)}}
\DoxyCodeLine{917 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{918 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_BUILTIN(builtin,major,minor,patch) JSON\_HEDLEY\_GNUC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{919 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{920 }
\DoxyCodeLine{921 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_HAS\_BUILTIN)}}
\DoxyCodeLine{922 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GCC\_HAS\_BUILTIN}}
\DoxyCodeLine{923 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{924 \textcolor{preprocessor}{\#if defined(\_\_has\_builtin)}}
\DoxyCodeLine{925 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_BUILTIN(builtin,major,minor,patch) \_\_has\_builtin(builtin)}}
\DoxyCodeLine{926 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{927 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_BUILTIN(builtin,major,minor,patch) JSON\_HEDLEY\_GCC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{928 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{929 }
\DoxyCodeLine{930 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_HAS\_FEATURE)}}
\DoxyCodeLine{931 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_HAS\_FEATURE}}
\DoxyCodeLine{932 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{933 \textcolor{preprocessor}{\#if defined(\_\_has\_feature)}}
\DoxyCodeLine{934 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_FEATURE(feature) \_\_has\_feature(feature)}}
\DoxyCodeLine{935 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{936 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_FEATURE(feature) (0)}}
\DoxyCodeLine{937 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{938 }
\DoxyCodeLine{939 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GNUC\_HAS\_FEATURE)}}
\DoxyCodeLine{940 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GNUC\_HAS\_FEATURE}}
\DoxyCodeLine{941 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{942 \textcolor{preprocessor}{\#if defined(\_\_has\_feature)}}
\DoxyCodeLine{943 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_FEATURE(feature,major,minor,patch) \_\_has\_feature(feature)}}
\DoxyCodeLine{944 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{945 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_FEATURE(feature,major,minor,patch) JSON\_HEDLEY\_GNUC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{946 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{947 }
\DoxyCodeLine{948 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_HAS\_FEATURE)}}
\DoxyCodeLine{949 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GCC\_HAS\_FEATURE}}
\DoxyCodeLine{950 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{951 \textcolor{preprocessor}{\#if defined(\_\_has\_feature)}}
\DoxyCodeLine{952 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_FEATURE(feature,major,minor,patch) \_\_has\_feature(feature)}}
\DoxyCodeLine{953 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{954 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_FEATURE(feature,major,minor,patch) JSON\_HEDLEY\_GCC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{955 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{956 }
\DoxyCodeLine{957 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_HAS\_EXTENSION)}}
\DoxyCodeLine{958 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_HAS\_EXTENSION}}
\DoxyCodeLine{959 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{960 \textcolor{preprocessor}{\#if defined(\_\_has\_extension)}}
\DoxyCodeLine{961 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_EXTENSION(extension) \_\_has\_extension(extension)}}
\DoxyCodeLine{962 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{963 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_EXTENSION(extension) (0)}}
\DoxyCodeLine{964 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{965 }
\DoxyCodeLine{966 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GNUC\_HAS\_EXTENSION)}}
\DoxyCodeLine{967 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GNUC\_HAS\_EXTENSION}}
\DoxyCodeLine{968 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{969 \textcolor{preprocessor}{\#if defined(\_\_has\_extension)}}
\DoxyCodeLine{970 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_EXTENSION(extension,major,minor,patch) \_\_has\_extension(extension)}}
\DoxyCodeLine{971 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{972 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_EXTENSION(extension,major,minor,patch) JSON\_HEDLEY\_GNUC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{973 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{974 }
\DoxyCodeLine{975 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_HAS\_EXTENSION)}}
\DoxyCodeLine{976 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GCC\_HAS\_EXTENSION}}
\DoxyCodeLine{977 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{978 \textcolor{preprocessor}{\#if defined(\_\_has\_extension)}}
\DoxyCodeLine{979 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_EXTENSION(extension,major,minor,patch) \_\_has\_extension(extension)}}
\DoxyCodeLine{980 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{981 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_EXTENSION(extension,major,minor,patch) JSON\_HEDLEY\_GCC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{982 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{983 }
\DoxyCodeLine{984 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_HAS\_DECLSPEC\_ATTRIBUTE)}}
\DoxyCodeLine{985 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_HAS\_DECLSPEC\_ATTRIBUTE}}
\DoxyCodeLine{986 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{987 \textcolor{preprocessor}{\#if defined(\_\_has\_declspec\_attribute)}}
\DoxyCodeLine{988 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_DECLSPEC\_ATTRIBUTE(attribute) \_\_has\_declspec\_attribute(attribute)}}
\DoxyCodeLine{989 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{990 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_DECLSPEC\_ATTRIBUTE(attribute) (0)}}
\DoxyCodeLine{991 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{992 }
\DoxyCodeLine{993 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GNUC\_HAS\_DECLSPEC\_ATTRIBUTE)}}
\DoxyCodeLine{994 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GNUC\_HAS\_DECLSPEC\_ATTRIBUTE}}
\DoxyCodeLine{995 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{996 \textcolor{preprocessor}{\#if defined(\_\_has\_declspec\_attribute)}}
\DoxyCodeLine{997 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_DECLSPEC\_ATTRIBUTE(attribute,major,minor,patch) \_\_has\_declspec\_attribute(attribute)}}
\DoxyCodeLine{998 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{999 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_DECLSPEC\_ATTRIBUTE(attribute,major,minor,patch) JSON\_HEDLEY\_GNUC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{1000 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1001 }
\DoxyCodeLine{1002 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_HAS\_DECLSPEC\_ATTRIBUTE)}}
\DoxyCodeLine{1003 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GCC\_HAS\_DECLSPEC\_ATTRIBUTE}}
\DoxyCodeLine{1004 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1005 \textcolor{preprocessor}{\#if defined(\_\_has\_declspec\_attribute)}}
\DoxyCodeLine{1006 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_DECLSPEC\_ATTRIBUTE(attribute,major,minor,patch) \_\_has\_declspec\_attribute(attribute)}}
\DoxyCodeLine{1007 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1008 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_DECLSPEC\_ATTRIBUTE(attribute,major,minor,patch) JSON\_HEDLEY\_GCC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{1009 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1010 }
\DoxyCodeLine{1011 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_HAS\_WARNING)}}
\DoxyCodeLine{1012 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_HAS\_WARNING}}
\DoxyCodeLine{1013 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1014 \textcolor{preprocessor}{\#if defined(\_\_has\_warning)}}
\DoxyCodeLine{1015 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_WARNING(warning) \_\_has\_warning(warning)}}
\DoxyCodeLine{1016 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1017 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_HAS\_WARNING(warning) (0)}}
\DoxyCodeLine{1018 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1019 }
\DoxyCodeLine{1020 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GNUC\_HAS\_WARNING)}}
\DoxyCodeLine{1021 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GNUC\_HAS\_WARNING}}
\DoxyCodeLine{1022 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1023 \textcolor{preprocessor}{\#if defined(\_\_has\_warning)}}
\DoxyCodeLine{1024 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_WARNING(warning,major,minor,patch) \_\_has\_warning(warning)}}
\DoxyCodeLine{1025 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1026 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GNUC\_HAS\_WARNING(warning,major,minor,patch) JSON\_HEDLEY\_GNUC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{1027 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1028 }
\DoxyCodeLine{1029 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_HAS\_WARNING)}}
\DoxyCodeLine{1030 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GCC\_HAS\_WARNING}}
\DoxyCodeLine{1031 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1032 \textcolor{preprocessor}{\#if defined(\_\_has\_warning)}}
\DoxyCodeLine{1033 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_WARNING(warning,major,minor,patch) \_\_has\_warning(warning)}}
\DoxyCodeLine{1034 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1035 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_HAS\_WARNING(warning,major,minor,patch) JSON\_HEDLEY\_GCC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{1036 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1037 }
\DoxyCodeLine{1038 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1039 \textcolor{preprocessor}{    (defined(\_\_STDC\_VERSION\_\_) \&\& (\_\_STDC\_VERSION\_\_ >= 199901L)) || \(\backslash\)}}
\DoxyCodeLine{1040 \textcolor{preprocessor}{    defined(\_\_clang\_\_) || \(\backslash\)}}
\DoxyCodeLine{1041 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,0,0) || \(\backslash\)}}
\DoxyCodeLine{1042 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1043 \textcolor{preprocessor}{    JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,0,0) || \(\backslash\)}}
\DoxyCodeLine{1044 \textcolor{preprocessor}{    JSON\_HEDLEY\_PGI\_VERSION\_CHECK(18,4,0) || \(\backslash\)}}
\DoxyCodeLine{1045 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1046 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1047 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,7,0) || \(\backslash\)}}
\DoxyCodeLine{1048 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(2,0,1) || \(\backslash\)}}
\DoxyCodeLine{1049 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,1,0) || \(\backslash\)}}
\DoxyCodeLine{1050 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,0,0) || \(\backslash\)}}
\DoxyCodeLine{1051 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1052 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1053 \textcolor{preprocessor}{    JSON\_HEDLEY\_CRAY\_VERSION\_CHECK(5,0,0) || \(\backslash\)}}
\DoxyCodeLine{1054 \textcolor{preprocessor}{    JSON\_HEDLEY\_TINYC\_VERSION\_CHECK(0,9,17) || \(\backslash\)}}
\DoxyCodeLine{1055 \textcolor{preprocessor}{    JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(8,0,0) || \(\backslash\)}}
\DoxyCodeLine{1056 \textcolor{preprocessor}{    (JSON\_HEDLEY\_IBM\_VERSION\_CHECK(10,1,0) \&\& defined(\_\_C99\_PRAGMA\_OPERATOR))}}
\DoxyCodeLine{1057 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PRAGMA(value) \_Pragma(\#value)}}
\DoxyCodeLine{1058 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(15,0,0)}}
\DoxyCodeLine{1059 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PRAGMA(value) \_\_pragma(value)}}
\DoxyCodeLine{1060 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1061 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PRAGMA(value)}}
\DoxyCodeLine{1062 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1063 }
\DoxyCodeLine{1064 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DIAGNOSTIC\_PUSH)}}
\DoxyCodeLine{1065 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DIAGNOSTIC\_PUSH}}
\DoxyCodeLine{1066 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1067 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DIAGNOSTIC\_POP)}}
\DoxyCodeLine{1068 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DIAGNOSTIC\_POP}}
\DoxyCodeLine{1069 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1070 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{1071 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \_Pragma("{}clang diagnostic push"{}})}
\DoxyCodeLine{1072 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_POP \_Pragma("{}clang diagnostic pop"{}})}
\DoxyCodeLine{1073 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0)}}
\DoxyCodeLine{1074 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \_Pragma("{}warning(push)"{}})}
\DoxyCodeLine{1075 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_POP \_Pragma("{}warning(pop)"{}})}
\DoxyCodeLine{1076 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,6,0)}}
\DoxyCodeLine{1077 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \_Pragma("{}GCC diagnostic push"{}})}
\DoxyCodeLine{1078 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_POP \_Pragma("{}GCC diagnostic pop"{}})}
\DoxyCodeLine{1079 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1080 \textcolor{preprocessor}{    JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(15,0,0) || \(\backslash\)}}
\DoxyCodeLine{1081 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1082 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \_\_pragma(warning(push))}}
\DoxyCodeLine{1083 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_POP \_\_pragma(warning(pop))}}
\DoxyCodeLine{1084 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_ARM\_VERSION\_CHECK(5,6,0)}}
\DoxyCodeLine{1085 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \_Pragma("{}push"{}})}
\DoxyCodeLine{1086 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_POP \_Pragma("{}pop"{}})}
\DoxyCodeLine{1087 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1088 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1089 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1090 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,4,0) || \(\backslash\)}}
\DoxyCodeLine{1091 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(8,1,0) || \(\backslash\)}}
\DoxyCodeLine{1092 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1093 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0)}}
\DoxyCodeLine{1094 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \_Pragma("{}diag\_push"{}})}
\DoxyCodeLine{1095 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_POP \_Pragma("{}diag\_pop"{}})}
\DoxyCodeLine{1096 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PELLES\_VERSION\_CHECK(2,90,0)}}
\DoxyCodeLine{1097 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \_Pragma("{}warning(push)"{}})}
\DoxyCodeLine{1098 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_POP \_Pragma("{}warning(pop)"{}})}
\DoxyCodeLine{1099 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1100 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_PUSH}}
\DoxyCodeLine{1101 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_POP}}
\DoxyCodeLine{1102 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1103 }
\DoxyCodeLine{1104 \textcolor{comment}{/* JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_ is for}}
\DoxyCodeLine{1105 \textcolor{comment}{   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */}}
\DoxyCodeLine{1106 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_)}}
\DoxyCodeLine{1107 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_}}
\DoxyCodeLine{1108 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1109 \textcolor{preprocessor}{\#if defined(\_\_cplusplus)}}
\DoxyCodeLine{1110 \textcolor{preprocessor}{\#  if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wc++98-\/compat"{}})}
\DoxyCodeLine{1111 \textcolor{preprocessor}{\#    if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wc++17-\/extensions"{}})}
\DoxyCodeLine{1112 \textcolor{preprocessor}{\#      if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wc++1z-\/extensions"{}})}
\DoxyCodeLine{1113 \textcolor{preprocessor}{\#        define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_(xpr) \(\backslash\)}}
\DoxyCodeLine{1114 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{1115 \textcolor{preprocessor}{    \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wc++98-\/compat\(\backslash\)"{}"{}}) \(\backslash\)}
\DoxyCodeLine{1116     \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wc++17-\/extensions\(\backslash\)"{}"{}) \(\backslash\)}
\DoxyCodeLine{1117     \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wc++1z-\/extensions\(\backslash\)"{}"{}) \(\backslash\)}
\DoxyCodeLine{1118     xpr \(\backslash\)}
\DoxyCodeLine{1119     JSON\_HEDLEY\_DIAGNOSTIC\_POP}
\DoxyCodeLine{1120 \textcolor{preprocessor}{\#      else}}
\DoxyCodeLine{1121 \textcolor{preprocessor}{\#        define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_(xpr) \(\backslash\)}}
\DoxyCodeLine{1122 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{1123 \textcolor{preprocessor}{    \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wc++98-\/compat\(\backslash\)"{}"{}}) \(\backslash\)}
\DoxyCodeLine{1124     \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wc++17-\/extensions\(\backslash\)"{}"{}) \(\backslash\)}
\DoxyCodeLine{1125     xpr \(\backslash\)}
\DoxyCodeLine{1126     JSON\_HEDLEY\_DIAGNOSTIC\_POP}
\DoxyCodeLine{1127 \textcolor{preprocessor}{\#      endif}}
\DoxyCodeLine{1128 \textcolor{preprocessor}{\#    else}}
\DoxyCodeLine{1129 \textcolor{preprocessor}{\#      define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_(xpr) \(\backslash\)}}
\DoxyCodeLine{1130 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{1131 \textcolor{preprocessor}{    \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wc++98-\/compat\(\backslash\)"{}"{}}) \(\backslash\)}
\DoxyCodeLine{1132     xpr \(\backslash\)}
\DoxyCodeLine{1133     JSON\_HEDLEY\_DIAGNOSTIC\_POP}
\DoxyCodeLine{1134 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{1135 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{1136 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1137 \textcolor{preprocessor}{\#if !defined(JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_)}}
\DoxyCodeLine{1138 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_(x) x}}
\DoxyCodeLine{1139 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1140 }
\DoxyCodeLine{1141 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CONST\_CAST)}}
\DoxyCodeLine{1142 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CONST\_CAST}}
\DoxyCodeLine{1143 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1144 \textcolor{preprocessor}{\#if defined(\_\_cplusplus)}}
\DoxyCodeLine{1145 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_CONST\_CAST(T, expr) (const\_cast<T>(expr))}}
\DoxyCodeLine{1146 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1147 \textcolor{preprocessor}{  JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wcast-\/qual"{}}) || \(\backslash\)}
\DoxyCodeLine{1148   JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,6,0) || \(\backslash\)}
\DoxyCodeLine{1149   JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0)}
\DoxyCodeLine{1150 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_CONST\_CAST(T, expr) (\_\_extension\_\_ (\{ \(\backslash\)}}
\DoxyCodeLine{1151 \textcolor{preprocessor}{        JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{1152 \textcolor{preprocessor}{        JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CAST\_QUAL \(\backslash\)}}
\DoxyCodeLine{1153 \textcolor{preprocessor}{        ((T) (expr)); \(\backslash\)}}
\DoxyCodeLine{1154 \textcolor{preprocessor}{        JSON\_HEDLEY\_DIAGNOSTIC\_POP \(\backslash\)}}
\DoxyCodeLine{1155 \textcolor{preprocessor}{    \}))}}
\DoxyCodeLine{1156 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1157 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_CONST\_CAST(T, expr) ((T) (expr))}}
\DoxyCodeLine{1158 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1159 }
\DoxyCodeLine{1160 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_REINTERPRET\_CAST)}}
\DoxyCodeLine{1161 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_REINTERPRET\_CAST}}
\DoxyCodeLine{1162 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1163 \textcolor{preprocessor}{\#if defined(\_\_cplusplus)}}
\DoxyCodeLine{1164 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_REINTERPRET\_CAST(T, expr) (reinterpret\_cast<T>(expr))}}
\DoxyCodeLine{1165 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1166 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_REINTERPRET\_CAST(T, expr) ((T) (expr))}}
\DoxyCodeLine{1167 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1168 }
\DoxyCodeLine{1169 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_STATIC\_CAST)}}
\DoxyCodeLine{1170 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_STATIC\_CAST}}
\DoxyCodeLine{1171 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1172 \textcolor{preprocessor}{\#if defined(\_\_cplusplus)}}
\DoxyCodeLine{1173 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_STATIC\_CAST(T, expr) (static\_cast<T>(expr))}}
\DoxyCodeLine{1174 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1175 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_STATIC\_CAST(T, expr) ((T) (expr))}}
\DoxyCodeLine{1176 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1177 }
\DoxyCodeLine{1178 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CPP\_CAST)}}
\DoxyCodeLine{1179 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CPP\_CAST}}
\DoxyCodeLine{1180 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1181 \textcolor{preprocessor}{\#if defined(\_\_cplusplus)}}
\DoxyCodeLine{1182 \textcolor{preprocessor}{\#  if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wold-\/style-\/cast"{}})}
\DoxyCodeLine{1183 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_CPP\_CAST(T, expr) \(\backslash\)}}
\DoxyCodeLine{1184 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{1185 \textcolor{preprocessor}{    \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wold-\/style-\/cast\(\backslash\)"{}"{}}) \(\backslash\)}
\DoxyCodeLine{1186     ((T) (expr)) \(\backslash\)}
\DoxyCodeLine{1187     JSON\_HEDLEY\_DIAGNOSTIC\_POP}
\DoxyCodeLine{1188 \textcolor{preprocessor}{\#  elif JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,3,0)}}
\DoxyCodeLine{1189 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_CPP\_CAST(T, expr) \(\backslash\)}}
\DoxyCodeLine{1190 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{1191 \textcolor{preprocessor}{    \_Pragma("{}diag\_suppress=Pe137"{}}) \(\backslash\)}
\DoxyCodeLine{1192     JSON\_HEDLEY\_DIAGNOSTIC\_POP}
\DoxyCodeLine{1193 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{1194 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_CPP\_CAST(T, expr) ((T) (expr))}}
\DoxyCodeLine{1195 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{1196 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1197 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_CPP\_CAST(T, expr) (expr)}}
\DoxyCodeLine{1198 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1199 }
\DoxyCodeLine{1200 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED)}}
\DoxyCodeLine{1201 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED}}
\DoxyCodeLine{1202 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1203 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wdeprecated-\/declarations"{}})}
\DoxyCodeLine{1204 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wdeprecated-\/declarations\(\backslash\)"{}"{}})}
\DoxyCodeLine{1205 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0)}}
\DoxyCodeLine{1206 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}warning(disable:1478 1786)"{}})}
\DoxyCodeLine{1207 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1208 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_\_pragma(warning(disable:1478 1786))}}
\DoxyCodeLine{1209 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PGI\_VERSION\_CHECK(20,7,0)}}
\DoxyCodeLine{1210 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}diag\_suppress 1215,1216,1444,1445"{}})}
\DoxyCodeLine{1211 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PGI\_VERSION\_CHECK(17,10,0)}}
\DoxyCodeLine{1212 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}diag\_suppress 1215,1444"{}})}
\DoxyCodeLine{1213 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,3,0)}}
\DoxyCodeLine{1214 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}GCC diagnostic ignored \(\backslash\)"{}-\/Wdeprecated-\/declarations\(\backslash\)"{}"{}})}
\DoxyCodeLine{1215 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(15,0,0)}}
\DoxyCodeLine{1216 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_\_pragma(warning(disable:4996))}}
\DoxyCodeLine{1217 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1218 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}diag\_suppress 1215,1444"{}})}
\DoxyCodeLine{1219 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1220 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1221 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,8,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1222 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1223 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1224 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1225 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1226 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1227 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1228 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) || \(\backslash\)}}
\DoxyCodeLine{1229 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1230 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0)}}
\DoxyCodeLine{1231 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}diag\_suppress 1291,1718"{}})}
\DoxyCodeLine{1232 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,13,0) \&\& !defined(\_\_cplusplus)}}
\DoxyCodeLine{1233 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}error\_messages(off,E\_DEPRECATED\_ATT,E\_DEPRECATED\_ATT\_MESS)"{}})}
\DoxyCodeLine{1234 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,13,0) \&\& defined(\_\_cplusplus)}}
\DoxyCodeLine{1235 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}error\_messages(off,symdeprecated,symdeprecated2)"{}})}
\DoxyCodeLine{1236 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,0,0)}}
\DoxyCodeLine{1237 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}diag\_suppress=Pe1444,Pe1215"{}})}
\DoxyCodeLine{1238 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PELLES\_VERSION\_CHECK(2,90,0)}}
\DoxyCodeLine{1239 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED \_Pragma("{}warn(disable:2241)"{}})}
\DoxyCodeLine{1240 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1241 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED}}
\DoxyCodeLine{1242 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1243 }
\DoxyCodeLine{1244 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS)}}
\DoxyCodeLine{1245 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS}}
\DoxyCodeLine{1246 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1247 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wunknown-\/pragmas"{}})}
\DoxyCodeLine{1248 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wunknown-\/pragmas\(\backslash\)"{}"{}})}
\DoxyCodeLine{1249 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0)}}
\DoxyCodeLine{1250 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \_Pragma("{}warning(disable:161)"{}})}
\DoxyCodeLine{1251 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1252 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \_\_pragma(warning(disable:161))}}
\DoxyCodeLine{1253 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PGI\_VERSION\_CHECK(17,10,0)}}
\DoxyCodeLine{1254 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \_Pragma("{}diag\_suppress 1675"{}})}
\DoxyCodeLine{1255 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,3,0)}}
\DoxyCodeLine{1256 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \_Pragma("{}GCC diagnostic ignored \(\backslash\)"{}-\/Wunknown-\/pragmas\(\backslash\)"{}"{}})}
\DoxyCodeLine{1257 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(15,0,0)}}
\DoxyCodeLine{1258 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \_\_pragma(warning(disable:4068))}}
\DoxyCodeLine{1259 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1260 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(16,9,0) || \(\backslash\)}}
\DoxyCodeLine{1261 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(8,0,0) || \(\backslash\)}}
\DoxyCodeLine{1262 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1263 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,3,0)}}
\DoxyCodeLine{1264 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \_Pragma("{}diag\_suppress 163"{}})}
\DoxyCodeLine{1265 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(8,0,0)}}
\DoxyCodeLine{1266 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \_Pragma("{}diag\_suppress 163"{}})}
\DoxyCodeLine{1267 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,0,0)}}
\DoxyCodeLine{1268 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \_Pragma("{}diag\_suppress=Pe161"{}})}
\DoxyCodeLine{1269 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1270 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \_Pragma("{}diag\_suppress 161"{}})}
\DoxyCodeLine{1271 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1272 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS}}
\DoxyCodeLine{1273 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1274 }
\DoxyCodeLine{1275 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES)}}
\DoxyCodeLine{1276 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES}}
\DoxyCodeLine{1277 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1278 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wunknown-\/attributes"{}})}
\DoxyCodeLine{1279 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wunknown-\/attributes\(\backslash\)"{}"{}})}
\DoxyCodeLine{1280 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,6,0)}}
\DoxyCodeLine{1281 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_Pragma("{}GCC diagnostic ignored \(\backslash\)"{}-\/Wdeprecated-\/declarations\(\backslash\)"{}"{}})}
\DoxyCodeLine{1282 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(17,0,0)}}
\DoxyCodeLine{1283 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_Pragma("{}warning(disable:1292)"{}})}
\DoxyCodeLine{1284 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1285 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_\_pragma(warning(disable:1292))}}
\DoxyCodeLine{1286 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(19,0,0)}}
\DoxyCodeLine{1287 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_\_pragma(warning(disable:5030))}}
\DoxyCodeLine{1288 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PGI\_VERSION\_CHECK(20,7,0)}}
\DoxyCodeLine{1289 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_Pragma("{}diag\_suppress 1097,1098"{}})}
\DoxyCodeLine{1290 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PGI\_VERSION\_CHECK(17,10,0)}}
\DoxyCodeLine{1291 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_Pragma("{}diag\_suppress 1097"{}})}
\DoxyCodeLine{1292 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,14,0) \&\& defined(\_\_cplusplus)}}
\DoxyCodeLine{1293 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_Pragma("{}error\_messages(off,attrskipunsup)"{}})}
\DoxyCodeLine{1294 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1295 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(18,1,0) || \(\backslash\)}}
\DoxyCodeLine{1296 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(8,3,0) || \(\backslash\)}}
\DoxyCodeLine{1297 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0)}}
\DoxyCodeLine{1298 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_Pragma("{}diag\_suppress 1173"{}})}
\DoxyCodeLine{1299 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,0,0)}}
\DoxyCodeLine{1300 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_Pragma("{}diag\_suppress=Pe1097"{}})}
\DoxyCodeLine{1301 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1302 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES \_Pragma("{}diag\_suppress 1097"{}})}
\DoxyCodeLine{1303 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1304 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES}}
\DoxyCodeLine{1305 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1306 }
\DoxyCodeLine{1307 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CAST\_QUAL)}}
\DoxyCodeLine{1308 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CAST\_QUAL}}
\DoxyCodeLine{1309 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1310 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wcast-\/qual"{}})}
\DoxyCodeLine{1311 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CAST\_QUAL \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wcast-\/qual\(\backslash\)"{}"{}})}
\DoxyCodeLine{1312 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0)}}
\DoxyCodeLine{1313 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CAST\_QUAL \_Pragma("{}warning(disable:2203 2331)"{}})}
\DoxyCodeLine{1314 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,0,0)}}
\DoxyCodeLine{1315 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CAST\_QUAL \_Pragma("{}GCC diagnostic ignored \(\backslash\)"{}-\/Wcast-\/qual\(\backslash\)"{}"{}})}
\DoxyCodeLine{1316 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1317 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CAST\_QUAL}}
\DoxyCodeLine{1318 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1319 }
\DoxyCodeLine{1320 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNUSED\_FUNCTION)}}
\DoxyCodeLine{1321 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNUSED\_FUNCTION}}
\DoxyCodeLine{1322 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1323 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wunused-\/function"{}})}
\DoxyCodeLine{1324 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNUSED\_FUNCTION \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wunused-\/function\(\backslash\)"{}"{}})}
\DoxyCodeLine{1325 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,4,0)}}
\DoxyCodeLine{1326 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNUSED\_FUNCTION \_Pragma("{}GCC diagnostic ignored \(\backslash\)"{}-\/Wunused-\/function\(\backslash\)"{}"{}})}
\DoxyCodeLine{1327 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(1,0,0)}}
\DoxyCodeLine{1328 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNUSED\_FUNCTION \_\_pragma(warning(disable:4505))}}
\DoxyCodeLine{1329 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1330 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNUSED\_FUNCTION \_Pragma("{}diag\_suppress 3142"{}})}
\DoxyCodeLine{1331 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1332 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNUSED\_FUNCTION}}
\DoxyCodeLine{1333 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1334 }
\DoxyCodeLine{1335 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DEPRECATED)}}
\DoxyCodeLine{1336 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DEPRECATED}}
\DoxyCodeLine{1337 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1338 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_DEPRECATED\_FOR)}}
\DoxyCodeLine{1339 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_DEPRECATED\_FOR}}
\DoxyCodeLine{1340 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1341 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1342 \textcolor{preprocessor}{    JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(14,0,0) || \(\backslash\)}}
\DoxyCodeLine{1343 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1344 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED(since) \_\_declspec(deprecated("{}Since "{}} \# since))}
\DoxyCodeLine{1345 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED\_FOR(since, replacement) \_\_declspec(deprecated("{}Since "{}} \#since "{}; use "{} \#replacement))}
\DoxyCodeLine{1346 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1347 \textcolor{preprocessor}{    (JSON\_HEDLEY\_HAS\_EXTENSION(attribute\_deprecated\_with\_message) \&\& !defined(JSON\_HEDLEY\_IAR\_VERSION)) || \(\backslash\)}}
\DoxyCodeLine{1348 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,5,0) || \(\backslash\)}}
\DoxyCodeLine{1349 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1350 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(5,6,0) || \(\backslash\)}}
\DoxyCodeLine{1351 \textcolor{preprocessor}{    JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,13,0) || \(\backslash\)}}
\DoxyCodeLine{1352 \textcolor{preprocessor}{    JSON\_HEDLEY\_PGI\_VERSION\_CHECK(17,10,0) || \(\backslash\)}}
\DoxyCodeLine{1353 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(18,1,0) || \(\backslash\)}}
\DoxyCodeLine{1354 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(18,1,0) || \(\backslash\)}}
\DoxyCodeLine{1355 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(8,3,0) || \(\backslash\)}}
\DoxyCodeLine{1356 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1357 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,3,0) || \(\backslash\)}}
\DoxyCodeLine{1358 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1359 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED(since) \_\_attribute\_\_((\_\_deprecated\_\_("{}Since "{}} \#since)))}
\DoxyCodeLine{1360 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED\_FOR(since, replacement) \_\_attribute\_\_((\_\_deprecated\_\_("{}Since "{}} \#since "{}; use "{} \#replacement)))}
\DoxyCodeLine{1361 \textcolor{preprocessor}{\#elif defined(\_\_cplusplus) \&\& (\_\_cplusplus >= 201402L)}}
\DoxyCodeLine{1362 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED(since) JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_([[deprecated("{}Since "{}} \#since)]])}
\DoxyCodeLine{1363 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED\_FOR(since, replacement) JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_([[deprecated("{}Since "{}} \#since "{}; use "{} \#replacement)]])}
\DoxyCodeLine{1364 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1365 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(deprecated) || \(\backslash\)}}
\DoxyCodeLine{1366 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,1,0) || \(\backslash\)}}
\DoxyCodeLine{1367 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1368 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1369 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,8,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1370 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1371 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1372 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1373 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1374 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1375 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1376 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) || \(\backslash\)}}
\DoxyCodeLine{1377 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1378 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1379 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10) || \(\backslash\)}}
\DoxyCodeLine{1380 \textcolor{preprocessor}{    JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,10,0)}}
\DoxyCodeLine{1381 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED(since) \_\_attribute\_\_((\_\_deprecated\_\_))}}
\DoxyCodeLine{1382 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED\_FOR(since, replacement) \_\_attribute\_\_((\_\_deprecated\_\_))}}
\DoxyCodeLine{1383 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1384 \textcolor{preprocessor}{    JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(13,10,0) || \(\backslash\)}}
\DoxyCodeLine{1385 \textcolor{preprocessor}{    JSON\_HEDLEY\_PELLES\_VERSION\_CHECK(6,50,0) || \(\backslash\)}}
\DoxyCodeLine{1386 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1387 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED(since) \_\_declspec(deprecated)}}
\DoxyCodeLine{1388 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED\_FOR(since, replacement) \_\_declspec(deprecated)}}
\DoxyCodeLine{1389 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,0,0)}}
\DoxyCodeLine{1390 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED(since) \_Pragma("{}deprecated"{}})}
\DoxyCodeLine{1391 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED\_FOR(since, replacement) \_Pragma("{}deprecated"{}})}
\DoxyCodeLine{1392 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1393 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED(since)}}
\DoxyCodeLine{1394 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_DEPRECATED\_FOR(since, replacement)}}
\DoxyCodeLine{1395 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1396 }
\DoxyCodeLine{1397 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_UNAVAILABLE)}}
\DoxyCodeLine{1398 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_UNAVAILABLE}}
\DoxyCodeLine{1399 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1400 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1401 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(warning) || \(\backslash\)}}
\DoxyCodeLine{1402 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1403 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1404 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1405 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_UNAVAILABLE(available\_since) \_\_attribute\_\_((\_\_warning\_\_("{}Not available until "{}} \#available\_since)))}
\DoxyCodeLine{1406 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1407 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_UNAVAILABLE(available\_since)}}
\DoxyCodeLine{1408 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1409 }
\DoxyCodeLine{1410 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_WARN\_UNUSED\_RESULT)}}
\DoxyCodeLine{1411 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}}
\DoxyCodeLine{1412 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1413 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_WARN\_UNUSED\_RESULT\_MSG)}}
\DoxyCodeLine{1414 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_WARN\_UNUSED\_RESULT\_MSG}}
\DoxyCodeLine{1415 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1416 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1417 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(warn\_unused\_result) || \(\backslash\)}}
\DoxyCodeLine{1418 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,4,0) || \(\backslash\)}}
\DoxyCodeLine{1419 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1420 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1421 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,8,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1422 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1423 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1424 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1425 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1426 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1427 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1428 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) || \(\backslash\)}}
\DoxyCodeLine{1429 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1430 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1431 \textcolor{preprocessor}{    (JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,15,0) \&\& defined(\_\_cplusplus)) || \(\backslash\)}}
\DoxyCodeLine{1432 \textcolor{preprocessor}{    JSON\_HEDLEY\_PGI\_VERSION\_CHECK(17,10,0) || \(\backslash\)}}
\DoxyCodeLine{1433 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1434 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_WARN\_UNUSED\_RESULT \_\_attribute\_\_((\_\_warn\_unused\_result\_\_))}}
\DoxyCodeLine{1435 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_WARN\_UNUSED\_RESULT\_MSG(msg) \_\_attribute\_\_((\_\_warn\_unused\_result\_\_))}}
\DoxyCodeLine{1436 \textcolor{preprocessor}{\#elif (JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE(nodiscard) >= 201907L)}}
\DoxyCodeLine{1437 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_WARN\_UNUSED\_RESULT JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_([[nodiscard]])}}
\DoxyCodeLine{1438 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_WARN\_UNUSED\_RESULT\_MSG(msg) JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_([[nodiscard(msg)]])}}
\DoxyCodeLine{1439 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE(nodiscard)}}
\DoxyCodeLine{1440 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_WARN\_UNUSED\_RESULT JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_([[nodiscard]])}}
\DoxyCodeLine{1441 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_WARN\_UNUSED\_RESULT\_MSG(msg) JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_([[nodiscard]])}}
\DoxyCodeLine{1442 \textcolor{preprocessor}{\#elif defined(\_Check\_return\_) }\textcolor{comment}{/* SAL */}\textcolor{preprocessor}{}}
\DoxyCodeLine{1443 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_WARN\_UNUSED\_RESULT \_Check\_return\_}}
\DoxyCodeLine{1444 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_WARN\_UNUSED\_RESULT\_MSG(msg) \_Check\_return\_}}
\DoxyCodeLine{1445 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1446 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}}
\DoxyCodeLine{1447 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_WARN\_UNUSED\_RESULT\_MSG(msg)}}
\DoxyCodeLine{1448 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1449 }
\DoxyCodeLine{1450 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_SENTINEL)}}
\DoxyCodeLine{1451 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_SENTINEL}}
\DoxyCodeLine{1452 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1453 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1454 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(sentinel) || \(\backslash\)}}
\DoxyCodeLine{1455 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,0,0) || \(\backslash\)}}
\DoxyCodeLine{1456 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1457 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(5,4,0) || \(\backslash\)}}
\DoxyCodeLine{1458 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1459 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_SENTINEL(position) \_\_attribute\_\_((\_\_sentinel\_\_(position)))}}
\DoxyCodeLine{1460 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1461 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_SENTINEL(position)}}
\DoxyCodeLine{1462 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1463 }
\DoxyCodeLine{1464 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_NO\_RETURN)}}
\DoxyCodeLine{1465 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_NO\_RETURN}}
\DoxyCodeLine{1466 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1467 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,0,0)}}
\DoxyCodeLine{1468 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN \_\_noreturn}}
\DoxyCodeLine{1469 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1470 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1471 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1472 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN \_\_attribute\_\_((\_\_noreturn\_\_))}}
\DoxyCodeLine{1473 \textcolor{preprocessor}{\#elif defined(\_\_STDC\_VERSION\_\_) \&\& \_\_STDC\_VERSION\_\_ >= 201112L}}
\DoxyCodeLine{1474 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN \_Noreturn}}
\DoxyCodeLine{1475 \textcolor{preprocessor}{\#elif defined(\_\_cplusplus) \&\& (\_\_cplusplus >= 201103L)}}
\DoxyCodeLine{1476 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_([[noreturn]])}}
\DoxyCodeLine{1477 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1478 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(noreturn) || \(\backslash\)}}
\DoxyCodeLine{1479 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,2,0) || \(\backslash\)}}
\DoxyCodeLine{1480 \textcolor{preprocessor}{    JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,11,0) || \(\backslash\)}}
\DoxyCodeLine{1481 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1482 \textcolor{preprocessor}{    JSON\_HEDLEY\_IBM\_VERSION\_CHECK(10,1,0) || \(\backslash\)}}
\DoxyCodeLine{1483 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1484 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,8,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1485 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1486 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1487 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1488 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1489 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1490 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1491 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) || \(\backslash\)}}
\DoxyCodeLine{1492 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1493 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1494 \textcolor{preprocessor}{    JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,10,0)}}
\DoxyCodeLine{1495 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN \_\_attribute\_\_((\_\_noreturn\_\_))}}
\DoxyCodeLine{1496 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,10,0)}}
\DoxyCodeLine{1497 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN \_Pragma("{}does\_not\_return"{}})}
\DoxyCodeLine{1498 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1499 \textcolor{preprocessor}{    JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(13,10,0) || \(\backslash\)}}
\DoxyCodeLine{1500 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1501 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN \_\_declspec(noreturn)}}
\DoxyCodeLine{1502 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_cplusplus)}}
\DoxyCodeLine{1503 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN \_Pragma("{}FUNC\_NEVER\_RETURNS;"{}})}
\DoxyCodeLine{1504 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_COMPCERT\_VERSION\_CHECK(3,2,0)}}
\DoxyCodeLine{1505 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN \_\_attribute((noreturn))}}
\DoxyCodeLine{1506 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PELLES\_VERSION\_CHECK(9,0,0)}}
\DoxyCodeLine{1507 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN \_\_declspec(noreturn)}}
\DoxyCodeLine{1508 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1509 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_RETURN}}
\DoxyCodeLine{1510 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1511 }
\DoxyCodeLine{1512 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_NO\_ESCAPE)}}
\DoxyCodeLine{1513 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_NO\_ESCAPE}}
\DoxyCodeLine{1514 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1515 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_ATTRIBUTE(noescape)}}
\DoxyCodeLine{1516 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_ESCAPE \_\_attribute\_\_((\_\_noescape\_\_))}}
\DoxyCodeLine{1517 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1518 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_ESCAPE}}
\DoxyCodeLine{1519 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1520 }
\DoxyCodeLine{1521 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_UNREACHABLE)}}
\DoxyCodeLine{1522 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_UNREACHABLE}}
\DoxyCodeLine{1523 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1524 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_UNREACHABLE\_RETURN)}}
\DoxyCodeLine{1525 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_UNREACHABLE\_RETURN}}
\DoxyCodeLine{1526 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1527 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_ASSUME)}}
\DoxyCodeLine{1528 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_ASSUME}}
\DoxyCodeLine{1529 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1530 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1531 \textcolor{preprocessor}{    JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(13,10,0) || \(\backslash\)}}
\DoxyCodeLine{1532 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1533 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1534 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_ASSUME(expr) \_\_assume(expr)}}
\DoxyCodeLine{1535 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_HAS\_BUILTIN(\_\_builtin\_assume)}}
\DoxyCodeLine{1536 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_ASSUME(expr) \_\_builtin\_assume(expr)}}
\DoxyCodeLine{1537 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1538 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,2,0) || \(\backslash\)}}
\DoxyCodeLine{1539 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(4,0,0)}}
\DoxyCodeLine{1540 \textcolor{preprocessor}{    \#if defined(\_\_cplusplus)}}
\DoxyCodeLine{1541 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_ASSUME(expr) std::\_nassert(expr)}}
\DoxyCodeLine{1542 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1543 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_ASSUME(expr) \_nassert(expr)}}
\DoxyCodeLine{1544 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1545 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1546 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1547 \textcolor{preprocessor}{    (JSON\_HEDLEY\_HAS\_BUILTIN(\_\_builtin\_unreachable) \&\& (!defined(JSON\_HEDLEY\_ARM\_VERSION))) || \(\backslash\)}}
\DoxyCodeLine{1548 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,5,0) || \(\backslash\)}}
\DoxyCodeLine{1549 \textcolor{preprocessor}{    JSON\_HEDLEY\_PGI\_VERSION\_CHECK(18,10,0) || \(\backslash\)}}
\DoxyCodeLine{1550 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1551 \textcolor{preprocessor}{    JSON\_HEDLEY\_IBM\_VERSION\_CHECK(13,1,5) || \(\backslash\)}}
\DoxyCodeLine{1552 \textcolor{preprocessor}{    JSON\_HEDLEY\_CRAY\_VERSION\_CHECK(10,0,0) || \(\backslash\)}}
\DoxyCodeLine{1553 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1554 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_UNREACHABLE() \_\_builtin\_unreachable()}}
\DoxyCodeLine{1555 \textcolor{preprocessor}{\#elif defined(JSON\_HEDLEY\_ASSUME)}}
\DoxyCodeLine{1556 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_UNREACHABLE() JSON\_HEDLEY\_ASSUME(0)}}
\DoxyCodeLine{1557 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1558 \textcolor{preprocessor}{\#if !defined(JSON\_HEDLEY\_ASSUME)}}
\DoxyCodeLine{1559 \textcolor{preprocessor}{    \#if defined(JSON\_HEDLEY\_UNREACHABLE)}}
\DoxyCodeLine{1560 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_ASSUME(expr) JSON\_HEDLEY\_STATIC\_CAST(void, ((expr) ? 1 : (JSON\_HEDLEY\_UNREACHABLE(), 1)))}}
\DoxyCodeLine{1561 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1562 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_ASSUME(expr) JSON\_HEDLEY\_STATIC\_CAST(void, expr)}}
\DoxyCodeLine{1563 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1564 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1565 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_UNREACHABLE)}}
\DoxyCodeLine{1566 \textcolor{preprocessor}{    \#if  \(\backslash\)}}
\DoxyCodeLine{1567 \textcolor{preprocessor}{        JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,2,0) || \(\backslash\)}}
\DoxyCodeLine{1568 \textcolor{preprocessor}{        JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(4,0,0)}}
\DoxyCodeLine{1569 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_UNREACHABLE\_RETURN(value) return (JSON\_HEDLEY\_STATIC\_CAST(void, JSON\_HEDLEY\_ASSUME(0)), (value))}}
\DoxyCodeLine{1570 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1571 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_UNREACHABLE\_RETURN(value) JSON\_HEDLEY\_UNREACHABLE()}}
\DoxyCodeLine{1572 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1573 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1574 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_UNREACHABLE\_RETURN(value) return (value)}}
\DoxyCodeLine{1575 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1576 \textcolor{preprocessor}{\#if !defined(JSON\_HEDLEY\_UNREACHABLE)}}
\DoxyCodeLine{1577 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_UNREACHABLE() JSON\_HEDLEY\_ASSUME(0)}}
\DoxyCodeLine{1578 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1579 }
\DoxyCodeLine{1580 JSON\_HEDLEY\_DIAGNOSTIC\_PUSH}
\DoxyCodeLine{1581 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wpedantic"{}})}
\DoxyCodeLine{1582 \textcolor{preprocessor}{    \#pragma clang diagnostic ignored "{}-\/Wpedantic"{}}}
\DoxyCodeLine{1583 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1584 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wc++98-\/compat-\/pedantic"{}}) \&\& defined(\_\_cplusplus)}
\DoxyCodeLine{1585 \textcolor{preprocessor}{    \#pragma clang diagnostic ignored "{}-\/Wc++98-\/compat-\/pedantic"{}}}
\DoxyCodeLine{1586 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1587 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_GCC\_HAS\_WARNING("{}-\/Wvariadic-\/macros"{}},4,0,0)}
\DoxyCodeLine{1588 \textcolor{preprocessor}{    \#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{1589 \textcolor{preprocessor}{        \#pragma clang diagnostic ignored "{}-\/Wvariadic-\/macros"{}}}
\DoxyCodeLine{1590 \textcolor{preprocessor}{    \#elif defined(JSON\_HEDLEY\_GCC\_VERSION)}}
\DoxyCodeLine{1591 \textcolor{preprocessor}{        \#pragma GCC diagnostic ignored "{}-\/Wvariadic-\/macros"{}}}
\DoxyCodeLine{1592 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1593 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1594 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_NON\_NULL)}}
\DoxyCodeLine{1595 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_NON\_NULL}}
\DoxyCodeLine{1596 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1597 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1598 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(nonnull) || \(\backslash\)}}
\DoxyCodeLine{1599 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,3,0) || \(\backslash\)}}
\DoxyCodeLine{1600 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1601 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0)}}
\DoxyCodeLine{1602 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NON\_NULL(...) \_\_attribute\_\_((\_\_nonnull\_\_(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{1603 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1604 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NON\_NULL(...)}}
\DoxyCodeLine{1605 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1606 JSON\_HEDLEY\_DIAGNOSTIC\_POP}
\DoxyCodeLine{1607 }
\DoxyCodeLine{1608 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PRINTF\_FORMAT)}}
\DoxyCodeLine{1609 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_PRINTF\_FORMAT}}
\DoxyCodeLine{1610 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1611 \textcolor{preprocessor}{\#if defined(\_\_MINGW32\_\_) \&\& JSON\_HEDLEY\_GCC\_HAS\_ATTRIBUTE(format,4,4,0) \&\& !defined(\_\_USE\_MINGW\_ANSI\_STDIO)}}
\DoxyCodeLine{1612 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PRINTF\_FORMAT(string\_idx,first\_to\_check) \_\_attribute\_\_((\_\_format\_\_(ms\_printf, string\_idx, first\_to\_check)))}}
\DoxyCodeLine{1613 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_) \&\& JSON\_HEDLEY\_GCC\_HAS\_ATTRIBUTE(format,4,4,0) \&\& defined(\_\_USE\_MINGW\_ANSI\_STDIO)}}
\DoxyCodeLine{1614 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PRINTF\_FORMAT(string\_idx,first\_to\_check) \_\_attribute\_\_((\_\_format\_\_(gnu\_printf, string\_idx, first\_to\_check)))}}
\DoxyCodeLine{1615 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1616 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(format) || \(\backslash\)}}
\DoxyCodeLine{1617 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,1,0) || \(\backslash\)}}
\DoxyCodeLine{1618 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1619 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(5,6,0) || \(\backslash\)}}
\DoxyCodeLine{1620 \textcolor{preprocessor}{    JSON\_HEDLEY\_IBM\_VERSION\_CHECK(10,1,0) || \(\backslash\)}}
\DoxyCodeLine{1621 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1622 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,8,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1623 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1624 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1625 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1626 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1627 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1628 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1629 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) || \(\backslash\)}}
\DoxyCodeLine{1630 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1631 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1632 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1633 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PRINTF\_FORMAT(string\_idx,first\_to\_check) \_\_attribute\_\_((\_\_format\_\_(\_\_printf\_\_, string\_idx, first\_to\_check)))}}
\DoxyCodeLine{1634 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PELLES\_VERSION\_CHECK(6,0,0)}}
\DoxyCodeLine{1635 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PRINTF\_FORMAT(string\_idx,first\_to\_check) \_\_declspec(vaformat(printf,string\_idx,first\_to\_check))}}
\DoxyCodeLine{1636 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1637 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_PRINTF\_FORMAT(string\_idx,first\_to\_check)}}
\DoxyCodeLine{1638 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1639 }
\DoxyCodeLine{1640 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CONSTEXPR)}}
\DoxyCodeLine{1641 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CONSTEXPR}}
\DoxyCodeLine{1642 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1643 \textcolor{preprocessor}{\#if defined(\_\_cplusplus)}}
\DoxyCodeLine{1644 \textcolor{preprocessor}{    \#if \_\_cplusplus >= 201103L}}
\DoxyCodeLine{1645 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_CONSTEXPR JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_(constexpr)}}
\DoxyCodeLine{1646 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1647 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1648 \textcolor{preprocessor}{\#if !defined(JSON\_HEDLEY\_CONSTEXPR)}}
\DoxyCodeLine{1649 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_CONSTEXPR}}
\DoxyCodeLine{1650 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1651 }
\DoxyCodeLine{1652 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PREDICT)}}
\DoxyCodeLine{1653 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_PREDICT}}
\DoxyCodeLine{1654 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1655 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_LIKELY)}}
\DoxyCodeLine{1656 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_LIKELY}}
\DoxyCodeLine{1657 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1658 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_UNLIKELY)}}
\DoxyCodeLine{1659 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_UNLIKELY}}
\DoxyCodeLine{1660 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1661 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_UNPREDICTABLE)}}
\DoxyCodeLine{1662 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_UNPREDICTABLE}}
\DoxyCodeLine{1663 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1664 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_BUILTIN(\_\_builtin\_unpredictable)}}
\DoxyCodeLine{1665 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_UNPREDICTABLE(expr) \_\_builtin\_unpredictable((expr))}}
\DoxyCodeLine{1666 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1667 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1668 \textcolor{preprocessor}{  (JSON\_HEDLEY\_HAS\_BUILTIN(\_\_builtin\_expect\_with\_probability) \&\& !defined(JSON\_HEDLEY\_PGI\_VERSION)) || \(\backslash\)}}
\DoxyCodeLine{1669 \textcolor{preprocessor}{  JSON\_HEDLEY\_GCC\_VERSION\_CHECK(9,0,0) || \(\backslash\)}}
\DoxyCodeLine{1670 \textcolor{preprocessor}{  JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1671 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PREDICT(expr, value, probability) \_\_builtin\_expect\_with\_probability(  (expr), (value), (probability))}}
\DoxyCodeLine{1672 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PREDICT\_TRUE(expr, probability)   \_\_builtin\_expect\_with\_probability(!!(expr),    1   , (probability))}}
\DoxyCodeLine{1673 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PREDICT\_FALSE(expr, probability)  \_\_builtin\_expect\_with\_probability(!!(expr),    0   , (probability))}}
\DoxyCodeLine{1674 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_LIKELY(expr)                      \_\_builtin\_expect                 (!!(expr),    1                  )}}
\DoxyCodeLine{1675 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_UNLIKELY(expr)                    \_\_builtin\_expect                 (!!(expr),    0                  )}}
\DoxyCodeLine{1676 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1677 \textcolor{preprocessor}{  (JSON\_HEDLEY\_HAS\_BUILTIN(\_\_builtin\_expect) \&\& !defined(JSON\_HEDLEY\_INTEL\_CL\_VERSION)) || \(\backslash\)}}
\DoxyCodeLine{1678 \textcolor{preprocessor}{  JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,0,0) || \(\backslash\)}}
\DoxyCodeLine{1679 \textcolor{preprocessor}{  JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1680 \textcolor{preprocessor}{  (JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,15,0) \&\& defined(\_\_cplusplus)) || \(\backslash\)}}
\DoxyCodeLine{1681 \textcolor{preprocessor}{  JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1682 \textcolor{preprocessor}{  JSON\_HEDLEY\_IBM\_VERSION\_CHECK(10,1,0) || \(\backslash\)}}
\DoxyCodeLine{1683 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1684 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,7,0) || \(\backslash\)}}
\DoxyCodeLine{1685 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(3,1,0) || \(\backslash\)}}
\DoxyCodeLine{1686 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,1,0) || \(\backslash\)}}
\DoxyCodeLine{1687 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(6,1,0) || \(\backslash\)}}
\DoxyCodeLine{1688 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1689 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1690 \textcolor{preprocessor}{  JSON\_HEDLEY\_TINYC\_VERSION\_CHECK(0,9,27) || \(\backslash\)}}
\DoxyCodeLine{1691 \textcolor{preprocessor}{  JSON\_HEDLEY\_CRAY\_VERSION\_CHECK(8,1,0) || \(\backslash\)}}
\DoxyCodeLine{1692 \textcolor{preprocessor}{  JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1693 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PREDICT(expr, expected, probability) \(\backslash\)}}
\DoxyCodeLine{1694 \textcolor{preprocessor}{    (((probability) >= 0.9) ? \_\_builtin\_expect((expr), (expected)) : (JSON\_HEDLEY\_STATIC\_CAST(void, expected), (expr)))}}
\DoxyCodeLine{1695 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PREDICT\_TRUE(expr, probability) \(\backslash\)}}
\DoxyCodeLine{1696 \textcolor{preprocessor}{    (\_\_extension\_\_ (\{ \(\backslash\)}}
\DoxyCodeLine{1697 \textcolor{preprocessor}{        double hedley\_probability\_ = (probability); \(\backslash\)}}
\DoxyCodeLine{1698 \textcolor{preprocessor}{        ((hedley\_probability\_ >= 0.9) ? \_\_builtin\_expect(!!(expr), 1) : ((hedley\_probability\_ <= 0.1) ? \_\_builtin\_expect(!!(expr), 0) : !!(expr))); \(\backslash\)}}
\DoxyCodeLine{1699 \textcolor{preprocessor}{    \}))}}
\DoxyCodeLine{1700 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PREDICT\_FALSE(expr, probability) \(\backslash\)}}
\DoxyCodeLine{1701 \textcolor{preprocessor}{    (\_\_extension\_\_ (\{ \(\backslash\)}}
\DoxyCodeLine{1702 \textcolor{preprocessor}{        double hedley\_probability\_ = (probability); \(\backslash\)}}
\DoxyCodeLine{1703 \textcolor{preprocessor}{        ((hedley\_probability\_ >= 0.9) ? \_\_builtin\_expect(!!(expr), 0) : ((hedley\_probability\_ <= 0.1) ? \_\_builtin\_expect(!!(expr), 1) : !!(expr))); \(\backslash\)}}
\DoxyCodeLine{1704 \textcolor{preprocessor}{    \}))}}
\DoxyCodeLine{1705 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_LIKELY(expr)   \_\_builtin\_expect(!!(expr), 1)}}
\DoxyCodeLine{1706 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_UNLIKELY(expr) \_\_builtin\_expect(!!(expr), 0)}}
\DoxyCodeLine{1707 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1708 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PREDICT(expr, expected, probability) (JSON\_HEDLEY\_STATIC\_CAST(void, expected), (expr))}}
\DoxyCodeLine{1709 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PREDICT\_TRUE(expr, probability) (!!(expr))}}
\DoxyCodeLine{1710 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PREDICT\_FALSE(expr, probability) (!!(expr))}}
\DoxyCodeLine{1711 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_LIKELY(expr) (!!(expr))}}
\DoxyCodeLine{1712 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_UNLIKELY(expr) (!!(expr))}}
\DoxyCodeLine{1713 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1714 \textcolor{preprocessor}{\#if !defined(JSON\_HEDLEY\_UNPREDICTABLE)}}
\DoxyCodeLine{1715 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_UNPREDICTABLE(expr) JSON\_HEDLEY\_PREDICT(expr, 1, 0.5)}}
\DoxyCodeLine{1716 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1717 }
\DoxyCodeLine{1718 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_MALLOC)}}
\DoxyCodeLine{1719 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_MALLOC}}
\DoxyCodeLine{1720 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1721 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1722 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(malloc) || \(\backslash\)}}
\DoxyCodeLine{1723 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,1,0) || \(\backslash\)}}
\DoxyCodeLine{1724 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1725 \textcolor{preprocessor}{    JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,11,0) || \(\backslash\)}}
\DoxyCodeLine{1726 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1727 \textcolor{preprocessor}{    JSON\_HEDLEY\_IBM\_VERSION\_CHECK(12,1,0) || \(\backslash\)}}
\DoxyCodeLine{1728 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1729 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,8,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1730 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1731 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1732 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1733 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1734 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1735 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1736 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) || \(\backslash\)}}
\DoxyCodeLine{1737 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1738 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1739 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1740 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MALLOC \_\_attribute\_\_((\_\_malloc\_\_))}}
\DoxyCodeLine{1741 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,10,0)}}
\DoxyCodeLine{1742 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MALLOC \_Pragma("{}returns\_new\_memory"{}})}
\DoxyCodeLine{1743 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1744 \textcolor{preprocessor}{    JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(14,0,0) || \(\backslash\)}}
\DoxyCodeLine{1745 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1746 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MALLOC \_\_declspec(restrict)}}
\DoxyCodeLine{1747 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1748 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_MALLOC}}
\DoxyCodeLine{1749 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1750 }
\DoxyCodeLine{1751 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PURE)}}
\DoxyCodeLine{1752 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_PURE}}
\DoxyCodeLine{1753 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1754 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1755 \textcolor{preprocessor}{  JSON\_HEDLEY\_HAS\_ATTRIBUTE(pure) || \(\backslash\)}}
\DoxyCodeLine{1756 \textcolor{preprocessor}{  JSON\_HEDLEY\_GCC\_VERSION\_CHECK(2,96,0) || \(\backslash\)}}
\DoxyCodeLine{1757 \textcolor{preprocessor}{  JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1758 \textcolor{preprocessor}{  JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,11,0) || \(\backslash\)}}
\DoxyCodeLine{1759 \textcolor{preprocessor}{  JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1760 \textcolor{preprocessor}{  JSON\_HEDLEY\_IBM\_VERSION\_CHECK(10,1,0) || \(\backslash\)}}
\DoxyCodeLine{1761 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1762 \textcolor{preprocessor}{  (JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,8,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1763 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1764 \textcolor{preprocessor}{  (JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1765 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1766 \textcolor{preprocessor}{  (JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1767 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1768 \textcolor{preprocessor}{  (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1769 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) || \(\backslash\)}}
\DoxyCodeLine{1770 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1771 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1772 \textcolor{preprocessor}{  JSON\_HEDLEY\_PGI\_VERSION\_CHECK(17,10,0) || \(\backslash\)}}
\DoxyCodeLine{1773 \textcolor{preprocessor}{  JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1774 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PURE \_\_attribute\_\_((\_\_pure\_\_))}}
\DoxyCodeLine{1775 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,10,0)}}
\DoxyCodeLine{1776 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PURE \_Pragma("{}does\_not\_write\_global\_data"{}})}
\DoxyCodeLine{1777 \textcolor{preprocessor}{\#elif defined(\_\_cplusplus) \&\& \(\backslash\)}}
\DoxyCodeLine{1778 \textcolor{preprocessor}{    ( \(\backslash\)}}
\DoxyCodeLine{1779 \textcolor{preprocessor}{      JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(2,0,1) || \(\backslash\)}}
\DoxyCodeLine{1780 \textcolor{preprocessor}{      JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(4,0,0) || \(\backslash\)}}
\DoxyCodeLine{1781 \textcolor{preprocessor}{      JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) \(\backslash\)}}
\DoxyCodeLine{1782 \textcolor{preprocessor}{    )}}
\DoxyCodeLine{1783 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PURE \_Pragma("{}FUNC\_IS\_PURE;"{}})}
\DoxyCodeLine{1784 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1785 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PURE}}
\DoxyCodeLine{1786 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1787 }
\DoxyCodeLine{1788 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CONST)}}
\DoxyCodeLine{1789 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CONST}}
\DoxyCodeLine{1790 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1791 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1792 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(const) || \(\backslash\)}}
\DoxyCodeLine{1793 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(2,5,0) || \(\backslash\)}}
\DoxyCodeLine{1794 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1795 \textcolor{preprocessor}{    JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,11,0) || \(\backslash\)}}
\DoxyCodeLine{1796 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1797 \textcolor{preprocessor}{    JSON\_HEDLEY\_IBM\_VERSION\_CHECK(10,1,0) || \(\backslash\)}}
\DoxyCodeLine{1798 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1799 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,8,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1800 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1801 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1802 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1803 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1804 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1805 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1806 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) || \(\backslash\)}}
\DoxyCodeLine{1807 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1808 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1809 \textcolor{preprocessor}{    JSON\_HEDLEY\_PGI\_VERSION\_CHECK(17,10,0) || \(\backslash\)}}
\DoxyCodeLine{1810 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1811 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_CONST \_\_attribute\_\_((\_\_const\_\_))}}
\DoxyCodeLine{1812 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1813 \textcolor{preprocessor}{    JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,10,0)}}
\DoxyCodeLine{1814 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_CONST \_Pragma("{}no\_side\_effect"{}})}
\DoxyCodeLine{1815 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1816 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_CONST JSON\_HEDLEY\_PURE}}
\DoxyCodeLine{1817 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1818 }
\DoxyCodeLine{1819 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_RESTRICT)}}
\DoxyCodeLine{1820 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_RESTRICT}}
\DoxyCodeLine{1821 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1822 \textcolor{preprocessor}{\#if defined(\_\_STDC\_VERSION\_\_) \&\& (\_\_STDC\_VERSION\_\_ >= 199901L) \&\& !defined(\_\_cplusplus)}}
\DoxyCodeLine{1823 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_RESTRICT restrict}}
\DoxyCodeLine{1824 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1825 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,1,0) || \(\backslash\)}}
\DoxyCodeLine{1826 \textcolor{preprocessor}{    JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(14,0,0) || \(\backslash\)}}
\DoxyCodeLine{1827 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1828 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0) || \(\backslash\)}}
\DoxyCodeLine{1829 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1830 \textcolor{preprocessor}{    JSON\_HEDLEY\_IBM\_VERSION\_CHECK(10,1,0) || \(\backslash\)}}
\DoxyCodeLine{1831 \textcolor{preprocessor}{    JSON\_HEDLEY\_PGI\_VERSION\_CHECK(17,10,0) || \(\backslash\)}}
\DoxyCodeLine{1832 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1833 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,2,4) || \(\backslash\)}}
\DoxyCodeLine{1834 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(8,1,0) || \(\backslash\)}}
\DoxyCodeLine{1835 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1836 \textcolor{preprocessor}{    (JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,14,0) \&\& defined(\_\_cplusplus)) || \(\backslash\)}}
\DoxyCodeLine{1837 \textcolor{preprocessor}{    JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,0,0) || \(\backslash\)}}
\DoxyCodeLine{1838 \textcolor{preprocessor}{    defined(\_\_clang\_\_) || \(\backslash\)}}
\DoxyCodeLine{1839 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1840 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_RESTRICT \_\_restrict}}
\DoxyCodeLine{1841 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,3,0) \&\& !defined(\_\_cplusplus)}}
\DoxyCodeLine{1842 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_RESTRICT \_Restrict}}
\DoxyCodeLine{1843 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1844 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_RESTRICT}}
\DoxyCodeLine{1845 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1846 }
\DoxyCodeLine{1847 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_INLINE)}}
\DoxyCodeLine{1848 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_INLINE}}
\DoxyCodeLine{1849 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1850 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1851 \textcolor{preprocessor}{    (defined(\_\_STDC\_VERSION\_\_) \&\& (\_\_STDC\_VERSION\_\_ >= 199901L)) || \(\backslash\)}}
\DoxyCodeLine{1852 \textcolor{preprocessor}{    (defined(\_\_cplusplus) \&\& (\_\_cplusplus >= 199711L))}}
\DoxyCodeLine{1853 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INLINE inline}}
\DoxyCodeLine{1854 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1855 \textcolor{preprocessor}{    defined(JSON\_HEDLEY\_GCC\_VERSION) || \(\backslash\)}}
\DoxyCodeLine{1856 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(6,2,0)}}
\DoxyCodeLine{1857 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INLINE \_\_inline\_\_}}
\DoxyCodeLine{1858 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1859 \textcolor{preprocessor}{    JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(12,0,0) || \(\backslash\)}}
\DoxyCodeLine{1860 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0) || \(\backslash\)}}
\DoxyCodeLine{1861 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1862 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,1,0) || \(\backslash\)}}
\DoxyCodeLine{1863 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(3,1,0) || \(\backslash\)}}
\DoxyCodeLine{1864 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,2,0) || \(\backslash\)}}
\DoxyCodeLine{1865 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(8,0,0) || \(\backslash\)}}
\DoxyCodeLine{1866 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1867 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1868 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1869 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INLINE \_\_inline}}
\DoxyCodeLine{1870 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1871 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_INLINE}}
\DoxyCodeLine{1872 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1873 }
\DoxyCodeLine{1874 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_ALWAYS\_INLINE)}}
\DoxyCodeLine{1875 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_ALWAYS\_INLINE}}
\DoxyCodeLine{1876 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1877 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1878 \textcolor{preprocessor}{  JSON\_HEDLEY\_HAS\_ATTRIBUTE(always\_inline) || \(\backslash\)}}
\DoxyCodeLine{1879 \textcolor{preprocessor}{  JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,0,0) || \(\backslash\)}}
\DoxyCodeLine{1880 \textcolor{preprocessor}{  JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1881 \textcolor{preprocessor}{  JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,11,0) || \(\backslash\)}}
\DoxyCodeLine{1882 \textcolor{preprocessor}{  JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1883 \textcolor{preprocessor}{  JSON\_HEDLEY\_IBM\_VERSION\_CHECK(10,1,0) || \(\backslash\)}}
\DoxyCodeLine{1884 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1885 \textcolor{preprocessor}{  (JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,8,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1886 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1887 \textcolor{preprocessor}{  (JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1888 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1889 \textcolor{preprocessor}{  (JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1890 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1891 \textcolor{preprocessor}{  (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1892 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) || \(\backslash\)}}
\DoxyCodeLine{1893 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1894 \textcolor{preprocessor}{  JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1895 \textcolor{preprocessor}{  JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10) || \(\backslash\)}}
\DoxyCodeLine{1896 \textcolor{preprocessor}{  JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,10,0)}}
\DoxyCodeLine{1897 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_ALWAYS\_INLINE \_\_attribute\_\_((\_\_always\_inline\_\_)) JSON\_HEDLEY\_INLINE}}
\DoxyCodeLine{1898 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1899 \textcolor{preprocessor}{  JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(12,0,0) || \(\backslash\)}}
\DoxyCodeLine{1900 \textcolor{preprocessor}{  JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1901 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_ALWAYS\_INLINE \_\_forceinline}}
\DoxyCodeLine{1902 \textcolor{preprocessor}{\#elif defined(\_\_cplusplus) \&\& \(\backslash\)}}
\DoxyCodeLine{1903 \textcolor{preprocessor}{    ( \(\backslash\)}}
\DoxyCodeLine{1904 \textcolor{preprocessor}{      JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1905 \textcolor{preprocessor}{      JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1906 \textcolor{preprocessor}{      JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1907 \textcolor{preprocessor}{      JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(6,1,0) || \(\backslash\)}}
\DoxyCodeLine{1908 \textcolor{preprocessor}{      JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1909 \textcolor{preprocessor}{      JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) \(\backslash\)}}
\DoxyCodeLine{1910 \textcolor{preprocessor}{    )}}
\DoxyCodeLine{1911 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_ALWAYS\_INLINE \_Pragma("{}FUNC\_ALWAYS\_INLINE;"{}})}
\DoxyCodeLine{1912 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,0,0)}}
\DoxyCodeLine{1913 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_ALWAYS\_INLINE \_Pragma("{}inline=forced"{}})}
\DoxyCodeLine{1914 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1915 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_ALWAYS\_INLINE JSON\_HEDLEY\_INLINE}}
\DoxyCodeLine{1916 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1917 }
\DoxyCodeLine{1918 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_NEVER\_INLINE)}}
\DoxyCodeLine{1919 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_NEVER\_INLINE}}
\DoxyCodeLine{1920 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1921 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{1922 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(noinline) || \(\backslash\)}}
\DoxyCodeLine{1923 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,0,0) || \(\backslash\)}}
\DoxyCodeLine{1924 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1925 \textcolor{preprocessor}{    JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,11,0) || \(\backslash\)}}
\DoxyCodeLine{1926 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1927 \textcolor{preprocessor}{    JSON\_HEDLEY\_IBM\_VERSION\_CHECK(10,1,0) || \(\backslash\)}}
\DoxyCodeLine{1928 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_VERSION\_CHECK(15,12,0) || \(\backslash\)}}
\DoxyCodeLine{1929 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(4,8,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1930 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK(5,2,0) || \(\backslash\)}}
\DoxyCodeLine{1931 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1932 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK(6,4,0) || \(\backslash\)}}
\DoxyCodeLine{1933 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,0,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1934 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(4,3,0) || \(\backslash\)}}
\DoxyCodeLine{1935 \textcolor{preprocessor}{    (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1936 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) || \(\backslash\)}}
\DoxyCodeLine{1937 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK(1,2,0) || \(\backslash\)}}
\DoxyCodeLine{1938 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK(2,1,0) || \(\backslash\)}}
\DoxyCodeLine{1939 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10) || \(\backslash\)}}
\DoxyCodeLine{1940 \textcolor{preprocessor}{    JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,10,0)}}
\DoxyCodeLine{1941 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NEVER\_INLINE \_\_attribute\_\_((\_\_noinline\_\_))}}
\DoxyCodeLine{1942 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{1943 \textcolor{preprocessor}{    JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(13,10,0) || \(\backslash\)}}
\DoxyCodeLine{1944 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{1945 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NEVER\_INLINE \_\_declspec(noinline)}}
\DoxyCodeLine{1946 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PGI\_VERSION\_CHECK(10,2,0)}}
\DoxyCodeLine{1947 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NEVER\_INLINE \_Pragma("{}noinline"{}})}
\DoxyCodeLine{1948 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(6,0,0) \&\& defined(\_\_cplusplus)}}
\DoxyCodeLine{1949 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NEVER\_INLINE \_Pragma("{}FUNC\_CANNOT\_INLINE;"{}})}
\DoxyCodeLine{1950 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,0,0)}}
\DoxyCodeLine{1951 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NEVER\_INLINE \_Pragma("{}inline=never"{}})}
\DoxyCodeLine{1952 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_COMPCERT\_VERSION\_CHECK(3,2,0)}}
\DoxyCodeLine{1953 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NEVER\_INLINE \_\_attribute((noinline))}}
\DoxyCodeLine{1954 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PELLES\_VERSION\_CHECK(9,0,0)}}
\DoxyCodeLine{1955 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NEVER\_INLINE \_\_declspec(noinline)}}
\DoxyCodeLine{1956 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1957 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NEVER\_INLINE}}
\DoxyCodeLine{1958 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1959 }
\DoxyCodeLine{1960 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PRIVATE)}}
\DoxyCodeLine{1961 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_PRIVATE}}
\DoxyCodeLine{1962 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1963 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_PUBLIC)}}
\DoxyCodeLine{1964 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_PUBLIC}}
\DoxyCodeLine{1965 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1966 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_IMPORT)}}
\DoxyCodeLine{1967 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_IMPORT}}
\DoxyCodeLine{1968 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1969 \textcolor{preprocessor}{\#if defined(\_WIN32) || defined(\_\_CYGWIN\_\_)}}
\DoxyCodeLine{1970 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PRIVATE}}
\DoxyCodeLine{1971 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_PUBLIC   \_\_declspec(dllexport)}}
\DoxyCodeLine{1972 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_IMPORT   \_\_declspec(dllimport)}}
\DoxyCodeLine{1973 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1974 \textcolor{preprocessor}{\#  if \(\backslash\)}}
\DoxyCodeLine{1975 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(visibility) || \(\backslash\)}}
\DoxyCodeLine{1976 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,3,0) || \(\backslash\)}}
\DoxyCodeLine{1977 \textcolor{preprocessor}{    JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,11,0) || \(\backslash\)}}
\DoxyCodeLine{1978 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{1979 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{1980 \textcolor{preprocessor}{    JSON\_HEDLEY\_IBM\_VERSION\_CHECK(13,1,0) || \(\backslash\)}}
\DoxyCodeLine{1981 \textcolor{preprocessor}{    ( \(\backslash\)}}
\DoxyCodeLine{1982 \textcolor{preprocessor}{      defined(\_\_TI\_EABI\_\_) \&\& \(\backslash\)}}
\DoxyCodeLine{1983 \textcolor{preprocessor}{      ( \(\backslash\)}}
\DoxyCodeLine{1984 \textcolor{preprocessor}{        (JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,2,0) \&\& defined(\_\_TI\_GNU\_ATTRIBUTE\_SUPPORT\_\_)) || \(\backslash\)}}
\DoxyCodeLine{1985 \textcolor{preprocessor}{        JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(7,5,0) \(\backslash\)}}
\DoxyCodeLine{1986 \textcolor{preprocessor}{      ) \(\backslash\)}}
\DoxyCodeLine{1987 \textcolor{preprocessor}{    ) || \(\backslash\)}}
\DoxyCodeLine{1988 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{1989 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_PRIVATE \_\_attribute\_\_((\_\_visibility\_\_("{}hidden"{}})))}
\DoxyCodeLine{1990 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_PUBLIC  \_\_attribute\_\_((\_\_visibility\_\_("{}default"{}})))}
\DoxyCodeLine{1991 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{1992 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_PRIVATE}}
\DoxyCodeLine{1993 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_PUBLIC}}
\DoxyCodeLine{1994 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{1995 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_IMPORT    extern}}
\DoxyCodeLine{1996 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1997 }
\DoxyCodeLine{1998 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_NO\_THROW)}}
\DoxyCodeLine{1999 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_NO\_THROW}}
\DoxyCodeLine{2000 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2001 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{2002 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(nothrow) || \(\backslash\)}}
\DoxyCodeLine{2003 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,3,0) || \(\backslash\)}}
\DoxyCodeLine{2004 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{2005 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{2006 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_THROW \_\_attribute\_\_((\_\_nothrow\_\_))}}
\DoxyCodeLine{2007 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{2008 \textcolor{preprocessor}{    JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(13,1,0) || \(\backslash\)}}
\DoxyCodeLine{2009 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0) || \(\backslash\)}}
\DoxyCodeLine{2010 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0)}}
\DoxyCodeLine{2011 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_THROW \_\_declspec(nothrow)}}
\DoxyCodeLine{2012 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2013 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NO\_THROW}}
\DoxyCodeLine{2014 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2015 }
\DoxyCodeLine{2016 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_FALL\_THROUGH)}}
\DoxyCodeLine{2017 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_FALL\_THROUGH}}
\DoxyCodeLine{2018 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2019 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{2020 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(fallthrough) || \(\backslash\)}}
\DoxyCodeLine{2021 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(7,0,0) || \(\backslash\)}}
\DoxyCodeLine{2022 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{2023 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_FALL\_THROUGH \_\_attribute\_\_((\_\_fallthrough\_\_))}}
\DoxyCodeLine{2024 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE\_NS(clang,fallthrough)}}
\DoxyCodeLine{2025 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_FALL\_THROUGH JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_([[clang::fallthrough]])}}
\DoxyCodeLine{2026 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE(fallthrough)}}
\DoxyCodeLine{2027 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_FALL\_THROUGH JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_([[fallthrough]])}}
\DoxyCodeLine{2028 \textcolor{preprocessor}{\#elif defined(\_\_fallthrough) }\textcolor{comment}{/* SAL */}\textcolor{preprocessor}{}}
\DoxyCodeLine{2029 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_FALL\_THROUGH \_\_fallthrough}}
\DoxyCodeLine{2030 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2031 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_FALL\_THROUGH}}
\DoxyCodeLine{2032 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2033 }
\DoxyCodeLine{2034 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_RETURNS\_NON\_NULL)}}
\DoxyCodeLine{2035 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_RETURNS\_NON\_NULL}}
\DoxyCodeLine{2036 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2037 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{2038 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_ATTRIBUTE(returns\_nonnull) || \(\backslash\)}}
\DoxyCodeLine{2039 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,9,0) || \(\backslash\)}}
\DoxyCodeLine{2040 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{2041 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_RETURNS\_NON\_NULL \_\_attribute\_\_((\_\_returns\_nonnull\_\_))}}
\DoxyCodeLine{2042 \textcolor{preprocessor}{\#elif defined(\_Ret\_notnull\_) }\textcolor{comment}{/* SAL */}\textcolor{preprocessor}{}}
\DoxyCodeLine{2043 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_RETURNS\_NON\_NULL \_Ret\_notnull\_}}
\DoxyCodeLine{2044 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2045 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_RETURNS\_NON\_NULL}}
\DoxyCodeLine{2046 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2047 }
\DoxyCodeLine{2048 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_ARRAY\_PARAM)}}
\DoxyCodeLine{2049 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_ARRAY\_PARAM}}
\DoxyCodeLine{2050 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2051 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{2052 \textcolor{preprocessor}{    defined(\_\_STDC\_VERSION\_\_) \&\& (\_\_STDC\_VERSION\_\_ >= 199901L) \&\& \(\backslash\)}}
\DoxyCodeLine{2053 \textcolor{preprocessor}{    !defined(\_\_STDC\_NO\_VLA\_\_) \&\& \(\backslash\)}}
\DoxyCodeLine{2054 \textcolor{preprocessor}{    !defined(\_\_cplusplus) \&\& \(\backslash\)}}
\DoxyCodeLine{2055 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_PGI\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{2056 \textcolor{preprocessor}{    !defined(JSON\_HEDLEY\_TINYC\_VERSION)}}
\DoxyCodeLine{2057 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_ARRAY\_PARAM(name) (name)}}
\DoxyCodeLine{2058 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2059 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_ARRAY\_PARAM(name)}}
\DoxyCodeLine{2060 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2061 }
\DoxyCodeLine{2062 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_IS\_CONSTANT)}}
\DoxyCodeLine{2063 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_IS\_CONSTANT}}
\DoxyCodeLine{2064 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2065 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_REQUIRE\_CONSTEXPR)}}
\DoxyCodeLine{2066 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_REQUIRE\_CONSTEXPR}}
\DoxyCodeLine{2067 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2068 \textcolor{comment}{/* JSON\_HEDLEY\_IS\_CONSTEXPR\_ is for}}
\DoxyCodeLine{2069 \textcolor{comment}{   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */}}
\DoxyCodeLine{2070 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_IS\_CONSTEXPR\_)}}
\DoxyCodeLine{2071 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_IS\_CONSTEXPR\_}}
\DoxyCodeLine{2072 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2073 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{2074 \textcolor{preprocessor}{    JSON\_HEDLEY\_HAS\_BUILTIN(\_\_builtin\_constant\_p) || \(\backslash\)}}
\DoxyCodeLine{2075 \textcolor{preprocessor}{    JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,4,0) || \(\backslash\)}}
\DoxyCodeLine{2076 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{2077 \textcolor{preprocessor}{    JSON\_HEDLEY\_TINYC\_VERSION\_CHECK(0,9,19) || \(\backslash\)}}
\DoxyCodeLine{2078 \textcolor{preprocessor}{    JSON\_HEDLEY\_ARM\_VERSION\_CHECK(4,1,0) || \(\backslash\)}}
\DoxyCodeLine{2079 \textcolor{preprocessor}{    JSON\_HEDLEY\_IBM\_VERSION\_CHECK(13,1,0) || \(\backslash\)}}
\DoxyCodeLine{2080 \textcolor{preprocessor}{    JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK(6,1,0) || \(\backslash\)}}
\DoxyCodeLine{2081 \textcolor{preprocessor}{    (JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK(5,10,0) \&\& !defined(\_\_cplusplus)) || \(\backslash\)}}
\DoxyCodeLine{2082 \textcolor{preprocessor}{    JSON\_HEDLEY\_CRAY\_VERSION\_CHECK(8,1,0) || \(\backslash\)}}
\DoxyCodeLine{2083 \textcolor{preprocessor}{    JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK(1,25,10)}}
\DoxyCodeLine{2084 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IS\_CONSTANT(expr) \_\_builtin\_constant\_p(expr)}}
\DoxyCodeLine{2085 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2086 \textcolor{preprocessor}{\#if !defined(\_\_cplusplus)}}
\DoxyCodeLine{2087 \textcolor{preprocessor}{\#  if \(\backslash\)}}
\DoxyCodeLine{2088 \textcolor{preprocessor}{       JSON\_HEDLEY\_HAS\_BUILTIN(\_\_builtin\_types\_compatible\_p) || \(\backslash\)}}
\DoxyCodeLine{2089 \textcolor{preprocessor}{       JSON\_HEDLEY\_GCC\_VERSION\_CHECK(3,4,0) || \(\backslash\)}}
\DoxyCodeLine{2090 \textcolor{preprocessor}{       JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{2091 \textcolor{preprocessor}{       JSON\_HEDLEY\_IBM\_VERSION\_CHECK(13,1,0) || \(\backslash\)}}
\DoxyCodeLine{2092 \textcolor{preprocessor}{       JSON\_HEDLEY\_CRAY\_VERSION\_CHECK(8,1,0) || \(\backslash\)}}
\DoxyCodeLine{2093 \textcolor{preprocessor}{       JSON\_HEDLEY\_ARM\_VERSION\_CHECK(5,4,0) || \(\backslash\)}}
\DoxyCodeLine{2094 \textcolor{preprocessor}{       JSON\_HEDLEY\_TINYC\_VERSION\_CHECK(0,9,24)}}
\DoxyCodeLine{2095 \textcolor{preprocessor}{\#if defined(\_\_INTPTR\_TYPE\_\_)}}
\DoxyCodeLine{2096 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IS\_CONSTEXPR\_(expr) \_\_builtin\_types\_compatible\_p(\_\_typeof\_\_((1 ? (void*) ((\_\_INTPTR\_TYPE\_\_) ((expr) * 0)) : (int*) 0)), int*)}}
\DoxyCodeLine{2097 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2098 \textcolor{preprocessor}{    \#include <stdint.h>}}
\DoxyCodeLine{2099 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IS\_CONSTEXPR\_(expr) \_\_builtin\_types\_compatible\_p(\_\_typeof\_\_((1 ? (void*) ((intptr\_t) ((expr) * 0)) : (int*) 0)), int*)}}
\DoxyCodeLine{2100 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2101 \textcolor{preprocessor}{\#  elif \(\backslash\)}}
\DoxyCodeLine{2102 \textcolor{preprocessor}{       ( \(\backslash\)}}
\DoxyCodeLine{2103 \textcolor{preprocessor}{          defined(\_\_STDC\_VERSION\_\_) \&\& (\_\_STDC\_VERSION\_\_ >= 201112L) \&\& \(\backslash\)}}
\DoxyCodeLine{2104 \textcolor{preprocessor}{          !defined(JSON\_HEDLEY\_SUNPRO\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{2105 \textcolor{preprocessor}{          !defined(JSON\_HEDLEY\_PGI\_VERSION) \&\& \(\backslash\)}}
\DoxyCodeLine{2106 \textcolor{preprocessor}{          !defined(JSON\_HEDLEY\_IAR\_VERSION)) || \(\backslash\)}}
\DoxyCodeLine{2107 \textcolor{preprocessor}{       (JSON\_HEDLEY\_HAS\_EXTENSION(c\_generic\_selections) \&\& !defined(JSON\_HEDLEY\_IAR\_VERSION)) || \(\backslash\)}}
\DoxyCodeLine{2108 \textcolor{preprocessor}{       JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,9,0) || \(\backslash\)}}
\DoxyCodeLine{2109 \textcolor{preprocessor}{       JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(17,0,0) || \(\backslash\)}}
\DoxyCodeLine{2110 \textcolor{preprocessor}{       JSON\_HEDLEY\_IBM\_VERSION\_CHECK(12,1,0) || \(\backslash\)}}
\DoxyCodeLine{2111 \textcolor{preprocessor}{       JSON\_HEDLEY\_ARM\_VERSION\_CHECK(5,3,0)}}
\DoxyCodeLine{2112 \textcolor{preprocessor}{\#if defined(\_\_INTPTR\_TYPE\_\_)}}
\DoxyCodeLine{2113 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IS\_CONSTEXPR\_(expr) \_Generic((1 ? (void*) ((\_\_INTPTR\_TYPE\_\_) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)}}
\DoxyCodeLine{2114 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2115 \textcolor{preprocessor}{    \#include <stdint.h>}}
\DoxyCodeLine{2116 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_IS\_CONSTEXPR\_(expr) \_Generic((1 ? (void*) ((intptr\_t) * 0) : (int*) 0), int*: 1, void*: 0)}}
\DoxyCodeLine{2117 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2118 \textcolor{preprocessor}{\#  elif \(\backslash\)}}
\DoxyCodeLine{2119 \textcolor{preprocessor}{       defined(JSON\_HEDLEY\_GCC\_VERSION) || \(\backslash\)}}
\DoxyCodeLine{2120 \textcolor{preprocessor}{       defined(JSON\_HEDLEY\_INTEL\_VERSION) || \(\backslash\)}}
\DoxyCodeLine{2121 \textcolor{preprocessor}{       defined(JSON\_HEDLEY\_TINYC\_VERSION) || \(\backslash\)}}
\DoxyCodeLine{2122 \textcolor{preprocessor}{       defined(JSON\_HEDLEY\_TI\_ARMCL\_VERSION) || \(\backslash\)}}
\DoxyCodeLine{2123 \textcolor{preprocessor}{       JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK(18,12,0) || \(\backslash\)}}
\DoxyCodeLine{2124 \textcolor{preprocessor}{       defined(JSON\_HEDLEY\_TI\_CL2000\_VERSION) || \(\backslash\)}}
\DoxyCodeLine{2125 \textcolor{preprocessor}{       defined(JSON\_HEDLEY\_TI\_CL6X\_VERSION) || \(\backslash\)}}
\DoxyCodeLine{2126 \textcolor{preprocessor}{       defined(JSON\_HEDLEY\_TI\_CL7X\_VERSION) || \(\backslash\)}}
\DoxyCodeLine{2127 \textcolor{preprocessor}{       defined(JSON\_HEDLEY\_TI\_CLPRU\_VERSION) || \(\backslash\)}}
\DoxyCodeLine{2128 \textcolor{preprocessor}{       defined(\_\_clang\_\_)}}
\DoxyCodeLine{2129 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_IS\_CONSTEXPR\_(expr) ( \(\backslash\)}}
\DoxyCodeLine{2130 \textcolor{preprocessor}{        sizeof(void) != \(\backslash\)}}
\DoxyCodeLine{2131 \textcolor{preprocessor}{        sizeof(*( \(\backslash\)}}
\DoxyCodeLine{2132 \textcolor{preprocessor}{                  1 ? \(\backslash\)}}
\DoxyCodeLine{2133 \textcolor{preprocessor}{                  ((void*) ((expr) * 0L) ) : \(\backslash\)}}
\DoxyCodeLine{2134 \textcolor{preprocessor}{((struct \{ char v[sizeof(void) * 2]; \} *) 1) \(\backslash\)}}
\DoxyCodeLine{2135 \textcolor{preprocessor}{                ) \(\backslash\)}}
\DoxyCodeLine{2136 \textcolor{preprocessor}{              ) \(\backslash\)}}
\DoxyCodeLine{2137 \textcolor{preprocessor}{                                            )}}
\DoxyCodeLine{2138 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{2139 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2140 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_IS\_CONSTEXPR\_)}}
\DoxyCodeLine{2141 \textcolor{preprocessor}{    \#if !defined(JSON\_HEDLEY\_IS\_CONSTANT)}}
\DoxyCodeLine{2142 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_IS\_CONSTANT(expr) JSON\_HEDLEY\_IS\_CONSTEXPR\_(expr)}}
\DoxyCodeLine{2143 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2144 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_REQUIRE\_CONSTEXPR(expr) (JSON\_HEDLEY\_IS\_CONSTEXPR\_(expr) ? (expr) : (-\/1))}}
\DoxyCodeLine{2145 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2146 \textcolor{preprocessor}{    \#if !defined(JSON\_HEDLEY\_IS\_CONSTANT)}}
\DoxyCodeLine{2147 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_IS\_CONSTANT(expr) (0)}}
\DoxyCodeLine{2148 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2149 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_REQUIRE\_CONSTEXPR(expr) (expr)}}
\DoxyCodeLine{2150 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2151 }
\DoxyCodeLine{2152 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_BEGIN\_C\_DECLS)}}
\DoxyCodeLine{2153 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_BEGIN\_C\_DECLS}}
\DoxyCodeLine{2154 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2155 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_END\_C\_DECLS)}}
\DoxyCodeLine{2156 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_END\_C\_DECLS}}
\DoxyCodeLine{2157 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2158 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_C\_DECL)}}
\DoxyCodeLine{2159 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_C\_DECL}}
\DoxyCodeLine{2160 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2161 \textcolor{preprocessor}{\#if defined(\_\_cplusplus)}}
\DoxyCodeLine{2162 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_BEGIN\_C\_DECLS extern "{}C"{}} \{}
\DoxyCodeLine{2163 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_END\_C\_DECLS \}}}
\DoxyCodeLine{2164 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_C\_DECL extern "{}C"{}}}
\DoxyCodeLine{2165 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2166 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_BEGIN\_C\_DECLS}}
\DoxyCodeLine{2167 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_END\_C\_DECLS}}
\DoxyCodeLine{2168 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_C\_DECL}}
\DoxyCodeLine{2169 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2170 }
\DoxyCodeLine{2171 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_STATIC\_ASSERT)}}
\DoxyCodeLine{2172 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_STATIC\_ASSERT}}
\DoxyCodeLine{2173 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2174 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{2175 \textcolor{preprocessor}{  !defined(\_\_cplusplus) \&\& ( \(\backslash\)}}
\DoxyCodeLine{2176 \textcolor{preprocessor}{      (defined(\_\_STDC\_VERSION\_\_) \&\& (\_\_STDC\_VERSION\_\_ >= 201112L)) || \(\backslash\)}}
\DoxyCodeLine{2177 \textcolor{preprocessor}{      (JSON\_HEDLEY\_HAS\_FEATURE(c\_static\_assert) \&\& !defined(JSON\_HEDLEY\_INTEL\_CL\_VERSION)) || \(\backslash\)}}
\DoxyCodeLine{2178 \textcolor{preprocessor}{      JSON\_HEDLEY\_GCC\_VERSION\_CHECK(6,0,0) || \(\backslash\)}}
\DoxyCodeLine{2179 \textcolor{preprocessor}{      JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0) || \(\backslash\)}}
\DoxyCodeLine{2180 \textcolor{preprocessor}{      defined(\_Static\_assert) \(\backslash\)}}
\DoxyCodeLine{2181 \textcolor{preprocessor}{    )}}
\DoxyCodeLine{2182 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_STATIC\_ASSERT(expr, message) \_Static\_assert(expr, message)}}
\DoxyCodeLine{2183 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{2184 \textcolor{preprocessor}{  (defined(\_\_cplusplus) \&\& (\_\_cplusplus >= 201103L)) || \(\backslash\)}}
\DoxyCodeLine{2185 \textcolor{preprocessor}{  JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(16,0,0) || \(\backslash\)}}
\DoxyCodeLine{2186 \textcolor{preprocessor}{  JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{2187 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_STATIC\_ASSERT(expr, message) JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_(static\_assert(expr, message))}}
\DoxyCodeLine{2188 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2189 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_STATIC\_ASSERT(expr, message)}}
\DoxyCodeLine{2190 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2191 }
\DoxyCodeLine{2192 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_NULL)}}
\DoxyCodeLine{2193 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_NULL}}
\DoxyCodeLine{2194 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2195 \textcolor{preprocessor}{\#if defined(\_\_cplusplus)}}
\DoxyCodeLine{2196 \textcolor{preprocessor}{    \#if \_\_cplusplus >= 201103L}}
\DoxyCodeLine{2197 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_NULL JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_(nullptr)}}
\DoxyCodeLine{2198 \textcolor{preprocessor}{    \#elif defined(NULL)}}
\DoxyCodeLine{2199 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_NULL NULL}}
\DoxyCodeLine{2200 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{2201 \textcolor{preprocessor}{        \#define JSON\_HEDLEY\_NULL JSON\_HEDLEY\_STATIC\_CAST(void*, 0)}}
\DoxyCodeLine{2202 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2203 \textcolor{preprocessor}{\#elif defined(NULL)}}
\DoxyCodeLine{2204 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NULL NULL}}
\DoxyCodeLine{2205 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2206 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_NULL ((void*) 0)}}
\DoxyCodeLine{2207 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2208 }
\DoxyCodeLine{2209 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_MESSAGE)}}
\DoxyCodeLine{2210 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_MESSAGE}}
\DoxyCodeLine{2211 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2212 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wunknown-\/pragmas"{}})}
\DoxyCodeLine{2213 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_MESSAGE(msg) \(\backslash\)}}
\DoxyCodeLine{2214 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{2215 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \(\backslash\)}}
\DoxyCodeLine{2216 \textcolor{preprocessor}{    JSON\_HEDLEY\_PRAGMA(message msg) \(\backslash\)}}
\DoxyCodeLine{2217 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_POP}}
\DoxyCodeLine{2218 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{2219 \textcolor{preprocessor}{  JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,4,0) || \(\backslash\)}}
\DoxyCodeLine{2220 \textcolor{preprocessor}{  JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0)}}
\DoxyCodeLine{2221 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_MESSAGE(msg) JSON\_HEDLEY\_PRAGMA(message msg)}}
\DoxyCodeLine{2222 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_CRAY\_VERSION\_CHECK(5,0,0)}}
\DoxyCodeLine{2223 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_MESSAGE(msg) JSON\_HEDLEY\_PRAGMA(\_CRI message msg)}}
\DoxyCodeLine{2224 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_IAR\_VERSION\_CHECK(8,0,0)}}
\DoxyCodeLine{2225 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_MESSAGE(msg) JSON\_HEDLEY\_PRAGMA(message(msg))}}
\DoxyCodeLine{2226 \textcolor{preprocessor}{\#elif JSON\_HEDLEY\_PELLES\_VERSION\_CHECK(2,0,0)}}
\DoxyCodeLine{2227 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_MESSAGE(msg) JSON\_HEDLEY\_PRAGMA(message(msg))}}
\DoxyCodeLine{2228 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2229 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_MESSAGE(msg)}}
\DoxyCodeLine{2230 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2231 }
\DoxyCodeLine{2232 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_WARNING)}}
\DoxyCodeLine{2233 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_WARNING}}
\DoxyCodeLine{2234 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2235 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wunknown-\/pragmas"{}})}
\DoxyCodeLine{2236 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_WARNING(msg) \(\backslash\)}}
\DoxyCodeLine{2237 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{2238 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS \(\backslash\)}}
\DoxyCodeLine{2239 \textcolor{preprocessor}{    JSON\_HEDLEY\_PRAGMA(clang warning msg) \(\backslash\)}}
\DoxyCodeLine{2240 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_POP}}
\DoxyCodeLine{2241 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{2242 \textcolor{preprocessor}{  JSON\_HEDLEY\_GCC\_VERSION\_CHECK(4,8,0) || \(\backslash\)}}
\DoxyCodeLine{2243 \textcolor{preprocessor}{  JSON\_HEDLEY\_PGI\_VERSION\_CHECK(18,4,0) || \(\backslash\)}}
\DoxyCodeLine{2244 \textcolor{preprocessor}{  JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(13,0,0)}}
\DoxyCodeLine{2245 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_WARNING(msg) JSON\_HEDLEY\_PRAGMA(GCC warning msg)}}
\DoxyCodeLine{2246 \textcolor{preprocessor}{\#elif \(\backslash\)}}
\DoxyCodeLine{2247 \textcolor{preprocessor}{  JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(15,0,0) || \(\backslash\)}}
\DoxyCodeLine{2248 \textcolor{preprocessor}{  JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{2249 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_WARNING(msg) JSON\_HEDLEY\_PRAGMA(message(msg))}}
\DoxyCodeLine{2250 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2251 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_WARNING(msg) JSON\_HEDLEY\_MESSAGE(msg)}}
\DoxyCodeLine{2252 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2253 }
\DoxyCodeLine{2254 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_REQUIRE)}}
\DoxyCodeLine{2255 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_REQUIRE}}
\DoxyCodeLine{2256 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2257 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_REQUIRE\_MSG)}}
\DoxyCodeLine{2258 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_REQUIRE\_MSG}}
\DoxyCodeLine{2259 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2260 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_ATTRIBUTE(diagnose\_if)}}
\DoxyCodeLine{2261 \textcolor{preprocessor}{\#  if JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wgcc-\/compat"{}})}
\DoxyCodeLine{2262 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_REQUIRE(expr) \(\backslash\)}}
\DoxyCodeLine{2263 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{2264 \textcolor{preprocessor}{    \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wgcc-\/compat\(\backslash\)"{}"{}}) \(\backslash\)}
\DoxyCodeLine{2265     \_\_attribute\_\_((diagnose\_if(!(expr), \#expr, "{}error"{}))) \(\backslash\)}
\DoxyCodeLine{2266     JSON\_HEDLEY\_DIAGNOSTIC\_POP}
\DoxyCodeLine{2267 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_REQUIRE\_MSG(expr,msg) \(\backslash\)}}
\DoxyCodeLine{2268 \textcolor{preprocessor}{    JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{2269 \textcolor{preprocessor}{    \_Pragma("{}clang diagnostic ignored \(\backslash\)"{}-\/Wgcc-\/compat\(\backslash\)"{}"{}}) \(\backslash\)}
\DoxyCodeLine{2270     \_\_attribute\_\_((diagnose\_if(!(expr), msg, "{}error"{}))) \(\backslash\)}
\DoxyCodeLine{2271     JSON\_HEDLEY\_DIAGNOSTIC\_POP}
\DoxyCodeLine{2272 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{2273 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_REQUIRE(expr) \_\_attribute\_\_((diagnose\_if(!(expr), \#expr, "{}error"{}})))}
\DoxyCodeLine{2274 \textcolor{preprocessor}{\#    define JSON\_HEDLEY\_REQUIRE\_MSG(expr,msg) \_\_attribute\_\_((diagnose\_if(!(expr), msg, "{}error"{}})))}
\DoxyCodeLine{2275 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{2276 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2277 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_REQUIRE(expr)}}
\DoxyCodeLine{2278 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_REQUIRE\_MSG(expr,msg)}}
\DoxyCodeLine{2279 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2280 }
\DoxyCodeLine{2281 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_FLAGS)}}
\DoxyCodeLine{2282 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_FLAGS}}
\DoxyCodeLine{2283 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2284 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_ATTRIBUTE(flag\_enum) \&\& (!defined(\_\_cplusplus) || JSON\_HEDLEY\_HAS\_WARNING("{}-\/Wbitfield-\/enum-\/conversion"{}}))}
\DoxyCodeLine{2285 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_FLAGS \_\_attribute\_\_((\_\_flag\_enum\_\_))}}
\DoxyCodeLine{2286 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2287 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_FLAGS}}
\DoxyCodeLine{2288 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2289 }
\DoxyCodeLine{2290 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_FLAGS\_CAST)}}
\DoxyCodeLine{2291 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_FLAGS\_CAST}}
\DoxyCodeLine{2292 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2293 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_INTEL\_VERSION\_CHECK(19,0,0)}}
\DoxyCodeLine{2294 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_FLAGS\_CAST(T, expr) (\_\_extension\_\_ (\{ \(\backslash\)}}
\DoxyCodeLine{2295 \textcolor{preprocessor}{        JSON\_HEDLEY\_DIAGNOSTIC\_PUSH \(\backslash\)}}
\DoxyCodeLine{2296 \textcolor{preprocessor}{        \_Pragma("{}warning(disable:188)"{}}) \(\backslash\)}
\DoxyCodeLine{2297         ((T) (expr)); \(\backslash\)}
\DoxyCodeLine{2298         JSON\_HEDLEY\_DIAGNOSTIC\_POP \(\backslash\)}
\DoxyCodeLine{2299     \}))}
\DoxyCodeLine{2300 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2301 \textcolor{preprocessor}{\#  define JSON\_HEDLEY\_FLAGS\_CAST(T, expr) JSON\_HEDLEY\_STATIC\_CAST(T, expr)}}
\DoxyCodeLine{2302 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2303 }
\DoxyCodeLine{2304 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_EMPTY\_BASES)}}
\DoxyCodeLine{2305 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_EMPTY\_BASES}}
\DoxyCodeLine{2306 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2307 \textcolor{preprocessor}{\#if \(\backslash\)}}
\DoxyCodeLine{2308 \textcolor{preprocessor}{    (JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(19,0,23918) \&\& !JSON\_HEDLEY\_MSVC\_VERSION\_CHECK(20,0,0)) || \(\backslash\)}}
\DoxyCodeLine{2309 \textcolor{preprocessor}{    JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK(2021,1,0)}}
\DoxyCodeLine{2310 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_EMPTY\_BASES \_\_declspec(empty\_bases)}}
\DoxyCodeLine{2311 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2312 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_EMPTY\_BASES}}
\DoxyCodeLine{2313 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2314 }
\DoxyCodeLine{2315 \textcolor{comment}{/* Remaining macros are deprecated. */}}
\DoxyCodeLine{2316 }
\DoxyCodeLine{2317 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_GCC\_NOT\_CLANG\_VERSION\_CHECK)}}
\DoxyCodeLine{2318 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_GCC\_NOT\_CLANG\_VERSION\_CHECK}}
\DoxyCodeLine{2319 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2320 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{2321 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_NOT\_CLANG\_VERSION\_CHECK(major,minor,patch) (0)}}
\DoxyCodeLine{2322 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2323 \textcolor{preprocessor}{    \#define JSON\_HEDLEY\_GCC\_NOT\_CLANG\_VERSION\_CHECK(major,minor,patch) JSON\_HEDLEY\_GCC\_VERSION\_CHECK(major,minor,patch)}}
\DoxyCodeLine{2324 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2325 }
\DoxyCodeLine{2326 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CLANG\_HAS\_ATTRIBUTE)}}
\DoxyCodeLine{2327 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CLANG\_HAS\_ATTRIBUTE}}
\DoxyCodeLine{2328 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2329 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CLANG\_HAS\_ATTRIBUTE(attribute) JSON\_HEDLEY\_HAS\_ATTRIBUTE(attribute)}}
\DoxyCodeLine{2330 }
\DoxyCodeLine{2331 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CLANG\_HAS\_CPP\_ATTRIBUTE)}}
\DoxyCodeLine{2332 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CLANG\_HAS\_CPP\_ATTRIBUTE}}
\DoxyCodeLine{2333 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2334 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CLANG\_HAS\_CPP\_ATTRIBUTE(attribute) JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE(attribute)}}
\DoxyCodeLine{2335 }
\DoxyCodeLine{2336 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CLANG\_HAS\_BUILTIN)}}
\DoxyCodeLine{2337 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CLANG\_HAS\_BUILTIN}}
\DoxyCodeLine{2338 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2339 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CLANG\_HAS\_BUILTIN(builtin) JSON\_HEDLEY\_HAS\_BUILTIN(builtin)}}
\DoxyCodeLine{2340 }
\DoxyCodeLine{2341 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CLANG\_HAS\_FEATURE)}}
\DoxyCodeLine{2342 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CLANG\_HAS\_FEATURE}}
\DoxyCodeLine{2343 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2344 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CLANG\_HAS\_FEATURE(feature) JSON\_HEDLEY\_HAS\_FEATURE(feature)}}
\DoxyCodeLine{2345 }
\DoxyCodeLine{2346 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CLANG\_HAS\_EXTENSION)}}
\DoxyCodeLine{2347 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CLANG\_HAS\_EXTENSION}}
\DoxyCodeLine{2348 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2349 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CLANG\_HAS\_EXTENSION(extension) JSON\_HEDLEY\_HAS\_EXTENSION(extension)}}
\DoxyCodeLine{2350 }
\DoxyCodeLine{2351 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CLANG\_HAS\_DECLSPEC\_DECLSPEC\_ATTRIBUTE)}}
\DoxyCodeLine{2352 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CLANG\_HAS\_DECLSPEC\_DECLSPEC\_ATTRIBUTE}}
\DoxyCodeLine{2353 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2354 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CLANG\_HAS\_DECLSPEC\_ATTRIBUTE(attribute) JSON\_HEDLEY\_HAS\_DECLSPEC\_ATTRIBUTE(attribute)}}
\DoxyCodeLine{2355 }
\DoxyCodeLine{2356 \textcolor{preprocessor}{\#if defined(JSON\_HEDLEY\_CLANG\_HAS\_WARNING)}}
\DoxyCodeLine{2357 \textcolor{preprocessor}{    \#undef JSON\_HEDLEY\_CLANG\_HAS\_WARNING}}
\DoxyCodeLine{2358 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2359 \textcolor{preprocessor}{\#define JSON\_HEDLEY\_CLANG\_HAS\_WARNING(warning) JSON\_HEDLEY\_HAS\_WARNING(warning)}}
\DoxyCodeLine{2360 }
\DoxyCodeLine{2361 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* !defined(JSON\_HEDLEY\_VERSION) || (JSON\_HEDLEY\_VERSION < X) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{2362 }
\DoxyCodeLine{2363 }
\DoxyCodeLine{2364 \textcolor{comment}{// This file contains all internal macro definitions (except those affecting ABI)}}
\DoxyCodeLine{2365 \textcolor{comment}{// You MUST include macro\_unscope.hpp at the end of json.hpp to undef all of them}}
\DoxyCodeLine{2366 }
\DoxyCodeLine{2367 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{2368 }
\DoxyCodeLine{2369 }
\DoxyCodeLine{2370 \textcolor{comment}{// exclude unsupported compilers}}
\DoxyCodeLine{2371 \textcolor{preprocessor}{\#if !defined(JSON\_SKIP\_UNSUPPORTED\_COMPILER\_CHECK)}}
\DoxyCodeLine{2372 \textcolor{preprocessor}{    \#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{2373 \textcolor{preprocessor}{        \#if (\_\_clang\_major\_\_ * 10000 + \_\_clang\_minor\_\_ * 100 + \_\_clang\_patchlevel\_\_) < 30400}}
\DoxyCodeLine{2374 \textcolor{preprocessor}{            \#error "{}unsupported Clang version -\/ see https://github.com/nlohmann/json\#supported-\/compilers"{}}}
\DoxyCodeLine{2375 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{2376 \textcolor{preprocessor}{    \#elif defined(\_\_GNUC\_\_) \&\& !(defined(\_\_ICC) || defined(\_\_INTEL\_COMPILER))}}
\DoxyCodeLine{2377 \textcolor{preprocessor}{        \#if (\_\_GNUC\_\_ * 10000 + \_\_GNUC\_MINOR\_\_ * 100 + \_\_GNUC\_PATCHLEVEL\_\_) < 40800}}
\DoxyCodeLine{2378 \textcolor{preprocessor}{            \#error "{}unsupported GCC version -\/ see https://github.com/nlohmann/json\#supported-\/compilers"{}}}
\DoxyCodeLine{2379 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{2380 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2381 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2382 }
\DoxyCodeLine{2383 \textcolor{comment}{// C++ language standard detection}}
\DoxyCodeLine{2384 \textcolor{comment}{// if the user manually specified the used c++ version this is skipped}}
\DoxyCodeLine{2385 \textcolor{preprocessor}{\#if !defined(JSON\_HAS\_CPP\_20) \&\& !defined(JSON\_HAS\_CPP\_17) \&\& !defined(JSON\_HAS\_CPP\_14) \&\& !defined(JSON\_HAS\_CPP\_11)}}
\DoxyCodeLine{2386 \textcolor{preprocessor}{    \#if (defined(\_\_cplusplus) \&\& \_\_cplusplus >= 202002L) || (defined(\_MSVC\_LANG) \&\& \_MSVC\_LANG >= 202002L)}}
\DoxyCodeLine{2387 \textcolor{preprocessor}{        \#define JSON\_HAS\_CPP\_20}}
\DoxyCodeLine{2388 \textcolor{preprocessor}{        \#define JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{2389 \textcolor{preprocessor}{        \#define JSON\_HAS\_CPP\_14}}
\DoxyCodeLine{2390 \textcolor{preprocessor}{    \#elif (defined(\_\_cplusplus) \&\& \_\_cplusplus >= 201703L) || (defined(\_HAS\_CXX17) \&\& \_HAS\_CXX17 == 1) }\textcolor{comment}{// fix for issue \#464}}
\DoxyCodeLine{2391 \textcolor{preprocessor}{        \#define JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{2392 \textcolor{preprocessor}{        \#define JSON\_HAS\_CPP\_14}}
\DoxyCodeLine{2393 \textcolor{preprocessor}{    \#elif (defined(\_\_cplusplus) \&\& \_\_cplusplus >= 201402L) || (defined(\_HAS\_CXX14) \&\& \_HAS\_CXX14 == 1)}}
\DoxyCodeLine{2394 \textcolor{preprocessor}{        \#define JSON\_HAS\_CPP\_14}}
\DoxyCodeLine{2395 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2396     \textcolor{comment}{// the cpp 11 flag is always specified because it is the minimal required version}}
\DoxyCodeLine{2397 \textcolor{preprocessor}{    \#define JSON\_HAS\_CPP\_11}}
\DoxyCodeLine{2398 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2399 }
\DoxyCodeLine{2400 \textcolor{preprocessor}{\#ifdef \_\_has\_include}}
\DoxyCodeLine{2401 \textcolor{preprocessor}{    \#if \_\_has\_include(<version>)}}
\DoxyCodeLine{2402 \textcolor{preprocessor}{        \#include <version>}}
\DoxyCodeLine{2403 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2404 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2405 }
\DoxyCodeLine{2406 \textcolor{preprocessor}{\#if !defined(JSON\_HAS\_FILESYSTEM) \&\& !defined(JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM)}}
\DoxyCodeLine{2407 \textcolor{preprocessor}{    \#ifdef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{2408 \textcolor{preprocessor}{        \#if defined(\_\_cpp\_lib\_filesystem)}}
\DoxyCodeLine{2409 \textcolor{preprocessor}{            \#define JSON\_HAS\_FILESYSTEM 1}}
\DoxyCodeLine{2410 \textcolor{preprocessor}{        \#elif defined(\_\_cpp\_lib\_experimental\_filesystem)}}
\DoxyCodeLine{2411 \textcolor{preprocessor}{            \#define JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM 1}}
\DoxyCodeLine{2412 \textcolor{preprocessor}{        \#elif !defined(\_\_has\_include)}}
\DoxyCodeLine{2413 \textcolor{preprocessor}{            \#define JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM 1}}
\DoxyCodeLine{2414 \textcolor{preprocessor}{        \#elif \_\_has\_include(<filesystem>)}}
\DoxyCodeLine{2415 \textcolor{preprocessor}{            \#define JSON\_HAS\_FILESYSTEM 1}}
\DoxyCodeLine{2416 \textcolor{preprocessor}{        \#elif \_\_has\_include(<experimental/filesystem>)}}
\DoxyCodeLine{2417 \textcolor{preprocessor}{            \#define JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM 1}}
\DoxyCodeLine{2418 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{2419 }
\DoxyCodeLine{2420         \textcolor{comment}{// std::filesystem does not work on MinGW GCC 8: https://sourceforge.net/p/mingw-\/w64/bugs/737/}}
\DoxyCodeLine{2421 \textcolor{preprocessor}{        \#if defined(\_\_MINGW32\_\_) \&\& defined(\_\_GNUC\_\_) \&\& \_\_GNUC\_\_ == 8}}
\DoxyCodeLine{2422 \textcolor{preprocessor}{            \#undef JSON\_HAS\_FILESYSTEM}}
\DoxyCodeLine{2423 \textcolor{preprocessor}{            \#undef JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{2424 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{2425 }
\DoxyCodeLine{2426         \textcolor{comment}{// no filesystem support before GCC 8: https://en.cppreference.com/w/cpp/compiler\_support}}
\DoxyCodeLine{2427 \textcolor{preprocessor}{        \#if defined(\_\_GNUC\_\_) \&\& !defined(\_\_clang\_\_) \&\& \_\_GNUC\_\_ < 8}}
\DoxyCodeLine{2428 \textcolor{preprocessor}{            \#undef JSON\_HAS\_FILESYSTEM}}
\DoxyCodeLine{2429 \textcolor{preprocessor}{            \#undef JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{2430 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{2431 }
\DoxyCodeLine{2432         \textcolor{comment}{// no filesystem support before Clang 7: https://en.cppreference.com/w/cpp/compiler\_support}}
\DoxyCodeLine{2433 \textcolor{preprocessor}{        \#if defined(\_\_clang\_major\_\_) \&\& \_\_clang\_major\_\_ < 7}}
\DoxyCodeLine{2434 \textcolor{preprocessor}{            \#undef JSON\_HAS\_FILESYSTEM}}
\DoxyCodeLine{2435 \textcolor{preprocessor}{            \#undef JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{2436 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{2437 }
\DoxyCodeLine{2438         \textcolor{comment}{// no filesystem support before MSVC 19.14: https://en.cppreference.com/w/cpp/compiler\_support}}
\DoxyCodeLine{2439 \textcolor{preprocessor}{        \#if defined(\_MSC\_VER) \&\& \_MSC\_VER < 1914}}
\DoxyCodeLine{2440 \textcolor{preprocessor}{            \#undef JSON\_HAS\_FILESYSTEM}}
\DoxyCodeLine{2441 \textcolor{preprocessor}{            \#undef JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{2442 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{2443 }
\DoxyCodeLine{2444         \textcolor{comment}{// no filesystem support before iOS 13}}
\DoxyCodeLine{2445 \textcolor{preprocessor}{        \#if defined(\_\_IPHONE\_OS\_VERSION\_MIN\_REQUIRED) \&\& \_\_IPHONE\_OS\_VERSION\_MIN\_REQUIRED < 130000}}
\DoxyCodeLine{2446 \textcolor{preprocessor}{            \#undef JSON\_HAS\_FILESYSTEM}}
\DoxyCodeLine{2447 \textcolor{preprocessor}{            \#undef JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{2448 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{2449 }
\DoxyCodeLine{2450         \textcolor{comment}{// no filesystem support before macOS Catalina}}
\DoxyCodeLine{2451 \textcolor{preprocessor}{        \#if defined(\_\_MAC\_OS\_X\_VERSION\_MIN\_REQUIRED) \&\& \_\_MAC\_OS\_X\_VERSION\_MIN\_REQUIRED < 101500}}
\DoxyCodeLine{2452 \textcolor{preprocessor}{            \#undef JSON\_HAS\_FILESYSTEM}}
\DoxyCodeLine{2453 \textcolor{preprocessor}{            \#undef JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{2454 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{2455 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2456 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2457 }
\DoxyCodeLine{2458 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{2459 \textcolor{preprocessor}{    \#define JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM 0}}
\DoxyCodeLine{2460 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2461 }
\DoxyCodeLine{2462 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_FILESYSTEM}}
\DoxyCodeLine{2463 \textcolor{preprocessor}{    \#define JSON\_HAS\_FILESYSTEM 0}}
\DoxyCodeLine{2464 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2465 }
\DoxyCodeLine{2466 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_THREE\_WAY\_COMPARISON}}
\DoxyCodeLine{2467 \textcolor{preprocessor}{    \#if defined(\_\_cpp\_impl\_three\_way\_comparison) \&\& \_\_cpp\_impl\_three\_way\_comparison >= 201907L \(\backslash\)}}
\DoxyCodeLine{2468 \textcolor{preprocessor}{        \&\& defined(\_\_cpp\_lib\_three\_way\_comparison) \&\& \_\_cpp\_lib\_three\_way\_comparison >= 201907L}}
\DoxyCodeLine{2469 \textcolor{preprocessor}{        \#define JSON\_HAS\_THREE\_WAY\_COMPARISON 1}}
\DoxyCodeLine{2470 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{2471 \textcolor{preprocessor}{        \#define JSON\_HAS\_THREE\_WAY\_COMPARISON 0}}
\DoxyCodeLine{2472 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2473 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2474 }
\DoxyCodeLine{2475 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_RANGES}}
\DoxyCodeLine{2476     \textcolor{comment}{// ranges header shipping in GCC 11.1.0 (released 2021-\/04-\/27) has syntax error}}
\DoxyCodeLine{2477 \textcolor{preprocessor}{    \#if defined(\_\_GLIBCXX\_\_) \&\& \_\_GLIBCXX\_\_ == 20210427}}
\DoxyCodeLine{2478 \textcolor{preprocessor}{        \#define JSON\_HAS\_RANGES 0}}
\DoxyCodeLine{2479 \textcolor{preprocessor}{    \#elif defined(\_\_cpp\_lib\_ranges)}}
\DoxyCodeLine{2480 \textcolor{preprocessor}{        \#define JSON\_HAS\_RANGES 1}}
\DoxyCodeLine{2481 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{2482 \textcolor{preprocessor}{        \#define JSON\_HAS\_RANGES 0}}
\DoxyCodeLine{2483 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{2484 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2485 }
\DoxyCodeLine{2486 \textcolor{preprocessor}{\#ifdef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{2487 \textcolor{preprocessor}{    \#define JSON\_INLINE\_VARIABLE inline}}
\DoxyCodeLine{2488 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2489 \textcolor{preprocessor}{    \#define JSON\_INLINE\_VARIABLE}}
\DoxyCodeLine{2490 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2491 }
\DoxyCodeLine{2492 \textcolor{preprocessor}{\#if JSON\_HEDLEY\_HAS\_ATTRIBUTE(no\_unique\_address)}}
\DoxyCodeLine{2493 \textcolor{preprocessor}{    \#define JSON\_NO\_UNIQUE\_ADDRESS [[no\_unique\_address]]}}
\DoxyCodeLine{2494 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2495 \textcolor{preprocessor}{    \#define JSON\_NO\_UNIQUE\_ADDRESS}}
\DoxyCodeLine{2496 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2497 }
\DoxyCodeLine{2498 \textcolor{comment}{// disable documentation warnings on clang}}
\DoxyCodeLine{2499 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{2500 \textcolor{preprocessor}{    \#pragma clang diagnostic push}}
\DoxyCodeLine{2501 \textcolor{preprocessor}{    \#pragma clang diagnostic ignored "{}-\/Wdocumentation"{}}}
\DoxyCodeLine{2502 \textcolor{preprocessor}{    \#pragma clang diagnostic ignored "{}-\/Wdocumentation-\/unknown-\/command"{}}}
\DoxyCodeLine{2503 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2504 }
\DoxyCodeLine{2505 \textcolor{comment}{// allow disabling exceptions}}
\DoxyCodeLine{2506 \textcolor{preprocessor}{\#if (defined(\_\_cpp\_exceptions) || defined(\_\_EXCEPTIONS) || defined(\_CPPUNWIND)) \&\& !defined(JSON\_NOEXCEPTION)}}
\DoxyCodeLine{2507 \textcolor{preprocessor}{    \#define JSON\_THROW(exception) throw exception}}
\DoxyCodeLine{2508 \textcolor{preprocessor}{    \#define JSON\_TRY try}}
\DoxyCodeLine{2509 \textcolor{preprocessor}{    \#define JSON\_CATCH(exception) catch(exception)}}
\DoxyCodeLine{2510 \textcolor{preprocessor}{    \#define JSON\_INTERNAL\_CATCH(exception) catch(exception)}}
\DoxyCodeLine{2511 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2512 \textcolor{preprocessor}{    \#include <cstdlib>}}
\DoxyCodeLine{2513 \textcolor{preprocessor}{    \#define JSON\_THROW(exception) std::abort()}}
\DoxyCodeLine{2514 \textcolor{preprocessor}{    \#define JSON\_TRY if(true)}}
\DoxyCodeLine{2515 \textcolor{preprocessor}{    \#define JSON\_CATCH(exception) if(false)}}
\DoxyCodeLine{2516 \textcolor{preprocessor}{    \#define JSON\_INTERNAL\_CATCH(exception) if(false)}}
\DoxyCodeLine{2517 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2518 }
\DoxyCodeLine{2519 \textcolor{comment}{// override exception macros}}
\DoxyCodeLine{2520 \textcolor{preprocessor}{\#if defined(JSON\_THROW\_USER)}}
\DoxyCodeLine{2521 \textcolor{preprocessor}{    \#undef JSON\_THROW}}
\DoxyCodeLine{2522 \textcolor{preprocessor}{    \#define JSON\_THROW JSON\_THROW\_USER}}
\DoxyCodeLine{2523 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2524 \textcolor{preprocessor}{\#if defined(JSON\_TRY\_USER)}}
\DoxyCodeLine{2525 \textcolor{preprocessor}{    \#undef JSON\_TRY}}
\DoxyCodeLine{2526 \textcolor{preprocessor}{    \#define JSON\_TRY JSON\_TRY\_USER}}
\DoxyCodeLine{2527 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2528 \textcolor{preprocessor}{\#if defined(JSON\_CATCH\_USER)}}
\DoxyCodeLine{2529 \textcolor{preprocessor}{    \#undef JSON\_CATCH}}
\DoxyCodeLine{2530 \textcolor{preprocessor}{    \#define JSON\_CATCH JSON\_CATCH\_USER}}
\DoxyCodeLine{2531 \textcolor{preprocessor}{    \#undef JSON\_INTERNAL\_CATCH}}
\DoxyCodeLine{2532 \textcolor{preprocessor}{    \#define JSON\_INTERNAL\_CATCH JSON\_CATCH\_USER}}
\DoxyCodeLine{2533 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2534 \textcolor{preprocessor}{\#if defined(JSON\_INTERNAL\_CATCH\_USER)}}
\DoxyCodeLine{2535 \textcolor{preprocessor}{    \#undef JSON\_INTERNAL\_CATCH}}
\DoxyCodeLine{2536 \textcolor{preprocessor}{    \#define JSON\_INTERNAL\_CATCH JSON\_INTERNAL\_CATCH\_USER}}
\DoxyCodeLine{2537 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2538 }
\DoxyCodeLine{2539 \textcolor{comment}{// allow overriding assert}}
\DoxyCodeLine{2540 \textcolor{preprocessor}{\#if !defined(JSON\_ASSERT)}}
\DoxyCodeLine{2541 \textcolor{preprocessor}{    \#include <cassert>} \textcolor{comment}{// assert}}
\DoxyCodeLine{2542 \textcolor{preprocessor}{    \#define JSON\_ASSERT(x) assert(x)}}
\DoxyCodeLine{2543 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2544 }
\DoxyCodeLine{2545 \textcolor{comment}{// allow to access some private functions (needed by the test suite)}}
\DoxyCodeLine{2546 \textcolor{preprocessor}{\#if defined(JSON\_TESTS\_PRIVATE)}}
\DoxyCodeLine{2547 \textcolor{preprocessor}{    \#define JSON\_PRIVATE\_UNLESS\_TESTED public}}
\DoxyCodeLine{2548 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2549 \textcolor{preprocessor}{    \#define JSON\_PRIVATE\_UNLESS\_TESTED private}}
\DoxyCodeLine{2550 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2551 }
\DoxyCodeLine{2557 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_SERIALIZE\_ENUM(ENUM\_TYPE, ...)                                            \(\backslash\)}}
\DoxyCodeLine{2558 \textcolor{preprocessor}{    template<typename BasicJsonType>                                                            \(\backslash\)}}
\DoxyCodeLine{2559 \textcolor{preprocessor}{    inline void to\_json(BasicJsonType\& j, const ENUM\_TYPE\& e)                                   \(\backslash\)}}
\DoxyCodeLine{2560 \textcolor{preprocessor}{    \{                                                                                           \(\backslash\)}}
\DoxyCodeLine{2561 \textcolor{preprocessor}{        static\_assert(std::is\_enum<ENUM\_TYPE>::value, \#ENUM\_TYPE "{} must be an enum!"{}});          \(\backslash\)}
\DoxyCodeLine{2562         static const std::pair<ENUM\_TYPE, BasicJsonType> m[] = \_\_VA\_ARGS\_\_;                     \(\backslash\)}
\DoxyCodeLine{2563         auto it = std::find\_if(std::begin(m), std::end(m),                                      \(\backslash\)}
\DoxyCodeLine{2564                                [e](const std::pair<ENUM\_TYPE, BasicJsonType>\& ej\_pair) -\/> bool  \(\backslash\)}
\DoxyCodeLine{2565         \{                                                                                       \(\backslash\)}
\DoxyCodeLine{2566             return ej\_pair.first == e;                                                          \(\backslash\)}
\DoxyCodeLine{2567         \});                                                                                     \(\backslash\)}
\DoxyCodeLine{2568         j = ((it != std::end(m)) ? it : std::begin(m))-\/>second;                                 \(\backslash\)}
\DoxyCodeLine{2569     \}                                                                                           \(\backslash\)}
\DoxyCodeLine{2570     template<typename BasicJsonType>                                                            \(\backslash\)}
\DoxyCodeLine{2571     inline void from\_json(const BasicJsonType\& j, ENUM\_TYPE\& e)                                 \(\backslash\)}
\DoxyCodeLine{2572     \{                                                                                           \(\backslash\)}
\DoxyCodeLine{2573         static\_assert(std::is\_enum<ENUM\_TYPE>::value, \#ENUM\_TYPE "{} must be an enum!"{});          \(\backslash\)}
\DoxyCodeLine{2574         static const std::pair<ENUM\_TYPE, BasicJsonType> m[] = \_\_VA\_ARGS\_\_;                     \(\backslash\)}
\DoxyCodeLine{2575         auto it = std::find\_if(std::begin(m), std::end(m),                                      \(\backslash\)}
\DoxyCodeLine{2576                                [\&j](const std::pair<ENUM\_TYPE, BasicJsonType>\& ej\_pair) -\/> bool \(\backslash\)}
\DoxyCodeLine{2577         \{                                                                                       \(\backslash\)}
\DoxyCodeLine{2578             return ej\_pair.second == j;                                                         \(\backslash\)}
\DoxyCodeLine{2579         \});                                                                                     \(\backslash\)}
\DoxyCodeLine{2580         e = ((it != std::end(m)) ? it : std::begin(m))-\/>first;                                  \(\backslash\)}
\DoxyCodeLine{2581     \}}
\DoxyCodeLine{2582 }
\DoxyCodeLine{2583 \textcolor{comment}{// Ugly macros to avoid uglier copy-\/paste when specializing basic\_json. They}}
\DoxyCodeLine{2584 \textcolor{comment}{// may be removed in the future once the class is split.}}
\DoxyCodeLine{2585 }
\DoxyCodeLine{2586 \textcolor{preprocessor}{\#define NLOHMANN\_BASIC\_JSON\_TPL\_DECLARATION                                \(\backslash\)}}
\DoxyCodeLine{2587 \textcolor{preprocessor}{    template<template<typename, typename, typename...> class ObjectType,   \(\backslash\)}}
\DoxyCodeLine{2588 \textcolor{preprocessor}{             template<typename, typename...> class ArrayType,              \(\backslash\)}}
\DoxyCodeLine{2589 \textcolor{preprocessor}{             class StringType, class BooleanType, class NumberIntegerType, \(\backslash\)}}
\DoxyCodeLine{2590 \textcolor{preprocessor}{             class NumberUnsignedType, class NumberFloatType,              \(\backslash\)}}
\DoxyCodeLine{2591 \textcolor{preprocessor}{             template<typename> class AllocatorType,                       \(\backslash\)}}
\DoxyCodeLine{2592 \textcolor{preprocessor}{             template<typename, typename = void> class JSONSerializer,     \(\backslash\)}}
\DoxyCodeLine{2593 \textcolor{preprocessor}{             class BinaryType>}}
\DoxyCodeLine{2594 }
\DoxyCodeLine{2595 \textcolor{preprocessor}{\#define NLOHMANN\_BASIC\_JSON\_TPL                                            \(\backslash\)}}
\DoxyCodeLine{2596 \textcolor{preprocessor}{    basic\_json<ObjectType, ArrayType, StringType, BooleanType,             \(\backslash\)}}
\DoxyCodeLine{2597 \textcolor{preprocessor}{    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \(\backslash\)}}
\DoxyCodeLine{2598 \textcolor{preprocessor}{    AllocatorType, JSONSerializer, BinaryType>}}
\DoxyCodeLine{2599 }
\DoxyCodeLine{2600 \textcolor{comment}{// Macros to simplify conversion from/to types}}
\DoxyCodeLine{2601 }
\DoxyCodeLine{2602 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_EXPAND( x ) x}}
\DoxyCodeLine{2603 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_GET\_MACRO(\_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9, \_10, \_11, \_12, \_13, \_14, \_15, \_16, \_17, \_18, \_19, \_20, \_21, \_22, \_23, \_24, \_25, \_26, \_27, \_28, \_29, \_30, \_31, \_32, \_33, \_34, \_35, \_36, \_37, \_38, \_39, \_40, \_41, \_42, \_43, \_44, \_45, \_46, \_47, \_48, \_49, \_50, \_51, \_52, \_53, \_54, \_55, \_56, \_57, \_58, \_59, \_60, \_61, \_62, \_63, \_64, NAME,...) NAME}}
\DoxyCodeLine{2604 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE(...) NLOHMANN\_JSON\_EXPAND(NLOHMANN\_JSON\_GET\_MACRO(\_\_VA\_ARGS\_\_, \(\backslash\)}}
\DoxyCodeLine{2605 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE64, \(\backslash\)}}
\DoxyCodeLine{2606 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE63, \(\backslash\)}}
\DoxyCodeLine{2607 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE62, \(\backslash\)}}
\DoxyCodeLine{2608 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE61, \(\backslash\)}}
\DoxyCodeLine{2609 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE60, \(\backslash\)}}
\DoxyCodeLine{2610 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE59, \(\backslash\)}}
\DoxyCodeLine{2611 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE58, \(\backslash\)}}
\DoxyCodeLine{2612 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE57, \(\backslash\)}}
\DoxyCodeLine{2613 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE56, \(\backslash\)}}
\DoxyCodeLine{2614 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE55, \(\backslash\)}}
\DoxyCodeLine{2615 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE54, \(\backslash\)}}
\DoxyCodeLine{2616 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE53, \(\backslash\)}}
\DoxyCodeLine{2617 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE52, \(\backslash\)}}
\DoxyCodeLine{2618 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE51, \(\backslash\)}}
\DoxyCodeLine{2619 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE50, \(\backslash\)}}
\DoxyCodeLine{2620 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE49, \(\backslash\)}}
\DoxyCodeLine{2621 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE48, \(\backslash\)}}
\DoxyCodeLine{2622 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE47, \(\backslash\)}}
\DoxyCodeLine{2623 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE46, \(\backslash\)}}
\DoxyCodeLine{2624 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE45, \(\backslash\)}}
\DoxyCodeLine{2625 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE44, \(\backslash\)}}
\DoxyCodeLine{2626 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE43, \(\backslash\)}}
\DoxyCodeLine{2627 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE42, \(\backslash\)}}
\DoxyCodeLine{2628 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE41, \(\backslash\)}}
\DoxyCodeLine{2629 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE40, \(\backslash\)}}
\DoxyCodeLine{2630 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE39, \(\backslash\)}}
\DoxyCodeLine{2631 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE38, \(\backslash\)}}
\DoxyCodeLine{2632 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE37, \(\backslash\)}}
\DoxyCodeLine{2633 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE36, \(\backslash\)}}
\DoxyCodeLine{2634 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE35, \(\backslash\)}}
\DoxyCodeLine{2635 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE34, \(\backslash\)}}
\DoxyCodeLine{2636 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE33, \(\backslash\)}}
\DoxyCodeLine{2637 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE32, \(\backslash\)}}
\DoxyCodeLine{2638 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE31, \(\backslash\)}}
\DoxyCodeLine{2639 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE30, \(\backslash\)}}
\DoxyCodeLine{2640 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE29, \(\backslash\)}}
\DoxyCodeLine{2641 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE28, \(\backslash\)}}
\DoxyCodeLine{2642 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE27, \(\backslash\)}}
\DoxyCodeLine{2643 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE26, \(\backslash\)}}
\DoxyCodeLine{2644 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE25, \(\backslash\)}}
\DoxyCodeLine{2645 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE24, \(\backslash\)}}
\DoxyCodeLine{2646 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE23, \(\backslash\)}}
\DoxyCodeLine{2647 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE22, \(\backslash\)}}
\DoxyCodeLine{2648 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE21, \(\backslash\)}}
\DoxyCodeLine{2649 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE20, \(\backslash\)}}
\DoxyCodeLine{2650 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE19, \(\backslash\)}}
\DoxyCodeLine{2651 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE18, \(\backslash\)}}
\DoxyCodeLine{2652 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE17, \(\backslash\)}}
\DoxyCodeLine{2653 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE16, \(\backslash\)}}
\DoxyCodeLine{2654 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE15, \(\backslash\)}}
\DoxyCodeLine{2655 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE14, \(\backslash\)}}
\DoxyCodeLine{2656 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE13, \(\backslash\)}}
\DoxyCodeLine{2657 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE12, \(\backslash\)}}
\DoxyCodeLine{2658 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE11, \(\backslash\)}}
\DoxyCodeLine{2659 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE10, \(\backslash\)}}
\DoxyCodeLine{2660 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE9, \(\backslash\)}}
\DoxyCodeLine{2661 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE8, \(\backslash\)}}
\DoxyCodeLine{2662 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE7, \(\backslash\)}}
\DoxyCodeLine{2663 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE6, \(\backslash\)}}
\DoxyCodeLine{2664 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE5, \(\backslash\)}}
\DoxyCodeLine{2665 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE4, \(\backslash\)}}
\DoxyCodeLine{2666 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE3, \(\backslash\)}}
\DoxyCodeLine{2667 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE2, \(\backslash\)}}
\DoxyCodeLine{2668 \textcolor{preprocessor}{        NLOHMANN\_JSON\_PASTE1)(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{2669 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE2(func, v1) func(v1)}}
\DoxyCodeLine{2670 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE3(func, v1, v2) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE2(func, v2)}}
\DoxyCodeLine{2671 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE4(func, v1, v2, v3) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE3(func, v2, v3)}}
\DoxyCodeLine{2672 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE5(func, v1, v2, v3, v4) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE4(func, v2, v3, v4)}}
\DoxyCodeLine{2673 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE5(func, v2, v3, v4, v5)}}
\DoxyCodeLine{2674 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE6(func, v2, v3, v4, v5, v6)}}
\DoxyCodeLine{2675 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE7(func, v2, v3, v4, v5, v6, v7)}}
\DoxyCodeLine{2676 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)}}
\DoxyCodeLine{2677 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)}}
\DoxyCodeLine{2678 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)}}
\DoxyCodeLine{2679 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)}}
\DoxyCodeLine{2680 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)}}
\DoxyCodeLine{2681 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)}}
\DoxyCodeLine{2682 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)}}
\DoxyCodeLine{2683 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)}}
\DoxyCodeLine{2684 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)}}
\DoxyCodeLine{2685 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)}}
\DoxyCodeLine{2686 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)}}
\DoxyCodeLine{2687 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)}}
\DoxyCodeLine{2688 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)}}
\DoxyCodeLine{2689 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)}}
\DoxyCodeLine{2690 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)}}
\DoxyCodeLine{2691 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)}}
\DoxyCodeLine{2692 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)}}
\DoxyCodeLine{2693 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)}}
\DoxyCodeLine{2694 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)}}
\DoxyCodeLine{2695 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)}}
\DoxyCodeLine{2696 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)}}
\DoxyCodeLine{2697 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)}}
\DoxyCodeLine{2698 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)}}
\DoxyCodeLine{2699 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)}}
\DoxyCodeLine{2700 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)}}
\DoxyCodeLine{2701 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)}}
\DoxyCodeLine{2702 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)}}
\DoxyCodeLine{2703 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)}}
\DoxyCodeLine{2704 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)}}
\DoxyCodeLine{2705 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)}}
\DoxyCodeLine{2706 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)}}
\DoxyCodeLine{2707 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)}}
\DoxyCodeLine{2708 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)}}
\DoxyCodeLine{2709 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)}}
\DoxyCodeLine{2710 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)}}
\DoxyCodeLine{2711 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)}}
\DoxyCodeLine{2712 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)}}
\DoxyCodeLine{2713 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)}}
\DoxyCodeLine{2714 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)}}
\DoxyCodeLine{2715 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)}}
\DoxyCodeLine{2716 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)}}
\DoxyCodeLine{2717 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)}}
\DoxyCodeLine{2718 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)}}
\DoxyCodeLine{2719 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)}}
\DoxyCodeLine{2720 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)}}
\DoxyCodeLine{2721 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)}}
\DoxyCodeLine{2722 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)}}
\DoxyCodeLine{2723 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)}}
\DoxyCodeLine{2724 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)}}
\DoxyCodeLine{2725 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)}}
\DoxyCodeLine{2726 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)}}
\DoxyCodeLine{2727 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)}}
\DoxyCodeLine{2728 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)}}
\DoxyCodeLine{2729 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)}}
\DoxyCodeLine{2730 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)}}
\DoxyCodeLine{2731 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN\_JSON\_PASTE2(func, v1) NLOHMANN\_JSON\_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)}}
\DoxyCodeLine{2732 }
\DoxyCodeLine{2733 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_TO(v1) nlohmann\_json\_j[\#v1] = nlohmann\_json\_t.v1;}}
\DoxyCodeLine{2734 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_FROM(v1) nlohmann\_json\_j.at(\#v1).get\_to(nlohmann\_json\_t.v1);}}
\DoxyCodeLine{2735 \textcolor{preprocessor}{\#define NLOHMANN\_JSON\_FROM\_WITH\_DEFAULT(v1) nlohmann\_json\_t.v1 = nlohmann\_json\_j.value(\#v1, nlohmann\_json\_default\_obj.v1);}}
\DoxyCodeLine{2736 }
\DoxyCodeLine{2742 \textcolor{preprocessor}{\#define NLOHMANN\_DEFINE\_TYPE\_INTRUSIVE(Type, ...)  \(\backslash\)}}
\DoxyCodeLine{2743 \textcolor{preprocessor}{    friend void to\_json(nlohmann::json\& nlohmann\_json\_j, const Type\& nlohmann\_json\_t) \{ NLOHMANN\_JSON\_EXPAND(NLOHMANN\_JSON\_PASTE(NLOHMANN\_JSON\_TO, \_\_VA\_ARGS\_\_)) \} \(\backslash\)}}
\DoxyCodeLine{2744 \textcolor{preprocessor}{    friend void from\_json(const nlohmann::json\& nlohmann\_json\_j, Type\& nlohmann\_json\_t) \{ NLOHMANN\_JSON\_EXPAND(NLOHMANN\_JSON\_PASTE(NLOHMANN\_JSON\_FROM, \_\_VA\_ARGS\_\_)) \}}}
\DoxyCodeLine{2745 }
\DoxyCodeLine{2746 \textcolor{preprocessor}{\#define NLOHMANN\_DEFINE\_TYPE\_INTRUSIVE\_WITH\_DEFAULT(Type, ...)  \(\backslash\)}}
\DoxyCodeLine{2747 \textcolor{preprocessor}{    friend void to\_json(nlohmann::json\& nlohmann\_json\_j, const Type\& nlohmann\_json\_t) \{ NLOHMANN\_JSON\_EXPAND(NLOHMANN\_JSON\_PASTE(NLOHMANN\_JSON\_TO, \_\_VA\_ARGS\_\_)) \} \(\backslash\)}}
\DoxyCodeLine{2748 \textcolor{preprocessor}{    friend void from\_json(const nlohmann::json\& nlohmann\_json\_j, Type\& nlohmann\_json\_t) \{ Type nlohmann\_json\_default\_obj; NLOHMANN\_JSON\_EXPAND(NLOHMANN\_JSON\_PASTE(NLOHMANN\_JSON\_FROM\_WITH\_DEFAULT, \_\_VA\_ARGS\_\_)) \}}}
\DoxyCodeLine{2749 }
\DoxyCodeLine{2755 \textcolor{preprocessor}{\#define NLOHMANN\_DEFINE\_TYPE\_NON\_INTRUSIVE(Type, ...)  \(\backslash\)}}
\DoxyCodeLine{2756 \textcolor{preprocessor}{    inline void to\_json(nlohmann::json\& nlohmann\_json\_j, const Type\& nlohmann\_json\_t) \{ NLOHMANN\_JSON\_EXPAND(NLOHMANN\_JSON\_PASTE(NLOHMANN\_JSON\_TO, \_\_VA\_ARGS\_\_)) \} \(\backslash\)}}
\DoxyCodeLine{2757 \textcolor{preprocessor}{    inline void from\_json(const nlohmann::json\& nlohmann\_json\_j, Type\& nlohmann\_json\_t) \{ NLOHMANN\_JSON\_EXPAND(NLOHMANN\_JSON\_PASTE(NLOHMANN\_JSON\_FROM, \_\_VA\_ARGS\_\_)) \}}}
\DoxyCodeLine{2758 }
\DoxyCodeLine{2759 \textcolor{preprocessor}{\#define NLOHMANN\_DEFINE\_TYPE\_NON\_INTRUSIVE\_WITH\_DEFAULT(Type, ...)  \(\backslash\)}}
\DoxyCodeLine{2760 \textcolor{preprocessor}{    inline void to\_json(nlohmann::json\& nlohmann\_json\_j, const Type\& nlohmann\_json\_t) \{ NLOHMANN\_JSON\_EXPAND(NLOHMANN\_JSON\_PASTE(NLOHMANN\_JSON\_TO, \_\_VA\_ARGS\_\_)) \} \(\backslash\)}}
\DoxyCodeLine{2761 \textcolor{preprocessor}{    inline void from\_json(const nlohmann::json\& nlohmann\_json\_j, Type\& nlohmann\_json\_t) \{ Type nlohmann\_json\_default\_obj; NLOHMANN\_JSON\_EXPAND(NLOHMANN\_JSON\_PASTE(NLOHMANN\_JSON\_FROM\_WITH\_DEFAULT, \_\_VA\_ARGS\_\_)) \}}}
\DoxyCodeLine{2762 }
\DoxyCodeLine{2763 }
\DoxyCodeLine{2764 \textcolor{comment}{// inspired from https://stackoverflow.com/a/26745591}}
\DoxyCodeLine{2765 \textcolor{comment}{// allows to call any std function as if (e.g. with begin):}}
\DoxyCodeLine{2766 \textcolor{comment}{// using std::begin; begin(x);}}
\DoxyCodeLine{2767 \textcolor{comment}{//}}
\DoxyCodeLine{2768 \textcolor{comment}{// it allows using the detected idiom to retrieve the return type}}
\DoxyCodeLine{2769 \textcolor{comment}{// of such an expression}}
\DoxyCodeLine{2770 \textcolor{preprocessor}{\#define NLOHMANN\_CAN\_CALL\_STD\_FUNC\_IMPL(std\_name)                                 \(\backslash\)}}
\DoxyCodeLine{2771 \textcolor{preprocessor}{    namespace detail \{                                                            \(\backslash\)}}
\DoxyCodeLine{2772 \textcolor{preprocessor}{    using std::std\_name;                                                          \(\backslash\)}}
\DoxyCodeLine{2773 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{2774 \textcolor{preprocessor}{    template<typename... T>                                                       \(\backslash\)}}
\DoxyCodeLine{2775 \textcolor{preprocessor}{    using result\_of\_\#\#std\_name = decltype(std\_name(std::declval<T>()...));        \(\backslash\)}}
\DoxyCodeLine{2776 \textcolor{preprocessor}{    \}                                                                             \(\backslash\)}}
\DoxyCodeLine{2777 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{2778 \textcolor{preprocessor}{    namespace detail2 \{                                                           \(\backslash\)}}
\DoxyCodeLine{2779 \textcolor{preprocessor}{    struct std\_name\#\#\_tag                                                         \(\backslash\)}}
\DoxyCodeLine{2780 \textcolor{preprocessor}{    \{                                                                             \(\backslash\)}}
\DoxyCodeLine{2781 \textcolor{preprocessor}{    \};                                                                            \(\backslash\)}}
\DoxyCodeLine{2782 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{2783 \textcolor{preprocessor}{    template<typename... T>                                                       \(\backslash\)}}
\DoxyCodeLine{2784 \textcolor{preprocessor}{    std\_name\#\#\_tag std\_name(T\&\&...);                                              \(\backslash\)}}
\DoxyCodeLine{2785 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{2786 \textcolor{preprocessor}{    template<typename... T>                                                       \(\backslash\)}}
\DoxyCodeLine{2787 \textcolor{preprocessor}{    using result\_of\_\#\#std\_name = decltype(std\_name(std::declval<T>()...));        \(\backslash\)}}
\DoxyCodeLine{2788 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{2789 \textcolor{preprocessor}{    template<typename... T>                                                       \(\backslash\)}}
\DoxyCodeLine{2790 \textcolor{preprocessor}{    struct would\_call\_std\_\#\#std\_name                                              \(\backslash\)}}
\DoxyCodeLine{2791 \textcolor{preprocessor}{    \{                                                                             \(\backslash\)}}
\DoxyCodeLine{2792 \textcolor{preprocessor}{        static constexpr auto const value = ::nlohmann::detail::                  \(\backslash\)}}
\DoxyCodeLine{2793 \textcolor{preprocessor}{                                            is\_detected\_exact<std\_name\#\#\_tag, result\_of\_\#\#std\_name, T...>::value; \(\backslash\)}}
\DoxyCodeLine{2794 \textcolor{preprocessor}{    \};                                                                            \(\backslash\)}}
\DoxyCodeLine{2795 \textcolor{preprocessor}{    \} }\textcolor{comment}{/* namespace detail2 */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{2796 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{2797 \textcolor{preprocessor}{    template<typename... T>                                                       \(\backslash\)}}
\DoxyCodeLine{2798 \textcolor{preprocessor}{    struct would\_call\_std\_\#\#std\_name : detail2::would\_call\_std\_\#\#std\_name<T...>   \(\backslash\)}}
\DoxyCodeLine{2799 \textcolor{preprocessor}{    \{                                                                             \(\backslash\)}}
\DoxyCodeLine{2800 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{2801 }
\DoxyCodeLine{2802 \textcolor{preprocessor}{\#ifndef JSON\_USE\_IMPLICIT\_CONVERSIONS}}
\DoxyCodeLine{2803 \textcolor{preprocessor}{    \#define JSON\_USE\_IMPLICIT\_CONVERSIONS 1}}
\DoxyCodeLine{2804 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2805 }
\DoxyCodeLine{2806 \textcolor{preprocessor}{\#if JSON\_USE\_IMPLICIT\_CONVERSIONS}}
\DoxyCodeLine{2807 \textcolor{preprocessor}{    \#define JSON\_EXPLICIT}}
\DoxyCodeLine{2808 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2809 \textcolor{preprocessor}{    \#define JSON\_EXPLICIT explicit}}
\DoxyCodeLine{2810 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2811 }
\DoxyCodeLine{2812 \textcolor{preprocessor}{\#ifndef JSON\_DISABLE\_ENUM\_SERIALIZATION}}
\DoxyCodeLine{2813 \textcolor{preprocessor}{    \#define JSON\_DISABLE\_ENUM\_SERIALIZATION 0}}
\DoxyCodeLine{2814 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2815 }
\DoxyCodeLine{2816 \textcolor{preprocessor}{\#ifndef JSON\_USE\_GLOBAL\_UDLS}}
\DoxyCodeLine{2817 \textcolor{preprocessor}{    \#define JSON\_USE\_GLOBAL\_UDLS 1}}
\DoxyCodeLine{2818 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2819 }
\DoxyCodeLine{2820 \textcolor{preprocessor}{\#if JSON\_HAS\_THREE\_WAY\_COMPARISON}}
\DoxyCodeLine{2821 \textcolor{preprocessor}{    \#include <compare>} \textcolor{comment}{// partial\_ordering}}
\DoxyCodeLine{2822 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2823 }
\DoxyCodeLine{2824 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{2825 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{2826 \{}
\DoxyCodeLine{2827 }
\DoxyCodeLine{2829 \textcolor{comment}{// JSON type enumeration //}}
\DoxyCodeLine{2831 \textcolor{comment}{}}
\DoxyCodeLine{2856 \textcolor{keyword}{enum class} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} : std::uint8\_t}
\DoxyCodeLine{2857 \{}
\DoxyCodeLine{2858     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{null}},             }
\DoxyCodeLine{2859     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{object}},           }
\DoxyCodeLine{2860     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}},            }
\DoxyCodeLine{2861     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{string}},           }
\DoxyCodeLine{2862     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{boolean}},          }
\DoxyCodeLine{2863     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{number\_integer}},   }
\DoxyCodeLine{2864     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{number\_unsigned}},  }
\DoxyCodeLine{2865     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{number\_float}},     }
\DoxyCodeLine{2866     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{binary}},           }
\DoxyCodeLine{2867     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{discarded}}         }
\DoxyCodeLine{2868 \};}
\DoxyCodeLine{2869 }
\DoxyCodeLine{2883 \textcolor{preprocessor}{\#if JSON\_HAS\_THREE\_WAY\_COMPARISON}}
\DoxyCodeLine{2884     \textcolor{keyword}{inline} std::partial\_ordering operator<=>(\textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} lhs, \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} rhs) \textcolor{keyword}{noexcept} \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{2885 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2886     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_aac7ca91589afb0bad68baec5949daaa2}{operator<}}(\textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} lhs, \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{2887 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2888 \{}
\DoxyCodeLine{2889     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::array<std::uint8\_t, 9> order = \{\{}
\DoxyCodeLine{2890             0 \textcolor{comment}{/* null */}, 3 \textcolor{comment}{/* object */}, 4 \textcolor{comment}{/* array */}, 5 \textcolor{comment}{/* string */},}
\DoxyCodeLine{2891             1 \textcolor{comment}{/* boolean */}, 2 \textcolor{comment}{/* integer */}, 2 \textcolor{comment}{/* unsigned */}, 2 \textcolor{comment}{/* float */},}
\DoxyCodeLine{2892             6 \textcolor{comment}{/* binary */}}
\DoxyCodeLine{2893         \}}
\DoxyCodeLine{2894     \};}
\DoxyCodeLine{2895 }
\DoxyCodeLine{2896     \textcolor{keyword}{const} \textcolor{keyword}{auto} l\_index = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(lhs);}
\DoxyCodeLine{2897     \textcolor{keyword}{const} \textcolor{keyword}{auto} r\_index = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(rhs);}
\DoxyCodeLine{2898 \textcolor{preprocessor}{\#if JSON\_HAS\_THREE\_WAY\_COMPARISON}}
\DoxyCodeLine{2899     \textcolor{keywordflow}{if} (l\_index < order.size() \&\& r\_index < order.size())}
\DoxyCodeLine{2900     \{}
\DoxyCodeLine{2901         \textcolor{keywordflow}{return} order[l\_index] <=> order[r\_index]; \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{2902     \}}
\DoxyCodeLine{2903     \textcolor{keywordflow}{return} std::partial\_ordering::unordered;}
\DoxyCodeLine{2904 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2905     \textcolor{keywordflow}{return} l\_index < order.size() \&\& r\_index < order.size() \&\& order[l\_index] < order[r\_index];}
\DoxyCodeLine{2906 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2907 \}}
\DoxyCodeLine{2908 }
\DoxyCodeLine{2909 \textcolor{comment}{// GCC selects the built-\/in operator< over an operator rewritten from}}
\DoxyCodeLine{2910 \textcolor{comment}{// a user-\/defined spaceship operator}}
\DoxyCodeLine{2911 \textcolor{comment}{// Clang, MSVC, and ICC select the rewritten candidate}}
\DoxyCodeLine{2912 \textcolor{comment}{// (see GCC bug https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=105200)}}
\DoxyCodeLine{2913 \textcolor{preprocessor}{\#if JSON\_HAS\_THREE\_WAY\_COMPARISON \&\& defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{2914 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_aac7ca91589afb0bad68baec5949daaa2}{operator<}}(\textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} lhs, \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{2915 \{}
\DoxyCodeLine{2916     \textcolor{keywordflow}{return} std::is\_lt(lhs <=> rhs); \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{2917 \}}
\DoxyCodeLine{2918 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2919 }
\DoxyCodeLine{2920 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{2921 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{2922 }
\DoxyCodeLine{2923 \textcolor{comment}{// \#include <nlohmann/detail/string\_escape.hpp>}}
\DoxyCodeLine{2924 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{2925 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{2926 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{2927 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{2928 \textcolor{comment}{//}}
\DoxyCodeLine{2929 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{2930 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{2931 }
\DoxyCodeLine{2932 }
\DoxyCodeLine{2933 }
\DoxyCodeLine{2934 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{2935 }
\DoxyCodeLine{2936 }
\DoxyCodeLine{2937 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{2938 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{2939 \{}
\DoxyCodeLine{2940 }
\DoxyCodeLine{2954 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{2955 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacedetail_a6fd295e53b1dd4f46e235e6afee26d5e}{replace\_substring}}(StringType\& s, \textcolor{keyword}{const} StringType\& f,}
\DoxyCodeLine{2956                               \textcolor{keyword}{const} StringType\& t)}
\DoxyCodeLine{2957 \{}
\DoxyCodeLine{2958     JSON\_ASSERT(!f.empty());}
\DoxyCodeLine{2959     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} pos = s.find(f);                \textcolor{comment}{// find first occurrence of f}}
\DoxyCodeLine{2960             pos != StringType::npos;          \textcolor{comment}{// make sure f was found}}
\DoxyCodeLine{2961             s.replace(pos, f.size(), t),      \textcolor{comment}{// replace with t, and}}
\DoxyCodeLine{2962             pos = s.find(f, pos + t.size()))  \textcolor{comment}{// find next occurrence of f}}
\DoxyCodeLine{2963     \{\}}
\DoxyCodeLine{2964 \}}
\DoxyCodeLine{2965 }
\DoxyCodeLine{2973 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{2974 \textcolor{keyword}{inline} StringType \mbox{\hyperlink{namespacedetail_af2a9ce4740e0b45d33129e2c8e53a0a8}{escape}}(StringType s)}
\DoxyCodeLine{2975 \{}
\DoxyCodeLine{2976     \mbox{\hyperlink{namespacedetail_a6fd295e53b1dd4f46e235e6afee26d5e}{replace\_substring}}(s, StringType\{\textcolor{stringliteral}{"{}\string~"{}}\}, StringType\{\textcolor{stringliteral}{"{}\string~0"{}}\});}
\DoxyCodeLine{2977     \mbox{\hyperlink{namespacedetail_a6fd295e53b1dd4f46e235e6afee26d5e}{replace\_substring}}(s, StringType\{\textcolor{stringliteral}{"{}/"{}}\}, StringType\{\textcolor{stringliteral}{"{}\string~1"{}}\});}
\DoxyCodeLine{2978     \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{2979 \}}
\DoxyCodeLine{2980 }
\DoxyCodeLine{2988 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{2989 \textcolor{keyword}{static} \textcolor{keywordtype}{void} unescape(StringType\& s)}
\DoxyCodeLine{2990 \{}
\DoxyCodeLine{2991     \mbox{\hyperlink{namespacedetail_a6fd295e53b1dd4f46e235e6afee26d5e}{replace\_substring}}(s, StringType\{\textcolor{stringliteral}{"{}\string~1"{}}\}, StringType\{\textcolor{stringliteral}{"{}/"{}}\});}
\DoxyCodeLine{2992     \mbox{\hyperlink{namespacedetail_a6fd295e53b1dd4f46e235e6afee26d5e}{replace\_substring}}(s, StringType\{\textcolor{stringliteral}{"{}\string~0"{}}\}, StringType\{\textcolor{stringliteral}{"{}\string~"{}}\});}
\DoxyCodeLine{2993 \}}
\DoxyCodeLine{2994 }
\DoxyCodeLine{2995 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{2996 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{2997 }
\DoxyCodeLine{2998 \textcolor{comment}{// \#include <nlohmann/detail/input/position\_t.hpp>}}
\DoxyCodeLine{2999 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{3000 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3001 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{3002 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{3003 \textcolor{comment}{//}}
\DoxyCodeLine{3004 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{3005 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{3006 }
\DoxyCodeLine{3007 }
\DoxyCodeLine{3008 }
\DoxyCodeLine{3009 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{3010 }
\DoxyCodeLine{3011 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{3012 }
\DoxyCodeLine{3013 }
\DoxyCodeLine{3014 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{3015 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{3016 \{}
\DoxyCodeLine{3017 }
\DoxyCodeLine{3019 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1position__t}{position\_t}}}
\DoxyCodeLine{3020 \{}
\DoxyCodeLine{3022     std::size\_t \mbox{\hyperlink{structdetail_1_1position__t_ac4d220d61ce61eeffbea40985727a3b0}{chars\_read\_total}} = 0;}
\DoxyCodeLine{3024     std::size\_t \mbox{\hyperlink{structdetail_1_1position__t_a6548d584bd03d1d47bfcd7cf8b1fb0c6}{chars\_read\_current\_line}} = 0;}
\DoxyCodeLine{3026     std::size\_t \mbox{\hyperlink{structdetail_1_1position__t_a9ec1ac6600d1364f4d1c9f67de6a670b}{lines\_read}} = 0;}
\DoxyCodeLine{3027 }
\DoxyCodeLine{3029     \textcolor{keyword}{constexpr} \textcolor{keyword}{operator} size\_t()\textcolor{keyword}{ const}}
\DoxyCodeLine{3030 \textcolor{keyword}{    }\{}
\DoxyCodeLine{3031         \textcolor{keywordflow}{return} \mbox{\hyperlink{structdetail_1_1position__t_ac4d220d61ce61eeffbea40985727a3b0}{chars\_read\_total}};}
\DoxyCodeLine{3032     \}}
\DoxyCodeLine{3033 \};}
\DoxyCodeLine{3034 }
\DoxyCodeLine{3035 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{3036 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{3037 }
\DoxyCodeLine{3038 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{3039 }
\DoxyCodeLine{3040 \textcolor{comment}{// \#include <nlohmann/detail/meta/cpp\_future.hpp>}}
\DoxyCodeLine{3041 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{3042 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3043 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{3044 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{3045 \textcolor{comment}{//}}
\DoxyCodeLine{3046 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{3047 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2018 The Abseil Authors}}
\DoxyCodeLine{3048 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{3049 }
\DoxyCodeLine{3050 }
\DoxyCodeLine{3051 }
\DoxyCodeLine{3052 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{3053 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{3054 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// conditional, enable\_if, false\_type, integral\_constant, is\_constructible, is\_integral, is\_same, remove\_cv, remove\_reference, true\_type}}
\DoxyCodeLine{3055 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// index\_sequence, make\_index\_sequence, index\_sequence\_for}}
\DoxyCodeLine{3056 }
\DoxyCodeLine{3057 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{3058 }
\DoxyCodeLine{3059 }
\DoxyCodeLine{3060 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{3061 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{3062 \{}
\DoxyCodeLine{3063 }
\DoxyCodeLine{3064 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3065 \textcolor{keyword}{using }uncvref\_t = \textcolor{keyword}{typename} std::remove\_cv<typename std::remove\_reference<T>::type>::type;}
\DoxyCodeLine{3066 }
\DoxyCodeLine{3067 \textcolor{preprocessor}{\#ifdef JSON\_HAS\_CPP\_14}}
\DoxyCodeLine{3068 }
\DoxyCodeLine{3069 \textcolor{comment}{// the following utilities are natively available in C++14}}
\DoxyCodeLine{3070 \textcolor{keyword}{using }std::enable\_if\_t;}
\DoxyCodeLine{3071 \textcolor{keyword}{using }std::index\_sequence;}
\DoxyCodeLine{3072 \textcolor{keyword}{using }std::make\_index\_sequence;}
\DoxyCodeLine{3073 \textcolor{keyword}{using }std::index\_sequence\_for;}
\DoxyCodeLine{3074 }
\DoxyCodeLine{3075 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3076 }
\DoxyCodeLine{3077 \textcolor{comment}{// alias templates to reduce boilerplate}}
\DoxyCodeLine{3078 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} B, \textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3079 \textcolor{keyword}{using }enable\_if\_t = \textcolor{keyword}{typename} std::enable\_if<B, T>::type;}
\DoxyCodeLine{3080 }
\DoxyCodeLine{3081 \textcolor{comment}{// The following code is taken from https://github.com/abseil/abseil-\/cpp/blob/10cb35e459f5ecca5b2ff107635da0bfa41011b4/absl/utility/utility.h}}
\DoxyCodeLine{3082 \textcolor{comment}{// which is part of Google Abseil (https://github.com/abseil/abseil-\/cpp), licensed under the Apache License 2.0.}}
\DoxyCodeLine{3083 }
\DoxyCodeLine{3085 }
\DoxyCodeLine{3086 \textcolor{comment}{// integer\_sequence}}
\DoxyCodeLine{3087 \textcolor{comment}{//}}
\DoxyCodeLine{3088 \textcolor{comment}{// Class template representing a compile-\/time integer sequence. An instantiation}}
\DoxyCodeLine{3089 \textcolor{comment}{// of `integer\_sequence<T, Ints...>` has a sequence of integers encoded in its}}
\DoxyCodeLine{3090 \textcolor{comment}{// type through its template arguments (which is a common need when}}
\DoxyCodeLine{3091 \textcolor{comment}{// working with C++11 variadic templates). `absl::integer\_sequence` is designed}}
\DoxyCodeLine{3092 \textcolor{comment}{// to be a drop-\/in replacement for C++14's `std::integer\_sequence`.}}
\DoxyCodeLine{3093 \textcolor{comment}{//}}
\DoxyCodeLine{3094 \textcolor{comment}{// Example:}}
\DoxyCodeLine{3095 \textcolor{comment}{//}}
\DoxyCodeLine{3096 \textcolor{comment}{//   template< class T, T... Ints >}}
\DoxyCodeLine{3097 \textcolor{comment}{//   void user\_function(integer\_sequence<T, Ints...>);}}
\DoxyCodeLine{3098 \textcolor{comment}{//}}
\DoxyCodeLine{3099 \textcolor{comment}{//   int main()}}
\DoxyCodeLine{3100 \textcolor{comment}{//   \{}}
\DoxyCodeLine{3101 \textcolor{comment}{//     // user\_function's `T` will be deduced to `int` and `Ints...`}}
\DoxyCodeLine{3102 \textcolor{comment}{//     // will be deduced to `0, 1, 2, 3, 4`.}}
\DoxyCodeLine{3103 \textcolor{comment}{//     user\_function(make\_integer\_sequence<int, 5>());}}
\DoxyCodeLine{3104 \textcolor{comment}{//   \}}}
\DoxyCodeLine{3105 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, T... Ints>}
\DoxyCodeLine{3106 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1integer__sequence}{integer\_sequence}}}
\DoxyCodeLine{3107 \{}
\DoxyCodeLine{3108     \textcolor{keyword}{using }value\_type = T;}
\DoxyCodeLine{3109     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::size\_t size() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{3110     \{}
\DoxyCodeLine{3111         \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}...(Ints);}
\DoxyCodeLine{3112     \}}
\DoxyCodeLine{3113 \};}
\DoxyCodeLine{3114 }
\DoxyCodeLine{3115 \textcolor{comment}{// index\_sequence}}
\DoxyCodeLine{3116 \textcolor{comment}{//}}
\DoxyCodeLine{3117 \textcolor{comment}{// A helper template for an `integer\_sequence` of `size\_t`,}}
\DoxyCodeLine{3118 \textcolor{comment}{// `absl::index\_sequence` is designed to be a drop-\/in replacement for C++14's}}
\DoxyCodeLine{3119 \textcolor{comment}{// `std::index\_sequence`.}}
\DoxyCodeLine{3120 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t}... Ints>}
\DoxyCodeLine{3121 \textcolor{keyword}{using }\mbox{\hyperlink{structdetail_1_1integer__sequence}{index\_sequence}} = \mbox{\hyperlink{structdetail_1_1integer__sequence}{integer\_sequence}}<size\_t, Ints...>;}
\DoxyCodeLine{3122 }
\DoxyCodeLine{3123 \textcolor{keyword}{namespace }utility\_internal}
\DoxyCodeLine{3124 \{}
\DoxyCodeLine{3125 }
\DoxyCodeLine{3126 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Seq, \textcolor{keywordtype}{size\_t} SeqSize, \textcolor{keywordtype}{size\_t} Rem>}
\DoxyCodeLine{3127 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1utility__internal_1_1Extend}{Extend}};}
\DoxyCodeLine{3128 }
\DoxyCodeLine{3129 \textcolor{comment}{// Note that SeqSize == sizeof...(Ints). It's passed explicitly for efficiency.}}
\DoxyCodeLine{3130 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, T... Ints, \textcolor{keywordtype}{size\_t} SeqSize>}
\DoxyCodeLine{3131 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1utility__internal_1_1Extend}{Extend}}<\mbox{\hyperlink{structdetail_1_1integer__sequence}{integer\_sequence}}<T, Ints...>, SeqSize, 0>}
\DoxyCodeLine{3132 \{}
\DoxyCodeLine{3133     \textcolor{keyword}{using }\mbox{\hyperlink{structdetail_1_1integer__sequence}{type}} = \mbox{\hyperlink{structdetail_1_1integer__sequence}{integer\_sequence}} < T, Ints..., (Ints + SeqSize)... >;}
\DoxyCodeLine{3134 \};}
\DoxyCodeLine{3135 }
\DoxyCodeLine{3136 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, T... Ints, \textcolor{keywordtype}{size\_t} SeqSize>}
\DoxyCodeLine{3137 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1utility__internal_1_1Extend}{Extend}}<\mbox{\hyperlink{structdetail_1_1integer__sequence}{integer\_sequence}}<T, Ints...>, SeqSize, 1>}
\DoxyCodeLine{3138 \{}
\DoxyCodeLine{3139     \textcolor{keyword}{using }\mbox{\hyperlink{structdetail_1_1integer__sequence}{type}} = \mbox{\hyperlink{structdetail_1_1integer__sequence}{integer\_sequence}} < T, Ints..., (Ints + SeqSize)..., 2 * SeqSize >;}
\DoxyCodeLine{3140 \};}
\DoxyCodeLine{3141 }
\DoxyCodeLine{3142 \textcolor{comment}{// Recursion helper for 'make\_integer\_sequence<T, N>'.}}
\DoxyCodeLine{3143 \textcolor{comment}{// 'Gen<T, N>::type' is an alias for 'integer\_sequence<T, 0, 1, ... N-\/1>'.}}
\DoxyCodeLine{3144 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{3145 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1utility__internal_1_1Gen}{Gen}}}
\DoxyCodeLine{3146 \{}
\DoxyCodeLine{3147     \textcolor{keyword}{using }type =}
\DoxyCodeLine{3148         \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1utility__internal_1_1Extend}{Extend}} < \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1utility__internal_1_1Gen}{Gen}} < T, N / 2 >::type, N / 2, N \% 2 >::type;}
\DoxyCodeLine{3149 \};}
\DoxyCodeLine{3150 }
\DoxyCodeLine{3151 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3152 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1utility__internal_1_1Gen}{Gen}}<T, 0>}
\DoxyCodeLine{3153 \{}
\DoxyCodeLine{3154     \textcolor{keyword}{using }\mbox{\hyperlink{structdetail_1_1integer__sequence}{type}} = \mbox{\hyperlink{structdetail_1_1integer__sequence}{integer\_sequence<T>}};}
\DoxyCodeLine{3155 \};}
\DoxyCodeLine{3156 }
\DoxyCodeLine{3157 \}  \textcolor{comment}{// namespace utility\_internal}}
\DoxyCodeLine{3158 }
\DoxyCodeLine{3159 \textcolor{comment}{// Compile-\/time sequences of integers}}
\DoxyCodeLine{3160 }
\DoxyCodeLine{3161 \textcolor{comment}{// make\_integer\_sequence}}
\DoxyCodeLine{3162 \textcolor{comment}{//}}
\DoxyCodeLine{3163 \textcolor{comment}{// This template alias is equivalent to}}
\DoxyCodeLine{3164 \textcolor{comment}{// `integer\_sequence<int, 0, 1, ..., N-\/1>`, and is designed to be a drop-\/in}}
\DoxyCodeLine{3165 \textcolor{comment}{// replacement for C++14's `std::make\_integer\_sequence`.}}
\DoxyCodeLine{3166 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, T N>}
\DoxyCodeLine{3167 \textcolor{keyword}{using }make\_integer\_sequence = \textcolor{keyword}{typename} utility\_internal::Gen<T, N>::type;}
\DoxyCodeLine{3168 }
\DoxyCodeLine{3169 \textcolor{comment}{// make\_index\_sequence}}
\DoxyCodeLine{3170 \textcolor{comment}{//}}
\DoxyCodeLine{3171 \textcolor{comment}{// This template alias is equivalent to `index\_sequence<0, 1, ..., N-\/1>`,}}
\DoxyCodeLine{3172 \textcolor{comment}{// and is designed to be a drop-\/in replacement for C++14's}}
\DoxyCodeLine{3173 \textcolor{comment}{// `std::make\_index\_sequence`.}}
\DoxyCodeLine{3174 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{3175 \textcolor{keyword}{using }make\_index\_sequence = make\_integer\_sequence<size\_t, N>;}
\DoxyCodeLine{3176 }
\DoxyCodeLine{3177 \textcolor{comment}{// index\_sequence\_for}}
\DoxyCodeLine{3178 \textcolor{comment}{//}}
\DoxyCodeLine{3179 \textcolor{comment}{// Converts a typename pack into an index sequence of the same length, and}}
\DoxyCodeLine{3180 \textcolor{comment}{// is designed to be a drop-\/in replacement for C++14's}}
\DoxyCodeLine{3181 \textcolor{comment}{// `std::index\_sequence\_for()`}}
\DoxyCodeLine{3182 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{3183 \textcolor{keyword}{using }index\_sequence\_for = make\_index\_sequence<\textcolor{keyword}{sizeof}...(Ts)>;}
\DoxyCodeLine{3184 }
\DoxyCodeLine{3186 }
\DoxyCodeLine{3187 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3188 }
\DoxyCodeLine{3189 \textcolor{comment}{// dispatch utility (taken from ranges-\/v3)}}
\DoxyCodeLine{3190 \textcolor{keyword}{template}<\textcolor{keywordtype}{unsigned} N> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag}} : \mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag}} < N -\/ 1 > \{\};}
\DoxyCodeLine{3191 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1priority__tag}{priority\_tag}}<0> \{\};}
\DoxyCodeLine{3192 }
\DoxyCodeLine{3193 \textcolor{comment}{// taken from ranges-\/v3}}
\DoxyCodeLine{3194 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3195 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1static__const}{static\_const}}}
\DoxyCodeLine{3196 \{}
\DoxyCodeLine{3197     \textcolor{keyword}{static} JSON\_INLINE\_VARIABLE \textcolor{keyword}{constexpr} T value\{\};}
\DoxyCodeLine{3198 \};}
\DoxyCodeLine{3199 }
\DoxyCodeLine{3200 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{3201     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3202     \textcolor{keyword}{constexpr} T \mbox{\hyperlink{structdetail_1_1static__const}{static\_const<T>::value}};}
\DoxyCodeLine{3203 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3204 }
\DoxyCodeLine{3205 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3206 \textcolor{keyword}{inline} \textcolor{keyword}{constexpr} std::array<T, \textcolor{keyword}{sizeof}...(Args)> make\_array(Args\&\& ... args)}
\DoxyCodeLine{3207 \{}
\DoxyCodeLine{3208     \textcolor{keywordflow}{return} std::array<T, \textcolor{keyword}{sizeof}...(Args)> \{\{\textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(std::forward<Args>(args))...\}\};}
\DoxyCodeLine{3209 \}}
\DoxyCodeLine{3210 }
\DoxyCodeLine{3211 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{3212 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{3213 }
\DoxyCodeLine{3214 \textcolor{comment}{// \#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{3215 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{3216 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3217 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{3218 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{3219 \textcolor{comment}{//}}
\DoxyCodeLine{3220 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{3221 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{3222 }
\DoxyCodeLine{3223 }
\DoxyCodeLine{3224 }
\DoxyCodeLine{3225 \textcolor{preprocessor}{\#include <limits>} \textcolor{comment}{// numeric\_limits}}
\DoxyCodeLine{3226 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// false\_type, is\_constructible, is\_integral, is\_same, true\_type}}
\DoxyCodeLine{3227 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// declval}}
\DoxyCodeLine{3228 \textcolor{preprocessor}{\#include <tuple>} \textcolor{comment}{// tuple}}
\DoxyCodeLine{3229 }
\DoxyCodeLine{3230 \textcolor{comment}{// \#include <nlohmann/detail/iterators/iterator\_traits.hpp>}}
\DoxyCodeLine{3231 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{3232 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3233 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{3234 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{3235 \textcolor{comment}{//}}
\DoxyCodeLine{3236 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{3237 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{3238 }
\DoxyCodeLine{3239 }
\DoxyCodeLine{3240 }
\DoxyCodeLine{3241 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// random\_access\_iterator\_tag}}
\DoxyCodeLine{3242 }
\DoxyCodeLine{3243 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{3244 }
\DoxyCodeLine{3245 \textcolor{comment}{// \#include <nlohmann/detail/meta/void\_t.hpp>}}
\DoxyCodeLine{3246 }
\DoxyCodeLine{3247 \textcolor{comment}{// \#include <nlohmann/detail/meta/cpp\_future.hpp>}}
\DoxyCodeLine{3248 }
\DoxyCodeLine{3249 }
\DoxyCodeLine{3250 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{3251 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{3252 \{}
\DoxyCodeLine{3253 }
\DoxyCodeLine{3254 \textcolor{keyword}{template}<\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3255 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1iterator__types}{iterator\_types}} \{\};}
\DoxyCodeLine{3256 }
\DoxyCodeLine{3257 \textcolor{keyword}{template}<\textcolor{keyword}{typename} It>}
\DoxyCodeLine{3258 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1iterator__types}{iterator\_types}} <}
\DoxyCodeLine{3259     It,}
\DoxyCodeLine{3260     void\_t<typename It::difference\_type, typename It::value\_type, typename It::pointer,}
\DoxyCodeLine{3261     typename It::reference, typename It::iterator\_category >>}
\DoxyCodeLine{3262 \{}
\DoxyCodeLine{3263     \textcolor{keyword}{using }difference\_type = \textcolor{keyword}{typename} It::difference\_type;}
\DoxyCodeLine{3264     \textcolor{keyword}{using }value\_type = \textcolor{keyword}{typename} It::value\_type;}
\DoxyCodeLine{3265     \textcolor{keyword}{using }pointer = \textcolor{keyword}{typename} It::pointer;}
\DoxyCodeLine{3266     \textcolor{keyword}{using }reference = \textcolor{keyword}{typename} It::reference;}
\DoxyCodeLine{3267     \textcolor{keyword}{using }iterator\_category = \textcolor{keyword}{typename} It::iterator\_category;}
\DoxyCodeLine{3268 \};}
\DoxyCodeLine{3269 }
\DoxyCodeLine{3270 \textcolor{comment}{// This is required as some compilers implement std::iterator\_traits in a way that}}
\DoxyCodeLine{3271 \textcolor{comment}{// doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.}}
\DoxyCodeLine{3272 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3273 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1iterator__traits}{iterator\_traits}}}
\DoxyCodeLine{3274 \{}
\DoxyCodeLine{3275 \};}
\DoxyCodeLine{3276 }
\DoxyCodeLine{3277 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3278 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1iterator__traits}{iterator\_traits}} < T, enable\_if\_t < !std::is\_pointer<T>::value >>}
\DoxyCodeLine{3279             : \mbox{\hyperlink{structdetail_1_1iterator__types}{iterator\_types}}<T>}
\DoxyCodeLine{3280 \{}
\DoxyCodeLine{3281 \};}
\DoxyCodeLine{3282 }
\DoxyCodeLine{3283 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3284 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1iterator__traits}{iterator\_traits}}<T*, enable\_if\_t<std::is\_object<T>::value>>}
\DoxyCodeLine{3285 \{}
\DoxyCodeLine{3286     \textcolor{keyword}{using }iterator\_category = std::random\_access\_iterator\_tag;}
\DoxyCodeLine{3287     \textcolor{keyword}{using }value\_type = T;}
\DoxyCodeLine{3288     \textcolor{keyword}{using }difference\_type = ptrdiff\_t;}
\DoxyCodeLine{3289     \textcolor{keyword}{using }pointer = T*;}
\DoxyCodeLine{3290     \textcolor{keyword}{using }reference = T\&;}
\DoxyCodeLine{3291 \};}
\DoxyCodeLine{3292 }
\DoxyCodeLine{3293 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{3294 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{3295 }
\DoxyCodeLine{3296 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{3297 }
\DoxyCodeLine{3298 \textcolor{comment}{// \#include <nlohmann/detail/meta/call\_std/begin.hpp>}}
\DoxyCodeLine{3299 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{3300 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3301 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{3302 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{3303 \textcolor{comment}{//}}
\DoxyCodeLine{3304 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{3305 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{3306 }
\DoxyCodeLine{3307 }
\DoxyCodeLine{3308 }
\DoxyCodeLine{3309 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{3310 }
\DoxyCodeLine{3311 }
\DoxyCodeLine{3312 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{3313 }
\DoxyCodeLine{3314 NLOHMANN\_CAN\_CALL\_STD\_FUNC\_IMPL(begin);}
\DoxyCodeLine{3315 }
\DoxyCodeLine{3316 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{3317 }
\DoxyCodeLine{3318 \textcolor{comment}{// \#include <nlohmann/detail/meta/call\_std/end.hpp>}}
\DoxyCodeLine{3319 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{3320 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3321 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{3322 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{3323 \textcolor{comment}{//}}
\DoxyCodeLine{3324 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{3325 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{3326 }
\DoxyCodeLine{3327 }
\DoxyCodeLine{3328 }
\DoxyCodeLine{3329 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{3330 }
\DoxyCodeLine{3331 }
\DoxyCodeLine{3332 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{3333 }
\DoxyCodeLine{3334 NLOHMANN\_CAN\_CALL\_STD\_FUNC\_IMPL(end);}
\DoxyCodeLine{3335 }
\DoxyCodeLine{3336 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{3337 }
\DoxyCodeLine{3338 \textcolor{comment}{// \#include <nlohmann/detail/meta/cpp\_future.hpp>}}
\DoxyCodeLine{3339 }
\DoxyCodeLine{3340 \textcolor{comment}{// \#include <nlohmann/detail/meta/detected.hpp>}}
\DoxyCodeLine{3341 }
\DoxyCodeLine{3342 \textcolor{comment}{// \#include <nlohmann/json\_fwd.hpp>}}
\DoxyCodeLine{3343 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{3344 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{3345 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{3346 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{3347 \textcolor{comment}{//}}
\DoxyCodeLine{3348 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{3349 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{3350 }
\DoxyCodeLine{3351 \textcolor{preprocessor}{\#ifndef INCLUDE\_NLOHMANN\_JSON\_FWD\_HPP\_}}
\DoxyCodeLine{3352 \textcolor{preprocessor}{    \#define INCLUDE\_NLOHMANN\_JSON\_FWD\_HPP\_}}
\DoxyCodeLine{3353 }
\DoxyCodeLine{3354 \textcolor{preprocessor}{    \#include <cstdint>} \textcolor{comment}{// int64\_t, uint64\_t}}
\DoxyCodeLine{3355 \textcolor{preprocessor}{    \#include <map>} \textcolor{comment}{// map}}
\DoxyCodeLine{3356 \textcolor{preprocessor}{    \#include <memory>} \textcolor{comment}{// allocator}}
\DoxyCodeLine{3357 \textcolor{preprocessor}{    \#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{3358 \textcolor{preprocessor}{    \#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{3359 }
\DoxyCodeLine{3360     \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{3361 }
\DoxyCodeLine{3362 }
\DoxyCodeLine{3368     NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{3369 }
\DoxyCodeLine{3377     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}, \textcolor{keyword}{typename} SFINAE = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3378     \textcolor{keyword}{struct }\mbox{\hyperlink{structadl__serializer}{adl\_serializer}};}
\DoxyCodeLine{3379 }
\DoxyCodeLine{3382     \textcolor{keyword}{template}<\textcolor{keyword}{template}<\textcolor{keyword}{typename} U, \textcolor{keyword}{typename} V, \textcolor{keyword}{typename}... Args> \textcolor{keyword}{class }ObjectType =}
\DoxyCodeLine{3383     std::map,}
\DoxyCodeLine{3384     \textcolor{keyword}{template}<\textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Args> \textcolor{keyword}{class }ArrayType = std::vector,}
\DoxyCodeLine{3385     \textcolor{keyword}{class }StringType = std::string, \textcolor{keyword}{class }BooleanType = bool,}
\DoxyCodeLine{3386     \textcolor{keyword}{class }NumberIntegerType = std::int64\_t,}
\DoxyCodeLine{3387     \textcolor{keyword}{class }NumberUnsignedType = std::uint64\_t,}
\DoxyCodeLine{3388     \textcolor{keyword}{class }NumberFloatType = double,}
\DoxyCodeLine{3389     \textcolor{keyword}{template}<\textcolor{keyword}{typename} U> \textcolor{keyword}{class }AllocatorType = std::allocator,}
\DoxyCodeLine{3390     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} SFINAE = \textcolor{keywordtype}{void}> \textcolor{keyword}{class }JSONSerializer =}
\DoxyCodeLine{3391     \mbox{\hyperlink{structadl__serializer}{adl\_serializer}},}
\DoxyCodeLine{3392     \textcolor{keyword}{class }BinaryType = std::vector<std::uint8\_t>>}
\DoxyCodeLine{3393     \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__json}{basic\_json}};}
\DoxyCodeLine{3394 }
\DoxyCodeLine{3397     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringType>}
\DoxyCodeLine{3398     \textcolor{keyword}{class }\mbox{\hyperlink{classjson__pointer}{json\_pointer}};}
\DoxyCodeLine{3399 }
\DoxyCodeLine{3404     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json}{json}} = \mbox{\hyperlink{classbasic__json}{basic\_json<>}};}
\DoxyCodeLine{3405 }
\DoxyCodeLine{3408     \textcolor{keyword}{template}<\textcolor{keyword}{class} Key, \textcolor{keyword}{class} T, \textcolor{keyword}{class} IgnoredLess, \textcolor{keyword}{class} Allocator>}
\DoxyCodeLine{3409     \textcolor{keyword}{struct }\mbox{\hyperlink{structordered__map}{ordered\_map}};}
\DoxyCodeLine{3410 }
\DoxyCodeLine{3413     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json}{ordered\_json}} = \mbox{\hyperlink{classbasic__json}{basic\_json<nlohmann::ordered\_map>}};}
\DoxyCodeLine{3414 }
\DoxyCodeLine{3415     NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{3416 }
\DoxyCodeLine{3417 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// INCLUDE\_NLOHMANN\_JSON\_FWD\_HPP\_}}
\DoxyCodeLine{3418 }
\DoxyCodeLine{3419 }
\DoxyCodeLine{3420 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{3429 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{3430 \{}
\DoxyCodeLine{3431 }
\DoxyCodeLine{3433 \textcolor{comment}{// helpers //}}
\DoxyCodeLine{3435 \textcolor{comment}{}}
\DoxyCodeLine{3436 \textcolor{comment}{// Note to maintainers:}}
\DoxyCodeLine{3437 \textcolor{comment}{//}}
\DoxyCodeLine{3438 \textcolor{comment}{// Every trait in this file expects a non CV-\/qualified type.}}
\DoxyCodeLine{3439 \textcolor{comment}{// The only exceptions are in the 'aliases for detected' section}}
\DoxyCodeLine{3440 \textcolor{comment}{// (i.e. those of the form: decltype(T::member\_function(std::declval<T>())))}}
\DoxyCodeLine{3441 \textcolor{comment}{//}}
\DoxyCodeLine{3442 \textcolor{comment}{// In this case, T has to be properly CV-\/qualified to constraint the function arguments}}
\DoxyCodeLine{3443 \textcolor{comment}{// (e.g. to\_json(BasicJsonType\&, const T\&))}}
\DoxyCodeLine{3444 }
\DoxyCodeLine{3445 \textcolor{keyword}{template}<\textcolor{keyword}{typename}> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__basic__json}{is\_basic\_json}} : std::false\_type \{\};}
\DoxyCodeLine{3446 }
\DoxyCodeLine{3447 NLOHMANN\_BASIC\_JSON\_TPL\_DECLARATION}
\DoxyCodeLine{3448 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__basic__json}{is\_basic\_json}}<NLOHMANN\_BASIC\_JSON\_TPL> : std::true\_type \{\};}
\DoxyCodeLine{3449 }
\DoxyCodeLine{3450 \textcolor{comment}{// used by exceptions create() member functions}}
\DoxyCodeLine{3451 \textcolor{comment}{// true\_type for pointer to possibly cv-\/qualified basic\_json or std::nullptr\_t}}
\DoxyCodeLine{3452 \textcolor{comment}{// false\_type otherwise}}
\DoxyCodeLine{3453 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonContext>}
\DoxyCodeLine{3454 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__basic__json__context}{is\_basic\_json\_context}} :}
\DoxyCodeLine{3455     std::integral\_constant < bool,}
\DoxyCodeLine{3456     is\_basic\_json<typename std::remove\_cv<typename std::remove\_pointer<BasicJsonContext>::type>::type>::value}
\DoxyCodeLine{3457     || std::is\_same<BasicJsonContext, std::nullptr\_t>::value >}
\DoxyCodeLine{3458 \{\};}
\DoxyCodeLine{3459 }
\DoxyCodeLine{3461 \textcolor{comment}{// json\_ref helpers //}}
\DoxyCodeLine{3463 \textcolor{comment}{}}
\DoxyCodeLine{3464 \textcolor{keyword}{template}<\textcolor{keyword}{typename}>}
\DoxyCodeLine{3465 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}};}
\DoxyCodeLine{3466 }
\DoxyCodeLine{3467 \textcolor{keyword}{template}<\textcolor{keyword}{typename}>}
\DoxyCodeLine{3468 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__json__ref}{is\_json\_ref}} : std::false\_type \{\};}
\DoxyCodeLine{3469 }
\DoxyCodeLine{3470 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3471 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__json__ref}{is\_json\_ref}}<\mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}<T>> : std::true\_type \{\};}
\DoxyCodeLine{3472 }
\DoxyCodeLine{3474 \textcolor{comment}{// aliases for detected //}}
\DoxyCodeLine{3476 \textcolor{comment}{}}
\DoxyCodeLine{3477 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3478 \textcolor{keyword}{using }mapped\_type\_t = \textcolor{keyword}{typename} T::mapped\_type;}
\DoxyCodeLine{3479 }
\DoxyCodeLine{3480 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3481 \textcolor{keyword}{using }key\_type\_t = \textcolor{keyword}{typename} T::key\_type;}
\DoxyCodeLine{3482 }
\DoxyCodeLine{3483 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3484 \textcolor{keyword}{using }value\_type\_t = \textcolor{keyword}{typename} T::value\_type;}
\DoxyCodeLine{3485 }
\DoxyCodeLine{3486 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3487 \textcolor{keyword}{using }difference\_type\_t = \textcolor{keyword}{typename} T::difference\_type;}
\DoxyCodeLine{3488 }
\DoxyCodeLine{3489 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3490 \textcolor{keyword}{using }pointer\_t = \textcolor{keyword}{typename} T::pointer;}
\DoxyCodeLine{3491 }
\DoxyCodeLine{3492 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3493 \textcolor{keyword}{using }reference\_t = \textcolor{keyword}{typename} T::reference;}
\DoxyCodeLine{3494 }
\DoxyCodeLine{3495 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3496 \textcolor{keyword}{using }iterator\_category\_t = \textcolor{keyword}{typename} T::iterator\_category;}
\DoxyCodeLine{3497 }
\DoxyCodeLine{3498 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3499 \textcolor{keyword}{using }to\_json\_function = \textcolor{keyword}{decltype}(T::to\_json(std::declval<Args>()...));}
\DoxyCodeLine{3500 }
\DoxyCodeLine{3501 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3502 \textcolor{keyword}{using }from\_json\_function = \textcolor{keyword}{decltype}(T::from\_json(std::declval<Args>()...));}
\DoxyCodeLine{3503 }
\DoxyCodeLine{3504 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{3505 \textcolor{keyword}{using }get\_template\_function = \textcolor{keyword}{decltype}(std::declval<T>().template get<U>());}
\DoxyCodeLine{3506 }
\DoxyCodeLine{3507 \textcolor{comment}{// trait checking if JSONSerializer<T>::from\_json(json const\&, udt\&) exists}}
\DoxyCodeLine{3508 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3509 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1has__from__json}{has\_from\_json}} : std::false\_type \{\};}
\DoxyCodeLine{3510 }
\DoxyCodeLine{3511 \textcolor{comment}{// trait checking if j.get<T> is valid}}
\DoxyCodeLine{3512 \textcolor{comment}{// use this trait instead of std::is\_constructible or std::is\_convertible,}}
\DoxyCodeLine{3513 \textcolor{comment}{// both rely on, or make use of implicit conversions, and thus fail when T}}
\DoxyCodeLine{3514 \textcolor{comment}{// has several constructors/operator= (see https://github.com/nlohmann/json/issues/958)}}
\DoxyCodeLine{3515 \textcolor{keyword}{template} <\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{3516 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__getable}{is\_getable}}}
\DoxyCodeLine{3517 \{}
\DoxyCodeLine{3518     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} value = is\_detected<get\_template\_function, const BasicJsonType\&, T>::value;}
\DoxyCodeLine{3519 \};}
\DoxyCodeLine{3520 }
\DoxyCodeLine{3521 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{3522 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1has__from__json}{has\_from\_json}} < BasicJsonType, T, enable\_if\_t < !\mbox{\hyperlink{structdetail_1_1is__basic__json}{is\_basic\_json}}<T>::\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} >>}
\DoxyCodeLine{3523 \{}
\DoxyCodeLine{3524     \textcolor{keyword}{using }serializer = \textcolor{keyword}{typename} BasicJsonType::template json\_serializer<T, void>;}
\DoxyCodeLine{3525 }
\DoxyCodeLine{3526     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{3527         is\_detected\_exact<void, from\_json\_function, serializer,}
\DoxyCodeLine{3528         \textcolor{keyword}{const} BasicJsonType\&, T\&>::value;}
\DoxyCodeLine{3529 \};}
\DoxyCodeLine{3530 }
\DoxyCodeLine{3531 \textcolor{comment}{// This trait checks if JSONSerializer<T>::from\_json(json const\&) exists}}
\DoxyCodeLine{3532 \textcolor{comment}{// this overload is used for non-\/default-\/constructible user-\/defined-\/types}}
\DoxyCodeLine{3533 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3534 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1has__non__default__from__json}{has\_non\_default\_from\_json}} : std::false\_type \{\};}
\DoxyCodeLine{3535 }
\DoxyCodeLine{3536 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{3537 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1has__non__default__from__json}{has\_non\_default\_from\_json}} < BasicJsonType, T, enable\_if\_t < !\mbox{\hyperlink{structdetail_1_1is__basic__json}{is\_basic\_json}}<T>::\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} >>}
\DoxyCodeLine{3538 \{}
\DoxyCodeLine{3539     \textcolor{keyword}{using }serializer = \textcolor{keyword}{typename} BasicJsonType::template json\_serializer<T, void>;}
\DoxyCodeLine{3540 }
\DoxyCodeLine{3541     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{3542         is\_detected\_exact<T, from\_json\_function, serializer,}
\DoxyCodeLine{3543         \textcolor{keyword}{const} BasicJsonType\&>::value;}
\DoxyCodeLine{3544 \};}
\DoxyCodeLine{3545 }
\DoxyCodeLine{3546 \textcolor{comment}{// This trait checks if BasicJsonType::json\_serializer<T>::to\_json exists}}
\DoxyCodeLine{3547 \textcolor{comment}{// Do not evaluate the trait when T is a basic\_json type, to avoid template instantiation infinite recursion.}}
\DoxyCodeLine{3548 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3549 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1has__to__json}{has\_to\_json}} : std::false\_type \{\};}
\DoxyCodeLine{3550 }
\DoxyCodeLine{3551 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{3552 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1has__to__json}{has\_to\_json}} < BasicJsonType, T, enable\_if\_t < !\mbox{\hyperlink{structdetail_1_1is__basic__json}{is\_basic\_json}}<T>::\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} >>}
\DoxyCodeLine{3553 \{}
\DoxyCodeLine{3554     \textcolor{keyword}{using }serializer = \textcolor{keyword}{typename} BasicJsonType::template json\_serializer<T, void>;}
\DoxyCodeLine{3555 }
\DoxyCodeLine{3556     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{3557         is\_detected\_exact<void, to\_json\_function, serializer, BasicJsonType\&,}
\DoxyCodeLine{3558         T>::value;}
\DoxyCodeLine{3559 \};}
\DoxyCodeLine{3560 }
\DoxyCodeLine{3561 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3562 \textcolor{keyword}{using }detect\_key\_compare = \textcolor{keyword}{typename} T::key\_compare;}
\DoxyCodeLine{3563 }
\DoxyCodeLine{3564 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3565 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1has__key__compare}{has\_key\_compare}} : std::integral\_constant<bool, is\_detected<detect\_key\_compare, T>::value> \{\};}
\DoxyCodeLine{3566 }
\DoxyCodeLine{3567 \textcolor{comment}{// obtains the actual object key comparator}}
\DoxyCodeLine{3568 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{3569 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1actual__object__comparator}{actual\_object\_comparator}}}
\DoxyCodeLine{3570 \{}
\DoxyCodeLine{3571     \textcolor{keyword}{using }object\_t = \textcolor{keyword}{typename} BasicJsonType::object\_t;}
\DoxyCodeLine{3572     \textcolor{keyword}{using }object\_comparator\_t = \textcolor{keyword}{typename} BasicJsonType::default\_object\_comparator\_t;}
\DoxyCodeLine{3573     \textcolor{keyword}{using }type = \textcolor{keyword}{typename} std::conditional < has\_key\_compare<object\_t>::value,}
\DoxyCodeLine{3574           \textcolor{keyword}{typename} object\_t::key\_compare, object\_comparator\_t>::type;}
\DoxyCodeLine{3575 \};}
\DoxyCodeLine{3576 }
\DoxyCodeLine{3577 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{3578 \textcolor{keyword}{using }actual\_object\_comparator\_t = \textcolor{keyword}{typename} actual\_object\_comparator<BasicJsonType>::type;}
\DoxyCodeLine{3579 }
\DoxyCodeLine{3581 \textcolor{comment}{// is\_ functions //}}
\DoxyCodeLine{3583 \textcolor{comment}{}}
\DoxyCodeLine{3584 \textcolor{comment}{// https://en.cppreference.com/w/cpp/types/conjunction}}
\DoxyCodeLine{3585 \textcolor{keyword}{template}<\textcolor{keyword}{class}...> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1conjunction}{conjunction}} : std::true\_type \{ \};}
\DoxyCodeLine{3586 \textcolor{keyword}{template}<\textcolor{keyword}{class} B> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1conjunction_3_01B_01_4}{conjunction<B>}} : B \{ \};}
\DoxyCodeLine{3587 \textcolor{keyword}{template}<\textcolor{keyword}{class }B, \textcolor{keyword}{class}... Bn>}
\DoxyCodeLine{3588 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1conjunction}{conjunction}}<B, Bn...>}
\DoxyCodeLine{3589 : std::conditional<static\_cast<bool>(B::value), conjunction<Bn...>, B>::type \{\};}
\DoxyCodeLine{3590 }
\DoxyCodeLine{3591 \textcolor{comment}{// https://en.cppreference.com/w/cpp/types/negation}}
\DoxyCodeLine{3592 \textcolor{keyword}{template}<\textcolor{keyword}{class} B> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1negation}{negation}} : std::integral\_constant < bool, !B::value > \{ \};}
\DoxyCodeLine{3593 }
\DoxyCodeLine{3594 \textcolor{comment}{// Reimplementation of is\_constructible and is\_default\_constructible, due to them being broken for}}
\DoxyCodeLine{3595 \textcolor{comment}{// std::pair and std::tuple until LWG 2367 fix (see https://cplusplus.github.io/LWG/lwg-\/defects.html\#2367).}}
\DoxyCodeLine{3596 \textcolor{comment}{// This causes compile errors in e.g. clang 3.5 or gcc 4.9.}}
\DoxyCodeLine{3597 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3598 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible}} : std::is\_default\_constructible<T> \{\};}
\DoxyCodeLine{3599 }
\DoxyCodeLine{3600 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{3601 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible}}<std::pair<T1, T2>>}
\DoxyCodeLine{3602             : \mbox{\hyperlink{structdetail_1_1conjunction}{conjunction}}<is\_default\_constructible<T1>, is\_default\_constructible<T2>> \{\};}
\DoxyCodeLine{3603 }
\DoxyCodeLine{3604 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{3605 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible}}<const std::pair<T1, T2>>}
\DoxyCodeLine{3606             : \mbox{\hyperlink{structdetail_1_1conjunction}{conjunction}}<is\_default\_constructible<T1>, is\_default\_constructible<T2>> \{\};}
\DoxyCodeLine{3607 }
\DoxyCodeLine{3608 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{3609 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible}}<std::tuple<Ts...>>}
\DoxyCodeLine{3610             : \mbox{\hyperlink{structdetail_1_1conjunction}{conjunction}}<is\_default\_constructible<Ts>...> \{\};}
\DoxyCodeLine{3611 }
\DoxyCodeLine{3612 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{3613 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible}}<const std::tuple<Ts...>>}
\DoxyCodeLine{3614             : \mbox{\hyperlink{structdetail_1_1conjunction}{conjunction}}<is\_default\_constructible<Ts>...> \{\};}
\DoxyCodeLine{3615 }
\DoxyCodeLine{3616 }
\DoxyCodeLine{3617 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3618 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible}} : std::is\_constructible<T, Args...> \{\};}
\DoxyCodeLine{3619 }
\DoxyCodeLine{3620 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{3621 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible}}<std::pair<T1, T2>> : \mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible}}<std::pair<T1, T2>> \{\};}
\DoxyCodeLine{3622 }
\DoxyCodeLine{3623 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{3624 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible}}<const std::pair<T1, T2>> : \mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible}}<const std::pair<T1, T2>> \{\};}
\DoxyCodeLine{3625 }
\DoxyCodeLine{3626 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{3627 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible}}<std::tuple<Ts...>> : \mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible}}<std::tuple<Ts...>> \{\};}
\DoxyCodeLine{3628 }
\DoxyCodeLine{3629 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{3630 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible}}<const std::tuple<Ts...>> : \mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible}}<const std::tuple<Ts...>> \{\};}
\DoxyCodeLine{3631 }
\DoxyCodeLine{3632 }
\DoxyCodeLine{3633 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3634 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__iterator__traits}{is\_iterator\_traits}} : std::false\_type \{\};}
\DoxyCodeLine{3635 }
\DoxyCodeLine{3636 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3637 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__iterator__traits}{is\_iterator\_traits}}<\mbox{\hyperlink{structdetail_1_1iterator__traits}{iterator\_traits}}<T>>}
\DoxyCodeLine{3638 \{}
\DoxyCodeLine{3639   \textcolor{keyword}{private}:}
\DoxyCodeLine{3640     \textcolor{keyword}{using }\mbox{\hyperlink{structdetail_1_1iterator__traits}{traits}} = \mbox{\hyperlink{structdetail_1_1iterator__traits}{iterator\_traits<T>}};}
\DoxyCodeLine{3641 }
\DoxyCodeLine{3642   \textcolor{keyword}{public}:}
\DoxyCodeLine{3643     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{3644         is\_detected<value\_type\_t, traits>::value \&\&}
\DoxyCodeLine{3645         is\_detected<difference\_type\_t, traits>::value \&\&}
\DoxyCodeLine{3646         is\_detected<pointer\_t, traits>::value \&\&}
\DoxyCodeLine{3647         is\_detected<iterator\_category\_t, traits>::value \&\&}
\DoxyCodeLine{3648         is\_detected<reference\_t, traits>::value;}
\DoxyCodeLine{3649 \};}
\DoxyCodeLine{3650 }
\DoxyCodeLine{3651 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3652 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__range}{is\_range}}}
\DoxyCodeLine{3653 \{}
\DoxyCodeLine{3654   \textcolor{keyword}{private}:}
\DoxyCodeLine{3655     \textcolor{keyword}{using }t\_ref = \textcolor{keyword}{typename} std::add\_lvalue\_reference<T>::type;}
\DoxyCodeLine{3656 }
\DoxyCodeLine{3657     \textcolor{keyword}{using }iterator = detected\_t<result\_of\_begin, t\_ref>;}
\DoxyCodeLine{3658     \textcolor{keyword}{using }sentinel = detected\_t<result\_of\_end, t\_ref>;}
\DoxyCodeLine{3659 }
\DoxyCodeLine{3660     \textcolor{comment}{// to be 100\% correct, it should use https://en.cppreference.com/w/cpp/iterator/input\_or\_output\_iterator}}
\DoxyCodeLine{3661     \textcolor{comment}{// and https://en.cppreference.com/w/cpp/iterator/sentinel\_for}}
\DoxyCodeLine{3662     \textcolor{comment}{// but reimplementing these would be too much work, as a lot of other concepts are used underneath}}
\DoxyCodeLine{3663     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} is\_iterator\_begin =}
\DoxyCodeLine{3664         \mbox{\hyperlink{structdetail_1_1is__iterator__traits}{is\_iterator\_traits<iterator\_traits<iterator>}}>::value;}
\DoxyCodeLine{3665 }
\DoxyCodeLine{3666   \textcolor{keyword}{public}:}
\DoxyCodeLine{3667     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} value = !std::is\_same<iterator, nonesuch>::value \&\& !std::is\_same<sentinel, nonesuch>::value \&\& is\_iterator\_begin;}
\DoxyCodeLine{3668 \};}
\DoxyCodeLine{3669 }
\DoxyCodeLine{3670 \textcolor{keyword}{template}<\textcolor{keyword}{typename} R>}
\DoxyCodeLine{3671 \textcolor{keyword}{using }iterator\_t = enable\_if\_t<is\_range<R>::value, result\_of\_begin<decltype(std::declval<R\&>())>>;}
\DoxyCodeLine{3672 }
\DoxyCodeLine{3673 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3674 \textcolor{keyword}{using }range\_value\_t = value\_type\_t<iterator\_traits<iterator\_t<T>>>;}
\DoxyCodeLine{3675 }
\DoxyCodeLine{3676 \textcolor{comment}{// The following implementation of is\_complete\_type is taken from}}
\DoxyCodeLine{3677 \textcolor{comment}{// https://blogs.msdn.microsoft.com/vcblog/2015/12/02/partial-\/support-\/for-\/expression-\/sfinae-\/in-\/vs-\/2015-\/update-\/1/}}
\DoxyCodeLine{3678 \textcolor{comment}{// and is written by Xiang Fan who agreed to using it in this library.}}
\DoxyCodeLine{3679 }
\DoxyCodeLine{3680 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3681 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__complete__type}{is\_complete\_type}} : std::false\_type \{\};}
\DoxyCodeLine{3682 }
\DoxyCodeLine{3683 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3684 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__complete__type}{is\_complete\_type}}<T, decltype(void(sizeof(T)))> : std::true\_type \{\};}
\DoxyCodeLine{3685 }
\DoxyCodeLine{3686 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleObjectType,}
\DoxyCodeLine{3687          \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3688 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__object__type__impl}{is\_compatible\_object\_type\_impl}} : std::false\_type \{\};}
\DoxyCodeLine{3689 }
\DoxyCodeLine{3690 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleObjectType>}
\DoxyCodeLine{3691 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__object__type__impl}{is\_compatible\_object\_type\_impl}} <}
\DoxyCodeLine{3692     BasicJsonType, CompatibleObjectType,}
\DoxyCodeLine{3693     enable\_if\_t < is\_detected<mapped\_type\_t, CompatibleObjectType>::\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}\&\&}
\DoxyCodeLine{3694     is\_detected<key\_type\_t, CompatibleObjectType>::value >>}
\DoxyCodeLine{3695 \{}
\DoxyCodeLine{3696     \textcolor{keyword}{using }object\_t = \textcolor{keyword}{typename} BasicJsonType::object\_t;}
\DoxyCodeLine{3697 }
\DoxyCodeLine{3698     \textcolor{comment}{// macOS's is\_constructible does not play well with nonesuch...}}
\DoxyCodeLine{3699     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{3700         \mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible}}<\textcolor{keyword}{typename} object\_t::key\_type,}
\DoxyCodeLine{3701         \textcolor{keyword}{typename} CompatibleObjectType::key\_type>::value \&\&}
\DoxyCodeLine{3702         \mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible}}<\textcolor{keyword}{typename} object\_t::mapped\_type,}
\DoxyCodeLine{3703         \textcolor{keyword}{typename} CompatibleObjectType::mapped\_type>::value;}
\DoxyCodeLine{3704 \};}
\DoxyCodeLine{3705 }
\DoxyCodeLine{3706 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleObjectType>}
\DoxyCodeLine{3707 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__object__type}{is\_compatible\_object\_type}}}
\DoxyCodeLine{3708     : \mbox{\hyperlink{structdetail_1_1is__compatible__object__type__impl}{is\_compatible\_object\_type\_impl}}<BasicJsonType, CompatibleObjectType> \{\};}
\DoxyCodeLine{3709 }
\DoxyCodeLine{3710 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleObjectType,}
\DoxyCodeLine{3711          \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3712 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible__object__type__impl}{is\_constructible\_object\_type\_impl}} : std::false\_type \{\};}
\DoxyCodeLine{3713 }
\DoxyCodeLine{3714 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleObjectType>}
\DoxyCodeLine{3715 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible__object__type__impl}{is\_constructible\_object\_type\_impl}} <}
\DoxyCodeLine{3716     BasicJsonType, ConstructibleObjectType,}
\DoxyCodeLine{3717     enable\_if\_t < is\_detected<mapped\_type\_t, ConstructibleObjectType>::\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}\&\&}
\DoxyCodeLine{3718     is\_detected<key\_type\_t, ConstructibleObjectType>::value >>}
\DoxyCodeLine{3719 \{}
\DoxyCodeLine{3720     \textcolor{keyword}{using }object\_t = \textcolor{keyword}{typename} BasicJsonType::object\_t;}
\DoxyCodeLine{3721 }
\DoxyCodeLine{3722     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{3723         (\mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible<ConstructibleObjectType>::value}} \&\&}
\DoxyCodeLine{3724          (std::is\_move\_assignable<ConstructibleObjectType>::value ||}
\DoxyCodeLine{3725           std::is\_copy\_assignable<ConstructibleObjectType>::value) \&\&}
\DoxyCodeLine{3726          (\mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible}}<\textcolor{keyword}{typename} ConstructibleObjectType::key\_type,}
\DoxyCodeLine{3727           \textcolor{keyword}{typename} object\_t::key\_type>::value \&\&}
\DoxyCodeLine{3728           std::is\_same <}
\DoxyCodeLine{3729           \textcolor{keyword}{typename} object\_t::mapped\_type,}
\DoxyCodeLine{3730           \textcolor{keyword}{typename} ConstructibleObjectType::mapped\_type >::value)) ||}
\DoxyCodeLine{3731         (\mbox{\hyperlink{structdetail_1_1has__from__json}{has\_from\_json}}<BasicJsonType,}
\DoxyCodeLine{3732          \textcolor{keyword}{typename} ConstructibleObjectType::mapped\_type>::value ||}
\DoxyCodeLine{3733          \mbox{\hyperlink{structdetail_1_1has__non__default__from__json}{has\_non\_default\_from\_json}} <}
\DoxyCodeLine{3734          BasicJsonType,}
\DoxyCodeLine{3735          \textcolor{keyword}{typename} ConstructibleObjectType::mapped\_type >::value);}
\DoxyCodeLine{3736 \};}
\DoxyCodeLine{3737 }
\DoxyCodeLine{3738 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleObjectType>}
\DoxyCodeLine{3739 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible__object__type}{is\_constructible\_object\_type}}}
\DoxyCodeLine{3740     : \mbox{\hyperlink{structdetail_1_1is__constructible__object__type__impl}{is\_constructible\_object\_type\_impl}}<BasicJsonType,}
\DoxyCodeLine{3741       ConstructibleObjectType> \{\};}
\DoxyCodeLine{3742 }
\DoxyCodeLine{3743 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleStringType>}
\DoxyCodeLine{3744 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__string__type}{is\_compatible\_string\_type}}}
\DoxyCodeLine{3745 \{}
\DoxyCodeLine{3746     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} value =}
\DoxyCodeLine{3747         \mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible<typename BasicJsonType::string\_t, CompatibleStringType>::value}};}
\DoxyCodeLine{3748 \};}
\DoxyCodeLine{3749 }
\DoxyCodeLine{3750 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleStringType>}
\DoxyCodeLine{3751 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible__string__type}{is\_constructible\_string\_type}}}
\DoxyCodeLine{3752 \{}
\DoxyCodeLine{3753     \textcolor{comment}{// launder type through decltype() to fix compilation failure on ICPC}}
\DoxyCodeLine{3754 \textcolor{preprocessor}{\#ifdef \_\_INTEL\_COMPILER}}
\DoxyCodeLine{3755     \textcolor{keyword}{using }laundered\_type = \textcolor{keyword}{decltype}(std::declval<ConstructibleStringType>());}
\DoxyCodeLine{3756 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3757     \textcolor{keyword}{using }laundered\_type = ConstructibleStringType;}
\DoxyCodeLine{3758 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3759 }
\DoxyCodeLine{3760     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} value =}
\DoxyCodeLine{3761         \mbox{\hyperlink{structdetail_1_1conjunction}{conjunction}} <}
\DoxyCodeLine{3762         \mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible<laundered\_type, typename BasicJsonType::string\_t>}},}
\DoxyCodeLine{3763         is\_detected\_exact<\textcolor{keyword}{typename} BasicJsonType::string\_t::value\_type,}
\DoxyCodeLine{3764         value\_type\_t, laundered\_type >>::value;}
\DoxyCodeLine{3765 \};}
\DoxyCodeLine{3766 }
\DoxyCodeLine{3767 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleArrayType, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3768 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__array__type__impl}{is\_compatible\_array\_type\_impl}} : std::false\_type \{\};}
\DoxyCodeLine{3769 }
\DoxyCodeLine{3770 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleArrayType>}
\DoxyCodeLine{3771 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__array__type__impl}{is\_compatible\_array\_type\_impl}} <}
\DoxyCodeLine{3772     BasicJsonType, CompatibleArrayType,}
\DoxyCodeLine{3773     enable\_if\_t <}
\DoxyCodeLine{3774     is\_detected<iterator\_t, CompatibleArrayType>::\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}\&\&}
\DoxyCodeLine{3775     \mbox{\hyperlink{structdetail_1_1is__iterator__traits}{is\_iterator\_traits}}<iterator\_traits<detected\_t<iterator\_t, CompatibleArrayType>>>::value\&\&}
\DoxyCodeLine{3776 \textcolor{comment}{// special case for types like std::filesystem::path whose iterator's value\_type are themselves}}
\DoxyCodeLine{3777 \textcolor{comment}{// c.f. https://github.com/nlohmann/json/pull/3073}}
\DoxyCodeLine{3778     !std::is\_same<CompatibleArrayType, detected\_t<range\_value\_t, CompatibleArrayType>>::value >>}
\DoxyCodeLine{3779 \{}
\DoxyCodeLine{3780     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{3781         \mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible}}<BasicJsonType,}
\DoxyCodeLine{3782         range\_value\_t<CompatibleArrayType>>::value;}
\DoxyCodeLine{3783 \};}
\DoxyCodeLine{3784 }
\DoxyCodeLine{3785 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleArrayType>}
\DoxyCodeLine{3786 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__array__type}{is\_compatible\_array\_type}}}
\DoxyCodeLine{3787     : \mbox{\hyperlink{structdetail_1_1is__compatible__array__type__impl}{is\_compatible\_array\_type\_impl}}<BasicJsonType, CompatibleArrayType> \{\};}
\DoxyCodeLine{3788 }
\DoxyCodeLine{3789 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleArrayType, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3790 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible__array__type__impl}{is\_constructible\_array\_type\_impl}} : std::false\_type \{\};}
\DoxyCodeLine{3791 }
\DoxyCodeLine{3792 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleArrayType>}
\DoxyCodeLine{3793 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible__array__type__impl}{is\_constructible\_array\_type\_impl}} <}
\DoxyCodeLine{3794     BasicJsonType, ConstructibleArrayType,}
\DoxyCodeLine{3795     enable\_if\_t<std::is\_same<ConstructibleArrayType,}
\DoxyCodeLine{3796     typename BasicJsonType::value\_type>::value >>}
\DoxyCodeLine{3797             : std::true\_type \{\};}
\DoxyCodeLine{3798 }
\DoxyCodeLine{3799 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleArrayType>}
\DoxyCodeLine{3800 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible__array__type__impl}{is\_constructible\_array\_type\_impl}} <}
\DoxyCodeLine{3801     BasicJsonType, ConstructibleArrayType,}
\DoxyCodeLine{3802     enable\_if\_t < !std::is\_same<ConstructibleArrayType,}
\DoxyCodeLine{3803     typename BasicJsonType::value\_type>::value\&\&}
\DoxyCodeLine{3804     !\mbox{\hyperlink{structdetail_1_1is__compatible__string__type}{is\_compatible\_string\_type}}<BasicJsonType, ConstructibleArrayType>::value\&\&}
\DoxyCodeLine{3805     \mbox{\hyperlink{structdetail_1_1is__default__constructible}{is\_default\_constructible}}<ConstructibleArrayType>::value\&\&}
\DoxyCodeLine{3806 (std::is\_move\_assignable<ConstructibleArrayType>::value ||}
\DoxyCodeLine{3807  std::is\_copy\_assignable<ConstructibleArrayType>::value)\&\&}
\DoxyCodeLine{3808 is\_detected<iterator\_t, ConstructibleArrayType>::value\&\&}
\DoxyCodeLine{3809 \mbox{\hyperlink{structdetail_1_1is__iterator__traits}{is\_iterator\_traits}}<iterator\_traits<detected\_t<iterator\_t, ConstructibleArrayType>>>::value\&\&}
\DoxyCodeLine{3810 is\_detected<range\_value\_t, ConstructibleArrayType>::value\&\&}
\DoxyCodeLine{3811 \textcolor{comment}{// special case for types like std::filesystem::path whose iterator's value\_type are themselves}}
\DoxyCodeLine{3812 \textcolor{comment}{// c.f. https://github.com/nlohmann/json/pull/3073}}
\DoxyCodeLine{3813 !std::is\_same<ConstructibleArrayType, detected\_t<range\_value\_t, ConstructibleArrayType>>::value\&\&}
\DoxyCodeLine{3814         \mbox{\hyperlink{structdetail_1_1is__complete__type}{is\_complete\_type}} <}
\DoxyCodeLine{3815         detected\_t<range\_value\_t, ConstructibleArrayType >>::value >>}
\DoxyCodeLine{3816 \{}
\DoxyCodeLine{3817     \textcolor{keyword}{using }value\_type = range\_value\_t<ConstructibleArrayType>;}
\DoxyCodeLine{3818 }
\DoxyCodeLine{3819     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{3820         std::is\_same<value\_type,}
\DoxyCodeLine{3821         \textcolor{keyword}{typename} BasicJsonType::array\_t::value\_type>::value ||}
\DoxyCodeLine{3822         \mbox{\hyperlink{structdetail_1_1has__from__json}{has\_from\_json}}<BasicJsonType,}
\DoxyCodeLine{3823         value\_type>::value ||}
\DoxyCodeLine{3824         \mbox{\hyperlink{structdetail_1_1has__non__default__from__json}{has\_non\_default\_from\_json}} <}
\DoxyCodeLine{3825         BasicJsonType,}
\DoxyCodeLine{3826         value\_type >::value;}
\DoxyCodeLine{3827 \};}
\DoxyCodeLine{3828 }
\DoxyCodeLine{3829 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleArrayType>}
\DoxyCodeLine{3830 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible__array__type}{is\_constructible\_array\_type}}}
\DoxyCodeLine{3831     : \mbox{\hyperlink{structdetail_1_1is__constructible__array__type__impl}{is\_constructible\_array\_type\_impl}}<BasicJsonType, ConstructibleArrayType> \{\};}
\DoxyCodeLine{3832 }
\DoxyCodeLine{3833 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealIntegerType, \textcolor{keyword}{typename} CompatibleNumberIntegerType,}
\DoxyCodeLine{3834          \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3835 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__integer__type__impl}{is\_compatible\_integer\_type\_impl}} : std::false\_type \{\};}
\DoxyCodeLine{3836 }
\DoxyCodeLine{3837 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealIntegerType, \textcolor{keyword}{typename} CompatibleNumberIntegerType>}
\DoxyCodeLine{3838 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__integer__type__impl}{is\_compatible\_integer\_type\_impl}} <}
\DoxyCodeLine{3839     RealIntegerType, CompatibleNumberIntegerType,}
\DoxyCodeLine{3840     enable\_if\_t < std::is\_integral<RealIntegerType>::value\&\&}
\DoxyCodeLine{3841     std::is\_integral<CompatibleNumberIntegerType>::value\&\&}
\DoxyCodeLine{3842     !std::is\_same<bool, CompatibleNumberIntegerType>::value >>}
\DoxyCodeLine{3843 \{}
\DoxyCodeLine{3844     \textcolor{comment}{// is there an assert somewhere on overflows?}}
\DoxyCodeLine{3845     \textcolor{keyword}{using }RealLimits = std::numeric\_limits<RealIntegerType>;}
\DoxyCodeLine{3846     \textcolor{keyword}{using }CompatibleLimits = std::numeric\_limits<CompatibleNumberIntegerType>;}
\DoxyCodeLine{3847 }
\DoxyCodeLine{3848     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{3849         \mbox{\hyperlink{structdetail_1_1is__constructible}{is\_constructible}}<RealIntegerType,}
\DoxyCodeLine{3850         CompatibleNumberIntegerType>::value \&\&}
\DoxyCodeLine{3851         CompatibleLimits::is\_integer \&\&}
\DoxyCodeLine{3852         RealLimits::is\_signed == CompatibleLimits::is\_signed;}
\DoxyCodeLine{3853 \};}
\DoxyCodeLine{3854 }
\DoxyCodeLine{3855 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RealIntegerType, \textcolor{keyword}{typename} CompatibleNumberIntegerType>}
\DoxyCodeLine{3856 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__integer__type}{is\_compatible\_integer\_type}}}
\DoxyCodeLine{3857     : \mbox{\hyperlink{structdetail_1_1is__compatible__integer__type__impl}{is\_compatible\_integer\_type\_impl}}<RealIntegerType,}
\DoxyCodeLine{3858       CompatibleNumberIntegerType> \{\};}
\DoxyCodeLine{3859 }
\DoxyCodeLine{3860 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleType, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3861 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__type__impl}{is\_compatible\_type\_impl}}: std::false\_type \{\};}
\DoxyCodeLine{3862 }
\DoxyCodeLine{3863 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleType>}
\DoxyCodeLine{3864 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__type__impl}{is\_compatible\_type\_impl}} <}
\DoxyCodeLine{3865     BasicJsonType, CompatibleType,}
\DoxyCodeLine{3866     enable\_if\_t<\mbox{\hyperlink{structdetail_1_1is__complete__type}{is\_complete\_type}}<CompatibleType>::\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} >>}
\DoxyCodeLine{3867 \{}
\DoxyCodeLine{3868     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{3869         \mbox{\hyperlink{structdetail_1_1has__to__json}{has\_to\_json<BasicJsonType, CompatibleType>::value}};}
\DoxyCodeLine{3870 \};}
\DoxyCodeLine{3871 }
\DoxyCodeLine{3872 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleType>}
\DoxyCodeLine{3873 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compatible__type}{is\_compatible\_type}}}
\DoxyCodeLine{3874     : \mbox{\hyperlink{structdetail_1_1is__compatible__type__impl}{is\_compatible\_type\_impl}}<BasicJsonType, CompatibleType> \{\};}
\DoxyCodeLine{3875 }
\DoxyCodeLine{3876 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{3877 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible__tuple}{is\_constructible\_tuple}} : std::false\_type \{\};}
\DoxyCodeLine{3878 }
\DoxyCodeLine{3879 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3880 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__constructible__tuple}{is\_constructible\_tuple}}<T1, std::tuple<Args...>> : \mbox{\hyperlink{structdetail_1_1conjunction}{conjunction}}<is\_constructible<T1, Args>...> \{\};}
\DoxyCodeLine{3881 }
\DoxyCodeLine{3882 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{3883 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__json__iterator__of}{is\_json\_iterator\_of}} : std::false\_type \{\};}
\DoxyCodeLine{3884 }
\DoxyCodeLine{3885 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{3886 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__json__iterator__of}{is\_json\_iterator\_of}}<BasicJsonType, typename BasicJsonType::iterator> : std::true\_type \{\};}
\DoxyCodeLine{3887 }
\DoxyCodeLine{3888 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{3889 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__json__iterator__of}{is\_json\_iterator\_of}}<BasicJsonType, typename BasicJsonType::const\_iterator> : std::true\_type}
\DoxyCodeLine{3890 \{\};}
\DoxyCodeLine{3891 }
\DoxyCodeLine{3892 \textcolor{comment}{// checks if a given type T is a template specialization of Primary}}
\DoxyCodeLine{3893 \textcolor{keyword}{template}<\textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{class }Primary, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{3894 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__specialization__of}{is\_specialization\_of}} : std::false\_type \{\};}
\DoxyCodeLine{3895 }
\DoxyCodeLine{3896 \textcolor{keyword}{template}<\textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{class }Primary, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3897 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__specialization__of}{is\_specialization\_of}}<Primary, Primary<Args...>> : std::true\_type \{\};}
\DoxyCodeLine{3898 }
\DoxyCodeLine{3899 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3900 \textcolor{keyword}{using }\mbox{\hyperlink{structdetail_1_1is__specialization__of}{is\_json\_pointer}} = \mbox{\hyperlink{structdetail_1_1is__specialization__of}{is\_specialization\_of<::nlohmann::json\_pointer, uncvref\_t<T>}}>;}
\DoxyCodeLine{3901 }
\DoxyCodeLine{3902 \textcolor{comment}{// checks if A and B are comparable using Compare functor}}
\DoxyCodeLine{3903 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Compare, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{3904 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__comparable}{is\_comparable}} : std::false\_type \{\};}
\DoxyCodeLine{3905 }
\DoxyCodeLine{3906 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Compare, \textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{3907 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__comparable}{is\_comparable}}<Compare, A, B, void\_t<}
\DoxyCodeLine{3908 decltype(std::declval<Compare>()(std::declval<A>(), std::declval<B>())),}
\DoxyCodeLine{3909 decltype(std::declval<Compare>()(std::declval<B>(), std::declval<A>()))}
\DoxyCodeLine{3910 >> : std::true\_type \{\};}
\DoxyCodeLine{3911 }
\DoxyCodeLine{3912 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3913 \textcolor{keyword}{using }detect\_is\_transparent = \textcolor{keyword}{typename} T::is\_transparent;}
\DoxyCodeLine{3914 }
\DoxyCodeLine{3915 \textcolor{comment}{// type trait to check if KeyType can be used as object key (without a BasicJsonType)}}
\DoxyCodeLine{3916 \textcolor{comment}{// see is\_usable\_as\_basic\_json\_key\_type below}}
\DoxyCodeLine{3917 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Comparator, \textcolor{keyword}{typename} ObjectKeyType, \textcolor{keyword}{typename} KeyTypeCVRef, \textcolor{keywordtype}{bool} RequireTransparentComparator = \textcolor{keyword}{true},}
\DoxyCodeLine{3918          \textcolor{keywordtype}{bool} ExcludeObjectKeyType = RequireTransparentComparator, \textcolor{keyword}{typename} KeyType = uncvref\_t<KeyTypeCVRef>>}
\DoxyCodeLine{3919 \textcolor{keyword}{using }is\_usable\_as\_key\_type = \textcolor{keyword}{typename} std::conditional <}
\DoxyCodeLine{3920                               \mbox{\hyperlink{structdetail_1_1is__comparable}{is\_comparable<Comparator, ObjectKeyType, KeyTypeCVRef>::value}}}
\DoxyCodeLine{3921                               \&\& !(ExcludeObjectKeyType \&\& std::is\_same<KeyType,}
\DoxyCodeLine{3922                                    ObjectKeyType>::value)}
\DoxyCodeLine{3923                               \&\& (!RequireTransparentComparator}
\DoxyCodeLine{3924                                   || is\_detected <detect\_is\_transparent, Comparator>::value)}
\DoxyCodeLine{3925                               \&\& !\mbox{\hyperlink{structdetail_1_1is__specialization__of}{is\_json\_pointer<KeyType>::value}},}
\DoxyCodeLine{3926                               std::true\_type,}
\DoxyCodeLine{3927                               std::false\_type >::type;}
\DoxyCodeLine{3928 }
\DoxyCodeLine{3929 \textcolor{comment}{// type trait to check if KeyType can be used as object key}}
\DoxyCodeLine{3930 \textcolor{comment}{// true if:}}
\DoxyCodeLine{3931 \textcolor{comment}{//   -\/ KeyType is comparable with BasicJsonType::object\_t::key\_type}}
\DoxyCodeLine{3932 \textcolor{comment}{//   -\/ if ExcludeObjectKeyType is true, KeyType is not BasicJsonType::object\_t::key\_type}}
\DoxyCodeLine{3933 \textcolor{comment}{//   -\/ the comparator is transparent or RequireTransparentComparator is false}}
\DoxyCodeLine{3934 \textcolor{comment}{//   -\/ KeyType is not a JSON iterator or json\_pointer}}
\DoxyCodeLine{3935 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} KeyTypeCVRef, \textcolor{keywordtype}{bool} RequireTransparentComparator = \textcolor{keyword}{true},}
\DoxyCodeLine{3936          \textcolor{keywordtype}{bool} ExcludeObjectKeyType = RequireTransparentComparator, \textcolor{keyword}{typename} KeyType = uncvref\_t<KeyTypeCVRef>>}
\DoxyCodeLine{3937 \textcolor{keyword}{using }is\_usable\_as\_basic\_json\_key\_type = \textcolor{keyword}{typename} std::conditional <}
\DoxyCodeLine{3938         is\_usable\_as\_key\_type<\textcolor{keyword}{typename} BasicJsonType::object\_comparator\_t,}
\DoxyCodeLine{3939         \textcolor{keyword}{typename} BasicJsonType::object\_t::key\_type, KeyTypeCVRef,}
\DoxyCodeLine{3940         RequireTransparentComparator, ExcludeObjectKeyType>::value}
\DoxyCodeLine{3941         \&\& !\mbox{\hyperlink{structdetail_1_1is__json__iterator__of}{is\_json\_iterator\_of<BasicJsonType, KeyType>::value}},}
\DoxyCodeLine{3942         std::true\_type,}
\DoxyCodeLine{3943         std::false\_type >::type;}
\DoxyCodeLine{3944 }
\DoxyCodeLine{3945 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectType, \textcolor{keyword}{typename} KeyType>}
\DoxyCodeLine{3946 \textcolor{keyword}{using }detect\_erase\_with\_key\_type = \textcolor{keyword}{decltype}(std::declval<ObjectType\&>().erase(std::declval<KeyType>()));}
\DoxyCodeLine{3947 }
\DoxyCodeLine{3948 \textcolor{comment}{// type trait to check if object\_t has an erase() member functions accepting KeyType}}
\DoxyCodeLine{3949 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} KeyType>}
\DoxyCodeLine{3950 \textcolor{keyword}{using }has\_erase\_with\_key\_type = \textcolor{keyword}{typename} std::conditional <}
\DoxyCodeLine{3951                                 is\_detected <}
\DoxyCodeLine{3952                                 detect\_erase\_with\_key\_type,}
\DoxyCodeLine{3953                                 \textcolor{keyword}{typename} BasicJsonType::object\_t, KeyType >::value,}
\DoxyCodeLine{3954                                 std::true\_type,}
\DoxyCodeLine{3955                                 std::false\_type >::type;}
\DoxyCodeLine{3956 }
\DoxyCodeLine{3957 \textcolor{comment}{// a naive helper to check if a type is an ordered\_map (exploits the fact that}}
\DoxyCodeLine{3958 \textcolor{comment}{// ordered\_map inherits capacity() from std::vector)}}
\DoxyCodeLine{3959 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3960 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__ordered__map}{is\_ordered\_map}}}
\DoxyCodeLine{3961 \{}
\DoxyCodeLine{3962     \textcolor{keyword}{using }one = char;}
\DoxyCodeLine{3963 }
\DoxyCodeLine{3964     \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__ordered__map_1_1two}{two}}}
\DoxyCodeLine{3965     \{}
\DoxyCodeLine{3966         \textcolor{keywordtype}{char} x[2]; \textcolor{comment}{// NOLINT(cppcoreguidelines-\/avoid-\/c-\/arrays,hicpp-\/avoid-\/c-\/arrays,modernize-\/avoid-\/c-\/arrays)}}
\DoxyCodeLine{3967     \};}
\DoxyCodeLine{3968 }
\DoxyCodeLine{3969     \textcolor{keyword}{template} <\textcolor{keyword}{typename} C> \textcolor{keyword}{static} one test( \textcolor{keyword}{decltype}(\&C::capacity) ) ;}
\DoxyCodeLine{3970     \textcolor{keyword}{template} <\textcolor{keyword}{typename} C> \textcolor{keyword}{static} \mbox{\hyperlink{structdetail_1_1is__ordered__map_1_1two}{two}} test(...);}
\DoxyCodeLine{3971 }
\DoxyCodeLine{3972     \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{sizeof}(test<T>(\textcolor{keyword}{nullptr})) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}) \}; \textcolor{comment}{// NOLINT(cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{3973 \};}
\DoxyCodeLine{3974 }
\DoxyCodeLine{3975 \textcolor{comment}{// to avoid useless casts (see https://github.com/nlohmann/json/issues/2893\#issuecomment-\/889152324)}}
\DoxyCodeLine{3976 template < typename T, typename U, enable\_if\_t < !std::is\_same<T, U>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{3977 T conditional\_static\_cast(U value)}
\DoxyCodeLine{3978 \{}
\DoxyCodeLine{3979     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(value);}
\DoxyCodeLine{3980 \}}
\DoxyCodeLine{3981 }
\DoxyCodeLine{3982 template<typename T, typename U, enable\_if\_t<std::is\_same<T, U>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{3983 T conditional\_static\_cast(U value)}
\DoxyCodeLine{3984 \{}
\DoxyCodeLine{3985     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}};}
\DoxyCodeLine{3986 \}}
\DoxyCodeLine{3987 }
\DoxyCodeLine{3988 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Types>}
\DoxyCodeLine{3989 \textcolor{keyword}{using }all\_integral = conjunction<std::is\_integral<Types>...>;}
\DoxyCodeLine{3990 }
\DoxyCodeLine{3991 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Types>}
\DoxyCodeLine{3992 \textcolor{keyword}{using }all\_signed = conjunction<std::is\_signed<Types>...>;}
\DoxyCodeLine{3993 }
\DoxyCodeLine{3994 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Types>}
\DoxyCodeLine{3995 \textcolor{keyword}{using }all\_unsigned = conjunction<std::is\_unsigned<Types>...>;}
\DoxyCodeLine{3996 }
\DoxyCodeLine{3997 \textcolor{comment}{// there's a disjunction trait in another PR; replace when merged}}
\DoxyCodeLine{3998 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Types>}
\DoxyCodeLine{3999 \textcolor{keyword}{using }same\_sign = std::integral\_constant < bool,}
\DoxyCodeLine{4000       all\_signed<Types...>::value || all\_unsigned<Types...>::value >;}
\DoxyCodeLine{4001 }
\DoxyCodeLine{4002 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OfType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4003 \textcolor{keyword}{using }never\_out\_of\_range = std::integral\_constant < bool,}
\DoxyCodeLine{4004       (std::is\_signed<OfType>::value \&\& (\textcolor{keyword}{sizeof}(T) < \textcolor{keyword}{sizeof}(OfType)))}
\DoxyCodeLine{4005       || (same\_sign<OfType, T>::value \&\& \textcolor{keyword}{sizeof}(OfType) == \textcolor{keyword}{sizeof}(T)) >;}
\DoxyCodeLine{4006 }
\DoxyCodeLine{4007 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OfType, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{4008          \textcolor{keywordtype}{bool} OfTypeSigned = std::is\_signed<OfType>::value,}
\DoxyCodeLine{4009          \textcolor{keywordtype}{bool} TSigned = std::is\_signed<T>::value>}
\DoxyCodeLine{4010 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1value__in__range__of__impl2}{value\_in\_range\_of\_impl2}};}
\DoxyCodeLine{4011 }
\DoxyCodeLine{4012 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OfType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4013 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1value__in__range__of__impl2}{value\_in\_range\_of\_impl2}}<OfType, T, false, false>}
\DoxyCodeLine{4014 \{}
\DoxyCodeLine{4015     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} test(T val)}
\DoxyCodeLine{4016     \{}
\DoxyCodeLine{4017         \textcolor{keyword}{using }CommonType = \textcolor{keyword}{typename} std::common\_type<OfType, T>::type;}
\DoxyCodeLine{4018         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}CommonType\textcolor{keyword}{>}(val) <= \textcolor{keyword}{static\_cast<}CommonType\textcolor{keyword}{>}((std::numeric\_limits<OfType>::max)());}
\DoxyCodeLine{4019     \}}
\DoxyCodeLine{4020 \};}
\DoxyCodeLine{4021 }
\DoxyCodeLine{4022 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OfType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4023 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1value__in__range__of__impl2}{value\_in\_range\_of\_impl2}}<OfType, T, true, false>}
\DoxyCodeLine{4024 \{}
\DoxyCodeLine{4025     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} test(T val)}
\DoxyCodeLine{4026     \{}
\DoxyCodeLine{4027         \textcolor{keyword}{using }CommonType = \textcolor{keyword}{typename} std::common\_type<OfType, T>::type;}
\DoxyCodeLine{4028         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}CommonType\textcolor{keyword}{>}(val) <= \textcolor{keyword}{static\_cast<}CommonType\textcolor{keyword}{>}((std::numeric\_limits<OfType>::max)());}
\DoxyCodeLine{4029     \}}
\DoxyCodeLine{4030 \};}
\DoxyCodeLine{4031 }
\DoxyCodeLine{4032 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OfType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4033 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1value__in__range__of__impl2}{value\_in\_range\_of\_impl2}}<OfType, T, false, true>}
\DoxyCodeLine{4034 \{}
\DoxyCodeLine{4035     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} test(T val)}
\DoxyCodeLine{4036     \{}
\DoxyCodeLine{4037         \textcolor{keyword}{using }CommonType = \textcolor{keyword}{typename} std::common\_type<OfType, T>::type;}
\DoxyCodeLine{4038         \textcolor{keywordflow}{return} val >= 0 \&\& \textcolor{keyword}{static\_cast<}CommonType\textcolor{keyword}{>}(val) <= \textcolor{keyword}{static\_cast<}CommonType\textcolor{keyword}{>}((std::numeric\_limits<OfType>::max)());}
\DoxyCodeLine{4039     \}}
\DoxyCodeLine{4040 \};}
\DoxyCodeLine{4041 }
\DoxyCodeLine{4042 }
\DoxyCodeLine{4043 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OfType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4044 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1value__in__range__of__impl2}{value\_in\_range\_of\_impl2}}<OfType, T, true, true>}
\DoxyCodeLine{4045 \{}
\DoxyCodeLine{4046     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} test(T val)}
\DoxyCodeLine{4047     \{}
\DoxyCodeLine{4048         \textcolor{keyword}{using }CommonType = \textcolor{keyword}{typename} std::common\_type<OfType, T>::type;}
\DoxyCodeLine{4049         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}CommonType\textcolor{keyword}{>}(val) >= \textcolor{keyword}{static\_cast<}CommonType\textcolor{keyword}{>}((std::numeric\_limits<OfType>::min)())}
\DoxyCodeLine{4050                \&\& \textcolor{keyword}{static\_cast<}CommonType\textcolor{keyword}{>}(val) <= \textcolor{keyword}{static\_cast<}CommonType\textcolor{keyword}{>}((std::numeric\_limits<OfType>::max)());}
\DoxyCodeLine{4051     \}}
\DoxyCodeLine{4052 \};}
\DoxyCodeLine{4053 }
\DoxyCodeLine{4054 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OfType, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{4055          \textcolor{keywordtype}{bool} NeverOutOfRange = never\_out\_of\_range<OfType, T>::value,}
\DoxyCodeLine{4056          \textcolor{keyword}{typename} = detail::enable\_if\_t<all\_integral<OfType, T>::value>>}
\DoxyCodeLine{4057 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1value__in__range__of__impl1}{value\_in\_range\_of\_impl1}};}
\DoxyCodeLine{4058 }
\DoxyCodeLine{4059 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OfType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4060 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1value__in__range__of__impl1}{value\_in\_range\_of\_impl1}}<OfType, T, false>}
\DoxyCodeLine{4061 \{}
\DoxyCodeLine{4062     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} test(T val)}
\DoxyCodeLine{4063     \{}
\DoxyCodeLine{4064         \textcolor{keywordflow}{return} \mbox{\hyperlink{structdetail_1_1value__in__range__of__impl2}{value\_in\_range\_of\_impl2<OfType, T>::test}}(val);}
\DoxyCodeLine{4065     \}}
\DoxyCodeLine{4066 \};}
\DoxyCodeLine{4067 }
\DoxyCodeLine{4068 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OfType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4069 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1value__in__range__of__impl1}{value\_in\_range\_of\_impl1}}<OfType, T, true>}
\DoxyCodeLine{4070 \{}
\DoxyCodeLine{4071     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} test(T \textcolor{comment}{/*val*/})}
\DoxyCodeLine{4072     \{}
\DoxyCodeLine{4073         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4074     \}}
\DoxyCodeLine{4075 \};}
\DoxyCodeLine{4076 }
\DoxyCodeLine{4077 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OfType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4078 \textcolor{keyword}{inline} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} value\_in\_range\_of(T val)}
\DoxyCodeLine{4079 \{}
\DoxyCodeLine{4080     \textcolor{keywordflow}{return} \mbox{\hyperlink{structdetail_1_1value__in__range__of__impl1}{value\_in\_range\_of\_impl1<OfType, T>::test}}(val);}
\DoxyCodeLine{4081 \}}
\DoxyCodeLine{4082 }
\DoxyCodeLine{4083 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Value>}
\DoxyCodeLine{4084 \textcolor{keyword}{using }bool\_constant = std::integral\_constant<bool, Value>;}
\DoxyCodeLine{4085 }
\DoxyCodeLine{4087 \textcolor{comment}{// is\_c\_string}}
\DoxyCodeLine{4089 \textcolor{comment}{}}
\DoxyCodeLine{4090 \textcolor{keyword}{namespace }impl}
\DoxyCodeLine{4091 \{}
\DoxyCodeLine{4092 }
\DoxyCodeLine{4093 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4094 \textcolor{keyword}{inline} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} is\_c\_string()}
\DoxyCodeLine{4095 \{}
\DoxyCodeLine{4096     \textcolor{keyword}{using }TUnExt = \textcolor{keyword}{typename} std::remove\_extent<T>::type;}
\DoxyCodeLine{4097     \textcolor{keyword}{using }TUnCVExt = \textcolor{keyword}{typename} std::remove\_cv<TUnExt>::type;}
\DoxyCodeLine{4098     \textcolor{keyword}{using }TUnPtr = \textcolor{keyword}{typename} std::remove\_pointer<T>::type;}
\DoxyCodeLine{4099     \textcolor{keyword}{using }TUnCVPtr = \textcolor{keyword}{typename} std::remove\_cv<TUnPtr>::type;}
\DoxyCodeLine{4100     \textcolor{keywordflow}{return}}
\DoxyCodeLine{4101         (std::is\_array<T>::value \&\& std::is\_same<TUnCVExt, char>::value)}
\DoxyCodeLine{4102         || (std::is\_pointer<T>::value \&\& std::is\_same<TUnCVPtr, char>::value);}
\DoxyCodeLine{4103 \}}
\DoxyCodeLine{4104 }
\DoxyCodeLine{4105 \}  \textcolor{comment}{// namespace impl}}
\DoxyCodeLine{4106 }
\DoxyCodeLine{4107 \textcolor{comment}{// checks whether T is a [cv] char */[cv] char[] C string}}
\DoxyCodeLine{4108 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4109 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__c__string}{is\_c\_string}} : bool\_constant<impl::is\_c\_string<T>()> \{\};}
\DoxyCodeLine{4110 }
\DoxyCodeLine{4111 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4112 \textcolor{keyword}{using }\mbox{\hyperlink{structdetail_1_1is__c__string}{is\_c\_string\_uncvref}} = \mbox{\hyperlink{structdetail_1_1is__c__string}{is\_c\_string<uncvref\_t<T>}}>;}
\DoxyCodeLine{4113 }
\DoxyCodeLine{4115 \textcolor{comment}{// is\_transparent}}
\DoxyCodeLine{4117 \textcolor{comment}{}}
\DoxyCodeLine{4118 \textcolor{keyword}{namespace }impl}
\DoxyCodeLine{4119 \{}
\DoxyCodeLine{4120 }
\DoxyCodeLine{4121 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4122 \textcolor{keyword}{inline} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structdetail_1_1is__transparent}{is\_transparent}}()}
\DoxyCodeLine{4123 \{}
\DoxyCodeLine{4124     \textcolor{keywordflow}{return} is\_detected<detect\_is\_transparent, T>::value;}
\DoxyCodeLine{4125 \}}
\DoxyCodeLine{4126 }
\DoxyCodeLine{4127 \}  \textcolor{comment}{// namespace impl}}
\DoxyCodeLine{4128 }
\DoxyCodeLine{4129 \textcolor{comment}{// checks whether T has a member named is\_transparent}}
\DoxyCodeLine{4130 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4131 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__transparent}{is\_transparent}} : bool\_constant<impl::is\_transparent<T>()> \{\};}
\DoxyCodeLine{4132 }
\DoxyCodeLine{4134 }
\DoxyCodeLine{4135 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{4136 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{4137 }
\DoxyCodeLine{4138 \textcolor{comment}{// \#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{4139 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{4140 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{4141 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{4142 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{4143 \textcolor{comment}{//}}
\DoxyCodeLine{4144 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{4145 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{4146 }
\DoxyCodeLine{4147 }
\DoxyCodeLine{4148 }
\DoxyCodeLine{4149 \textcolor{preprocessor}{\#include <cstring>} \textcolor{comment}{// strlen}}
\DoxyCodeLine{4150 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{4151 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// forward}}
\DoxyCodeLine{4152 }
\DoxyCodeLine{4153 \textcolor{comment}{// \#include <nlohmann/detail/meta/cpp\_future.hpp>}}
\DoxyCodeLine{4154 }
\DoxyCodeLine{4155 \textcolor{comment}{// \#include <nlohmann/detail/meta/detected.hpp>}}
\DoxyCodeLine{4156 }
\DoxyCodeLine{4157 }
\DoxyCodeLine{4158 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{4159 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{4160 \{}
\DoxyCodeLine{4161 }
\DoxyCodeLine{4162 \textcolor{keyword}{inline} std::size\_t concat\_length()}
\DoxyCodeLine{4163 \{}
\DoxyCodeLine{4164     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4165 \}}
\DoxyCodeLine{4166 }
\DoxyCodeLine{4167 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{4168 \textcolor{keyword}{inline} std::size\_t concat\_length(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* cstr, Args\&\& ... rest);}
\DoxyCodeLine{4169 }
\DoxyCodeLine{4170 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{4171 \textcolor{keyword}{inline} std::size\_t concat\_length(\textcolor{keyword}{const} StringType\& str, Args\&\& ... rest);}
\DoxyCodeLine{4172 }
\DoxyCodeLine{4173 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{4174 \textcolor{keyword}{inline} std::size\_t concat\_length(\textcolor{keyword}{const} \textcolor{keywordtype}{char} \textcolor{comment}{/*c*/}, Args\&\& ... rest)}
\DoxyCodeLine{4175 \{}
\DoxyCodeLine{4176     \textcolor{keywordflow}{return} 1 + concat\_length(std::forward<Args>(rest)...);}
\DoxyCodeLine{4177 \}}
\DoxyCodeLine{4178 }
\DoxyCodeLine{4179 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{4180 \textcolor{keyword}{inline} std::size\_t concat\_length(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* cstr, Args\&\& ... rest)}
\DoxyCodeLine{4181 \{}
\DoxyCodeLine{4182     \textcolor{comment}{// cppcheck-\/suppress ignoredReturnValue}}
\DoxyCodeLine{4183     return ::strlen(cstr) + concat\_length(std::forward<Args>(rest)...);}
\DoxyCodeLine{4184 \}}
\DoxyCodeLine{4185 }
\DoxyCodeLine{4186 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{4187 \textcolor{keyword}{inline} std::size\_t concat\_length(\textcolor{keyword}{const} StringType\& str, Args\&\& ... rest)}
\DoxyCodeLine{4188 \{}
\DoxyCodeLine{4189     \textcolor{keywordflow}{return} str.size() + concat\_length(std::forward<Args>(rest)...);}
\DoxyCodeLine{4190 \}}
\DoxyCodeLine{4191 }
\DoxyCodeLine{4192 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OutStringType>}
\DoxyCodeLine{4193 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} concat\_into(OutStringType\& \textcolor{comment}{/*out*/})}
\DoxyCodeLine{4194 \{\}}
\DoxyCodeLine{4195 }
\DoxyCodeLine{4196 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType, \textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{4197 \textcolor{keyword}{using }string\_can\_append = \textcolor{keyword}{decltype}(std::declval<StringType\&>().append(std::declval < Arg \&\& > ()));}
\DoxyCodeLine{4198 }
\DoxyCodeLine{4199 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType, \textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{4200 \textcolor{keyword}{using }detect\_string\_can\_append = is\_detected<string\_can\_append, StringType, Arg>;}
\DoxyCodeLine{4201 }
\DoxyCodeLine{4202 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType, \textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{4203 \textcolor{keyword}{using }string\_can\_append\_op = \textcolor{keyword}{decltype}(std::declval<StringType\&>() += std::declval < Arg \&\& > ());}
\DoxyCodeLine{4204 }
\DoxyCodeLine{4205 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType, \textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{4206 \textcolor{keyword}{using }detect\_string\_can\_append\_op = is\_detected<string\_can\_append\_op, StringType, Arg>;}
\DoxyCodeLine{4207 }
\DoxyCodeLine{4208 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType, \textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{4209 \textcolor{keyword}{using }string\_can\_append\_iter = \textcolor{keyword}{decltype}(std::declval<StringType\&>().append(std::declval<const Arg\&>().begin(), std::declval<const Arg\&>().end()));}
\DoxyCodeLine{4210 }
\DoxyCodeLine{4211 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType, \textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{4212 \textcolor{keyword}{using }detect\_string\_can\_append\_iter = is\_detected<string\_can\_append\_iter, StringType, Arg>;}
\DoxyCodeLine{4213 }
\DoxyCodeLine{4214 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType, \textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{4215 \textcolor{keyword}{using }string\_can\_append\_data = \textcolor{keyword}{decltype}(std::declval<StringType\&>().append(std::declval<const Arg\&>().data(), std::declval<const Arg\&>().size()));}
\DoxyCodeLine{4216 }
\DoxyCodeLine{4217 \textcolor{keyword}{template}<\textcolor{keyword}{typename} StringType, \textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{4218 \textcolor{keyword}{using }detect\_string\_can\_append\_data = is\_detected<string\_can\_append\_data, StringType, Arg>;}
\DoxyCodeLine{4219 }
\DoxyCodeLine{4220 \textcolor{keyword}{template} < \textcolor{keyword}{typename} OutStringType, \textcolor{keyword}{typename} Arg, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{4221            enable\_if\_t < !detect\_string\_can\_append<OutStringType, Arg>::value}
\DoxyCodeLine{4222                          \&\& detect\_string\_can\_append\_op<OutStringType, Arg>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{4223 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} concat\_into(OutStringType\& out, Arg \&\& arg, Args \&\& ... rest);}
\DoxyCodeLine{4224 }
\DoxyCodeLine{4225 \textcolor{keyword}{template} < \textcolor{keyword}{typename} OutStringType, \textcolor{keyword}{typename} Arg, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{4226            enable\_if\_t < !detect\_string\_can\_append<OutStringType, Arg>::value}
\DoxyCodeLine{4227                          \&\& !detect\_string\_can\_append\_op<OutStringType, Arg>::value}
\DoxyCodeLine{4228                          \&\& detect\_string\_can\_append\_iter<OutStringType, Arg>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{4229 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} concat\_into(OutStringType\& out, \textcolor{keyword}{const} Arg\& arg, Args \&\& ... rest);}
\DoxyCodeLine{4230 }
\DoxyCodeLine{4231 \textcolor{keyword}{template} < \textcolor{keyword}{typename} OutStringType, \textcolor{keyword}{typename} Arg, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{4232            enable\_if\_t < !detect\_string\_can\_append<OutStringType, Arg>::value}
\DoxyCodeLine{4233                          \&\& !detect\_string\_can\_append\_op<OutStringType, Arg>::value}
\DoxyCodeLine{4234                          \&\& !detect\_string\_can\_append\_iter<OutStringType, Arg>::value}
\DoxyCodeLine{4235                          \&\& detect\_string\_can\_append\_data<OutStringType, Arg>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{4236 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} concat\_into(OutStringType\& out, \textcolor{keyword}{const} Arg\& arg, Args \&\& ... rest);}
\DoxyCodeLine{4237 }
\DoxyCodeLine{4238 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OutStringType, \textcolor{keyword}{typename} Arg, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{4239          enable\_if\_t<detect\_string\_can\_append<OutStringType, Arg>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4240 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} concat\_into(OutStringType\& out, Arg \&\& arg, Args \&\& ... rest)}
\DoxyCodeLine{4241 \{}
\DoxyCodeLine{4242     out.append(std::forward<Arg>(arg));}
\DoxyCodeLine{4243     concat\_into(out, std::forward<Args>(rest)...);}
\DoxyCodeLine{4244 \}}
\DoxyCodeLine{4245 }
\DoxyCodeLine{4246 \textcolor{keyword}{template} < \textcolor{keyword}{typename} OutStringType, \textcolor{keyword}{typename} Arg, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{4247            enable\_if\_t < !detect\_string\_can\_append<OutStringType, Arg>::value}
\DoxyCodeLine{4248                          \&\& detect\_string\_can\_append\_op<OutStringType, Arg>::value, \textcolor{keywordtype}{int} > >}
\DoxyCodeLine{4249 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} concat\_into(OutStringType\& out, Arg\&\& arg, Args\&\& ... rest)}
\DoxyCodeLine{4250 \{}
\DoxyCodeLine{4251     out += std::forward<Arg>(arg);}
\DoxyCodeLine{4252     concat\_into(out, std::forward<Args>(rest)...);}
\DoxyCodeLine{4253 \}}
\DoxyCodeLine{4254 }
\DoxyCodeLine{4255 \textcolor{keyword}{template} < \textcolor{keyword}{typename} OutStringType, \textcolor{keyword}{typename} Arg, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{4256            enable\_if\_t < !detect\_string\_can\_append<OutStringType, Arg>::value}
\DoxyCodeLine{4257                          \&\& !detect\_string\_can\_append\_op<OutStringType, Arg>::value}
\DoxyCodeLine{4258                          \&\& detect\_string\_can\_append\_iter<OutStringType, Arg>::value, \textcolor{keywordtype}{int} > >}
\DoxyCodeLine{4259 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} concat\_into(OutStringType\& out, \textcolor{keyword}{const} Arg\& arg, Args\&\& ... rest)}
\DoxyCodeLine{4260 \{}
\DoxyCodeLine{4261     out.append(arg.begin(), arg.end());}
\DoxyCodeLine{4262     concat\_into(out, std::forward<Args>(rest)...);}
\DoxyCodeLine{4263 \}}
\DoxyCodeLine{4264 }
\DoxyCodeLine{4265 \textcolor{keyword}{template} < \textcolor{keyword}{typename} OutStringType, \textcolor{keyword}{typename} Arg, \textcolor{keyword}{typename}... Args,}
\DoxyCodeLine{4266            enable\_if\_t < !detect\_string\_can\_append<OutStringType, Arg>::value}
\DoxyCodeLine{4267                          \&\& !detect\_string\_can\_append\_op<OutStringType, Arg>::value}
\DoxyCodeLine{4268                          \&\& !detect\_string\_can\_append\_iter<OutStringType, Arg>::value}
\DoxyCodeLine{4269                          \&\& detect\_string\_can\_append\_data<OutStringType, Arg>::value, \textcolor{keywordtype}{int} > >}
\DoxyCodeLine{4270 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} concat\_into(OutStringType\& out, \textcolor{keyword}{const} Arg\& arg, Args\&\& ... rest)}
\DoxyCodeLine{4271 \{}
\DoxyCodeLine{4272     out.append(arg.data(), arg.size());}
\DoxyCodeLine{4273     concat\_into(out, std::forward<Args>(rest)...);}
\DoxyCodeLine{4274 \}}
\DoxyCodeLine{4275 }
\DoxyCodeLine{4276 \textcolor{keyword}{template}<\textcolor{keyword}{typename} OutStringType = std::string, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{4277 \textcolor{keyword}{inline} OutStringType concat(Args \&\& ... args)}
\DoxyCodeLine{4278 \{}
\DoxyCodeLine{4279     OutStringType str;}
\DoxyCodeLine{4280     str.reserve(concat\_length(std::forward<Args>(args)...));}
\DoxyCodeLine{4281     concat\_into(str, std::forward<Args>(args)...);}
\DoxyCodeLine{4282     \textcolor{keywordflow}{return} str;}
\DoxyCodeLine{4283 \}}
\DoxyCodeLine{4284 }
\DoxyCodeLine{4285 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{4286 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{4287 }
\DoxyCodeLine{4288 }
\DoxyCodeLine{4289 }
\DoxyCodeLine{4290 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{4291 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{4292 \{}
\DoxyCodeLine{4293 }
\DoxyCodeLine{4295 \textcolor{comment}{// exceptions //}}
\DoxyCodeLine{4297 \textcolor{comment}{}}
\DoxyCodeLine{4300 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1exception}{exception}} : \textcolor{keyword}{public} std::exception}
\DoxyCodeLine{4301 \{}
\DoxyCodeLine{4302   \textcolor{keyword}{public}:}
\DoxyCodeLine{4304     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \mbox{\hyperlink{classdetail_1_1exception_ae75d7315f5f2d85958da6d961375caf0}{what}}() const noexcept\textcolor{keyword}{ override}}
\DoxyCodeLine{4305 \textcolor{keyword}{    }\{}
\DoxyCodeLine{4306         \textcolor{keywordflow}{return} m.what();}
\DoxyCodeLine{4307     \}}
\DoxyCodeLine{4308 }
\DoxyCodeLine{4310     \textcolor{keyword}{const} \textcolor{keywordtype}{int} \mbox{\hyperlink{classdetail_1_1exception_a63b819fbb2ef34df9dad1e309207fa24}{id}}; \textcolor{comment}{// NOLINT(cppcoreguidelines-\/non-\/private-\/member-\/variables-\/in-\/classes)}}
\DoxyCodeLine{4311 }
\DoxyCodeLine{4312   \textcolor{keyword}{protected}:}
\DoxyCodeLine{4313     JSON\_HEDLEY\_NON\_NULL(3)}
\DoxyCodeLine{4314     \mbox{\hyperlink{classdetail_1_1exception}{exception}}(\textcolor{keywordtype}{int} id\_, const \textcolor{keywordtype}{char}* what\_arg) : \textcolor{keywordtype}{id}(id\_), m(what\_arg) \{\} \textcolor{comment}{// NOLINT(bugprone-\/throw-\/keyword-\/missing)}}
\DoxyCodeLine{4315 }
\DoxyCodeLine{4316     \textcolor{keyword}{static} std::string name(\textcolor{keyword}{const} std::string\& ename, \textcolor{keywordtype}{int} id\_)}
\DoxyCodeLine{4317     \{}
\DoxyCodeLine{4318         \textcolor{keywordflow}{return} concat(\textcolor{stringliteral}{"{}[json.exception."{}}, ename, \textcolor{charliteral}{'.'}, std::to\_string(id\_), \textcolor{stringliteral}{"{}] "{}});}
\DoxyCodeLine{4319     \}}
\DoxyCodeLine{4320 }
\DoxyCodeLine{4321     \textcolor{keyword}{static} std::string diagnostics(std::nullptr\_t \textcolor{comment}{/*leaf\_element*/})}
\DoxyCodeLine{4322     \{}
\DoxyCodeLine{4323         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4324     \}}
\DoxyCodeLine{4325 }
\DoxyCodeLine{4326     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{4327     \textcolor{keyword}{static} std::string diagnostics(\textcolor{keyword}{const} BasicJsonType* leaf\_element)}
\DoxyCodeLine{4328     \{}
\DoxyCodeLine{4329 \textcolor{preprocessor}{\#if JSON\_DIAGNOSTICS}}
\DoxyCodeLine{4330         std::vector<std::string> tokens;}
\DoxyCodeLine{4331         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}* current = leaf\_element; current != \textcolor{keyword}{nullptr} \&\& current-\/>m\_parent != \textcolor{keyword}{nullptr}; current = current-\/>m\_parent)}
\DoxyCodeLine{4332         \{}
\DoxyCodeLine{4333             \textcolor{keywordflow}{switch} (current-\/>m\_parent-\/>type())}
\DoxyCodeLine{4334             \{}
\DoxyCodeLine{4335                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}}:}
\DoxyCodeLine{4336                 \{}
\DoxyCodeLine{4337                     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < current-\/>m\_parent-\/>m\_value.array-\/>size(); ++i)}
\DoxyCodeLine{4338                     \{}
\DoxyCodeLine{4339                         \textcolor{keywordflow}{if} (\&current-\/>m\_parent-\/>m\_value.array-\/>operator[](i) == current)}
\DoxyCodeLine{4340                         \{}
\DoxyCodeLine{4341                             tokens.emplace\_back(std::to\_string(i));}
\DoxyCodeLine{4342                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4343                         \}}
\DoxyCodeLine{4344                     \}}
\DoxyCodeLine{4345                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{4346                 \}}
\DoxyCodeLine{4347 }
\DoxyCodeLine{4348                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{value\_t::object}}:}
\DoxyCodeLine{4349                 \{}
\DoxyCodeLine{4350                     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& element : *current-\/>m\_parent-\/>m\_value.object)}
\DoxyCodeLine{4351                     \{}
\DoxyCodeLine{4352                         \textcolor{keywordflow}{if} (\&element.second == current)}
\DoxyCodeLine{4353                         \{}
\DoxyCodeLine{4354                             tokens.emplace\_back(element.first.c\_str());}
\DoxyCodeLine{4355                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4356                         \}}
\DoxyCodeLine{4357                     \}}
\DoxyCodeLine{4358                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{4359                 \}}
\DoxyCodeLine{4360 }
\DoxyCodeLine{4361                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{value\_t::null}}: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{4362                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}}: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{4363                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{value\_t::boolean}}: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{4364                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{value\_t::number\_integer}}: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{4365                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{value\_t::number\_unsigned}}: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{4366                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{value\_t::number\_float}}: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{4367                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{value\_t::binary}}: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{4368                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{value\_t::discarded}}: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{4369                 \textcolor{keywordflow}{default}:   \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{4370                     \textcolor{keywordflow}{break}; \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{4371             \}}
\DoxyCodeLine{4372         \}}
\DoxyCodeLine{4373 }
\DoxyCodeLine{4374         \textcolor{keywordflow}{if} (tokens.empty())}
\DoxyCodeLine{4375         \{}
\DoxyCodeLine{4376             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4377         \}}
\DoxyCodeLine{4378 }
\DoxyCodeLine{4379         \textcolor{keyword}{auto} str = std::accumulate(tokens.rbegin(), tokens.rend(), std::string\{\},}
\DoxyCodeLine{4380                                    [](\textcolor{keyword}{const} std::string \& a, \textcolor{keyword}{const} std::string \& b)}
\DoxyCodeLine{4381         \{}
\DoxyCodeLine{4382             return concat(a, \textcolor{stringliteral}{'/'}, detail::escape(b));}
\DoxyCodeLine{4383         \});}
\DoxyCodeLine{4384         \textcolor{keywordflow}{return} concat(\textcolor{charliteral}{'('}, str, \textcolor{stringliteral}{"{}) "{}});}
\DoxyCodeLine{4385 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4386         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(leaf\_element);}
\DoxyCodeLine{4387         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4388 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4389     \}}
\DoxyCodeLine{4390 }
\DoxyCodeLine{4391   \textcolor{keyword}{private}:}
\DoxyCodeLine{4393     std::runtime\_error m;}
\DoxyCodeLine{4394 \};}
\DoxyCodeLine{4395 }
\DoxyCodeLine{4398 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1parse__error}{parse\_error}} : \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1exception}{exception}}}
\DoxyCodeLine{4399 \{}
\DoxyCodeLine{4400   \textcolor{keyword}{public}:}
\DoxyCodeLine{4410     template<typename BasicJsonContext, enable\_if\_t<is\_basic\_json\_context<BasicJsonContext>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4411     \textcolor{keyword}{static} \mbox{\hyperlink{classdetail_1_1parse__error}{parse\_error}} \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{create}}(\textcolor{keywordtype}{int} id\_, \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1position__t}{position\_t}}\& pos, \textcolor{keyword}{const} std::string\& what\_arg, BasicJsonContext context)}
\DoxyCodeLine{4412     \{}
\DoxyCodeLine{4413         std::string w = concat(exception::name(\textcolor{stringliteral}{"{}parse\_error"{}}, id\_), \textcolor{stringliteral}{"{}parse error"{}},}
\DoxyCodeLine{4414                                position\_string(pos), \textcolor{stringliteral}{"{}: "{}}, exception::diagnostics(context), what\_arg);}
\DoxyCodeLine{4415         \textcolor{keywordflow}{return} \{id\_, pos.\mbox{\hyperlink{structdetail_1_1position__t_ac4d220d61ce61eeffbea40985727a3b0}{chars\_read\_total}}, w.c\_str()\};}
\DoxyCodeLine{4416     \}}
\DoxyCodeLine{4417 }
\DoxyCodeLine{4418     template<typename BasicJsonContext, enable\_if\_t<is\_basic\_json\_context<BasicJsonContext>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4419     \textcolor{keyword}{static} \mbox{\hyperlink{classdetail_1_1parse__error}{parse\_error}} \mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{create}}(\textcolor{keywordtype}{int} id\_, std::size\_t byte\_, \textcolor{keyword}{const} std::string\& what\_arg, BasicJsonContext context)}
\DoxyCodeLine{4420     \{}
\DoxyCodeLine{4421         std::string w = concat(exception::name(\textcolor{stringliteral}{"{}parse\_error"{}}, id\_), \textcolor{stringliteral}{"{}parse error"{}},}
\DoxyCodeLine{4422                                (byte\_ != 0 ? (concat(\textcolor{stringliteral}{"{} at byte "{}}, std::to\_string(byte\_))) : \textcolor{stringliteral}{"{}"{}}),}
\DoxyCodeLine{4423                                \textcolor{stringliteral}{"{}: "{}}, exception::diagnostics(context), what\_arg);}
\DoxyCodeLine{4424         \textcolor{keywordflow}{return} \{id\_, byte\_, w.c\_str()\};}
\DoxyCodeLine{4425     \}}
\DoxyCodeLine{4426 }
\DoxyCodeLine{4436     \textcolor{keyword}{const} std::size\_t \mbox{\hyperlink{classdetail_1_1parse__error_a5bce7d135aa3a38d1d3f4ed7bf8615e1}{byte}};}
\DoxyCodeLine{4437 }
\DoxyCodeLine{4438   \textcolor{keyword}{private}:}
\DoxyCodeLine{4439     \mbox{\hyperlink{classdetail_1_1parse__error}{parse\_error}}(\textcolor{keywordtype}{int} id\_, std::size\_t byte\_, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what\_arg)}
\DoxyCodeLine{4440         : \mbox{\hyperlink{classdetail_1_1exception}{exception}}(id\_, what\_arg), \mbox{\hyperlink{classdetail_1_1parse__error_a5bce7d135aa3a38d1d3f4ed7bf8615e1}{byte}}(byte\_) \{\}}
\DoxyCodeLine{4441 }
\DoxyCodeLine{4442     \textcolor{keyword}{static} std::string position\_string(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1position__t}{position\_t}}\& pos)}
\DoxyCodeLine{4443     \{}
\DoxyCodeLine{4444         \textcolor{keywordflow}{return} concat(\textcolor{stringliteral}{"{} at line "{}}, std::to\_string(pos.\mbox{\hyperlink{structdetail_1_1position__t_a9ec1ac6600d1364f4d1c9f67de6a670b}{lines\_read}} + 1),}
\DoxyCodeLine{4445                       \textcolor{stringliteral}{"{}, column "{}}, std::to\_string(pos.\mbox{\hyperlink{structdetail_1_1position__t_a6548d584bd03d1d47bfcd7cf8b1fb0c6}{chars\_read\_current\_line}}));}
\DoxyCodeLine{4446     \}}
\DoxyCodeLine{4447 \};}
\DoxyCodeLine{4448 }
\DoxyCodeLine{4451 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1invalid__iterator}{invalid\_iterator}} : \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1exception}{exception}}}
\DoxyCodeLine{4452 \{}
\DoxyCodeLine{4453   \textcolor{keyword}{public}:}
\DoxyCodeLine{4454     template<typename BasicJsonContext, enable\_if\_t<is\_basic\_json\_context<BasicJsonContext>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4455     \textcolor{keyword}{static} \mbox{\hyperlink{classdetail_1_1invalid__iterator}{invalid\_iterator}} create(\textcolor{keywordtype}{int} id\_, \textcolor{keyword}{const} std::string\& what\_arg, BasicJsonContext context)}
\DoxyCodeLine{4456     \{}
\DoxyCodeLine{4457         std::string w = concat(exception::name(\textcolor{stringliteral}{"{}invalid\_iterator"{}}, id\_), exception::diagnostics(context), what\_arg);}
\DoxyCodeLine{4458         \textcolor{keywordflow}{return} \{id\_, w.c\_str()\};}
\DoxyCodeLine{4459     \}}
\DoxyCodeLine{4460 }
\DoxyCodeLine{4461   \textcolor{keyword}{private}:}
\DoxyCodeLine{4462     JSON\_HEDLEY\_NON\_NULL(3)}
\DoxyCodeLine{4463     \mbox{\hyperlink{classdetail_1_1invalid__iterator}{invalid\_iterator}}(\textcolor{keywordtype}{int} id\_, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what\_arg)}
\DoxyCodeLine{4464         : \mbox{\hyperlink{classdetail_1_1exception}{exception}}(id\_, what\_arg) \{\}}
\DoxyCodeLine{4465 \};}
\DoxyCodeLine{4466 }
\DoxyCodeLine{4469 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1type__error}{type\_error}} : \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1exception}{exception}}}
\DoxyCodeLine{4470 \{}
\DoxyCodeLine{4471   \textcolor{keyword}{public}:}
\DoxyCodeLine{4472     template<typename BasicJsonContext, enable\_if\_t<is\_basic\_json\_context<BasicJsonContext>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4473     \textcolor{keyword}{static} \mbox{\hyperlink{classdetail_1_1type__error}{type\_error}} create(\textcolor{keywordtype}{int} id\_, \textcolor{keyword}{const} std::string\& what\_arg, BasicJsonContext context)}
\DoxyCodeLine{4474     \{}
\DoxyCodeLine{4475         std::string w = concat(exception::name(\textcolor{stringliteral}{"{}type\_error"{}}, id\_), exception::diagnostics(context), what\_arg);}
\DoxyCodeLine{4476         \textcolor{keywordflow}{return} \{id\_, w.c\_str()\};}
\DoxyCodeLine{4477     \}}
\DoxyCodeLine{4478 }
\DoxyCodeLine{4479   \textcolor{keyword}{private}:}
\DoxyCodeLine{4480     JSON\_HEDLEY\_NON\_NULL(3)}
\DoxyCodeLine{4481     \mbox{\hyperlink{classdetail_1_1type__error}{type\_error}}(\textcolor{keywordtype}{int} id\_, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what\_arg) : \mbox{\hyperlink{classdetail_1_1exception}{exception}}(id\_, what\_arg) \{\}}
\DoxyCodeLine{4482 \};}
\DoxyCodeLine{4483 }
\DoxyCodeLine{4486 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1out__of__range}{out\_of\_range}} : \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1exception}{exception}}}
\DoxyCodeLine{4487 \{}
\DoxyCodeLine{4488   \textcolor{keyword}{public}:}
\DoxyCodeLine{4489     template<typename BasicJsonContext, enable\_if\_t<is\_basic\_json\_context<BasicJsonContext>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4490     \textcolor{keyword}{static} \mbox{\hyperlink{classdetail_1_1out__of__range}{out\_of\_range}} create(\textcolor{keywordtype}{int} id\_, \textcolor{keyword}{const} std::string\& what\_arg, BasicJsonContext context)}
\DoxyCodeLine{4491     \{}
\DoxyCodeLine{4492         std::string w = concat(exception::name(\textcolor{stringliteral}{"{}out\_of\_range"{}}, id\_), exception::diagnostics(context), what\_arg);}
\DoxyCodeLine{4493         \textcolor{keywordflow}{return} \{id\_, w.c\_str()\};}
\DoxyCodeLine{4494     \}}
\DoxyCodeLine{4495 }
\DoxyCodeLine{4496   \textcolor{keyword}{private}:}
\DoxyCodeLine{4497     JSON\_HEDLEY\_NON\_NULL(3)}
\DoxyCodeLine{4498     \mbox{\hyperlink{classdetail_1_1out__of__range}{out\_of\_range}}(\textcolor{keywordtype}{int} id\_, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what\_arg) : \mbox{\hyperlink{classdetail_1_1exception}{exception}}(id\_, what\_arg) \{\}}
\DoxyCodeLine{4499 \};}
\DoxyCodeLine{4500 }
\DoxyCodeLine{4503 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1other__error}{other\_error}} : \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1exception}{exception}}}
\DoxyCodeLine{4504 \{}
\DoxyCodeLine{4505   \textcolor{keyword}{public}:}
\DoxyCodeLine{4506     template<typename BasicJsonContext, enable\_if\_t<is\_basic\_json\_context<BasicJsonContext>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4507     \textcolor{keyword}{static} \mbox{\hyperlink{classdetail_1_1other__error}{other\_error}} create(\textcolor{keywordtype}{int} id\_, \textcolor{keyword}{const} std::string\& what\_arg, BasicJsonContext context)}
\DoxyCodeLine{4508     \{}
\DoxyCodeLine{4509         std::string w = concat(exception::name(\textcolor{stringliteral}{"{}other\_error"{}}, id\_), exception::diagnostics(context), what\_arg);}
\DoxyCodeLine{4510         \textcolor{keywordflow}{return} \{id\_, w.c\_str()\};}
\DoxyCodeLine{4511     \}}
\DoxyCodeLine{4512 }
\DoxyCodeLine{4513   \textcolor{keyword}{private}:}
\DoxyCodeLine{4514     JSON\_HEDLEY\_NON\_NULL(3)}
\DoxyCodeLine{4515     \mbox{\hyperlink{classdetail_1_1other__error}{other\_error}}(\textcolor{keywordtype}{int} id\_, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what\_arg) : \mbox{\hyperlink{classdetail_1_1exception}{exception}}(id\_, what\_arg) \{\}}
\DoxyCodeLine{4516 \};}
\DoxyCodeLine{4517 }
\DoxyCodeLine{4518 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{4519 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{4520 }
\DoxyCodeLine{4521 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{4522 }
\DoxyCodeLine{4523 \textcolor{comment}{// \#include <nlohmann/detail/meta/cpp\_future.hpp>}}
\DoxyCodeLine{4524 }
\DoxyCodeLine{4525 \textcolor{comment}{// \#include <nlohmann/detail/meta/identity\_tag.hpp>}}
\DoxyCodeLine{4526 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{4527 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{4528 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{4529 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{4530 \textcolor{comment}{//}}
\DoxyCodeLine{4531 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{4532 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{4533 }
\DoxyCodeLine{4534 }
\DoxyCodeLine{4535 }
\DoxyCodeLine{4536 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{4537 }
\DoxyCodeLine{4538 }
\DoxyCodeLine{4539 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{4540 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{4541 \{}
\DoxyCodeLine{4542 }
\DoxyCodeLine{4543 \textcolor{comment}{// dispatching helper struct}}
\DoxyCodeLine{4544 \textcolor{keyword}{template} <\textcolor{keyword}{class} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1identity__tag}{identity\_tag}} \{\};}
\DoxyCodeLine{4545 }
\DoxyCodeLine{4546 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{4547 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{4548 }
\DoxyCodeLine{4549 \textcolor{comment}{// \#include <nlohmann/detail/meta/std\_fs.hpp>}}
\DoxyCodeLine{4550 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{4551 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{4552 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{4553 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{4554 \textcolor{comment}{//}}
\DoxyCodeLine{4555 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{4556 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{4557 }
\DoxyCodeLine{4558 }
\DoxyCodeLine{4559 }
\DoxyCodeLine{4560 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{4561 }
\DoxyCodeLine{4562 }
\DoxyCodeLine{4563 \textcolor{preprocessor}{\#if JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{4564 \textcolor{preprocessor}{\#include <experimental/filesystem>}}
\DoxyCodeLine{4565 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{4566 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{4567 \{}
\DoxyCodeLine{4568 \textcolor{keyword}{namespace }std\_fs = std::experimental::filesystem;}
\DoxyCodeLine{4569 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{4570 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{4571 \textcolor{preprocessor}{\#elif JSON\_HAS\_FILESYSTEM}}
\DoxyCodeLine{4572 \textcolor{preprocessor}{\#include <filesystem>}}
\DoxyCodeLine{4573 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{4574 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{4575 \{}
\DoxyCodeLine{4576 \textcolor{keyword}{namespace }std\_fs = std::filesystem;}
\DoxyCodeLine{4577 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{4578 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{4579 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4580 }
\DoxyCodeLine{4581 \textcolor{comment}{// \#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{4582 }
\DoxyCodeLine{4583 \textcolor{comment}{// \#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{4584 }
\DoxyCodeLine{4585 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{4586 }
\DoxyCodeLine{4587 }
\DoxyCodeLine{4588 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{4589 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{4590 \{}
\DoxyCodeLine{4591 }
\DoxyCodeLine{4592 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{4593 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} std::nullptr\_t\& n)}
\DoxyCodeLine{4594 \{}
\DoxyCodeLine{4595     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_null()))}
\DoxyCodeLine{4596     \{}
\DoxyCodeLine{4597         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be null, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4598     \}}
\DoxyCodeLine{4599     n = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{4600 \}}
\DoxyCodeLine{4601 }
\DoxyCodeLine{4602 \textcolor{comment}{// overloads for basic\_json template parameters}}
\DoxyCodeLine{4603 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ArithmeticType,}
\DoxyCodeLine{4604            enable\_if\_t < std::is\_arithmetic<ArithmeticType>::value\&\&}
\DoxyCodeLine{4605                          !std::is\_same<ArithmeticType, typename BasicJsonType::boolean\_t>::value,}
\DoxyCodeLine{4606                          \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{4607 \textcolor{keywordtype}{void} get\_arithmetic\_value(\textcolor{keyword}{const} BasicJsonType\& j, ArithmeticType\& val)}
\DoxyCodeLine{4608 \{}
\DoxyCodeLine{4609     \textcolor{keywordflow}{switch} (\textcolor{keyword}{static\_cast<}\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}\textcolor{keyword}{>}(j))}
\DoxyCodeLine{4610     \{}
\DoxyCodeLine{4611         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{value\_t::number\_unsigned}}:}
\DoxyCodeLine{4612         \{}
\DoxyCodeLine{4613             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_unsigned\_t*>());}
\DoxyCodeLine{4614             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4615         \}}
\DoxyCodeLine{4616         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{value\_t::number\_integer}}:}
\DoxyCodeLine{4617         \{}
\DoxyCodeLine{4618             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_integer\_t*>());}
\DoxyCodeLine{4619             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4620         \}}
\DoxyCodeLine{4621         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{value\_t::number\_float}}:}
\DoxyCodeLine{4622         \{}
\DoxyCodeLine{4623             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_float\_t*>());}
\DoxyCodeLine{4624             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4625         \}}
\DoxyCodeLine{4626 }
\DoxyCodeLine{4627         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{value\_t::null}}:}
\DoxyCodeLine{4628         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{value\_t::object}}:}
\DoxyCodeLine{4629         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}}:}
\DoxyCodeLine{4630         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}}:}
\DoxyCodeLine{4631         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{value\_t::boolean}}:}
\DoxyCodeLine{4632         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{value\_t::binary}}:}
\DoxyCodeLine{4633         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{value\_t::discarded}}:}
\DoxyCodeLine{4634         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{4635             JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be number, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4636     \}}
\DoxyCodeLine{4637 \}}
\DoxyCodeLine{4638 }
\DoxyCodeLine{4639 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{4640 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::boolean\_t\& b)}
\DoxyCodeLine{4641 \{}
\DoxyCodeLine{4642     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_boolean()))}
\DoxyCodeLine{4643     \{}
\DoxyCodeLine{4644         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be boolean, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4645     \}}
\DoxyCodeLine{4646     b = *j.template get\_ptr<const typename BasicJsonType::boolean\_t*>();}
\DoxyCodeLine{4647 \}}
\DoxyCodeLine{4648 }
\DoxyCodeLine{4649 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{4650 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::string\_t\& s)}
\DoxyCodeLine{4651 \{}
\DoxyCodeLine{4652     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_string()))}
\DoxyCodeLine{4653     \{}
\DoxyCodeLine{4654         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be string, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4655     \}}
\DoxyCodeLine{4656     s = *j.template get\_ptr<const typename BasicJsonType::string\_t*>();}
\DoxyCodeLine{4657 \}}
\DoxyCodeLine{4658 }
\DoxyCodeLine{4659 \textcolor{keyword}{template} <}
\DoxyCodeLine{4660     \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} StringType,}
\DoxyCodeLine{4661     enable\_if\_t <}
\DoxyCodeLine{4662         std::is\_assignable<StringType\&, const typename BasicJsonType::string\_t>::value}
\DoxyCodeLine{4663         \&\& is\_detected\_exact<typename BasicJsonType::string\_t::value\_type, value\_type\_t, StringType>::value}
\DoxyCodeLine{4664         \&\& !std::is\_same<typename BasicJsonType::string\_t, StringType>::value}
\DoxyCodeLine{4665         \&\& !is\_json\_ref<StringType>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{4666 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, StringType\& s)}
\DoxyCodeLine{4667 \{}
\DoxyCodeLine{4668     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_string()))}
\DoxyCodeLine{4669     \{}
\DoxyCodeLine{4670         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be string, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4671     \}}
\DoxyCodeLine{4672 }
\DoxyCodeLine{4673     s = *j.template get\_ptr<const typename BasicJsonType::string\_t*>();}
\DoxyCodeLine{4674 \}}
\DoxyCodeLine{4675 }
\DoxyCodeLine{4676 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{4677 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::number\_float\_t\& val)}
\DoxyCodeLine{4678 \{}
\DoxyCodeLine{4679     get\_arithmetic\_value(j, val);}
\DoxyCodeLine{4680 \}}
\DoxyCodeLine{4681 }
\DoxyCodeLine{4682 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{4683 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t\& val)}
\DoxyCodeLine{4684 \{}
\DoxyCodeLine{4685     get\_arithmetic\_value(j, val);}
\DoxyCodeLine{4686 \}}
\DoxyCodeLine{4687 }
\DoxyCodeLine{4688 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{4689 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t\& val)}
\DoxyCodeLine{4690 \{}
\DoxyCodeLine{4691     get\_arithmetic\_value(j, val);}
\DoxyCodeLine{4692 \}}
\DoxyCodeLine{4693 }
\DoxyCodeLine{4694 \textcolor{preprocessor}{\#if !JSON\_DISABLE\_ENUM\_SERIALIZATION}}
\DoxyCodeLine{4695 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} EnumType,}
\DoxyCodeLine{4696          enable\_if\_t<std::is\_enum<EnumType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4697 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, EnumType\& e)}
\DoxyCodeLine{4698 \{}
\DoxyCodeLine{4699     \textcolor{keyword}{typename} std::underlying\_type<EnumType>::type val;}
\DoxyCodeLine{4700     get\_arithmetic\_value(j, val);}
\DoxyCodeLine{4701     e = \textcolor{keyword}{static\_cast<}EnumType\textcolor{keyword}{>}(val);}
\DoxyCodeLine{4702 \}}
\DoxyCodeLine{4703 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_DISABLE\_ENUM\_SERIALIZATION}}
\DoxyCodeLine{4704 }
\DoxyCodeLine{4705 \textcolor{comment}{// forward\_list doesn't have an insert method}}
\DoxyCodeLine{4706 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Allocator,}
\DoxyCodeLine{4707          enable\_if\_t<is\_getable<BasicJsonType, T>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4708 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, std::forward\_list<T, Allocator>\& l)}
\DoxyCodeLine{4709 \{}
\DoxyCodeLine{4710     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{4711     \{}
\DoxyCodeLine{4712         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4713     \}}
\DoxyCodeLine{4714     l.clear();}
\DoxyCodeLine{4715     std::transform(j.rbegin(), j.rend(),}
\DoxyCodeLine{4716                    std::front\_inserter(l), [](\textcolor{keyword}{const} BasicJsonType \& i)}
\DoxyCodeLine{4717     \{}
\DoxyCodeLine{4718         return i.template get<T>();}
\DoxyCodeLine{4719     \});}
\DoxyCodeLine{4720 \}}
\DoxyCodeLine{4721 }
\DoxyCodeLine{4722 \textcolor{comment}{// valarray doesn't have an insert method}}
\DoxyCodeLine{4723 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{4724          enable\_if\_t<is\_getable<BasicJsonType, T>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4725 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, std::valarray<T>\& l)}
\DoxyCodeLine{4726 \{}
\DoxyCodeLine{4727     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{4728     \{}
\DoxyCodeLine{4729         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4730     \}}
\DoxyCodeLine{4731     l.resize(j.size());}
\DoxyCodeLine{4732     std::transform(j.begin(), j.end(), std::begin(l),}
\DoxyCodeLine{4733                    [](\textcolor{keyword}{const} BasicJsonType \& elem)}
\DoxyCodeLine{4734     \{}
\DoxyCodeLine{4735         return elem.template get<T>();}
\DoxyCodeLine{4736     \});}
\DoxyCodeLine{4737 \}}
\DoxyCodeLine{4738 }
\DoxyCodeLine{4739 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{4740 \textcolor{keyword}{auto} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, T (\&arr)[N])  \textcolor{comment}{// NOLINT(cppcoreguidelines-\/avoid-\/c-\/arrays,hicpp-\/avoid-\/c-\/arrays,modernize-\/avoid-\/c-\/arrays)}}
\DoxyCodeLine{4741 -\/> \textcolor{keyword}{decltype}(j.template get<T>(), void())}
\DoxyCodeLine{4742 \{}
\DoxyCodeLine{4743     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < N; ++i)}
\DoxyCodeLine{4744     \{}
\DoxyCodeLine{4745         arr[i] = j.at(i).template get<T>();}
\DoxyCodeLine{4746     \}}
\DoxyCodeLine{4747 \}}
\DoxyCodeLine{4748 }
\DoxyCodeLine{4749 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{4750 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json\_array\_impl(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::array\_t\& arr, priority\_tag<3> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{4751 \{}
\DoxyCodeLine{4752     arr = *j.template get\_ptr<const typename BasicJsonType::array\_t*>();}
\DoxyCodeLine{4753 \}}
\DoxyCodeLine{4754 }
\DoxyCodeLine{4755 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{4756 \textcolor{keyword}{auto} from\_json\_array\_impl(\textcolor{keyword}{const} BasicJsonType\& j, std::array<T, N>\& arr,}
\DoxyCodeLine{4757                           priority\_tag<2> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{4758 -\/> \textcolor{keyword}{decltype}(j.template get<T>(), void())}
\DoxyCodeLine{4759 \{}
\DoxyCodeLine{4760     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < N; ++i)}
\DoxyCodeLine{4761     \{}
\DoxyCodeLine{4762         arr[i] = j.at(i).template get<T>();}
\DoxyCodeLine{4763     \}}
\DoxyCodeLine{4764 \}}
\DoxyCodeLine{4765 }
\DoxyCodeLine{4766 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleArrayType,}
\DoxyCodeLine{4767          enable\_if\_t<}
\DoxyCodeLine{4768              std::is\_assignable<ConstructibleArrayType\&, ConstructibleArrayType>::value,}
\DoxyCodeLine{4769              \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4770 \textcolor{keyword}{auto} from\_json\_array\_impl(\textcolor{keyword}{const} BasicJsonType\& j, ConstructibleArrayType\& arr, priority\_tag<1> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{4771 -\/> \textcolor{keyword}{decltype}(}
\DoxyCodeLine{4772     arr.reserve(std::declval<typename ConstructibleArrayType::size\_type>()),}
\DoxyCodeLine{4773     j.template get<typename ConstructibleArrayType::value\_type>(),}
\DoxyCodeLine{4774     void())}
\DoxyCodeLine{4775 \{}
\DoxyCodeLine{4776     \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{4777 }
\DoxyCodeLine{4778     ConstructibleArrayType ret;}
\DoxyCodeLine{4779     ret.reserve(j.size());}
\DoxyCodeLine{4780     std::transform(j.begin(), j.end(),}
\DoxyCodeLine{4781                    std::inserter(ret, end(ret)), [](\textcolor{keyword}{const} BasicJsonType \& i)}
\DoxyCodeLine{4782     \{}
\DoxyCodeLine{4783         \textcolor{comment}{// get<BasicJsonType>() returns *this, this won't call a from\_json}}
\DoxyCodeLine{4784         \textcolor{comment}{// method when value\_type is BasicJsonType}}
\DoxyCodeLine{4785         \textcolor{keywordflow}{return} i.template get<typename ConstructibleArrayType::value\_type>();}
\DoxyCodeLine{4786     \});}
\DoxyCodeLine{4787     arr = std::move(ret);}
\DoxyCodeLine{4788 \}}
\DoxyCodeLine{4789 }
\DoxyCodeLine{4790 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleArrayType,}
\DoxyCodeLine{4791          enable\_if\_t<}
\DoxyCodeLine{4792              std::is\_assignable<ConstructibleArrayType\&, ConstructibleArrayType>::value,}
\DoxyCodeLine{4793              \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4794 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json\_array\_impl(\textcolor{keyword}{const} BasicJsonType\& j, ConstructibleArrayType\& arr,}
\DoxyCodeLine{4795                                  priority\_tag<0> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{4796 \{}
\DoxyCodeLine{4797     \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{4798 }
\DoxyCodeLine{4799     ConstructibleArrayType ret;}
\DoxyCodeLine{4800     std::transform(}
\DoxyCodeLine{4801         j.begin(), j.end(), std::inserter(ret, end(ret)),}
\DoxyCodeLine{4802         [](\textcolor{keyword}{const} BasicJsonType \& i)}
\DoxyCodeLine{4803     \{}
\DoxyCodeLine{4804         \textcolor{comment}{// get<BasicJsonType>() returns *this, this won't call a from\_json}}
\DoxyCodeLine{4805         \textcolor{comment}{// method when value\_type is BasicJsonType}}
\DoxyCodeLine{4806         \textcolor{keywordflow}{return} i.template get<typename ConstructibleArrayType::value\_type>();}
\DoxyCodeLine{4807     \});}
\DoxyCodeLine{4808     arr = std::move(ret);}
\DoxyCodeLine{4809 \}}
\DoxyCodeLine{4810 }
\DoxyCodeLine{4811 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleArrayType,}
\DoxyCodeLine{4812            enable\_if\_t <}
\DoxyCodeLine{4813                is\_constructible\_array\_type<BasicJsonType, ConstructibleArrayType>::value\&\&}
\DoxyCodeLine{4814                !is\_constructible\_object\_type<BasicJsonType, ConstructibleArrayType>::value\&\&}
\DoxyCodeLine{4815                !is\_constructible\_string\_type<BasicJsonType, ConstructibleArrayType>::value\&\&}
\DoxyCodeLine{4816                !std::is\_same<ConstructibleArrayType, typename BasicJsonType::binary\_t>::value\&\&}
\DoxyCodeLine{4817                !is\_basic\_json<ConstructibleArrayType>::value,}
\DoxyCodeLine{4818                \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{4819 \textcolor{keyword}{auto} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, ConstructibleArrayType\& arr)}
\DoxyCodeLine{4820 -\/> \textcolor{keyword}{decltype}(from\_json\_array\_impl(j, arr, priority\_tag<3> \{\}),}
\DoxyCodeLine{4821 j.template get<typename ConstructibleArrayType::value\_type>(),}
\DoxyCodeLine{4822 void())}
\DoxyCodeLine{4823 \{}
\DoxyCodeLine{4824     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{4825     \{}
\DoxyCodeLine{4826         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4827     \}}
\DoxyCodeLine{4828 }
\DoxyCodeLine{4829     from\_json\_array\_impl(j, arr, priority\_tag<3> \{\});}
\DoxyCodeLine{4830 \}}
\DoxyCodeLine{4831 }
\DoxyCodeLine{4832 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, std::size\_t... Idx >}
\DoxyCodeLine{4833 std::array<T, \textcolor{keyword}{sizeof}...(Idx)> from\_json\_inplace\_array\_impl(BasicJsonType\&\& j,}
\DoxyCodeLine{4834         identity\_tag<std::array<T, \textcolor{keyword}{sizeof}...(Idx)>> \textcolor{comment}{/*unused*/}, index\_sequence<Idx...> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{4835 \{}
\DoxyCodeLine{4836     \textcolor{keywordflow}{return} \{ \{ std::forward<BasicJsonType>(j).at(Idx).template get<T>()... \} \};}
\DoxyCodeLine{4837 \}}
\DoxyCodeLine{4838 }
\DoxyCodeLine{4839 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N >}
\DoxyCodeLine{4840 \textcolor{keyword}{auto} from\_json(BasicJsonType\&\& j, identity\_tag<std::array<T, N>> tag)}
\DoxyCodeLine{4841 -\/> \textcolor{keyword}{decltype}(from\_json\_inplace\_array\_impl(std::forward<BasicJsonType>(j), tag, make\_index\_sequence<N> \{\}))}
\DoxyCodeLine{4842 \{}
\DoxyCodeLine{4843     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{4844     \{}
\DoxyCodeLine{4845         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4846     \}}
\DoxyCodeLine{4847 }
\DoxyCodeLine{4848     \textcolor{keywordflow}{return} from\_json\_inplace\_array\_impl(std::forward<BasicJsonType>(j), tag, make\_index\_sequence<N> \{\});}
\DoxyCodeLine{4849 \}}
\DoxyCodeLine{4850 }
\DoxyCodeLine{4851 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{4852 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::binary\_t\& bin)}
\DoxyCodeLine{4853 \{}
\DoxyCodeLine{4854     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_binary()))}
\DoxyCodeLine{4855     \{}
\DoxyCodeLine{4856         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be binary, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4857     \}}
\DoxyCodeLine{4858 }
\DoxyCodeLine{4859     bin = *j.template get\_ptr<const typename BasicJsonType::binary\_t*>();}
\DoxyCodeLine{4860 \}}
\DoxyCodeLine{4861 }
\DoxyCodeLine{4862 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ConstructibleObjectType,}
\DoxyCodeLine{4863          enable\_if\_t<is\_constructible\_object\_type<BasicJsonType, ConstructibleObjectType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{4864 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, ConstructibleObjectType\& obj)}
\DoxyCodeLine{4865 \{}
\DoxyCodeLine{4866     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_object()))}
\DoxyCodeLine{4867     \{}
\DoxyCodeLine{4868         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be object, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4869     \}}
\DoxyCodeLine{4870 }
\DoxyCodeLine{4871     ConstructibleObjectType ret;}
\DoxyCodeLine{4872     \textcolor{keyword}{const} \textcolor{keyword}{auto}* inner\_object = j.template get\_ptr<const typename BasicJsonType::object\_t*>();}
\DoxyCodeLine{4873     \textcolor{keyword}{using }value\_type = \textcolor{keyword}{typename} ConstructibleObjectType::value\_type;}
\DoxyCodeLine{4874     std::transform(}
\DoxyCodeLine{4875         inner\_object-\/>begin(), inner\_object-\/>end(),}
\DoxyCodeLine{4876         std::inserter(ret, ret.begin()),}
\DoxyCodeLine{4877         [](\textcolor{keyword}{typename} BasicJsonType::object\_t::value\_type \textcolor{keyword}{const} \& p)}
\DoxyCodeLine{4878     \{}
\DoxyCodeLine{4879         return value\_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped\_type>());}
\DoxyCodeLine{4880     \});}
\DoxyCodeLine{4881     obj = std::move(ret);}
\DoxyCodeLine{4882 \}}
\DoxyCodeLine{4883 }
\DoxyCodeLine{4884 \textcolor{comment}{// overload for arithmetic types, not chosen for basic\_json template arguments}}
\DoxyCodeLine{4885 \textcolor{comment}{// (BooleanType, etc..); note: Is it really necessary to provide explicit}}
\DoxyCodeLine{4886 \textcolor{comment}{// overloads for boolean\_t etc. in case of a custom BooleanType which is not}}
\DoxyCodeLine{4887 \textcolor{comment}{// an arithmetic type?}}
\DoxyCodeLine{4888 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} ArithmeticType,}
\DoxyCodeLine{4889            enable\_if\_t <}
\DoxyCodeLine{4890                std::is\_arithmetic<ArithmeticType>::value\&\&}
\DoxyCodeLine{4891                !std::is\_same<ArithmeticType, typename BasicJsonType::number\_unsigned\_t>::value\&\&}
\DoxyCodeLine{4892                !std::is\_same<ArithmeticType, typename BasicJsonType::number\_integer\_t>::value\&\&}
\DoxyCodeLine{4893                !std::is\_same<ArithmeticType, typename BasicJsonType::number\_float\_t>::value\&\&}
\DoxyCodeLine{4894                !std::is\_same<ArithmeticType, typename BasicJsonType::boolean\_t>::value,}
\DoxyCodeLine{4895                \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{4896 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, ArithmeticType\& val)}
\DoxyCodeLine{4897 \{}
\DoxyCodeLine{4898     \textcolor{keywordflow}{switch} (\textcolor{keyword}{static\_cast<}\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}\textcolor{keyword}{>}(j))}
\DoxyCodeLine{4899     \{}
\DoxyCodeLine{4900         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{value\_t::number\_unsigned}}:}
\DoxyCodeLine{4901         \{}
\DoxyCodeLine{4902             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_unsigned\_t*>());}
\DoxyCodeLine{4903             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4904         \}}
\DoxyCodeLine{4905         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{value\_t::number\_integer}}:}
\DoxyCodeLine{4906         \{}
\DoxyCodeLine{4907             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_integer\_t*>());}
\DoxyCodeLine{4908             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4909         \}}
\DoxyCodeLine{4910         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{value\_t::number\_float}}:}
\DoxyCodeLine{4911         \{}
\DoxyCodeLine{4912             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::number\_float\_t*>());}
\DoxyCodeLine{4913             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4914         \}}
\DoxyCodeLine{4915         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{value\_t::boolean}}:}
\DoxyCodeLine{4916         \{}
\DoxyCodeLine{4917             val = \textcolor{keyword}{static\_cast<}ArithmeticType\textcolor{keyword}{>}(*j.template get\_ptr<const typename BasicJsonType::boolean\_t*>());}
\DoxyCodeLine{4918             \textcolor{keywordflow}{break};}
\DoxyCodeLine{4919         \}}
\DoxyCodeLine{4920 }
\DoxyCodeLine{4921         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{value\_t::null}}:}
\DoxyCodeLine{4922         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{value\_t::object}}:}
\DoxyCodeLine{4923         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}}:}
\DoxyCodeLine{4924         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}}:}
\DoxyCodeLine{4925         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{value\_t::binary}}:}
\DoxyCodeLine{4926         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{value\_t::discarded}}:}
\DoxyCodeLine{4927         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{4928             JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be number, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4929     \}}
\DoxyCodeLine{4930 \}}
\DoxyCodeLine{4931 }
\DoxyCodeLine{4932 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename}... Args, std::size\_t... Idx>}
\DoxyCodeLine{4933 std::tuple<Args...> from\_json\_tuple\_impl\_base(BasicJsonType\&\& j, index\_sequence<Idx...> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{4934 \{}
\DoxyCodeLine{4935     \textcolor{keywordflow}{return} std::make\_tuple(std::forward<BasicJsonType>(j).at(Idx).\textcolor{keyword}{template} get<Args>()...);}
\DoxyCodeLine{4936 \}}
\DoxyCodeLine{4937 }
\DoxyCodeLine{4938 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{class} A1, \textcolor{keyword}{class} A2 >}
\DoxyCodeLine{4939 std::pair<A1, A2> from\_json\_tuple\_impl(BasicJsonType\&\& j, identity\_tag<std::pair<A1, A2>> \textcolor{comment}{/*unused*/}, priority\_tag<0> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{4940 \{}
\DoxyCodeLine{4941     \textcolor{keywordflow}{return} \{std::forward<BasicJsonType>(j).at(0).template get<A1>(),}
\DoxyCodeLine{4942             std::forward<BasicJsonType>(j).at(1).template get<A2>()\};}
\DoxyCodeLine{4943 \}}
\DoxyCodeLine{4944 }
\DoxyCodeLine{4945 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} A1, \textcolor{keyword}{typename} A2>}
\DoxyCodeLine{4946 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json\_tuple\_impl(BasicJsonType\&\& j, std::pair<A1, A2>\& p, priority\_tag<1> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{4947 \{}
\DoxyCodeLine{4948     p = from\_json\_tuple\_impl(std::forward<BasicJsonType>(j), identity\_tag<std::pair<A1, A2>> \{\}, priority\_tag<0> \{\});}
\DoxyCodeLine{4949 \}}
\DoxyCodeLine{4950 }
\DoxyCodeLine{4951 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{4952 std::tuple<Args...> from\_json\_tuple\_impl(BasicJsonType\&\& j, identity\_tag<std::tuple<Args...>> \textcolor{comment}{/*unused*/}, priority\_tag<2> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{4953 \{}
\DoxyCodeLine{4954     \textcolor{keywordflow}{return} from\_json\_tuple\_impl\_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index\_sequence\_for<Args...> \{\});}
\DoxyCodeLine{4955 \}}
\DoxyCodeLine{4956 }
\DoxyCodeLine{4957 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{4958 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json\_tuple\_impl(BasicJsonType\&\& j, std::tuple<Args...>\& t, priority\_tag<3> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{4959 \{}
\DoxyCodeLine{4960     t = from\_json\_tuple\_impl\_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index\_sequence\_for<Args...> \{\});}
\DoxyCodeLine{4961 \}}
\DoxyCodeLine{4962 }
\DoxyCodeLine{4963 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} TupleRelated>}
\DoxyCodeLine{4964 \textcolor{keyword}{auto} from\_json(BasicJsonType\&\& j, TupleRelated\&\& t)}
\DoxyCodeLine{4965 -\/> \textcolor{keyword}{decltype}(from\_json\_tuple\_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority\_tag<3> \{\}))}
\DoxyCodeLine{4966 \{}
\DoxyCodeLine{4967     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{4968     \{}
\DoxyCodeLine{4969         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4970     \}}
\DoxyCodeLine{4971 }
\DoxyCodeLine{4972     \textcolor{keywordflow}{return} from\_json\_tuple\_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority\_tag<3> \{\});}
\DoxyCodeLine{4973 \}}
\DoxyCodeLine{4974 }
\DoxyCodeLine{4975 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} Key, \textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} Compare, \textcolor{keyword}{typename} Allocator,}
\DoxyCodeLine{4976            \textcolor{keyword}{typename} = enable\_if\_t < !std::is\_constructible <}
\DoxyCodeLine{4977                                         \textcolor{keyword}{typename} BasicJsonType::string\_t, Key >::value >>}
\DoxyCodeLine{4978 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, std::map<Key, Value, Compare, Allocator>\& m)}
\DoxyCodeLine{4979 \{}
\DoxyCodeLine{4980     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{4981     \{}
\DoxyCodeLine{4982         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{4983     \}}
\DoxyCodeLine{4984     m.clear();}
\DoxyCodeLine{4985     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& p : j)}
\DoxyCodeLine{4986     \{}
\DoxyCodeLine{4987         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!p.is\_array()))}
\DoxyCodeLine{4988         \{}
\DoxyCodeLine{4989             JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, p.type\_name()), \&j));}
\DoxyCodeLine{4990         \}}
\DoxyCodeLine{4991         m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());}
\DoxyCodeLine{4992     \}}
\DoxyCodeLine{4993 \}}
\DoxyCodeLine{4994 }
\DoxyCodeLine{4995 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} Key, \textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} Hash, \textcolor{keyword}{typename} KeyEqual, \textcolor{keyword}{typename} Allocator,}
\DoxyCodeLine{4996            \textcolor{keyword}{typename} = enable\_if\_t < !std::is\_constructible <}
\DoxyCodeLine{4997                                         \textcolor{keyword}{typename} BasicJsonType::string\_t, Key >::value >>}
\DoxyCodeLine{4998 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, std::unordered\_map<Key, Value, Hash, KeyEqual, Allocator>\& m)}
\DoxyCodeLine{4999 \{}
\DoxyCodeLine{5000     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_array()))}
\DoxyCodeLine{5001     \{}
\DoxyCodeLine{5002         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{5003     \}}
\DoxyCodeLine{5004     m.clear();}
\DoxyCodeLine{5005     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& p : j)}
\DoxyCodeLine{5006     \{}
\DoxyCodeLine{5007         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!p.is\_array()))}
\DoxyCodeLine{5008         \{}
\DoxyCodeLine{5009             JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be array, but is "{}}, p.type\_name()), \&j));}
\DoxyCodeLine{5010         \}}
\DoxyCodeLine{5011         m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());}
\DoxyCodeLine{5012     \}}
\DoxyCodeLine{5013 \}}
\DoxyCodeLine{5014 }
\DoxyCodeLine{5015 \textcolor{preprocessor}{\#if JSON\_HAS\_FILESYSTEM || JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{5016 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5017 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} from\_json(\textcolor{keyword}{const} BasicJsonType\& j, std\_fs::path\& p)}
\DoxyCodeLine{5018 \{}
\DoxyCodeLine{5019     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!j.is\_string()))}
\DoxyCodeLine{5020     \{}
\DoxyCodeLine{5021         JSON\_THROW(type\_error::create(302, concat(\textcolor{stringliteral}{"{}type must be string, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{5022     \}}
\DoxyCodeLine{5023     p = *j.template get\_ptr<const typename BasicJsonType::string\_t*>();}
\DoxyCodeLine{5024 \}}
\DoxyCodeLine{5025 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5026 }
\DoxyCodeLine{5027 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1from__json__fn}{from\_json\_fn}}}
\DoxyCodeLine{5028 \{}
\DoxyCodeLine{5029     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{5030     \textcolor{keyword}{auto} operator()(\textcolor{keyword}{const} BasicJsonType\& j, T\&\& val) \textcolor{keyword}{const}}
\DoxyCodeLine{5031     \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(from\_json(j, std::forward<T>(val))))}
\DoxyCodeLine{5032     -\/> \textcolor{keyword}{decltype}(from\_json(j, std::forward<T>(val)))}
\DoxyCodeLine{5033     \{}
\DoxyCodeLine{5034         \textcolor{keywordflow}{return} from\_json(j, std::forward<T>(val));}
\DoxyCodeLine{5035     \}}
\DoxyCodeLine{5036 \};}
\DoxyCodeLine{5037 }
\DoxyCodeLine{5038 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{5039 }
\DoxyCodeLine{5040 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{5044 \textcolor{keyword}{namespace }\textcolor{comment}{// NOLINT(cert-\/dcl59-\/cpp,fuchsia-\/header-\/anon-\/namespaces,google-\/build-\/namespaces)}}
\DoxyCodeLine{5045 \{}
\DoxyCodeLine{5046 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5047 JSON\_INLINE\_VARIABLE \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto}\& from\_json = \textcolor{comment}{// NOLINT(misc-\/definitions-\/in-\/headers)}}
\DoxyCodeLine{5048     \mbox{\hyperlink{structdetail_1_1static__const}{detail::static\_const<detail::from\_json\_fn>::value}};}
\DoxyCodeLine{5049 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{5050 \}  \textcolor{comment}{// namespace}}
\DoxyCodeLine{5051 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5052 }
\DoxyCodeLine{5053 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{5054 }
\DoxyCodeLine{5055 \textcolor{comment}{// \#include <nlohmann/detail/conversions/to\_json.hpp>}}
\DoxyCodeLine{5056 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{5057 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{5058 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{5059 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{5060 \textcolor{comment}{//}}
\DoxyCodeLine{5061 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{5062 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{5063 }
\DoxyCodeLine{5064 }
\DoxyCodeLine{5065 }
\DoxyCodeLine{5066 \textcolor{preprocessor}{\#include <algorithm>} \textcolor{comment}{// copy}}
\DoxyCodeLine{5067 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// begin, end}}
\DoxyCodeLine{5068 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{5069 \textcolor{preprocessor}{\#include <tuple>} \textcolor{comment}{// tuple, get}}
\DoxyCodeLine{5070 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// is\_same, is\_constructible, is\_floating\_point, is\_enum, underlying\_type}}
\DoxyCodeLine{5071 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// move, forward, declval, pair}}
\DoxyCodeLine{5072 \textcolor{preprocessor}{\#include <valarray>} \textcolor{comment}{// valarray}}
\DoxyCodeLine{5073 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{5074 }
\DoxyCodeLine{5075 \textcolor{comment}{// \#include <nlohmann/detail/iterators/iteration\_proxy.hpp>}}
\DoxyCodeLine{5076 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{5077 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{5078 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{5079 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{5080 \textcolor{comment}{//}}
\DoxyCodeLine{5081 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{5082 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{5083 }
\DoxyCodeLine{5084 }
\DoxyCodeLine{5085 }
\DoxyCodeLine{5086 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{5087 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// input\_iterator\_tag}}
\DoxyCodeLine{5088 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string, to\_string}}
\DoxyCodeLine{5089 \textcolor{preprocessor}{\#include <tuple>} \textcolor{comment}{// tuple\_size, get, tuple\_element}}
\DoxyCodeLine{5090 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// move}}
\DoxyCodeLine{5091 }
\DoxyCodeLine{5092 \textcolor{preprocessor}{\#if JSON\_HAS\_RANGES}}
\DoxyCodeLine{5093 \textcolor{preprocessor}{    \#include <ranges>} \textcolor{comment}{// enable\_borrowed\_range}}
\DoxyCodeLine{5094 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5095 }
\DoxyCodeLine{5096 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{5097 }
\DoxyCodeLine{5098 \textcolor{comment}{// \#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{5099 }
\DoxyCodeLine{5100 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{5101 }
\DoxyCodeLine{5102 }
\DoxyCodeLine{5103 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{5104 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{5105 \{}
\DoxyCodeLine{5106 }
\DoxyCodeLine{5107 \textcolor{keyword}{template}<\textcolor{keyword}{typename} \textcolor{keywordtype}{string}\_type>}
\DoxyCodeLine{5108 \textcolor{keywordtype}{void} int\_to\_string( string\_type\& target, std::size\_t value )}
\DoxyCodeLine{5109 \{}
\DoxyCodeLine{5110     \textcolor{comment}{// For ADL}}
\DoxyCodeLine{5111     \textcolor{keyword}{using }std::to\_string;}
\DoxyCodeLine{5112     target = to\_string(value);}
\DoxyCodeLine{5113 \}}
\DoxyCodeLine{5114 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}}
\DoxyCodeLine{5115 \{}
\DoxyCodeLine{5116   \textcolor{keyword}{public}:}
\DoxyCodeLine{5117     \textcolor{keyword}{using }difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{5118     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{value\_type}} = \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}};}
\DoxyCodeLine{5119     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{pointer}} = \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{value\_type}} *;}
\DoxyCodeLine{5120     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{reference}} = \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{value\_type}} \&;}
\DoxyCodeLine{5121     \textcolor{keyword}{using }iterator\_category = std::input\_iterator\_tag;}
\DoxyCodeLine{5122     \textcolor{keyword}{using }string\_type = \textcolor{keyword}{typename} std::remove\_cv< typename std::remove\_reference<decltype( std::declval<IteratorType>().\mbox{\hyperlink{classdetail_1_1iteration__proxy__value_ad12633bc0d3ac7a651381b174a7914ee}{key}}() ) >::type >::type;}
\DoxyCodeLine{5123 }
\DoxyCodeLine{5124   \textcolor{keyword}{private}:}
\DoxyCodeLine{5126     IteratorType anchor\{\};}
\DoxyCodeLine{5128     std::size\_t array\_index = 0;}
\DoxyCodeLine{5130     \textcolor{keyword}{mutable} std::size\_t array\_index\_last = 0;}
\DoxyCodeLine{5132     \textcolor{keyword}{mutable} string\_type array\_index\_str = \textcolor{stringliteral}{"{}0"{}};}
\DoxyCodeLine{5134     string\_type empty\_str\{\};}
\DoxyCodeLine{5135 }
\DoxyCodeLine{5136   \textcolor{keyword}{public}:}
\DoxyCodeLine{5137     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5138     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}(IteratorType it, std::size\_t array\_index\_ = 0)}
\DoxyCodeLine{5139     \textcolor{keyword}{noexcept}(std::is\_nothrow\_move\_constructible<IteratorType>::value}
\DoxyCodeLine{5140              \&\& std::is\_nothrow\_default\_constructible<string\_type>::value)}
\DoxyCodeLine{5141         : anchor(std::move(it))}
\DoxyCodeLine{5142         , array\_index(array\_index\_)}
\DoxyCodeLine{5143     \{\}}
\DoxyCodeLine{5144 }
\DoxyCodeLine{5145     \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}(\mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}} \textcolor{keyword}{const}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5146     \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}\& operator=(\mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}} \textcolor{keyword}{const}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5147     \textcolor{comment}{// older GCCs are a bit fussy and require explicit noexcept specifiers on defaulted functions}}
\DoxyCodeLine{5148     \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}(\mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}\&\&)}
\DoxyCodeLine{5149     \textcolor{keyword}{noexcept}(std::is\_nothrow\_move\_constructible<IteratorType>::value}
\DoxyCodeLine{5150              \&\& std::is\_nothrow\_move\_constructible<string\_type>::value) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5151     \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}\& operator=(\mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}\&\&)}
\DoxyCodeLine{5152     \textcolor{keyword}{noexcept}(std::is\_nothrow\_move\_assignable<IteratorType>::value}
\DoxyCodeLine{5153              \&\& std::is\_nothrow\_move\_assignable<string\_type>::value) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5154     \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{\string~iteration\_proxy\_value}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5155 }
\DoxyCodeLine{5157     \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}\& \mbox{\hyperlink{classdetail_1_1iteration__proxy__value_a54d22aec1f615a38697466817d7cc819}{operator*}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{5158 \textcolor{keyword}{    }\{}
\DoxyCodeLine{5159         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{5160     \}}
\DoxyCodeLine{5161 }
\DoxyCodeLine{5163     \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}\& \mbox{\hyperlink{classdetail_1_1iteration__proxy__value_a52dffef3e0c58a6bcd5b8b9e6fcf4552}{operator++}}()}
\DoxyCodeLine{5164     \{}
\DoxyCodeLine{5165         ++anchor;}
\DoxyCodeLine{5166         ++array\_index;}
\DoxyCodeLine{5167 }
\DoxyCodeLine{5168         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{5169     \}}
\DoxyCodeLine{5170 }
\DoxyCodeLine{5171     \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value_a52dffef3e0c58a6bcd5b8b9e6fcf4552}{operator++}}(\textcolor{keywordtype}{int})\& \textcolor{comment}{// NOLINT(cert-\/dcl21-\/cpp)}}
\DoxyCodeLine{5172     \{}
\DoxyCodeLine{5173         \textcolor{keyword}{auto} tmp = \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}(anchor, array\_index);}
\DoxyCodeLine{5174         ++anchor;}
\DoxyCodeLine{5175         ++array\_index;}
\DoxyCodeLine{5176         \textcolor{keywordflow}{return} tmp;}
\DoxyCodeLine{5177     \}}
\DoxyCodeLine{5178 }
\DoxyCodeLine{5180     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value_a139d22be442a277268cfb78bb4eef95d}{operator==}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}\& o)\textcolor{keyword}{ const}}
\DoxyCodeLine{5181 \textcolor{keyword}{    }\{}
\DoxyCodeLine{5182         \textcolor{keywordflow}{return} anchor == o.anchor;}
\DoxyCodeLine{5183     \}}
\DoxyCodeLine{5184 }
\DoxyCodeLine{5186     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value_a23745b98de19578adc4efb509e59be28}{operator!=}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}\& o)\textcolor{keyword}{ const}}
\DoxyCodeLine{5187 \textcolor{keyword}{    }\{}
\DoxyCodeLine{5188         \textcolor{keywordflow}{return} anchor != o.anchor;}
\DoxyCodeLine{5189     \}}
\DoxyCodeLine{5190 }
\DoxyCodeLine{5192     \textcolor{keyword}{const} string\_type\& \mbox{\hyperlink{classdetail_1_1iteration__proxy__value_ad12633bc0d3ac7a651381b174a7914ee}{key}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{5193 \textcolor{keyword}{    }\{}
\DoxyCodeLine{5194         JSON\_ASSERT(anchor.m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{5195 }
\DoxyCodeLine{5196         \textcolor{keywordflow}{switch} (anchor.m\_object-\/>type())}
\DoxyCodeLine{5197         \{}
\DoxyCodeLine{5198             \textcolor{comment}{// use integer array index as key}}
\DoxyCodeLine{5199             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}}:}
\DoxyCodeLine{5200             \{}
\DoxyCodeLine{5201                 \textcolor{keywordflow}{if} (array\_index != array\_index\_last)}
\DoxyCodeLine{5202                 \{}
\DoxyCodeLine{5203                     int\_to\_string( array\_index\_str, array\_index );}
\DoxyCodeLine{5204                     array\_index\_last = array\_index;}
\DoxyCodeLine{5205                 \}}
\DoxyCodeLine{5206                 \textcolor{keywordflow}{return} array\_index\_str;}
\DoxyCodeLine{5207             \}}
\DoxyCodeLine{5208 }
\DoxyCodeLine{5209             \textcolor{comment}{// use key from the object}}
\DoxyCodeLine{5210             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{value\_t::object}}:}
\DoxyCodeLine{5211                 \textcolor{keywordflow}{return} anchor.key();}
\DoxyCodeLine{5212 }
\DoxyCodeLine{5213             \textcolor{comment}{// use an empty key for all primitive types}}
\DoxyCodeLine{5214             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{value\_t::null}}:}
\DoxyCodeLine{5215             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}}:}
\DoxyCodeLine{5216             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{value\_t::boolean}}:}
\DoxyCodeLine{5217             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{value\_t::number\_integer}}:}
\DoxyCodeLine{5218             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{value\_t::number\_unsigned}}:}
\DoxyCodeLine{5219             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{value\_t::number\_float}}:}
\DoxyCodeLine{5220             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{value\_t::binary}}:}
\DoxyCodeLine{5221             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{value\_t::discarded}}:}
\DoxyCodeLine{5222             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{5223                 \textcolor{keywordflow}{return} empty\_str;}
\DoxyCodeLine{5224         \}}
\DoxyCodeLine{5225     \}}
\DoxyCodeLine{5226 }
\DoxyCodeLine{5228     \textcolor{keyword}{typename} IteratorType::reference \mbox{\hyperlink{classdetail_1_1iteration__proxy__value_aac08993af9f4f0bf3d058b4beae36a45}{value}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{5229 \textcolor{keyword}{    }\{}
\DoxyCodeLine{5230         \textcolor{keywordflow}{return} anchor.value();}
\DoxyCodeLine{5231     \}}
\DoxyCodeLine{5232 \};}
\DoxyCodeLine{5233 }
\DoxyCodeLine{5235 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}}}
\DoxyCodeLine{5236 \{}
\DoxyCodeLine{5237   \textcolor{keyword}{private}:}
\DoxyCodeLine{5239     \textcolor{keyword}{typename} IteratorType::pointer container = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{5240 }
\DoxyCodeLine{5241   \textcolor{keyword}{public}:}
\DoxyCodeLine{5242     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5243 }
\DoxyCodeLine{5245     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1iteration__proxy_abc711365efc12210a983fba0e39b5811}{iteration\_proxy}}(\textcolor{keyword}{typename} IteratorType::reference cont) noexcept}
\DoxyCodeLine{5246         : container(\&cont) \{\}}
\DoxyCodeLine{5247 }
\DoxyCodeLine{5248     \mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}}(\mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}} \textcolor{keyword}{const}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5249     \mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}}\& operator=(\mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}} \textcolor{keyword}{const}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5250     \mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}}(\mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}}\&\&) noexcept = default;}
\DoxyCodeLine{5251     \mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}}\& operator=(\mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}}\&\&) noexcept = default;}
\DoxyCodeLine{5252     \string~\mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy}}() = default;}
\DoxyCodeLine{5253 }
\DoxyCodeLine{5255     \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value}}<IteratorType> \mbox{\hyperlink{classdetail_1_1iteration__proxy_a8d35bb0cd56024e1ab1c7277de32e2ab}{begin}}() const noexcept}
\DoxyCodeLine{5256     \{}
\DoxyCodeLine{5257         \textcolor{keywordflow}{return} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value<IteratorType>}}(container-\/>begin());}
\DoxyCodeLine{5258     \}}
\DoxyCodeLine{5259 }
\DoxyCodeLine{5261     \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value<IteratorType>}} \mbox{\hyperlink{classdetail_1_1iteration__proxy_a1037b697552341a5697fa15ee95250d1}{end}}() const noexcept}
\DoxyCodeLine{5262     \{}
\DoxyCodeLine{5263         \textcolor{keywordflow}{return} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value<IteratorType>}}(container-\/>end());}
\DoxyCodeLine{5264     \}}
\DoxyCodeLine{5265 \};}
\DoxyCodeLine{5266 }
\DoxyCodeLine{5267 \textcolor{comment}{// Structured Bindings Support}}
\DoxyCodeLine{5268 \textcolor{comment}{// For further reference see https://blog.tartanllama.xyz/structured-\/bindings/}}
\DoxyCodeLine{5269 \textcolor{comment}{// And see https://github.com/nlohmann/json/pull/1391}}
\DoxyCodeLine{5270 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} IteratorType, enable\_if\_t<N == 0, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5271 \textcolor{keyword}{auto} get(\textcolor{keyword}{const} nlohmann::detail::iteration\_proxy\_value<IteratorType>\& i) -\/> \textcolor{keyword}{decltype}(i.key())}
\DoxyCodeLine{5272 \{}
\DoxyCodeLine{5273     \textcolor{keywordflow}{return} i.key();}
\DoxyCodeLine{5274 \}}
\DoxyCodeLine{5275 \textcolor{comment}{// Structured Bindings Support}}
\DoxyCodeLine{5276 \textcolor{comment}{// For further reference see https://blog.tartanllama.xyz/structured-\/bindings/}}
\DoxyCodeLine{5277 \textcolor{comment}{// And see https://github.com/nlohmann/json/pull/1391}}
\DoxyCodeLine{5278 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} IteratorType, enable\_if\_t<N == 1, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5279 \textcolor{keyword}{auto} get(\textcolor{keyword}{const} nlohmann::detail::iteration\_proxy\_value<IteratorType>\& i) -\/> \textcolor{keyword}{decltype}(i.value())}
\DoxyCodeLine{5280 \{}
\DoxyCodeLine{5281     \textcolor{keywordflow}{return} i.value();}
\DoxyCodeLine{5282 \}}
\DoxyCodeLine{5283 }
\DoxyCodeLine{5284 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{5285 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{5286 }
\DoxyCodeLine{5287 \textcolor{comment}{// The Addition to the STD Namespace is required to add}}
\DoxyCodeLine{5288 \textcolor{comment}{// Structured Bindings Support to the iteration\_proxy\_value class}}
\DoxyCodeLine{5289 \textcolor{comment}{// For further reference see https://blog.tartanllama.xyz/structured-\/bindings/}}
\DoxyCodeLine{5290 \textcolor{comment}{// And see https://github.com/nlohmann/json/pull/1391}}
\DoxyCodeLine{5291 \textcolor{keyword}{namespace }std}
\DoxyCodeLine{5292 \{}
\DoxyCodeLine{5293 }
\DoxyCodeLine{5294 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{5295     \textcolor{comment}{// Fix: https://github.com/nlohmann/json/issues/1401}}
\DoxyCodeLine{5296 \textcolor{preprocessor}{    \#pragma clang diagnostic push}}
\DoxyCodeLine{5297 \textcolor{preprocessor}{    \#pragma clang diagnostic ignored "{}-\/Wmismatched-\/tags"{}}}
\DoxyCodeLine{5298 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5299 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{5300 \textcolor{keyword}{class }tuple\_size<::nlohmann::detail::iteration\_proxy\_value<IteratorType>>}
\DoxyCodeLine{5301             : \textcolor{keyword}{public} std::integral\_constant<std::size\_t, 2> \{\};}
\DoxyCodeLine{5302 }
\DoxyCodeLine{5303 \textcolor{keyword}{template}<std::\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{5304 \textcolor{keyword}{class }tuple\_element<N, ::nlohmann::detail::iteration\_proxy\_value<IteratorType >>}
\DoxyCodeLine{5305 \{}
\DoxyCodeLine{5306   \textcolor{keyword}{public}:}
\DoxyCodeLine{5307     \textcolor{keyword}{using }type = \textcolor{keyword}{decltype}(}
\DoxyCodeLine{5308                      get<N>(std::declval <}
\DoxyCodeLine{5309                             ::nlohmann::detail::iteration\_proxy\_value<IteratorType >> ()));}
\DoxyCodeLine{5310 \};}
\DoxyCodeLine{5311 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{5312 \textcolor{preprocessor}{    \#pragma clang diagnostic pop}}
\DoxyCodeLine{5313 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5314 }
\DoxyCodeLine{5315 \}  \textcolor{comment}{// namespace std}}
\DoxyCodeLine{5316 }
\DoxyCodeLine{5317 \textcolor{preprocessor}{\#if JSON\_HAS\_RANGES}}
\DoxyCodeLine{5318     \textcolor{keyword}{template} <\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{5319     \textcolor{keyword}{inline} \textcolor{keyword}{constexpr} bool ::std::ranges::enable\_borrowed\_range<::nlohmann::detail::iteration\_proxy<IteratorType>> = \textcolor{keyword}{true};}
\DoxyCodeLine{5320 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5321 }
\DoxyCodeLine{5322 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{5323 }
\DoxyCodeLine{5324 \textcolor{comment}{// \#include <nlohmann/detail/meta/cpp\_future.hpp>}}
\DoxyCodeLine{5325 }
\DoxyCodeLine{5326 \textcolor{comment}{// \#include <nlohmann/detail/meta/std\_fs.hpp>}}
\DoxyCodeLine{5327 }
\DoxyCodeLine{5328 \textcolor{comment}{// \#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{5329 }
\DoxyCodeLine{5330 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{5331 }
\DoxyCodeLine{5332 }
\DoxyCodeLine{5333 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{5334 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{5335 \{}
\DoxyCodeLine{5336 }
\DoxyCodeLine{5338 \textcolor{comment}{// constructors //}}
\DoxyCodeLine{5340 \textcolor{comment}{}}
\DoxyCodeLine{5341 \textcolor{comment}{/*}}
\DoxyCodeLine{5342 \textcolor{comment}{ * Note all external\_constructor<>::construct functions need to call}}
\DoxyCodeLine{5343 \textcolor{comment}{ * j.m\_value.destroy(j.m\_type) to avoid a memory leak in case j contains an}}
\DoxyCodeLine{5344 \textcolor{comment}{ * allocated value (e.g., a string). See bug issue}}
\DoxyCodeLine{5345 \textcolor{comment}{ * https://github.com/nlohmann/json/issues/2865 for more information.}}
\DoxyCodeLine{5346 \textcolor{comment}{ */}}
\DoxyCodeLine{5347 }
\DoxyCodeLine{5348 \textcolor{keyword}{template}<value\_t> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1external__constructor}{external\_constructor}};}
\DoxyCodeLine{5349 }
\DoxyCodeLine{5350 \textcolor{keyword}{template}<>}
\DoxyCodeLine{5351 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1external__constructor}{external\_constructor}}<\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}::\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{boolean}}>}
\DoxyCodeLine{5352 \{}
\DoxyCodeLine{5353     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5354     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::boolean\_t b) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5355     \{}
\DoxyCodeLine{5356         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5357         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{value\_t::boolean}};}
\DoxyCodeLine{5358         j.m\_value = b;}
\DoxyCodeLine{5359         j.assert\_invariant();}
\DoxyCodeLine{5360     \}}
\DoxyCodeLine{5361 \};}
\DoxyCodeLine{5362 }
\DoxyCodeLine{5363 \textcolor{keyword}{template}<>}
\DoxyCodeLine{5364 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1external__constructor}{external\_constructor}}<\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}::\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{string}}>}
\DoxyCodeLine{5365 \{}
\DoxyCodeLine{5366     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5367     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::string\_t\& s)}
\DoxyCodeLine{5368     \{}
\DoxyCodeLine{5369         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5370         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}};}
\DoxyCodeLine{5371         j.m\_value = s;}
\DoxyCodeLine{5372         j.assert\_invariant();}
\DoxyCodeLine{5373     \}}
\DoxyCodeLine{5374 }
\DoxyCodeLine{5375     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5376     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::string\_t\&\& s)}
\DoxyCodeLine{5377     \{}
\DoxyCodeLine{5378         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5379         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}};}
\DoxyCodeLine{5380         j.m\_value = std::move(s);}
\DoxyCodeLine{5381         j.assert\_invariant();}
\DoxyCodeLine{5382     \}}
\DoxyCodeLine{5383 }
\DoxyCodeLine{5384     \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleStringType,}
\DoxyCodeLine{5385                enable\_if\_t < !std::is\_same<CompatibleStringType, typename BasicJsonType::string\_t>::value,}
\DoxyCodeLine{5386                              \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{5387     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{const} CompatibleStringType\& str)}
\DoxyCodeLine{5388     \{}
\DoxyCodeLine{5389         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5390         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}};}
\DoxyCodeLine{5391         j.m\_value.string = j.template create<typename BasicJsonType::string\_t>(str);}
\DoxyCodeLine{5392         j.assert\_invariant();}
\DoxyCodeLine{5393     \}}
\DoxyCodeLine{5394 \};}
\DoxyCodeLine{5395 }
\DoxyCodeLine{5396 \textcolor{keyword}{template}<>}
\DoxyCodeLine{5397 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1external__constructor}{external\_constructor}}<\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}::\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{binary}}>}
\DoxyCodeLine{5398 \{}
\DoxyCodeLine{5399     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5400     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::binary\_t\& b)}
\DoxyCodeLine{5401     \{}
\DoxyCodeLine{5402         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5403         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{value\_t::binary}};}
\DoxyCodeLine{5404         j.m\_value = \textcolor{keyword}{typename} BasicJsonType::binary\_t(b);}
\DoxyCodeLine{5405         j.assert\_invariant();}
\DoxyCodeLine{5406     \}}
\DoxyCodeLine{5407 }
\DoxyCodeLine{5408     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5409     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::binary\_t\&\& b)}
\DoxyCodeLine{5410     \{}
\DoxyCodeLine{5411         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5412         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{value\_t::binary}};}
\DoxyCodeLine{5413         j.m\_value = \textcolor{keyword}{typename} BasicJsonType::binary\_t(std::move(b));}
\DoxyCodeLine{5414         j.assert\_invariant();}
\DoxyCodeLine{5415     \}}
\DoxyCodeLine{5416 \};}
\DoxyCodeLine{5417 }
\DoxyCodeLine{5418 \textcolor{keyword}{template}<>}
\DoxyCodeLine{5419 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1external__constructor}{external\_constructor}}<\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}::\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{number\_float}}>}
\DoxyCodeLine{5420 \{}
\DoxyCodeLine{5421     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5422     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::number\_float\_t val) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5423     \{}
\DoxyCodeLine{5424         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5425         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{value\_t::number\_float}};}
\DoxyCodeLine{5426         j.m\_value = val;}
\DoxyCodeLine{5427         j.assert\_invariant();}
\DoxyCodeLine{5428     \}}
\DoxyCodeLine{5429 \};}
\DoxyCodeLine{5430 }
\DoxyCodeLine{5431 \textcolor{keyword}{template}<>}
\DoxyCodeLine{5432 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1external__constructor}{external\_constructor}}<\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}::\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{number\_unsigned}}>}
\DoxyCodeLine{5433 \{}
\DoxyCodeLine{5434     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5435     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t val) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5436     \{}
\DoxyCodeLine{5437         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5438         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{value\_t::number\_unsigned}};}
\DoxyCodeLine{5439         j.m\_value = val;}
\DoxyCodeLine{5440         j.assert\_invariant();}
\DoxyCodeLine{5441     \}}
\DoxyCodeLine{5442 \};}
\DoxyCodeLine{5443 }
\DoxyCodeLine{5444 \textcolor{keyword}{template}<>}
\DoxyCodeLine{5445 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1external__constructor}{external\_constructor}}<\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}::\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{number\_integer}}>}
\DoxyCodeLine{5446 \{}
\DoxyCodeLine{5447     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5448     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t val) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5449     \{}
\DoxyCodeLine{5450         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5451         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{value\_t::number\_integer}};}
\DoxyCodeLine{5452         j.m\_value = val;}
\DoxyCodeLine{5453         j.assert\_invariant();}
\DoxyCodeLine{5454     \}}
\DoxyCodeLine{5455 \};}
\DoxyCodeLine{5456 }
\DoxyCodeLine{5457 \textcolor{keyword}{template}<>}
\DoxyCodeLine{5458 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1external__constructor}{external\_constructor}}<\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}::\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}}>}
\DoxyCodeLine{5459 \{}
\DoxyCodeLine{5460     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5461     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::array\_t\& arr)}
\DoxyCodeLine{5462     \{}
\DoxyCodeLine{5463         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5464         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}};}
\DoxyCodeLine{5465         j.m\_value = arr;}
\DoxyCodeLine{5466         j.set\_parents();}
\DoxyCodeLine{5467         j.assert\_invariant();}
\DoxyCodeLine{5468     \}}
\DoxyCodeLine{5469 }
\DoxyCodeLine{5470     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5471     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::array\_t\&\& arr)}
\DoxyCodeLine{5472     \{}
\DoxyCodeLine{5473         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5474         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}};}
\DoxyCodeLine{5475         j.m\_value = std::move(arr);}
\DoxyCodeLine{5476         j.set\_parents();}
\DoxyCodeLine{5477         j.assert\_invariant();}
\DoxyCodeLine{5478     \}}
\DoxyCodeLine{5479 }
\DoxyCodeLine{5480     \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleArrayType,}
\DoxyCodeLine{5481                enable\_if\_t < !std::is\_same<CompatibleArrayType, typename BasicJsonType::array\_t>::value,}
\DoxyCodeLine{5482                              \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{5483     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{const} CompatibleArrayType\& arr)}
\DoxyCodeLine{5484     \{}
\DoxyCodeLine{5485         \textcolor{keyword}{using }std::begin;}
\DoxyCodeLine{5486         \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{5487 }
\DoxyCodeLine{5488         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5489         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}};}
\DoxyCodeLine{5490         j.m\_value.array = j.template create<typename BasicJsonType::array\_t>(begin(arr), end(arr));}
\DoxyCodeLine{5491         j.set\_parents();}
\DoxyCodeLine{5492         j.assert\_invariant();}
\DoxyCodeLine{5493     \}}
\DoxyCodeLine{5494 }
\DoxyCodeLine{5495     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5496     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{const} std::vector<bool>\& arr)}
\DoxyCodeLine{5497     \{}
\DoxyCodeLine{5498         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5499         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}};}
\DoxyCodeLine{5500         j.m\_value = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}};}
\DoxyCodeLine{5501         j.m\_value.array-\/>reserve(arr.size());}
\DoxyCodeLine{5502         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keywordtype}{bool} x : arr)}
\DoxyCodeLine{5503         \{}
\DoxyCodeLine{5504             j.m\_value.array-\/>push\_back(x);}
\DoxyCodeLine{5505             j.set\_parent(j.m\_value.array-\/>back());}
\DoxyCodeLine{5506         \}}
\DoxyCodeLine{5507         j.assert\_invariant();}
\DoxyCodeLine{5508     \}}
\DoxyCodeLine{5509 }
\DoxyCodeLine{5510     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{5511              enable\_if\_t<std::is\_convertible<T, BasicJsonType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5512     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{const} std::valarray<T>\& arr)}
\DoxyCodeLine{5513     \{}
\DoxyCodeLine{5514         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5515         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}};}
\DoxyCodeLine{5516         j.m\_value = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}};}
\DoxyCodeLine{5517         j.m\_value.array-\/>resize(arr.size());}
\DoxyCodeLine{5518         \textcolor{keywordflow}{if} (arr.size() > 0)}
\DoxyCodeLine{5519         \{}
\DoxyCodeLine{5520             std::copy(std::begin(arr), std::end(arr), j.m\_value.array-\/>begin());}
\DoxyCodeLine{5521         \}}
\DoxyCodeLine{5522         j.set\_parents();}
\DoxyCodeLine{5523         j.assert\_invariant();}
\DoxyCodeLine{5524     \}}
\DoxyCodeLine{5525 \};}
\DoxyCodeLine{5526 }
\DoxyCodeLine{5527 \textcolor{keyword}{template}<>}
\DoxyCodeLine{5528 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1external__constructor}{external\_constructor}}<\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}::\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{object}}>}
\DoxyCodeLine{5529 \{}
\DoxyCodeLine{5530     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5531     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::object\_t\& obj)}
\DoxyCodeLine{5532     \{}
\DoxyCodeLine{5533         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5534         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{value\_t::object}};}
\DoxyCodeLine{5535         j.m\_value = obj;}
\DoxyCodeLine{5536         j.set\_parents();}
\DoxyCodeLine{5537         j.assert\_invariant();}
\DoxyCodeLine{5538     \}}
\DoxyCodeLine{5539 }
\DoxyCodeLine{5540     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5541     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::object\_t\&\& obj)}
\DoxyCodeLine{5542     \{}
\DoxyCodeLine{5543         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5544         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{value\_t::object}};}
\DoxyCodeLine{5545         j.m\_value = std::move(obj);}
\DoxyCodeLine{5546         j.set\_parents();}
\DoxyCodeLine{5547         j.assert\_invariant();}
\DoxyCodeLine{5548     \}}
\DoxyCodeLine{5549 }
\DoxyCodeLine{5550     \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleObjectType,}
\DoxyCodeLine{5551                enable\_if\_t < !std::is\_same<CompatibleObjectType, typename BasicJsonType::object\_t>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{5552     \textcolor{keyword}{static} \textcolor{keywordtype}{void} construct(BasicJsonType\& j, \textcolor{keyword}{const} CompatibleObjectType\& obj)}
\DoxyCodeLine{5553     \{}
\DoxyCodeLine{5554         \textcolor{keyword}{using }std::begin;}
\DoxyCodeLine{5555         \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{5556 }
\DoxyCodeLine{5557         j.m\_value.destroy(j.m\_type);}
\DoxyCodeLine{5558         j.m\_type = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{value\_t::object}};}
\DoxyCodeLine{5559         j.m\_value.object = j.template create<typename BasicJsonType::object\_t>(begin(obj), end(obj));}
\DoxyCodeLine{5560         j.set\_parents();}
\DoxyCodeLine{5561         j.assert\_invariant();}
\DoxyCodeLine{5562     \}}
\DoxyCodeLine{5563 \};}
\DoxyCodeLine{5564 }
\DoxyCodeLine{5566 \textcolor{comment}{// to\_json //}}
\DoxyCodeLine{5568 \textcolor{comment}{}}
\DoxyCodeLine{5569 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{5570          enable\_if\_t<std::is\_same<T, typename BasicJsonType::boolean\_t>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5571 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, T b) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5572 \{}
\DoxyCodeLine{5573     \mbox{\hyperlink{structdetail_1_1external__constructor}{external\_constructor<value\_t::boolean>::construct}}(j, b);}
\DoxyCodeLine{5574 \}}
\DoxyCodeLine{5575 }
\DoxyCodeLine{5576 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} BoolRef,}
\DoxyCodeLine{5577            enable\_if\_t <}
\DoxyCodeLine{5578                ((std::is\_same<std::vector<bool>::reference, BoolRef>::value}
\DoxyCodeLine{5579                  \&\& !std::is\_same <std::vector<bool>::reference, \textcolor{keyword}{typename} BasicJsonType::boolean\_t\&>::value)}
\DoxyCodeLine{5580                 || (std::is\_same<std::vector<bool>::const\_reference, BoolRef>::value}
\DoxyCodeLine{5581                     \&\& !std::is\_same <detail::uncvref\_t<std::vector<bool>::const\_reference>,}
\DoxyCodeLine{5582                                       \textcolor{keyword}{typename} BasicJsonType::boolean\_t >::value))}
\DoxyCodeLine{5583                \&\& std::is\_convertible<const BoolRef\&, typename BasicJsonType::boolean\_t>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{5584 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} BoolRef\& b) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5585 \{}
\DoxyCodeLine{5586     external\_constructor<value\_t::boolean>::construct(j, \textcolor{keyword}{static\_cast<}typename BasicJsonType::boolean\_t\textcolor{keyword}{>}(b));}
\DoxyCodeLine{5587 \}}
\DoxyCodeLine{5588 }
\DoxyCodeLine{5589 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleString,}
\DoxyCodeLine{5590          enable\_if\_t<std::is\_constructible<typename BasicJsonType::string\_t, CompatibleString>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5591 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} CompatibleString\& s)}
\DoxyCodeLine{5592 \{}
\DoxyCodeLine{5593     external\_constructor<value\_t::string>::construct(j, s);}
\DoxyCodeLine{5594 \}}
\DoxyCodeLine{5595 }
\DoxyCodeLine{5596 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5597 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::string\_t\&\& s)}
\DoxyCodeLine{5598 \{}
\DoxyCodeLine{5599     external\_constructor<value\_t::string>::construct(j, std::move(s));}
\DoxyCodeLine{5600 \}}
\DoxyCodeLine{5601 }
\DoxyCodeLine{5602 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} FloatType,}
\DoxyCodeLine{5603          enable\_if\_t<std::is\_floating\_point<FloatType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5604 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, FloatType val) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5605 \{}
\DoxyCodeLine{5606     external\_constructor<value\_t::number\_float>::construct(j, \textcolor{keyword}{static\_cast<}typename BasicJsonType::number\_float\_t\textcolor{keyword}{>}(val));}
\DoxyCodeLine{5607 \}}
\DoxyCodeLine{5608 }
\DoxyCodeLine{5609 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleNumberUnsignedType,}
\DoxyCodeLine{5610          enable\_if\_t<is\_compatible\_integer\_type<typename BasicJsonType::number\_unsigned\_t, CompatibleNumberUnsignedType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5611 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, CompatibleNumberUnsignedType val) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5612 \{}
\DoxyCodeLine{5613     external\_constructor<value\_t::number\_unsigned>::construct(j, \textcolor{keyword}{static\_cast<}typename BasicJsonType::number\_unsigned\_t\textcolor{keyword}{>}(val));}
\DoxyCodeLine{5614 \}}
\DoxyCodeLine{5615 }
\DoxyCodeLine{5616 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleNumberIntegerType,}
\DoxyCodeLine{5617          enable\_if\_t<is\_compatible\_integer\_type<typename BasicJsonType::number\_integer\_t, CompatibleNumberIntegerType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5618 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, CompatibleNumberIntegerType val) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5619 \{}
\DoxyCodeLine{5620     external\_constructor<value\_t::number\_integer>::construct(j, \textcolor{keyword}{static\_cast<}typename BasicJsonType::number\_integer\_t\textcolor{keyword}{>}(val));}
\DoxyCodeLine{5621 \}}
\DoxyCodeLine{5622 }
\DoxyCodeLine{5623 \textcolor{preprocessor}{\#if !JSON\_DISABLE\_ENUM\_SERIALIZATION}}
\DoxyCodeLine{5624 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} EnumType,}
\DoxyCodeLine{5625          enable\_if\_t<std::is\_enum<EnumType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5626 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, EnumType e) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5627 \{}
\DoxyCodeLine{5628     \textcolor{keyword}{using }underlying\_type = \textcolor{keyword}{typename} std::underlying\_type<EnumType>::type;}
\DoxyCodeLine{5629     external\_constructor<value\_t::number\_integer>::construct(j, \textcolor{keyword}{static\_cast<}underlying\_type\textcolor{keyword}{>}(e));}
\DoxyCodeLine{5630 \}}
\DoxyCodeLine{5631 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_DISABLE\_ENUM\_SERIALIZATION}}
\DoxyCodeLine{5632 }
\DoxyCodeLine{5633 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5634 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} std::vector<bool>\& e)}
\DoxyCodeLine{5635 \{}
\DoxyCodeLine{5636     external\_constructor<value\_t::array>::construct(j, e);}
\DoxyCodeLine{5637 \}}
\DoxyCodeLine{5638 }
\DoxyCodeLine{5639 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleArrayType,}
\DoxyCodeLine{5640            enable\_if\_t < is\_compatible\_array\_type<BasicJsonType,}
\DoxyCodeLine{5641                          CompatibleArrayType>::value\&\&}
\DoxyCodeLine{5642                          !is\_compatible\_object\_type<BasicJsonType, CompatibleArrayType>::value\&\&}
\DoxyCodeLine{5643                          !is\_compatible\_string\_type<BasicJsonType, CompatibleArrayType>::value\&\&}
\DoxyCodeLine{5644                          !std::is\_same<typename BasicJsonType::binary\_t, CompatibleArrayType>::value\&\&}
\DoxyCodeLine{5645                          !is\_basic\_json<CompatibleArrayType>::value,}
\DoxyCodeLine{5646                          \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{5647 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} CompatibleArrayType\& arr)}
\DoxyCodeLine{5648 \{}
\DoxyCodeLine{5649     external\_constructor<value\_t::array>::construct(j, arr);}
\DoxyCodeLine{5650 \}}
\DoxyCodeLine{5651 }
\DoxyCodeLine{5652 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5653 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::binary\_t\& bin)}
\DoxyCodeLine{5654 \{}
\DoxyCodeLine{5655     external\_constructor<value\_t::binary>::construct(j, bin);}
\DoxyCodeLine{5656 \}}
\DoxyCodeLine{5657 }
\DoxyCodeLine{5658 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{5659          enable\_if\_t<std::is\_convertible<T, BasicJsonType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5660 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} std::valarray<T>\& arr)}
\DoxyCodeLine{5661 \{}
\DoxyCodeLine{5662     external\_constructor<value\_t::array>::construct(j, std::move(arr));}
\DoxyCodeLine{5663 \}}
\DoxyCodeLine{5664 }
\DoxyCodeLine{5665 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5666 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::array\_t\&\& arr)}
\DoxyCodeLine{5667 \{}
\DoxyCodeLine{5668     external\_constructor<value\_t::array>::construct(j, std::move(arr));}
\DoxyCodeLine{5669 \}}
\DoxyCodeLine{5670 }
\DoxyCodeLine{5671 \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CompatibleObjectType,}
\DoxyCodeLine{5672            enable\_if\_t < is\_compatible\_object\_type<BasicJsonType, CompatibleObjectType>::value\&\& !is\_basic\_json<CompatibleObjectType>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{5673 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} CompatibleObjectType\& obj)}
\DoxyCodeLine{5674 \{}
\DoxyCodeLine{5675     external\_constructor<value\_t::object>::construct(j, obj);}
\DoxyCodeLine{5676 \}}
\DoxyCodeLine{5677 }
\DoxyCodeLine{5678 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5679 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{typename} BasicJsonType::object\_t\&\& obj)}
\DoxyCodeLine{5680 \{}
\DoxyCodeLine{5681     external\_constructor<value\_t::object>::construct(j, std::move(obj));}
\DoxyCodeLine{5682 \}}
\DoxyCodeLine{5683 }
\DoxyCodeLine{5684 \textcolor{keyword}{template} <}
\DoxyCodeLine{5685     \textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T, std::size\_t N,}
\DoxyCodeLine{5686     enable\_if\_t < !std::is\_constructible<\textcolor{keyword}{typename} BasicJsonType::string\_t,}
\DoxyCodeLine{5687                   \textcolor{keyword}{const} T(\&)[N]>::value, \textcolor{comment}{// NOLINT(cppcoreguidelines-\/avoid-\/c-\/arrays,hicpp-\/avoid-\/c-\/arrays,modernize-\/avoid-\/c-\/arrays)}}
\DoxyCodeLine{5688                   \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{5689 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} T(\&arr)[N]) \textcolor{comment}{// NOLINT(cppcoreguidelines-\/avoid-\/c-\/arrays,hicpp-\/avoid-\/c-\/arrays,modernize-\/avoid-\/c-\/arrays)}}
\DoxyCodeLine{5690 \{}
\DoxyCodeLine{5691     external\_constructor<value\_t::array>::construct(j, arr);}
\DoxyCodeLine{5692 \}}
\DoxyCodeLine{5693 }
\DoxyCodeLine{5694 template < typename BasicJsonType, typename T1, typename T2, enable\_if\_t < std::is\_constructible<BasicJsonType, T1>::value\&\& std::is\_constructible<BasicJsonType, T2>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{5695 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} std::pair<T1, T2>\& p)}
\DoxyCodeLine{5696 \{}
\DoxyCodeLine{5697     j = \{ p.first, p.second \};}
\DoxyCodeLine{5698 \}}
\DoxyCodeLine{5699 }
\DoxyCodeLine{5700 \textcolor{comment}{// for https://github.com/nlohmann/json/pull/1134}}
\DoxyCodeLine{5701 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{5702          enable\_if\_t<std::is\_same<T, iteration\_proxy\_value<typename BasicJsonType::iterator>>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{5703 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} T\& b)}
\DoxyCodeLine{5704 \{}
\DoxyCodeLine{5705     j = \{ \{b.key(), b.value()\} \};}
\DoxyCodeLine{5706 \}}
\DoxyCodeLine{5707 }
\DoxyCodeLine{5708 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} Tuple, std::size\_t... Idx>}
\DoxyCodeLine{5709 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json\_tuple\_impl(BasicJsonType\& j, \textcolor{keyword}{const} Tuple\& t, index\_sequence<Idx...> \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{5710 \{}
\DoxyCodeLine{5711     j = \{ std::get<Idx>(t)... \};}
\DoxyCodeLine{5712 \}}
\DoxyCodeLine{5713 }
\DoxyCodeLine{5714 template<typename BasicJsonType, typename T, enable\_if\_t<is\_constructible\_tuple<BasicJsonType, T>::value, \textcolor{keywordtype}{int} > = 0>}
\DoxyCodeLine{5715 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} T\& t)}
\DoxyCodeLine{5716 \{}
\DoxyCodeLine{5717     to\_json\_tuple\_impl(j, t, make\_index\_sequence<std::tuple\_size<T>::value> \{\});}
\DoxyCodeLine{5718 \}}
\DoxyCodeLine{5719 }
\DoxyCodeLine{5720 \textcolor{preprocessor}{\#if JSON\_HAS\_FILESYSTEM || JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{5721 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5722 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} to\_json(BasicJsonType\& j, \textcolor{keyword}{const} std\_fs::path\& p)}
\DoxyCodeLine{5723 \{}
\DoxyCodeLine{5724     j = p.string();}
\DoxyCodeLine{5725 \}}
\DoxyCodeLine{5726 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5727 }
\DoxyCodeLine{5728 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1to__json__fn}{to\_json\_fn}}}
\DoxyCodeLine{5729 \{}
\DoxyCodeLine{5730     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{5731     \textcolor{keyword}{auto} operator()(BasicJsonType\& j, T\&\& val) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(to\_json(j, std::forward<T>(val))))}
\DoxyCodeLine{5732     -\/> \textcolor{keyword}{decltype}(to\_json(j, std::forward<T>(val)), void())}
\DoxyCodeLine{5733     \{}
\DoxyCodeLine{5734         \textcolor{keywordflow}{return} to\_json(j, std::forward<T>(val));}
\DoxyCodeLine{5735     \}}
\DoxyCodeLine{5736 \};}
\DoxyCodeLine{5737 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{5738 }
\DoxyCodeLine{5739 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{5743 \textcolor{keyword}{namespace }\textcolor{comment}{// NOLINT(cert-\/dcl59-\/cpp,fuchsia-\/header-\/anon-\/namespaces,google-\/build-\/namespaces)}}
\DoxyCodeLine{5744 \{}
\DoxyCodeLine{5745 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5746 JSON\_INLINE\_VARIABLE \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto}\& to\_json = \textcolor{comment}{// NOLINT(misc-\/definitions-\/in-\/headers)}}
\DoxyCodeLine{5747     \mbox{\hyperlink{structdetail_1_1static__const}{detail::static\_const<detail::to\_json\_fn>::value}};}
\DoxyCodeLine{5748 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{5749 \}  \textcolor{comment}{// namespace}}
\DoxyCodeLine{5750 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5751 }
\DoxyCodeLine{5752 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{5753 }
\DoxyCodeLine{5754 \textcolor{comment}{// \#include <nlohmann/detail/meta/identity\_tag.hpp>}}
\DoxyCodeLine{5755 }
\DoxyCodeLine{5756 }
\DoxyCodeLine{5757 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{5758 }
\DoxyCodeLine{5760 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ValueType, \textcolor{keyword}{typename}>}
\DoxyCodeLine{5761 \textcolor{keyword}{struct }\mbox{\hyperlink{structadl__serializer}{adl\_serializer}}}
\DoxyCodeLine{5762 \{}
\DoxyCodeLine{5765     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} TargetType = ValueType>}
\DoxyCodeLine{5766     \textcolor{keyword}{static} \textcolor{keyword}{auto} \mbox{\hyperlink{structadl__serializer_a5645c63fe43bd9b4ebc9917f9c99d0fd}{from\_json}}(BasicJsonType \&\& j, TargetType\& val) \textcolor{keyword}{noexcept}(}
\DoxyCodeLine{5767         \textcolor{keyword}{noexcept}(::nlohmann::from\_json(std::forward<BasicJsonType>(j), val)))}
\DoxyCodeLine{5768     -\/> \textcolor{keyword}{decltype}(::nlohmann::from\_json(std::forward<BasicJsonType>(j), val), void())}
\DoxyCodeLine{5769     \{}
\DoxyCodeLine{5770         ::nlohmann::from\_json(std::forward<BasicJsonType>(j), val);}
\DoxyCodeLine{5771     \}}
\DoxyCodeLine{5772 }
\DoxyCodeLine{5775     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} TargetType = ValueType>}
\DoxyCodeLine{5776     \textcolor{keyword}{static} \textcolor{keyword}{auto} \mbox{\hyperlink{structadl__serializer_a1e06f0bcb63296fc306dbe4162a0f2a3}{from\_json}}(BasicJsonType \&\& j) \textcolor{keyword}{noexcept}(}
\DoxyCodeLine{5777     \textcolor{keyword}{noexcept}(::nlohmann::from\_json(std::forward<BasicJsonType>(j), \mbox{\hyperlink{structdetail_1_1identity__tag}{detail::identity\_tag<TargetType>}} \{\})))}
\DoxyCodeLine{5778     -\/> \textcolor{keyword}{decltype}(::nlohmann::from\_json(std::forward<BasicJsonType>(j), \mbox{\hyperlink{structdetail_1_1identity__tag}{detail::identity\_tag<TargetType>}} \{\}))}
\DoxyCodeLine{5779     \{}
\DoxyCodeLine{5780         return ::nlohmann::from\_json(std::forward<BasicJsonType>(j), \mbox{\hyperlink{structdetail_1_1identity__tag}{detail::identity\_tag<TargetType>}} \{\});}
\DoxyCodeLine{5781     \}}
\DoxyCodeLine{5782 }
\DoxyCodeLine{5785     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} TargetType = ValueType>}
\DoxyCodeLine{5786     \textcolor{keyword}{static} \textcolor{keyword}{auto} \mbox{\hyperlink{structadl__serializer_a0216149429fe899cf45cbf14e08e2166}{to\_json}}(BasicJsonType\& j, TargetType \&\& val) \textcolor{keyword}{noexcept}(}
\DoxyCodeLine{5787         \textcolor{keyword}{noexcept}(::nlohmann::to\_json(j, std::forward<TargetType>(val))))}
\DoxyCodeLine{5788     -\/> \textcolor{keyword}{decltype}(::nlohmann::to\_json(j, std::forward<TargetType>(val)), void())}
\DoxyCodeLine{5789     \{}
\DoxyCodeLine{5790         ::nlohmann::to\_json(j, std::forward<TargetType>(val));}
\DoxyCodeLine{5791     \}}
\DoxyCodeLine{5792 \};}
\DoxyCodeLine{5793 }
\DoxyCodeLine{5794 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{5795 }
\DoxyCodeLine{5796 \textcolor{comment}{// \#include <nlohmann/byte\_container\_with\_subtype.hpp>}}
\DoxyCodeLine{5797 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{5798 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{5799 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{5800 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{5801 \textcolor{comment}{//}}
\DoxyCodeLine{5802 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{5803 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{5804 }
\DoxyCodeLine{5805 }
\DoxyCodeLine{5806 }
\DoxyCodeLine{5807 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// uint8\_t, uint64\_t}}
\DoxyCodeLine{5808 \textcolor{preprocessor}{\#include <tuple>} \textcolor{comment}{// tie}}
\DoxyCodeLine{5809 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// move}}
\DoxyCodeLine{5810 }
\DoxyCodeLine{5811 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{5812 }
\DoxyCodeLine{5813 }
\DoxyCodeLine{5814 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{5815 }
\DoxyCodeLine{5818 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryType>}
\DoxyCodeLine{5819 \textcolor{keyword}{class }\mbox{\hyperlink{classbyte__container__with__subtype}{byte\_container\_with\_subtype}} : \textcolor{keyword}{public} BinaryType}
\DoxyCodeLine{5820 \{}
\DoxyCodeLine{5821   \textcolor{keyword}{public}:}
\DoxyCodeLine{5822     \textcolor{keyword}{using }container\_type = BinaryType;}
\DoxyCodeLine{5823     \textcolor{keyword}{using }subtype\_type = std::uint64\_t;}
\DoxyCodeLine{5824 }
\DoxyCodeLine{5826     \mbox{\hyperlink{classbyte__container__with__subtype_a17bc4a2dabb6c7a5ec2cba3f3aaf0431}{byte\_container\_with\_subtype}}() noexcept(noexcept(container\_type()))}
\DoxyCodeLine{5827         : container\_type()}
\DoxyCodeLine{5828     \{\}}
\DoxyCodeLine{5829 }
\DoxyCodeLine{5831     \mbox{\hyperlink{classbyte__container__with__subtype_a7f9fb60d4a835e97fbf1c2de7fa382e2}{byte\_container\_with\_subtype}}(\textcolor{keyword}{const} container\_type\& b) \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(container\_type(b)))}
\DoxyCodeLine{5832         : container\_type(b)}
\DoxyCodeLine{5833     \{\}}
\DoxyCodeLine{5834 }
\DoxyCodeLine{5836     \mbox{\hyperlink{classbyte__container__with__subtype_a42b8b66b00eb5c0057d4420e196dadf0}{byte\_container\_with\_subtype}}(container\_type\&\& b) \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(container\_type(std::move(b))))}
\DoxyCodeLine{5837         : container\_type(std::move(b))}
\DoxyCodeLine{5838     \{\}}
\DoxyCodeLine{5839 }
\DoxyCodeLine{5841     \mbox{\hyperlink{classbyte__container__with__subtype_a759c6a582dd0684adf7fb9641ef586a4}{byte\_container\_with\_subtype}}(\textcolor{keyword}{const} container\_type\& b, subtype\_type subtype\_) \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(container\_type(b)))}
\DoxyCodeLine{5842         : container\_type(b)}
\DoxyCodeLine{5843         , m\_subtype(subtype\_)}
\DoxyCodeLine{5844         , m\_has\_subtype(\textcolor{keyword}{true})}
\DoxyCodeLine{5845     \{\}}
\DoxyCodeLine{5846 }
\DoxyCodeLine{5848     \mbox{\hyperlink{classbyte__container__with__subtype_a3b43bde08a4bff8917bcfad01d9e6089}{byte\_container\_with\_subtype}}(container\_type\&\& b, subtype\_type subtype\_) \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(container\_type(std::move(b))))}
\DoxyCodeLine{5849         : container\_type(std::move(b))}
\DoxyCodeLine{5850         , m\_subtype(subtype\_)}
\DoxyCodeLine{5851         , m\_has\_subtype(\textcolor{keyword}{true})}
\DoxyCodeLine{5852     \{\}}
\DoxyCodeLine{5853 }
\DoxyCodeLine{5854     \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classbyte__container__with__subtype}{byte\_container\_with\_subtype}}\& rhs)\textcolor{keyword}{ const}}
\DoxyCodeLine{5855 \textcolor{keyword}{    }\{}
\DoxyCodeLine{5856         \textcolor{keywordflow}{return} std::tie(\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }BinaryType\&\textcolor{keyword}{>}(*\textcolor{keyword}{this}), m\_subtype, m\_has\_subtype) ==}
\DoxyCodeLine{5857                std::tie(\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }BinaryType\&\textcolor{keyword}{>}(rhs), rhs.m\_subtype, rhs.m\_has\_subtype);}
\DoxyCodeLine{5858     \}}
\DoxyCodeLine{5859 }
\DoxyCodeLine{5860     \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} \mbox{\hyperlink{classbyte__container__with__subtype}{byte\_container\_with\_subtype}}\& rhs)\textcolor{keyword}{ const}}
\DoxyCodeLine{5861 \textcolor{keyword}{    }\{}
\DoxyCodeLine{5862         \textcolor{keywordflow}{return} !(rhs == *\textcolor{keyword}{this});}
\DoxyCodeLine{5863     \}}
\DoxyCodeLine{5864 }
\DoxyCodeLine{5867     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbyte__container__with__subtype_aa211ecfe3f0a626e96c54ea7e160491b}{set\_subtype}}(subtype\_type subtype\_) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5868     \{}
\DoxyCodeLine{5869         m\_subtype = subtype\_;}
\DoxyCodeLine{5870         m\_has\_subtype = \textcolor{keyword}{true};}
\DoxyCodeLine{5871     \}}
\DoxyCodeLine{5872 }
\DoxyCodeLine{5875     \textcolor{keyword}{constexpr} subtype\_type \mbox{\hyperlink{classbyte__container__with__subtype_a678460360dd494c33fbfde782e7c8201}{subtype}}() const noexcept}
\DoxyCodeLine{5876     \{}
\DoxyCodeLine{5877         \textcolor{keywordflow}{return} m\_has\_subtype ? m\_subtype : \textcolor{keyword}{static\_cast<}subtype\_type\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{5878     \}}
\DoxyCodeLine{5879 }
\DoxyCodeLine{5882     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbyte__container__with__subtype_a793fab04ad06741b6909dde032d9ea35}{has\_subtype}}() const noexcept}
\DoxyCodeLine{5883     \{}
\DoxyCodeLine{5884         \textcolor{keywordflow}{return} m\_has\_subtype;}
\DoxyCodeLine{5885     \}}
\DoxyCodeLine{5886 }
\DoxyCodeLine{5889     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbyte__container__with__subtype_ad18f6a7557a2bfce28f1ed8d4d10607c}{clear\_subtype}}() noexcept}
\DoxyCodeLine{5890     \{}
\DoxyCodeLine{5891         m\_subtype = 0;}
\DoxyCodeLine{5892         m\_has\_subtype = \textcolor{keyword}{false};}
\DoxyCodeLine{5893     \}}
\DoxyCodeLine{5894 }
\DoxyCodeLine{5895   \textcolor{keyword}{private}:}
\DoxyCodeLine{5896     subtype\_type m\_subtype = 0;}
\DoxyCodeLine{5897     \textcolor{keywordtype}{bool} m\_has\_subtype = \textcolor{keyword}{false};}
\DoxyCodeLine{5898 \};}
\DoxyCodeLine{5899 }
\DoxyCodeLine{5900 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{5901 }
\DoxyCodeLine{5902 \textcolor{comment}{// \#include <nlohmann/detail/conversions/from\_json.hpp>}}
\DoxyCodeLine{5903 }
\DoxyCodeLine{5904 \textcolor{comment}{// \#include <nlohmann/detail/conversions/to\_json.hpp>}}
\DoxyCodeLine{5905 }
\DoxyCodeLine{5906 \textcolor{comment}{// \#include <nlohmann/detail/exceptions.hpp>}}
\DoxyCodeLine{5907 }
\DoxyCodeLine{5908 \textcolor{comment}{// \#include <nlohmann/detail/hash.hpp>}}
\DoxyCodeLine{5909 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{5910 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{5911 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{5912 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{5913 \textcolor{comment}{//}}
\DoxyCodeLine{5914 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{5915 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{5916 }
\DoxyCodeLine{5917 }
\DoxyCodeLine{5918 }
\DoxyCodeLine{5919 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// uint8\_t}}
\DoxyCodeLine{5920 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{5921 \textcolor{preprocessor}{\#include <functional>} \textcolor{comment}{// hash}}
\DoxyCodeLine{5922 }
\DoxyCodeLine{5923 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{5924 }
\DoxyCodeLine{5925 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{5926 }
\DoxyCodeLine{5927 }
\DoxyCodeLine{5928 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{5929 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{5930 \{}
\DoxyCodeLine{5931 }
\DoxyCodeLine{5932 \textcolor{comment}{// boost::hash\_combine}}
\DoxyCodeLine{5933 \textcolor{keyword}{inline} std::size\_t combine(std::size\_t seed, std::size\_t h) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{5934 \{}
\DoxyCodeLine{5935     seed \string^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);}
\DoxyCodeLine{5936     \textcolor{keywordflow}{return} seed;}
\DoxyCodeLine{5937 \}}
\DoxyCodeLine{5938 }
\DoxyCodeLine{5950 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{5951 std::size\_t \mbox{\hyperlink{namespacedetail_a9dd43d16a6a490b032ceaca358755a29}{hash}}(\textcolor{keyword}{const} BasicJsonType\& j)}
\DoxyCodeLine{5952 \{}
\DoxyCodeLine{5953     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{5954     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{5955     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{5956     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{5957 }
\DoxyCodeLine{5958     \textcolor{keyword}{const} \textcolor{keyword}{auto} type = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(j.type());}
\DoxyCodeLine{5959     \textcolor{keywordflow}{switch} (j.type())}
\DoxyCodeLine{5960     \{}
\DoxyCodeLine{5961         \textcolor{keywordflow}{case} BasicJsonType::value\_t::null:}
\DoxyCodeLine{5962         \textcolor{keywordflow}{case} BasicJsonType::value\_t::discarded:}
\DoxyCodeLine{5963         \{}
\DoxyCodeLine{5964             \textcolor{keywordflow}{return} combine(type, 0);}
\DoxyCodeLine{5965         \}}
\DoxyCodeLine{5966 }
\DoxyCodeLine{5967         \textcolor{keywordflow}{case} BasicJsonType::value\_t::object:}
\DoxyCodeLine{5968         \{}
\DoxyCodeLine{5969             \textcolor{keyword}{auto} seed = combine(type, j.size());}
\DoxyCodeLine{5970             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& element : j.items())}
\DoxyCodeLine{5971             \{}
\DoxyCodeLine{5972                 \textcolor{keyword}{const} \textcolor{keyword}{auto} h = std::hash<string\_t> \{\}(element.key());}
\DoxyCodeLine{5973                 seed = combine(seed, h);}
\DoxyCodeLine{5974                 seed = combine(seed, \mbox{\hyperlink{namespacedetail_a9dd43d16a6a490b032ceaca358755a29}{hash}}(element.value()));}
\DoxyCodeLine{5975             \}}
\DoxyCodeLine{5976             \textcolor{keywordflow}{return} seed;}
\DoxyCodeLine{5977         \}}
\DoxyCodeLine{5978 }
\DoxyCodeLine{5979         \textcolor{keywordflow}{case} BasicJsonType::value\_t::array:}
\DoxyCodeLine{5980         \{}
\DoxyCodeLine{5981             \textcolor{keyword}{auto} seed = combine(type, j.size());}
\DoxyCodeLine{5982             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& element : j)}
\DoxyCodeLine{5983             \{}
\DoxyCodeLine{5984                 seed = combine(seed, \mbox{\hyperlink{namespacedetail_a9dd43d16a6a490b032ceaca358755a29}{hash}}(element));}
\DoxyCodeLine{5985             \}}
\DoxyCodeLine{5986             \textcolor{keywordflow}{return} seed;}
\DoxyCodeLine{5987         \}}
\DoxyCodeLine{5988 }
\DoxyCodeLine{5989         \textcolor{keywordflow}{case} BasicJsonType::value\_t::string:}
\DoxyCodeLine{5990         \{}
\DoxyCodeLine{5991             \textcolor{keyword}{const} \textcolor{keyword}{auto} h = std::hash<string\_t> \{\}(j.template get\_ref<const string\_t\&>());}
\DoxyCodeLine{5992             \textcolor{keywordflow}{return} combine(type, h);}
\DoxyCodeLine{5993         \}}
\DoxyCodeLine{5994 }
\DoxyCodeLine{5995         \textcolor{keywordflow}{case} BasicJsonType::value\_t::boolean:}
\DoxyCodeLine{5996         \{}
\DoxyCodeLine{5997             \textcolor{keyword}{const} \textcolor{keyword}{auto} h = std::hash<bool> \{\}(j.template get<bool>());}
\DoxyCodeLine{5998             \textcolor{keywordflow}{return} combine(type, h);}
\DoxyCodeLine{5999         \}}
\DoxyCodeLine{6000 }
\DoxyCodeLine{6001         \textcolor{keywordflow}{case} BasicJsonType::value\_t::number\_integer:}
\DoxyCodeLine{6002         \{}
\DoxyCodeLine{6003             \textcolor{keyword}{const} \textcolor{keyword}{auto} h = std::hash<number\_integer\_t> \{\}(j.template get<number\_integer\_t>());}
\DoxyCodeLine{6004             \textcolor{keywordflow}{return} combine(type, h);}
\DoxyCodeLine{6005         \}}
\DoxyCodeLine{6006 }
\DoxyCodeLine{6007         \textcolor{keywordflow}{case} BasicJsonType::value\_t::number\_unsigned:}
\DoxyCodeLine{6008         \{}
\DoxyCodeLine{6009             \textcolor{keyword}{const} \textcolor{keyword}{auto} h = std::hash<number\_unsigned\_t> \{\}(j.template get<number\_unsigned\_t>());}
\DoxyCodeLine{6010             \textcolor{keywordflow}{return} combine(type, h);}
\DoxyCodeLine{6011         \}}
\DoxyCodeLine{6012 }
\DoxyCodeLine{6013         \textcolor{keywordflow}{case} BasicJsonType::value\_t::number\_float:}
\DoxyCodeLine{6014         \{}
\DoxyCodeLine{6015             \textcolor{keyword}{const} \textcolor{keyword}{auto} h = std::hash<number\_float\_t> \{\}(j.template get<number\_float\_t>());}
\DoxyCodeLine{6016             \textcolor{keywordflow}{return} combine(type, h);}
\DoxyCodeLine{6017         \}}
\DoxyCodeLine{6018 }
\DoxyCodeLine{6019         \textcolor{keywordflow}{case} BasicJsonType::value\_t::binary:}
\DoxyCodeLine{6020         \{}
\DoxyCodeLine{6021             \textcolor{keyword}{auto} seed = combine(type, j.get\_binary().size());}
\DoxyCodeLine{6022             \textcolor{keyword}{const} \textcolor{keyword}{auto} h = std::hash<bool> \{\}(j.get\_binary().has\_subtype());}
\DoxyCodeLine{6023             seed = combine(seed, h);}
\DoxyCodeLine{6024             seed = combine(seed, \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(j.get\_binary().subtype()));}
\DoxyCodeLine{6025             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto} \textcolor{keywordtype}{byte} : j.get\_binary())}
\DoxyCodeLine{6026             \{}
\DoxyCodeLine{6027                 seed = combine(seed, std::hash<std::uint8\_t> \{\}(byte));}
\DoxyCodeLine{6028             \}}
\DoxyCodeLine{6029             \textcolor{keywordflow}{return} seed;}
\DoxyCodeLine{6030         \}}
\DoxyCodeLine{6031 }
\DoxyCodeLine{6032         \textcolor{keywordflow}{default}:                   \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{6033             JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{6034             \textcolor{keywordflow}{return} 0;              \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{6035     \}}
\DoxyCodeLine{6036 \}}
\DoxyCodeLine{6037 }
\DoxyCodeLine{6038 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{6039 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{6040 }
\DoxyCodeLine{6041 \textcolor{comment}{// \#include <nlohmann/detail/input/binary\_reader.hpp>}}
\DoxyCodeLine{6042 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{6043 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{6044 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{6045 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{6046 \textcolor{comment}{//}}
\DoxyCodeLine{6047 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{6048 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{6049 }
\DoxyCodeLine{6050 }
\DoxyCodeLine{6051 }
\DoxyCodeLine{6052 \textcolor{preprocessor}{\#include <algorithm>} \textcolor{comment}{// generate\_n}}
\DoxyCodeLine{6053 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{6054 \textcolor{preprocessor}{\#include <cmath>} \textcolor{comment}{// ldexp}}
\DoxyCodeLine{6055 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{6056 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// uint8\_t, uint16\_t, uint32\_t, uint64\_t}}
\DoxyCodeLine{6057 \textcolor{preprocessor}{\#include <cstdio>} \textcolor{comment}{// snprintf}}
\DoxyCodeLine{6058 \textcolor{preprocessor}{\#include <cstring>} \textcolor{comment}{// memcpy}}
\DoxyCodeLine{6059 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// back\_inserter}}
\DoxyCodeLine{6060 \textcolor{preprocessor}{\#include <limits>} \textcolor{comment}{// numeric\_limits}}
\DoxyCodeLine{6061 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// char\_traits, string}}
\DoxyCodeLine{6062 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// make\_pair, move}}
\DoxyCodeLine{6063 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{6064 }
\DoxyCodeLine{6065 \textcolor{comment}{// \#include <nlohmann/detail/exceptions.hpp>}}
\DoxyCodeLine{6066 }
\DoxyCodeLine{6067 \textcolor{comment}{// \#include <nlohmann/detail/input/input\_adapters.hpp>}}
\DoxyCodeLine{6068 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{6069 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{6070 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{6071 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{6072 \textcolor{comment}{//}}
\DoxyCodeLine{6073 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{6074 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{6075 }
\DoxyCodeLine{6076 }
\DoxyCodeLine{6077 }
\DoxyCodeLine{6078 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{6079 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{6080 \textcolor{preprocessor}{\#include <cstring>} \textcolor{comment}{// strlen}}
\DoxyCodeLine{6081 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// begin, end, iterator\_traits, random\_access\_iterator\_tag, distance, next}}
\DoxyCodeLine{6082 \textcolor{preprocessor}{\#include <memory>} \textcolor{comment}{// shared\_ptr, make\_shared, addressof}}
\DoxyCodeLine{6083 \textcolor{preprocessor}{\#include <numeric>} \textcolor{comment}{// accumulate}}
\DoxyCodeLine{6084 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string, char\_traits}}
\DoxyCodeLine{6085 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// enable\_if, is\_base\_of, is\_pointer, is\_integral, remove\_pointer}}
\DoxyCodeLine{6086 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// pair, declval}}
\DoxyCodeLine{6087 }
\DoxyCodeLine{6088 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{6089 \textcolor{preprocessor}{    \#include <cstdio>}   \textcolor{comment}{// FILE *}}
\DoxyCodeLine{6090 \textcolor{preprocessor}{    \#include <istream>}  \textcolor{comment}{// istream}}
\DoxyCodeLine{6091 \textcolor{preprocessor}{\#endif                  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{6092 }
\DoxyCodeLine{6093 \textcolor{comment}{// \#include <nlohmann/detail/iterators/iterator\_traits.hpp>}}
\DoxyCodeLine{6094 }
\DoxyCodeLine{6095 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{6096 }
\DoxyCodeLine{6097 }
\DoxyCodeLine{6098 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{6099 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{6100 \{}
\DoxyCodeLine{6101 }
\DoxyCodeLine{6103 \textcolor{keyword}{enum class} \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} \{ \mbox{\hyperlink{classbasic__json}{json}}, cbor, msgpack, ubjson, bson, bjdata \};}
\DoxyCodeLine{6104 }
\DoxyCodeLine{6106 \textcolor{comment}{// input adapters //}}
\DoxyCodeLine{6108 \textcolor{comment}{}}
\DoxyCodeLine{6109 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{6114 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}}
\DoxyCodeLine{6115 \{}
\DoxyCodeLine{6116   \textcolor{keyword}{public}:}
\DoxyCodeLine{6117     \textcolor{keyword}{using }char\_type = char;}
\DoxyCodeLine{6118 }
\DoxyCodeLine{6119     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{6120     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}(std::FILE* f) noexcept}
\DoxyCodeLine{6121         : m\_file(f)}
\DoxyCodeLine{6122     \{}
\DoxyCodeLine{6123         JSON\_ASSERT(m\_file != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{6124     \}}
\DoxyCodeLine{6125 }
\DoxyCodeLine{6126     \textcolor{comment}{// make class move-\/only}}
\DoxyCodeLine{6127     \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6128     \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}(\mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\&\&) \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6129     \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6130     \mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\& operator=(\mbox{\hyperlink{classdetail_1_1file__input__adapter}{file\_input\_adapter}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6131     \mbox{\hyperlink{classdetail_1_1file__input__adapter}{\string~file\_input\_adapter}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6132 }
\DoxyCodeLine{6133     std::char\_traits<char>::int\_type get\_character() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{6134     \{}
\DoxyCodeLine{6135         \textcolor{keywordflow}{return} std::fgetc(m\_file);}
\DoxyCodeLine{6136     \}}
\DoxyCodeLine{6137 }
\DoxyCodeLine{6138   \textcolor{keyword}{private}:}
\DoxyCodeLine{6140     std::FILE* m\_file;}
\DoxyCodeLine{6141 \};}
\DoxyCodeLine{6142 }
\DoxyCodeLine{6143 }
\DoxyCodeLine{6153 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}}
\DoxyCodeLine{6154 \{}
\DoxyCodeLine{6155   \textcolor{keyword}{public}:}
\DoxyCodeLine{6156     \textcolor{keyword}{using }char\_type = char;}
\DoxyCodeLine{6157 }
\DoxyCodeLine{6158     \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{\string~input\_stream\_adapter}}()}
\DoxyCodeLine{6159     \{}
\DoxyCodeLine{6160         \textcolor{comment}{// clear stream flags; we use underlying streambuf I/O, do not}}
\DoxyCodeLine{6161         \textcolor{comment}{// maintain ifstream flags, except eof}}
\DoxyCodeLine{6162         \textcolor{keywordflow}{if} (is != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{6163         \{}
\DoxyCodeLine{6164             is-\/>clear(is-\/>rdstate() \& std::ios::eofbit);}
\DoxyCodeLine{6165         \}}
\DoxyCodeLine{6166     \}}
\DoxyCodeLine{6167 }
\DoxyCodeLine{6168     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}(std::istream\& i)}
\DoxyCodeLine{6169         : is(\&i), sb(i.rdbuf())}
\DoxyCodeLine{6170     \{\}}
\DoxyCodeLine{6171 }
\DoxyCodeLine{6172     \textcolor{comment}{// delete because of pointer members}}
\DoxyCodeLine{6173     \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6174     \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\& operator=(\mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6175     \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\& operator=(\mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6176 }
\DoxyCodeLine{6177     \mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}(\mbox{\hyperlink{classdetail_1_1input__stream__adapter}{input\_stream\_adapter}}\&\& rhs) noexcept}
\DoxyCodeLine{6178         : is(rhs.is), sb(rhs.sb)}
\DoxyCodeLine{6179     \{}
\DoxyCodeLine{6180         rhs.is = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{6181         rhs.sb = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{6182     \}}
\DoxyCodeLine{6183 }
\DoxyCodeLine{6184     \textcolor{comment}{// std::istream/std::streambuf use std::char\_traits<char>::to\_int\_type, to}}
\DoxyCodeLine{6185     \textcolor{comment}{// ensure that std::char\_traits<char>::eof() and the character 0xFF do not}}
\DoxyCodeLine{6186     \textcolor{comment}{// end up as the same value, e.g. 0xFFFFFFFF.}}
\DoxyCodeLine{6187     std::char\_traits<char>::int\_type get\_character()}
\DoxyCodeLine{6188     \{}
\DoxyCodeLine{6189         \textcolor{keyword}{auto} res = sb-\/>sbumpc();}
\DoxyCodeLine{6190         \textcolor{comment}{// set eof manually, as we don't use the istream interface.}}
\DoxyCodeLine{6191         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(res == std::char\_traits<char>::eof()))}
\DoxyCodeLine{6192         \{}
\DoxyCodeLine{6193             is-\/>clear(is-\/>rdstate() | std::ios::eofbit);}
\DoxyCodeLine{6194         \}}
\DoxyCodeLine{6195         \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{6196     \}}
\DoxyCodeLine{6197 }
\DoxyCodeLine{6198   \textcolor{keyword}{private}:}
\DoxyCodeLine{6200     std::istream* is = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{6201     std::streambuf* sb = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{6202 \};}
\DoxyCodeLine{6203 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{6204 }
\DoxyCodeLine{6205 \textcolor{comment}{// General-\/purpose iterator-\/based adapter. It might not be as fast as}}
\DoxyCodeLine{6206 \textcolor{comment}{// theoretically possible for some containers, but it is extremely versatile.}}
\DoxyCodeLine{6207 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{6208 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{iterator\_input\_adapter}}}
\DoxyCodeLine{6209 \{}
\DoxyCodeLine{6210   \textcolor{keyword}{public}:}
\DoxyCodeLine{6211     \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} std::iterator\_traits<IteratorType>::value\_type;}
\DoxyCodeLine{6212 }
\DoxyCodeLine{6213     \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{iterator\_input\_adapter}}(IteratorType first, IteratorType last)}
\DoxyCodeLine{6214         : current(std::move(first)), end(std::move(last))}
\DoxyCodeLine{6215     \{\}}
\DoxyCodeLine{6216 }
\DoxyCodeLine{6217     \textcolor{keyword}{typename} std::char\_traits<char\_type>::int\_type get\_character()}
\DoxyCodeLine{6218     \{}
\DoxyCodeLine{6219         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(current != end))}
\DoxyCodeLine{6220         \{}
\DoxyCodeLine{6221             \textcolor{keyword}{auto} result = std::char\_traits<char\_type>::to\_int\_type(*current);}
\DoxyCodeLine{6222             std::advance(current, 1);}
\DoxyCodeLine{6223             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{6224         \}}
\DoxyCodeLine{6225 }
\DoxyCodeLine{6226         \textcolor{keywordflow}{return} std::char\_traits<char\_type>::eof();}
\DoxyCodeLine{6227     \}}
\DoxyCodeLine{6228 }
\DoxyCodeLine{6229   \textcolor{keyword}{private}:}
\DoxyCodeLine{6230     IteratorType current;}
\DoxyCodeLine{6231     IteratorType end;}
\DoxyCodeLine{6232 }
\DoxyCodeLine{6233     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BaseInputAdapter, \textcolor{keywordtype}{size\_t} T>}
\DoxyCodeLine{6234     \textcolor{keyword}{friend} \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1wide__string__input__helper}{wide\_string\_input\_helper}};}
\DoxyCodeLine{6235 }
\DoxyCodeLine{6236     \textcolor{keywordtype}{bool} empty()\textcolor{keyword}{ const}}
\DoxyCodeLine{6237 \textcolor{keyword}{    }\{}
\DoxyCodeLine{6238         \textcolor{keywordflow}{return} current == end;}
\DoxyCodeLine{6239     \}}
\DoxyCodeLine{6240 \};}
\DoxyCodeLine{6241 }
\DoxyCodeLine{6242 }
\DoxyCodeLine{6243 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BaseInputAdapter, \textcolor{keywordtype}{size\_t} T>}
\DoxyCodeLine{6244 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1wide__string__input__helper}{wide\_string\_input\_helper}};}
\DoxyCodeLine{6245 }
\DoxyCodeLine{6246 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BaseInputAdapter>}
\DoxyCodeLine{6247 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1wide__string__input__helper}{wide\_string\_input\_helper}}<BaseInputAdapter, 4>}
\DoxyCodeLine{6248 \{}
\DoxyCodeLine{6249     \textcolor{comment}{// UTF-\/32}}
\DoxyCodeLine{6250     \textcolor{keyword}{static} \textcolor{keywordtype}{void} fill\_buffer(BaseInputAdapter\& input,}
\DoxyCodeLine{6251                             std::array<std::char\_traits<char>::int\_type, 4>\& utf8\_bytes,}
\DoxyCodeLine{6252                             \textcolor{keywordtype}{size\_t}\& utf8\_bytes\_index,}
\DoxyCodeLine{6253                             \textcolor{keywordtype}{size\_t}\& utf8\_bytes\_filled)}
\DoxyCodeLine{6254     \{}
\DoxyCodeLine{6255         utf8\_bytes\_index = 0;}
\DoxyCodeLine{6256 }
\DoxyCodeLine{6257         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(input.empty()))}
\DoxyCodeLine{6258         \{}
\DoxyCodeLine{6259             utf8\_bytes[0] = std::char\_traits<char>::eof();}
\DoxyCodeLine{6260             utf8\_bytes\_filled = 1;}
\DoxyCodeLine{6261         \}}
\DoxyCodeLine{6262         \textcolor{keywordflow}{else}}
\DoxyCodeLine{6263         \{}
\DoxyCodeLine{6264             \textcolor{comment}{// get the current character}}
\DoxyCodeLine{6265             \textcolor{keyword}{const} \textcolor{keyword}{auto} wc = input.get\_character();}
\DoxyCodeLine{6266 }
\DoxyCodeLine{6267             \textcolor{comment}{// UTF-\/32 to UTF-\/8 encoding}}
\DoxyCodeLine{6268             \textcolor{keywordflow}{if} (wc < 0x80)}
\DoxyCodeLine{6269             \{}
\DoxyCodeLine{6270                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(wc);}
\DoxyCodeLine{6271                 utf8\_bytes\_filled = 1;}
\DoxyCodeLine{6272             \}}
\DoxyCodeLine{6273             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (wc <= 0x7FF)}
\DoxyCodeLine{6274             \{}
\DoxyCodeLine{6275                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xC0u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 6u) \& 0x1Fu));}
\DoxyCodeLine{6276                 utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3Fu));}
\DoxyCodeLine{6277                 utf8\_bytes\_filled = 2;}
\DoxyCodeLine{6278             \}}
\DoxyCodeLine{6279             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (wc <= 0xFFFF)}
\DoxyCodeLine{6280             \{}
\DoxyCodeLine{6281                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xE0u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 12u) \& 0x0Fu));}
\DoxyCodeLine{6282                 utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 6u) \& 0x3Fu));}
\DoxyCodeLine{6283                 utf8\_bytes[2] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3Fu));}
\DoxyCodeLine{6284                 utf8\_bytes\_filled = 3;}
\DoxyCodeLine{6285             \}}
\DoxyCodeLine{6286             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (wc <= 0x10FFFF)}
\DoxyCodeLine{6287             \{}
\DoxyCodeLine{6288                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xF0u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 18u) \& 0x07u));}
\DoxyCodeLine{6289                 utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 12u) \& 0x3Fu));}
\DoxyCodeLine{6290                 utf8\_bytes[2] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 6u) \& 0x3Fu));}
\DoxyCodeLine{6291                 utf8\_bytes[3] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3Fu));}
\DoxyCodeLine{6292                 utf8\_bytes\_filled = 4;}
\DoxyCodeLine{6293             \}}
\DoxyCodeLine{6294             \textcolor{keywordflow}{else}}
\DoxyCodeLine{6295             \{}
\DoxyCodeLine{6296                 \textcolor{comment}{// unknown character}}
\DoxyCodeLine{6297                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(wc);}
\DoxyCodeLine{6298                 utf8\_bytes\_filled = 1;}
\DoxyCodeLine{6299             \}}
\DoxyCodeLine{6300         \}}
\DoxyCodeLine{6301     \}}
\DoxyCodeLine{6302 \};}
\DoxyCodeLine{6303 }
\DoxyCodeLine{6304 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BaseInputAdapter>}
\DoxyCodeLine{6305 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1wide__string__input__helper}{wide\_string\_input\_helper}}<BaseInputAdapter, 2>}
\DoxyCodeLine{6306 \{}
\DoxyCodeLine{6307     \textcolor{comment}{// UTF-\/16}}
\DoxyCodeLine{6308     \textcolor{keyword}{static} \textcolor{keywordtype}{void} fill\_buffer(BaseInputAdapter\& input,}
\DoxyCodeLine{6309                             std::array<std::char\_traits<char>::int\_type, 4>\& utf8\_bytes,}
\DoxyCodeLine{6310                             \textcolor{keywordtype}{size\_t}\& utf8\_bytes\_index,}
\DoxyCodeLine{6311                             \textcolor{keywordtype}{size\_t}\& utf8\_bytes\_filled)}
\DoxyCodeLine{6312     \{}
\DoxyCodeLine{6313         utf8\_bytes\_index = 0;}
\DoxyCodeLine{6314 }
\DoxyCodeLine{6315         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(input.empty()))}
\DoxyCodeLine{6316         \{}
\DoxyCodeLine{6317             utf8\_bytes[0] = std::char\_traits<char>::eof();}
\DoxyCodeLine{6318             utf8\_bytes\_filled = 1;}
\DoxyCodeLine{6319         \}}
\DoxyCodeLine{6320         \textcolor{keywordflow}{else}}
\DoxyCodeLine{6321         \{}
\DoxyCodeLine{6322             \textcolor{comment}{// get the current character}}
\DoxyCodeLine{6323             \textcolor{keyword}{const} \textcolor{keyword}{auto} wc = input.get\_character();}
\DoxyCodeLine{6324 }
\DoxyCodeLine{6325             \textcolor{comment}{// UTF-\/16 to UTF-\/8 encoding}}
\DoxyCodeLine{6326             \textcolor{keywordflow}{if} (wc < 0x80)}
\DoxyCodeLine{6327             \{}
\DoxyCodeLine{6328                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(wc);}
\DoxyCodeLine{6329                 utf8\_bytes\_filled = 1;}
\DoxyCodeLine{6330             \}}
\DoxyCodeLine{6331             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (wc <= 0x7FF)}
\DoxyCodeLine{6332             \{}
\DoxyCodeLine{6333                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xC0u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 6u)));}
\DoxyCodeLine{6334                 utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3Fu));}
\DoxyCodeLine{6335                 utf8\_bytes\_filled = 2;}
\DoxyCodeLine{6336             \}}
\DoxyCodeLine{6337             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (0xD800 > wc || wc >= 0xE000)}
\DoxyCodeLine{6338             \{}
\DoxyCodeLine{6339                 utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xE0u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 12u)));}
\DoxyCodeLine{6340                 utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) >> 6u) \& 0x3Fu));}
\DoxyCodeLine{6341                 utf8\_bytes[2] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3Fu));}
\DoxyCodeLine{6342                 utf8\_bytes\_filled = 3;}
\DoxyCodeLine{6343             \}}
\DoxyCodeLine{6344             \textcolor{keywordflow}{else}}
\DoxyCodeLine{6345             \{}
\DoxyCodeLine{6346                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!input.empty()))}
\DoxyCodeLine{6347                 \{}
\DoxyCodeLine{6348                     \textcolor{keyword}{const} \textcolor{keyword}{auto} wc2 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(input.get\_character());}
\DoxyCodeLine{6349                     \textcolor{keyword}{const} \textcolor{keyword}{auto} charcode = 0x10000u + (((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(wc) \& 0x3FFu) << 10u) | (wc2 \& 0x3FFu));}
\DoxyCodeLine{6350                     utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0xF0u | (charcode >> 18u));}
\DoxyCodeLine{6351                     utf8\_bytes[1] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((charcode >> 12u) \& 0x3Fu));}
\DoxyCodeLine{6352                     utf8\_bytes[2] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | ((charcode >> 6u) \& 0x3Fu));}
\DoxyCodeLine{6353                     utf8\_bytes[3] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(0x80u | (charcode \& 0x3Fu));}
\DoxyCodeLine{6354                     utf8\_bytes\_filled = 4;}
\DoxyCodeLine{6355                 \}}
\DoxyCodeLine{6356                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{6357                 \{}
\DoxyCodeLine{6358                     utf8\_bytes[0] = \textcolor{keyword}{static\_cast<}std::char\_traits<char>::int\_type\textcolor{keyword}{>}(wc);}
\DoxyCodeLine{6359                     utf8\_bytes\_filled = 1;}
\DoxyCodeLine{6360                 \}}
\DoxyCodeLine{6361             \}}
\DoxyCodeLine{6362         \}}
\DoxyCodeLine{6363     \}}
\DoxyCodeLine{6364 \};}
\DoxyCodeLine{6365 }
\DoxyCodeLine{6366 \textcolor{comment}{// Wraps another input apdater to convert wide character types into individual bytes.}}
\DoxyCodeLine{6367 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BaseInputAdapter, \textcolor{keyword}{typename} W\textcolor{keywordtype}{id}eCharType>}
\DoxyCodeLine{6368 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{wide\_string\_input\_adapter}}}
\DoxyCodeLine{6369 \{}
\DoxyCodeLine{6370   \textcolor{keyword}{public}:}
\DoxyCodeLine{6371     \textcolor{keyword}{using }char\_type = char;}
\DoxyCodeLine{6372 }
\DoxyCodeLine{6373     \mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{wide\_string\_input\_adapter}}(BaseInputAdapter base)}
\DoxyCodeLine{6374         : base\_adapter(base) \{\}}
\DoxyCodeLine{6375 }
\DoxyCodeLine{6376     \textcolor{keyword}{typename} std::char\_traits<char>::int\_type get\_character() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{6377     \{}
\DoxyCodeLine{6378         \textcolor{comment}{// check if buffer needs to be filled}}
\DoxyCodeLine{6379         \textcolor{keywordflow}{if} (utf8\_bytes\_index == utf8\_bytes\_filled)}
\DoxyCodeLine{6380         \{}
\DoxyCodeLine{6381             fill\_buffer<sizeof(WideCharType)>();}
\DoxyCodeLine{6382 }
\DoxyCodeLine{6383             JSON\_ASSERT(utf8\_bytes\_filled > 0);}
\DoxyCodeLine{6384             JSON\_ASSERT(utf8\_bytes\_index == 0);}
\DoxyCodeLine{6385         \}}
\DoxyCodeLine{6386 }
\DoxyCodeLine{6387         \textcolor{comment}{// use buffer}}
\DoxyCodeLine{6388         JSON\_ASSERT(utf8\_bytes\_filled > 0);}
\DoxyCodeLine{6389         JSON\_ASSERT(utf8\_bytes\_index < utf8\_bytes\_filled);}
\DoxyCodeLine{6390         \textcolor{keywordflow}{return} utf8\_bytes[utf8\_bytes\_index++];}
\DoxyCodeLine{6391     \}}
\DoxyCodeLine{6392 }
\DoxyCodeLine{6393   \textcolor{keyword}{private}:}
\DoxyCodeLine{6394     BaseInputAdapter base\_adapter;}
\DoxyCodeLine{6395 }
\DoxyCodeLine{6396     \textcolor{keyword}{template}<\textcolor{keywordtype}{size\_t} T>}
\DoxyCodeLine{6397     \textcolor{keywordtype}{void} fill\_buffer()}
\DoxyCodeLine{6398     \{}
\DoxyCodeLine{6399         \mbox{\hyperlink{structdetail_1_1wide__string__input__helper}{wide\_string\_input\_helper<BaseInputAdapter, T>::fill\_buffer}}(base\_adapter, utf8\_bytes, utf8\_bytes\_index, utf8\_bytes\_filled);}
\DoxyCodeLine{6400     \}}
\DoxyCodeLine{6401 }
\DoxyCodeLine{6403     std::array<std::char\_traits<char>::int\_type, 4> utf8\_bytes = \{\{0, 0, 0, 0\}\};}
\DoxyCodeLine{6404 }
\DoxyCodeLine{6406     std::size\_t utf8\_bytes\_index = 0;}
\DoxyCodeLine{6408     std::size\_t utf8\_bytes\_filled = 0;}
\DoxyCodeLine{6409 \};}
\DoxyCodeLine{6410 }
\DoxyCodeLine{6411 }
\DoxyCodeLine{6412 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{6413 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1iterator__input__adapter__factory}{iterator\_input\_adapter\_factory}}}
\DoxyCodeLine{6414 \{}
\DoxyCodeLine{6415     \textcolor{keyword}{using }iterator\_type = IteratorType;}
\DoxyCodeLine{6416     \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} std::iterator\_traits<iterator\_type>::value\_type;}
\DoxyCodeLine{6417     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{adapter\_type}} = \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{iterator\_input\_adapter<iterator\_type>}};}
\DoxyCodeLine{6418 }
\DoxyCodeLine{6419     \textcolor{keyword}{static} \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{adapter\_type}} create(IteratorType first, IteratorType last)}
\DoxyCodeLine{6420     \{}
\DoxyCodeLine{6421         \textcolor{keywordflow}{return} \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{adapter\_type}}(std::move(first), std::move(last));}
\DoxyCodeLine{6422     \}}
\DoxyCodeLine{6423 \};}
\DoxyCodeLine{6424 }
\DoxyCodeLine{6425 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6426 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__iterator__of__multibyte}{is\_iterator\_of\_multibyte}}}
\DoxyCodeLine{6427 \{}
\DoxyCodeLine{6428     \textcolor{keyword}{using }value\_type = \textcolor{keyword}{typename} std::iterator\_traits<T>::value\_type;}
\DoxyCodeLine{6429     \textcolor{keyword}{enum}}
\DoxyCodeLine{6430     \{}
\DoxyCodeLine{6431         \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} = \textcolor{keyword}{sizeof}(value\_type) > 1}
\DoxyCodeLine{6432     \};}
\DoxyCodeLine{6433 \};}
\DoxyCodeLine{6434 }
\DoxyCodeLine{6435 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{6436 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1iterator__input__adapter__factory}{iterator\_input\_adapter\_factory}}<IteratorType, enable\_if\_t<\mbox{\hyperlink{structdetail_1_1is__iterator__of__multibyte}{is\_iterator\_of\_multibyte}}<IteratorType>::\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}>>}
\DoxyCodeLine{6437 \{}
\DoxyCodeLine{6438     \textcolor{keyword}{using }iterator\_type = IteratorType;}
\DoxyCodeLine{6439     \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} std::iterator\_traits<iterator\_type>::value\_type;}
\DoxyCodeLine{6440     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{base\_adapter\_type}} = \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{iterator\_input\_adapter<iterator\_type>}};}
\DoxyCodeLine{6441     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{adapter\_type}} = \mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{wide\_string\_input\_adapter<base\_adapter\_type, char\_type>}};}
\DoxyCodeLine{6442 }
\DoxyCodeLine{6443     \textcolor{keyword}{static} \mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{adapter\_type}} create(IteratorType first, IteratorType last)}
\DoxyCodeLine{6444     \{}
\DoxyCodeLine{6445         \textcolor{keywordflow}{return} \mbox{\hyperlink{classdetail_1_1wide__string__input__adapter}{adapter\_type}}(\mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{base\_adapter\_type}}(std::move(first), std::move(last)));}
\DoxyCodeLine{6446     \}}
\DoxyCodeLine{6447 \};}
\DoxyCodeLine{6448 }
\DoxyCodeLine{6449 \textcolor{comment}{// General purpose iterator-\/based input}}
\DoxyCodeLine{6450 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{6451 \textcolor{keyword}{typename} \mbox{\hyperlink{classdetail_1_1iterator__input__adapter}{iterator\_input\_adapter\_factory<IteratorType>::adapter\_type}} input\_adapter(IteratorType first, IteratorType last)}
\DoxyCodeLine{6452 \{}
\DoxyCodeLine{6453     \textcolor{keyword}{using }factory\_type = \mbox{\hyperlink{structdetail_1_1iterator__input__adapter__factory}{iterator\_input\_adapter\_factory<IteratorType>}};}
\DoxyCodeLine{6454     \textcolor{keywordflow}{return} factory\_type::create(first, last);}
\DoxyCodeLine{6455 \}}
\DoxyCodeLine{6456 }
\DoxyCodeLine{6457 \textcolor{comment}{// Convenience shorthand from container to iterator}}
\DoxyCodeLine{6458 \textcolor{comment}{// Enables ADL on begin(container) and end(container)}}
\DoxyCodeLine{6459 \textcolor{comment}{// Encloses the using declarations in namespace for not to leak them to outside scope}}
\DoxyCodeLine{6460 }
\DoxyCodeLine{6461 \textcolor{keyword}{namespace }container\_input\_adapter\_factory\_impl}
\DoxyCodeLine{6462 \{}
\DoxyCodeLine{6463 }
\DoxyCodeLine{6464 \textcolor{keyword}{using }std::begin;}
\DoxyCodeLine{6465 \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{6466 }
\DoxyCodeLine{6467 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ContainerType, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{6468 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1container__input__adapter__factory__impl_1_1container__input__adapter__factory}{container\_input\_adapter\_factory}} \{\};}
\DoxyCodeLine{6469 }
\DoxyCodeLine{6470 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ContainerType>}
\DoxyCodeLine{6471 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1container__input__adapter__factory__impl_1_1container__input__adapter__factory}{container\_input\_adapter\_factory}}< ContainerType,}
\DoxyCodeLine{6472        void\_t<decltype(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>()))>>}
\DoxyCodeLine{6473        \{}
\DoxyCodeLine{6474            \textcolor{keyword}{using }adapter\_type = \textcolor{keyword}{decltype}(input\_adapter(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())));}
\DoxyCodeLine{6475 }
\DoxyCodeLine{6476            \textcolor{keyword}{static} adapter\_type create(\textcolor{keyword}{const} ContainerType\& container)}
\DoxyCodeLine{6477 \{}
\DoxyCodeLine{6478     \textcolor{keywordflow}{return} input\_adapter(begin(container), end(container));}
\DoxyCodeLine{6479 \}}
\DoxyCodeLine{6480        \};}
\DoxyCodeLine{6481 }
\DoxyCodeLine{6482 \}  \textcolor{comment}{// namespace container\_input\_adapter\_factory\_impl}}
\DoxyCodeLine{6483 }
\DoxyCodeLine{6484 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ContainerType>}
\DoxyCodeLine{6485 \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1container__input__adapter__factory__impl_1_1container__input__adapter__factory}{container\_input\_adapter\_factory\_impl::container\_input\_adapter\_factory<ContainerType>::adapter\_type}} input\_adapter(\textcolor{keyword}{const} ContainerType\& container)}
\DoxyCodeLine{6486 \{}
\DoxyCodeLine{6487     \textcolor{keywordflow}{return} \mbox{\hyperlink{structdetail_1_1container__input__adapter__factory__impl_1_1container__input__adapter__factory}{container\_input\_adapter\_factory\_impl::container\_input\_adapter\_factory<ContainerType>::create}}(container);}
\DoxyCodeLine{6488 \}}
\DoxyCodeLine{6489 }
\DoxyCodeLine{6490 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{6491 \textcolor{comment}{// Special cases with fast paths}}
\DoxyCodeLine{6492 \textcolor{keyword}{inline} file\_input\_adapter input\_adapter(std::FILE* file)}
\DoxyCodeLine{6493 \{}
\DoxyCodeLine{6494     \textcolor{keywordflow}{return} file\_input\_adapter(file);}
\DoxyCodeLine{6495 \}}
\DoxyCodeLine{6496 }
\DoxyCodeLine{6497 \textcolor{keyword}{inline} input\_stream\_adapter input\_adapter(std::istream\& stream)}
\DoxyCodeLine{6498 \{}
\DoxyCodeLine{6499     \textcolor{keywordflow}{return} input\_stream\_adapter(stream);}
\DoxyCodeLine{6500 \}}
\DoxyCodeLine{6501 }
\DoxyCodeLine{6502 \textcolor{keyword}{inline} input\_stream\_adapter input\_adapter(std::istream\&\& stream)}
\DoxyCodeLine{6503 \{}
\DoxyCodeLine{6504     \textcolor{keywordflow}{return} input\_stream\_adapter(stream);}
\DoxyCodeLine{6505 \}}
\DoxyCodeLine{6506 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{6507 }
\DoxyCodeLine{6508 \textcolor{keyword}{using }contiguous\_bytes\_input\_adapter = \textcolor{keyword}{decltype}(input\_adapter(std::declval<const char*>(), std::declval<const char*>()));}
\DoxyCodeLine{6509 }
\DoxyCodeLine{6510 \textcolor{comment}{// Null-\/delimited strings, and the like.}}
\DoxyCodeLine{6511 \textcolor{keyword}{template} < \textcolor{keyword}{typename} CharT,}
\DoxyCodeLine{6512            \textcolor{keyword}{typename} std::enable\_if <}
\DoxyCodeLine{6513                std::is\_pointer<CharT>::value\&\&}
\DoxyCodeLine{6514                !std::is\_array<CharT>::value\&\&}
\DoxyCodeLine{6515                std::is\_integral<typename std::remove\_pointer<CharT>::type>::value\&\&}
\DoxyCodeLine{6516                \textcolor{keyword}{sizeof}(\textcolor{keyword}{typename} std::remove\_pointer<CharT>::type) == 1,}
\DoxyCodeLine{6517                \textcolor{keywordtype}{int} >::type = 0 >}
\DoxyCodeLine{6518 contiguous\_bytes\_input\_adapter input\_adapter(CharT b)}
\DoxyCodeLine{6519 \{}
\DoxyCodeLine{6520     \textcolor{keyword}{auto} length = std::strlen(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(b));}
\DoxyCodeLine{6521     \textcolor{keyword}{const} \textcolor{keyword}{auto}* ptr = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(b);}
\DoxyCodeLine{6522     \textcolor{keywordflow}{return} input\_adapter(ptr, ptr + length);}
\DoxyCodeLine{6523 \}}
\DoxyCodeLine{6524 }
\DoxyCodeLine{6525 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, std::\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{6526 \textcolor{keyword}{auto} input\_adapter(T (\&array)[N]) -\/> \textcolor{keyword}{decltype}(input\_adapter(array, array + N)) \textcolor{comment}{// NOLINT(cppcoreguidelines-\/avoid-\/c-\/arrays,hicpp-\/avoid-\/c-\/arrays,modernize-\/avoid-\/c-\/arrays)}}
\DoxyCodeLine{6527 \{}
\DoxyCodeLine{6528     \textcolor{keywordflow}{return} input\_adapter(array, array + N);}
\DoxyCodeLine{6529 \}}
\DoxyCodeLine{6530 }
\DoxyCodeLine{6531 \textcolor{comment}{// This class only handles inputs of input\_buffer\_adapter type.}}
\DoxyCodeLine{6532 \textcolor{comment}{// It's required so that expressions like \{ptr, len\} can be implicitly cast}}
\DoxyCodeLine{6533 \textcolor{comment}{// to the correct adapter.}}
\DoxyCodeLine{6534 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1span__input__adapter}{span\_input\_adapter}}}
\DoxyCodeLine{6535 \{}
\DoxyCodeLine{6536   \textcolor{keyword}{public}:}
\DoxyCodeLine{6537     \textcolor{keyword}{template} < \textcolor{keyword}{typename} CharT,}
\DoxyCodeLine{6538                \textcolor{keyword}{typename} std::enable\_if <}
\DoxyCodeLine{6539                    std::is\_pointer<CharT>::value\&\&}
\DoxyCodeLine{6540                    std::is\_integral<typename std::remove\_pointer<CharT>::type>::value\&\&}
\DoxyCodeLine{6541                    \textcolor{keyword}{sizeof}(\textcolor{keyword}{typename} std::remove\_pointer<CharT>::type) == 1,}
\DoxyCodeLine{6542                    \textcolor{keywordtype}{int} >::type = 0 >}
\DoxyCodeLine{6543     \mbox{\hyperlink{classdetail_1_1span__input__adapter}{span\_input\_adapter}}(CharT b, std::size\_t l)}
\DoxyCodeLine{6544         : ia(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(b), \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(b) + l) \{\}}
\DoxyCodeLine{6545 }
\DoxyCodeLine{6546     \textcolor{keyword}{template}<\textcolor{keyword}{class }IteratorType,}
\DoxyCodeLine{6547              \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{6548                  std::is\_same<typename iterator\_traits<IteratorType>::iterator\_category, std::random\_access\_iterator\_tag>::value,}
\DoxyCodeLine{6549                  \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{6550     \mbox{\hyperlink{classdetail_1_1span__input__adapter}{span\_input\_adapter}}(IteratorType first, IteratorType last)}
\DoxyCodeLine{6551         : ia(input\_adapter(first, last)) \{\}}
\DoxyCodeLine{6552 }
\DoxyCodeLine{6553     contiguous\_bytes\_input\_adapter\&\& get()}
\DoxyCodeLine{6554     \{}
\DoxyCodeLine{6555         \textcolor{keywordflow}{return} std::move(ia); \textcolor{comment}{// NOLINT(hicpp-\/move-\/const-\/arg,performance-\/move-\/const-\/arg)}}
\DoxyCodeLine{6556     \}}
\DoxyCodeLine{6557 }
\DoxyCodeLine{6558   \textcolor{keyword}{private}:}
\DoxyCodeLine{6559     contiguous\_bytes\_input\_adapter ia;}
\DoxyCodeLine{6560 \};}
\DoxyCodeLine{6561 }
\DoxyCodeLine{6562 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{6563 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{6564 }
\DoxyCodeLine{6565 \textcolor{comment}{// \#include <nlohmann/detail/input/json\_sax.hpp>}}
\DoxyCodeLine{6566 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{6567 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{6568 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{6569 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{6570 \textcolor{comment}{//}}
\DoxyCodeLine{6571 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{6572 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{6573 }
\DoxyCodeLine{6574 }
\DoxyCodeLine{6575 }
\DoxyCodeLine{6576 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{6577 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{6578 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// move}}
\DoxyCodeLine{6579 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{6580 }
\DoxyCodeLine{6581 \textcolor{comment}{// \#include <nlohmann/detail/exceptions.hpp>}}
\DoxyCodeLine{6582 }
\DoxyCodeLine{6583 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{6584 }
\DoxyCodeLine{6585 \textcolor{comment}{// \#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{6586 }
\DoxyCodeLine{6587 }
\DoxyCodeLine{6588 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{6589 }
\DoxyCodeLine{6598 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{6599 \textcolor{keyword}{struct }\mbox{\hyperlink{structjson__sax}{json\_sax}}}
\DoxyCodeLine{6600 \{}
\DoxyCodeLine{6601     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{6602     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{6603     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{6604     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{6605     \textcolor{keyword}{using }binary\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t;}
\DoxyCodeLine{6606 }
\DoxyCodeLine{6611     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_acbcc09c0ada2782cd73cc4135823181d}{null}}() = 0;}
\DoxyCodeLine{6612 }
\DoxyCodeLine{6618     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_ab89f75382c0fd7fe81c95fc84cfa3150}{boolean}}(\textcolor{keywordtype}{bool} val) = 0;}
\DoxyCodeLine{6619 }
\DoxyCodeLine{6625     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a46cc306b7677553d8f6bd8c9592eb1bd}{number\_integer}}(number\_integer\_t val) = 0;}
\DoxyCodeLine{6626 }
\DoxyCodeLine{6632     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a32f8a32794cb384f0de3d3a96a6bb696}{number\_unsigned}}(number\_unsigned\_t val) = 0;}
\DoxyCodeLine{6633 }
\DoxyCodeLine{6640     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a19eafa3a92fc75e0258a842283396aa9}{number\_float}}(number\_float\_t val, \textcolor{keyword}{const} string\_t\& s) = 0;}
\DoxyCodeLine{6641 }
\DoxyCodeLine{6648     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a3da9ee0c61f1a37e6c6a3d2dccb16765}{string}}(string\_t\& val) = 0;}
\DoxyCodeLine{6649 }
\DoxyCodeLine{6656     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}}(binary\_t\& val) = 0;}
\DoxyCodeLine{6657 }
\DoxyCodeLine{6664     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a54a0883df64f40664395e3dad674aaa5}{start\_object}}(std::size\_t elements) = 0;}
\DoxyCodeLine{6665 }
\DoxyCodeLine{6672     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}(string\_t\& val) = 0;}
\DoxyCodeLine{6673 }
\DoxyCodeLine{6678     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_ac34854cab5e023c5d0e8b381a11aba5b}{end\_object}}() = 0;}
\DoxyCodeLine{6679 }
\DoxyCodeLine{6686     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_afc4d5c0d123f2e3c939060a778c4f22c}{start\_array}}(std::size\_t elements) = 0;}
\DoxyCodeLine{6687 }
\DoxyCodeLine{6692     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a81fbddbf7dc96eab21ef916625ad5f3b}{end\_array}}() = 0;}
\DoxyCodeLine{6693 }
\DoxyCodeLine{6701     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_af165920966b60b78e57a2e4d92a63897}{parse\_error}}(std::size\_t position,}
\DoxyCodeLine{6702                              \textcolor{keyword}{const} std::string\& last\_token,}
\DoxyCodeLine{6703                              \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1exception}{detail::exception}}\& ex) = 0;}
\DoxyCodeLine{6704 }
\DoxyCodeLine{6705     \mbox{\hyperlink{structjson__sax}{json\_sax}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6706     \mbox{\hyperlink{structjson__sax}{json\_sax}}(\textcolor{keyword}{const} \mbox{\hyperlink{structjson__sax}{json\_sax}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6707     \mbox{\hyperlink{structjson__sax}{json\_sax}}(\mbox{\hyperlink{structjson__sax}{json\_sax}}\&\&) noexcept = default;}
\DoxyCodeLine{6708     \mbox{\hyperlink{structjson__sax}{json\_sax}}\& operator=(const \mbox{\hyperlink{structjson__sax}{json\_sax}}\&) = default;}
\DoxyCodeLine{6709     \mbox{\hyperlink{structjson__sax}{json\_sax}}\& operator=(\mbox{\hyperlink{structjson__sax}{json\_sax}}\&\&) noexcept = default;}
\DoxyCodeLine{6710     virtual \string~\mbox{\hyperlink{structjson__sax}{json\_sax}}() = default;}
\DoxyCodeLine{6711 \};}
\DoxyCodeLine{6712 }
\DoxyCodeLine{6713 }
\DoxyCodeLine{6714 namespace \mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{6715 \{}
\DoxyCodeLine{6729 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{6730 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{json\_sax\_dom\_parser}}}
\DoxyCodeLine{6731 \{}
\DoxyCodeLine{6732   \textcolor{keyword}{public}:}
\DoxyCodeLine{6733     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{6734     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{6735     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{6736     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{6737     \textcolor{keyword}{using }binary\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t;}
\DoxyCodeLine{6738 }
\DoxyCodeLine{6744     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser_a3ee72f78d1ebdd8f8573ccf2b8e3ea6f}{json\_sax\_dom\_parser}}(BasicJsonType\& r, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions\_ = \textcolor{keyword}{true})}
\DoxyCodeLine{6745         : root(r), allow\_exceptions(allow\_exceptions\_)}
\DoxyCodeLine{6746     \{\}}
\DoxyCodeLine{6747 }
\DoxyCodeLine{6748     \textcolor{comment}{// make class move-\/only}}
\DoxyCodeLine{6749     \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{json\_sax\_dom\_parser}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{json\_sax\_dom\_parser}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6750     \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{json\_sax\_dom\_parser}}(\mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{json\_sax\_dom\_parser}}\&\&) = \textcolor{keywordflow}{default}; \textcolor{comment}{// NOLINT(hicpp-\/noexcept-\/move,performance-\/noexcept-\/move-\/constructor)}}
\DoxyCodeLine{6751     \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{json\_sax\_dom\_parser}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{json\_sax\_dom\_parser}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6752     \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{json\_sax\_dom\_parser}}\& operator=(\mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{json\_sax\_dom\_parser}}\&\&) = \textcolor{keywordflow}{default}; \textcolor{comment}{// NOLINT(hicpp-\/noexcept-\/move,performance-\/noexcept-\/move-\/constructor)}}
\DoxyCodeLine{6753     \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{\string~json\_sax\_dom\_parser}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6754 }
\DoxyCodeLine{6755     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_acbcc09c0ada2782cd73cc4135823181d}{null}}()}
\DoxyCodeLine{6756     \{}
\DoxyCodeLine{6757         handle\_value(\textcolor{keyword}{nullptr});}
\DoxyCodeLine{6758         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6759     \}}
\DoxyCodeLine{6760 }
\DoxyCodeLine{6761     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_ab89f75382c0fd7fe81c95fc84cfa3150}{boolean}}(\textcolor{keywordtype}{bool} val)}
\DoxyCodeLine{6762     \{}
\DoxyCodeLine{6763         handle\_value(val);}
\DoxyCodeLine{6764         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6765     \}}
\DoxyCodeLine{6766 }
\DoxyCodeLine{6767     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a46cc306b7677553d8f6bd8c9592eb1bd}{number\_integer}}(number\_integer\_t val)}
\DoxyCodeLine{6768     \{}
\DoxyCodeLine{6769         handle\_value(val);}
\DoxyCodeLine{6770         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6771     \}}
\DoxyCodeLine{6772 }
\DoxyCodeLine{6773     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a32f8a32794cb384f0de3d3a96a6bb696}{number\_unsigned}}(number\_unsigned\_t val)}
\DoxyCodeLine{6774     \{}
\DoxyCodeLine{6775         handle\_value(val);}
\DoxyCodeLine{6776         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6777     \}}
\DoxyCodeLine{6778 }
\DoxyCodeLine{6779     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a19eafa3a92fc75e0258a842283396aa9}{number\_float}}(number\_float\_t val, \textcolor{keyword}{const} string\_t\& \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{6780     \{}
\DoxyCodeLine{6781         handle\_value(val);}
\DoxyCodeLine{6782         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6783     \}}
\DoxyCodeLine{6784 }
\DoxyCodeLine{6785     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a3da9ee0c61f1a37e6c6a3d2dccb16765}{string}}(string\_t\& val)}
\DoxyCodeLine{6786     \{}
\DoxyCodeLine{6787         handle\_value(val);}
\DoxyCodeLine{6788         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6789     \}}
\DoxyCodeLine{6790 }
\DoxyCodeLine{6791     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}}(binary\_t\& val)}
\DoxyCodeLine{6792     \{}
\DoxyCodeLine{6793         handle\_value(std::move(val));}
\DoxyCodeLine{6794         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6795     \}}
\DoxyCodeLine{6796 }
\DoxyCodeLine{6797     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a54a0883df64f40664395e3dad674aaa5}{start\_object}}(std::size\_t len)}
\DoxyCodeLine{6798     \{}
\DoxyCodeLine{6799         ref\_stack.push\_back(handle\_value(BasicJsonType::value\_t::object));}
\DoxyCodeLine{6800 }
\DoxyCodeLine{6801         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(len != \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1) \&\& len > ref\_stack.back()-\/>max\_size()))}
\DoxyCodeLine{6802         \{}
\DoxyCodeLine{6803             JSON\_THROW(out\_of\_range::create(408, concat(\textcolor{stringliteral}{"{}excessive object size: "{}}, std::to\_string(len)), ref\_stack.back()));}
\DoxyCodeLine{6804         \}}
\DoxyCodeLine{6805 }
\DoxyCodeLine{6806         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6807     \}}
\DoxyCodeLine{6808 }
\DoxyCodeLine{6809     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}(string\_t\& val)}
\DoxyCodeLine{6810     \{}
\DoxyCodeLine{6811         JSON\_ASSERT(!ref\_stack.empty());}
\DoxyCodeLine{6812         JSON\_ASSERT(ref\_stack.back()-\/>is\_object());}
\DoxyCodeLine{6813 }
\DoxyCodeLine{6814         \textcolor{comment}{// add null at given key and store the reference for later}}
\DoxyCodeLine{6815         object\_element = \&(ref\_stack.back()-\/>m\_value.object-\/>operator[](val));}
\DoxyCodeLine{6816         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6817     \}}
\DoxyCodeLine{6818 }
\DoxyCodeLine{6819     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_ac34854cab5e023c5d0e8b381a11aba5b}{end\_object}}()}
\DoxyCodeLine{6820     \{}
\DoxyCodeLine{6821         JSON\_ASSERT(!ref\_stack.empty());}
\DoxyCodeLine{6822         JSON\_ASSERT(ref\_stack.back()-\/>is\_object());}
\DoxyCodeLine{6823 }
\DoxyCodeLine{6824         ref\_stack.back()-\/>set\_parents();}
\DoxyCodeLine{6825         ref\_stack.pop\_back();}
\DoxyCodeLine{6826         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6827     \}}
\DoxyCodeLine{6828 }
\DoxyCodeLine{6829     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_afc4d5c0d123f2e3c939060a778c4f22c}{start\_array}}(std::size\_t len)}
\DoxyCodeLine{6830     \{}
\DoxyCodeLine{6831         ref\_stack.push\_back(handle\_value(BasicJsonType::value\_t::array));}
\DoxyCodeLine{6832 }
\DoxyCodeLine{6833         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(len != \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1) \&\& len > ref\_stack.back()-\/>max\_size()))}
\DoxyCodeLine{6834         \{}
\DoxyCodeLine{6835             JSON\_THROW(out\_of\_range::create(408, concat(\textcolor{stringliteral}{"{}excessive array size: "{}}, std::to\_string(len)), ref\_stack.back()));}
\DoxyCodeLine{6836         \}}
\DoxyCodeLine{6837 }
\DoxyCodeLine{6838         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6839     \}}
\DoxyCodeLine{6840 }
\DoxyCodeLine{6841     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a81fbddbf7dc96eab21ef916625ad5f3b}{end\_array}}()}
\DoxyCodeLine{6842     \{}
\DoxyCodeLine{6843         JSON\_ASSERT(!ref\_stack.empty());}
\DoxyCodeLine{6844         JSON\_ASSERT(ref\_stack.back()-\/>is\_array());}
\DoxyCodeLine{6845 }
\DoxyCodeLine{6846         ref\_stack.back()-\/>set\_parents();}
\DoxyCodeLine{6847         ref\_stack.pop\_back();}
\DoxyCodeLine{6848         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6849     \}}
\DoxyCodeLine{6850 }
\DoxyCodeLine{6851     \textcolor{keyword}{template}<\textcolor{keyword}{class} Exception>}
\DoxyCodeLine{6852     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_af165920966b60b78e57a2e4d92a63897}{parse\_error}}(std::size\_t \textcolor{comment}{/*unused*/}, \textcolor{keyword}{const} std::string\& \textcolor{comment}{/*unused*/},}
\DoxyCodeLine{6853                      \textcolor{keyword}{const} Exception\& ex)}
\DoxyCodeLine{6854     \{}
\DoxyCodeLine{6855         errored = \textcolor{keyword}{true};}
\DoxyCodeLine{6856         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(ex);}
\DoxyCodeLine{6857         \textcolor{keywordflow}{if} (allow\_exceptions)}
\DoxyCodeLine{6858         \{}
\DoxyCodeLine{6859             JSON\_THROW(ex);}
\DoxyCodeLine{6860         \}}
\DoxyCodeLine{6861         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{6862     \}}
\DoxyCodeLine{6863 }
\DoxyCodeLine{6864     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} is\_errored()\textcolor{keyword}{ const}}
\DoxyCodeLine{6865 \textcolor{keyword}{    }\{}
\DoxyCodeLine{6866         \textcolor{keywordflow}{return} errored;}
\DoxyCodeLine{6867     \}}
\DoxyCodeLine{6868 }
\DoxyCodeLine{6869   \textcolor{keyword}{private}:}
\DoxyCodeLine{6876     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{6877     JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{6878     BasicJsonType* handle\_value(Value\&\& v)}
\DoxyCodeLine{6879     \{}
\DoxyCodeLine{6880         \textcolor{keywordflow}{if} (ref\_stack.empty())}
\DoxyCodeLine{6881         \{}
\DoxyCodeLine{6882             root = BasicJsonType(std::forward<Value>(v));}
\DoxyCodeLine{6883             \textcolor{keywordflow}{return} \&root;}
\DoxyCodeLine{6884         \}}
\DoxyCodeLine{6885 }
\DoxyCodeLine{6886         JSON\_ASSERT(ref\_stack.back()-\/>is\_array() || ref\_stack.back()-\/>is\_object());}
\DoxyCodeLine{6887 }
\DoxyCodeLine{6888         \textcolor{keywordflow}{if} (ref\_stack.back()-\/>is\_array())}
\DoxyCodeLine{6889         \{}
\DoxyCodeLine{6890             ref\_stack.back()-\/>m\_value.array-\/>emplace\_back(std::forward<Value>(v));}
\DoxyCodeLine{6891             \textcolor{keywordflow}{return} \&(ref\_stack.back()-\/>m\_value.array-\/>back());}
\DoxyCodeLine{6892         \}}
\DoxyCodeLine{6893 }
\DoxyCodeLine{6894         JSON\_ASSERT(ref\_stack.back()-\/>is\_object());}
\DoxyCodeLine{6895         JSON\_ASSERT(object\_element);}
\DoxyCodeLine{6896         *object\_element = BasicJsonType(std::forward<Value>(v));}
\DoxyCodeLine{6897         \textcolor{keywordflow}{return} object\_element;}
\DoxyCodeLine{6898     \}}
\DoxyCodeLine{6899 }
\DoxyCodeLine{6901     BasicJsonType\& root;}
\DoxyCodeLine{6903     std::vector<BasicJsonType*> ref\_stack \{\};}
\DoxyCodeLine{6905     BasicJsonType* object\_element = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{6907     \textcolor{keywordtype}{bool} errored = \textcolor{keyword}{false};}
\DoxyCodeLine{6909     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true};}
\DoxyCodeLine{6910 \};}
\DoxyCodeLine{6911 }
\DoxyCodeLine{6912 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{6913 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser}}}
\DoxyCodeLine{6914 \{}
\DoxyCodeLine{6915   \textcolor{keyword}{public}:}
\DoxyCodeLine{6916     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{6917     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{6918     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{6919     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{6920     \textcolor{keyword}{using }binary\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t;}
\DoxyCodeLine{6921     \textcolor{keyword}{using }parser\_callback\_t = \textcolor{keyword}{typename} BasicJsonType::parser\_callback\_t;}
\DoxyCodeLine{6922     \textcolor{keyword}{using }parse\_event\_t = \textcolor{keyword}{typename} BasicJsonType::parse\_event\_t;}
\DoxyCodeLine{6923 }
\DoxyCodeLine{6924     \mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser}}(BasicJsonType\& r,}
\DoxyCodeLine{6925                                  \textcolor{keyword}{const} parser\_callback\_t cb,}
\DoxyCodeLine{6926                                  \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions\_ = \textcolor{keyword}{true})}
\DoxyCodeLine{6927         : root(r), callback(cb), allow\_exceptions(allow\_exceptions\_)}
\DoxyCodeLine{6928     \{}
\DoxyCodeLine{6929         keep\_stack.push\_back(\textcolor{keyword}{true});}
\DoxyCodeLine{6930     \}}
\DoxyCodeLine{6931 }
\DoxyCodeLine{6932     \textcolor{comment}{// make class move-\/only}}
\DoxyCodeLine{6933     \mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6934     \mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser}}(\mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser}}\&\&) = \textcolor{keywordflow}{default}; \textcolor{comment}{// NOLINT(hicpp-\/noexcept-\/move,performance-\/noexcept-\/move-\/constructor)}}
\DoxyCodeLine{6935     \mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6936     \mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser}}\& operator=(\mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser}}\&\&) = \textcolor{keywordflow}{default}; \textcolor{comment}{// NOLINT(hicpp-\/noexcept-\/move,performance-\/noexcept-\/move-\/constructor)}}
\DoxyCodeLine{6937     \mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{\string~json\_sax\_dom\_callback\_parser}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6938 }
\DoxyCodeLine{6939     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_acbcc09c0ada2782cd73cc4135823181d}{null}}()}
\DoxyCodeLine{6940     \{}
\DoxyCodeLine{6941         handle\_value(\textcolor{keyword}{nullptr});}
\DoxyCodeLine{6942         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6943     \}}
\DoxyCodeLine{6944 }
\DoxyCodeLine{6945     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_ab89f75382c0fd7fe81c95fc84cfa3150}{boolean}}(\textcolor{keywordtype}{bool} val)}
\DoxyCodeLine{6946     \{}
\DoxyCodeLine{6947         handle\_value(val);}
\DoxyCodeLine{6948         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6949     \}}
\DoxyCodeLine{6950 }
\DoxyCodeLine{6951     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a46cc306b7677553d8f6bd8c9592eb1bd}{number\_integer}}(number\_integer\_t val)}
\DoxyCodeLine{6952     \{}
\DoxyCodeLine{6953         handle\_value(val);}
\DoxyCodeLine{6954         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6955     \}}
\DoxyCodeLine{6956 }
\DoxyCodeLine{6957     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a32f8a32794cb384f0de3d3a96a6bb696}{number\_unsigned}}(number\_unsigned\_t val)}
\DoxyCodeLine{6958     \{}
\DoxyCodeLine{6959         handle\_value(val);}
\DoxyCodeLine{6960         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6961     \}}
\DoxyCodeLine{6962 }
\DoxyCodeLine{6963     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a19eafa3a92fc75e0258a842283396aa9}{number\_float}}(number\_float\_t val, \textcolor{keyword}{const} string\_t\& \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{6964     \{}
\DoxyCodeLine{6965         handle\_value(val);}
\DoxyCodeLine{6966         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6967     \}}
\DoxyCodeLine{6968 }
\DoxyCodeLine{6969     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a3da9ee0c61f1a37e6c6a3d2dccb16765}{string}}(string\_t\& val)}
\DoxyCodeLine{6970     \{}
\DoxyCodeLine{6971         handle\_value(val);}
\DoxyCodeLine{6972         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6973     \}}
\DoxyCodeLine{6974 }
\DoxyCodeLine{6975     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}}(binary\_t\& val)}
\DoxyCodeLine{6976     \{}
\DoxyCodeLine{6977         handle\_value(std::move(val));}
\DoxyCodeLine{6978         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6979     \}}
\DoxyCodeLine{6980 }
\DoxyCodeLine{6981     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a54a0883df64f40664395e3dad674aaa5}{start\_object}}(std::size\_t len)}
\DoxyCodeLine{6982     \{}
\DoxyCodeLine{6983         \textcolor{comment}{// check callback for object start}}
\DoxyCodeLine{6984         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} keep = callback(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(ref\_stack.size()), parse\_event\_t::object\_start, \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{discarded}});}
\DoxyCodeLine{6985         keep\_stack.push\_back(keep);}
\DoxyCodeLine{6986 }
\DoxyCodeLine{6987         \textcolor{keyword}{auto} val = handle\_value(BasicJsonType::value\_t::object, \textcolor{keyword}{true});}
\DoxyCodeLine{6988         ref\_stack.push\_back(val.second);}
\DoxyCodeLine{6989 }
\DoxyCodeLine{6990         \textcolor{comment}{// check object limit}}
\DoxyCodeLine{6991         \textcolor{keywordflow}{if} (ref\_stack.back() \&\& JSON\_HEDLEY\_UNLIKELY(len != \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1) \&\& len > ref\_stack.back()-\/>max\_size()))}
\DoxyCodeLine{6992         \{}
\DoxyCodeLine{6993             JSON\_THROW(out\_of\_range::create(408, concat(\textcolor{stringliteral}{"{}excessive object size: "{}}, std::to\_string(len)), ref\_stack.back()));}
\DoxyCodeLine{6994         \}}
\DoxyCodeLine{6995 }
\DoxyCodeLine{6996         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{6997     \}}
\DoxyCodeLine{6998 }
\DoxyCodeLine{6999     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}(string\_t\& val)}
\DoxyCodeLine{7000     \{}
\DoxyCodeLine{7001         BasicJsonType k = BasicJsonType(val);}
\DoxyCodeLine{7002 }
\DoxyCodeLine{7003         \textcolor{comment}{// check callback for key}}
\DoxyCodeLine{7004         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} keep = callback(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(ref\_stack.size()), parse\_event\_t::key, k);}
\DoxyCodeLine{7005         key\_keep\_stack.push\_back(keep);}
\DoxyCodeLine{7006 }
\DoxyCodeLine{7007         \textcolor{comment}{// add discarded value at given key and store the reference for later}}
\DoxyCodeLine{7008         \textcolor{keywordflow}{if} (keep \&\& ref\_stack.back())}
\DoxyCodeLine{7009         \{}
\DoxyCodeLine{7010             object\_element = \&(ref\_stack.back()-\/>m\_value.object-\/>operator[](val) = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{discarded}});}
\DoxyCodeLine{7011         \}}
\DoxyCodeLine{7012 }
\DoxyCodeLine{7013         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7014     \}}
\DoxyCodeLine{7015 }
\DoxyCodeLine{7016     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_ac34854cab5e023c5d0e8b381a11aba5b}{end\_object}}()}
\DoxyCodeLine{7017     \{}
\DoxyCodeLine{7018         \textcolor{keywordflow}{if} (ref\_stack.back())}
\DoxyCodeLine{7019         \{}
\DoxyCodeLine{7020             \textcolor{keywordflow}{if} (!callback(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(ref\_stack.size()) -\/ 1, parse\_event\_t::object\_end, *ref\_stack.back()))}
\DoxyCodeLine{7021             \{}
\DoxyCodeLine{7022                 \textcolor{comment}{// discard object}}
\DoxyCodeLine{7023                 *ref\_stack.back() = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{discarded}};}
\DoxyCodeLine{7024             \}}
\DoxyCodeLine{7025             \textcolor{keywordflow}{else}}
\DoxyCodeLine{7026             \{}
\DoxyCodeLine{7027                 ref\_stack.back()-\/>set\_parents();}
\DoxyCodeLine{7028             \}}
\DoxyCodeLine{7029         \}}
\DoxyCodeLine{7030 }
\DoxyCodeLine{7031         JSON\_ASSERT(!ref\_stack.empty());}
\DoxyCodeLine{7032         JSON\_ASSERT(!keep\_stack.empty());}
\DoxyCodeLine{7033         ref\_stack.pop\_back();}
\DoxyCodeLine{7034         keep\_stack.pop\_back();}
\DoxyCodeLine{7035 }
\DoxyCodeLine{7036         \textcolor{keywordflow}{if} (!ref\_stack.empty() \&\& ref\_stack.back() \&\& ref\_stack.back()-\/>is\_structured())}
\DoxyCodeLine{7037         \{}
\DoxyCodeLine{7038             \textcolor{comment}{// remove discarded value}}
\DoxyCodeLine{7039             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = ref\_stack.back()-\/>begin(); it != ref\_stack.back()-\/>end(); ++it)}
\DoxyCodeLine{7040             \{}
\DoxyCodeLine{7041                 \textcolor{keywordflow}{if} (it-\/>is\_discarded())}
\DoxyCodeLine{7042                 \{}
\DoxyCodeLine{7043                     ref\_stack.back()-\/>erase(it);}
\DoxyCodeLine{7044                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{7045                 \}}
\DoxyCodeLine{7046             \}}
\DoxyCodeLine{7047         \}}
\DoxyCodeLine{7048 }
\DoxyCodeLine{7049         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7050     \}}
\DoxyCodeLine{7051 }
\DoxyCodeLine{7052     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_afc4d5c0d123f2e3c939060a778c4f22c}{start\_array}}(std::size\_t len)}
\DoxyCodeLine{7053     \{}
\DoxyCodeLine{7054         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} keep = callback(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(ref\_stack.size()), parse\_event\_t::array\_start, \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{discarded}});}
\DoxyCodeLine{7055         keep\_stack.push\_back(keep);}
\DoxyCodeLine{7056 }
\DoxyCodeLine{7057         \textcolor{keyword}{auto} val = handle\_value(BasicJsonType::value\_t::array, \textcolor{keyword}{true});}
\DoxyCodeLine{7058         ref\_stack.push\_back(val.second);}
\DoxyCodeLine{7059 }
\DoxyCodeLine{7060         \textcolor{comment}{// check array limit}}
\DoxyCodeLine{7061         \textcolor{keywordflow}{if} (ref\_stack.back() \&\& JSON\_HEDLEY\_UNLIKELY(len != \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1) \&\& len > ref\_stack.back()-\/>max\_size()))}
\DoxyCodeLine{7062         \{}
\DoxyCodeLine{7063             JSON\_THROW(out\_of\_range::create(408, concat(\textcolor{stringliteral}{"{}excessive array size: "{}}, std::to\_string(len)), ref\_stack.back()));}
\DoxyCodeLine{7064         \}}
\DoxyCodeLine{7065 }
\DoxyCodeLine{7066         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7067     \}}
\DoxyCodeLine{7068 }
\DoxyCodeLine{7069     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a81fbddbf7dc96eab21ef916625ad5f3b}{end\_array}}()}
\DoxyCodeLine{7070     \{}
\DoxyCodeLine{7071         \textcolor{keywordtype}{bool} keep = \textcolor{keyword}{true};}
\DoxyCodeLine{7072 }
\DoxyCodeLine{7073         \textcolor{keywordflow}{if} (ref\_stack.back())}
\DoxyCodeLine{7074         \{}
\DoxyCodeLine{7075             keep = callback(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(ref\_stack.size()) -\/ 1, parse\_event\_t::array\_end, *ref\_stack.back());}
\DoxyCodeLine{7076             \textcolor{keywordflow}{if} (keep)}
\DoxyCodeLine{7077             \{}
\DoxyCodeLine{7078                 ref\_stack.back()-\/>set\_parents();}
\DoxyCodeLine{7079             \}}
\DoxyCodeLine{7080             \textcolor{keywordflow}{else}}
\DoxyCodeLine{7081             \{}
\DoxyCodeLine{7082                 \textcolor{comment}{// discard array}}
\DoxyCodeLine{7083                 *ref\_stack.back() = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{discarded}};}
\DoxyCodeLine{7084             \}}
\DoxyCodeLine{7085         \}}
\DoxyCodeLine{7086 }
\DoxyCodeLine{7087         JSON\_ASSERT(!ref\_stack.empty());}
\DoxyCodeLine{7088         JSON\_ASSERT(!keep\_stack.empty());}
\DoxyCodeLine{7089         ref\_stack.pop\_back();}
\DoxyCodeLine{7090         keep\_stack.pop\_back();}
\DoxyCodeLine{7091 }
\DoxyCodeLine{7092         \textcolor{comment}{// remove discarded value}}
\DoxyCodeLine{7093         \textcolor{keywordflow}{if} (!keep \&\& !ref\_stack.empty() \&\& ref\_stack.back()-\/>is\_array())}
\DoxyCodeLine{7094         \{}
\DoxyCodeLine{7095             ref\_stack.back()-\/>m\_value.array-\/>pop\_back();}
\DoxyCodeLine{7096         \}}
\DoxyCodeLine{7097 }
\DoxyCodeLine{7098         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7099     \}}
\DoxyCodeLine{7100 }
\DoxyCodeLine{7101     \textcolor{keyword}{template}<\textcolor{keyword}{class} Exception>}
\DoxyCodeLine{7102     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_af165920966b60b78e57a2e4d92a63897}{parse\_error}}(std::size\_t \textcolor{comment}{/*unused*/}, \textcolor{keyword}{const} std::string\& \textcolor{comment}{/*unused*/},}
\DoxyCodeLine{7103                      \textcolor{keyword}{const} Exception\& ex)}
\DoxyCodeLine{7104     \{}
\DoxyCodeLine{7105         errored = \textcolor{keyword}{true};}
\DoxyCodeLine{7106         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(ex);}
\DoxyCodeLine{7107         \textcolor{keywordflow}{if} (allow\_exceptions)}
\DoxyCodeLine{7108         \{}
\DoxyCodeLine{7109             JSON\_THROW(ex);}
\DoxyCodeLine{7110         \}}
\DoxyCodeLine{7111         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{7112     \}}
\DoxyCodeLine{7113 }
\DoxyCodeLine{7114     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} is\_errored()\textcolor{keyword}{ const}}
\DoxyCodeLine{7115 \textcolor{keyword}{    }\{}
\DoxyCodeLine{7116         \textcolor{keywordflow}{return} errored;}
\DoxyCodeLine{7117     \}}
\DoxyCodeLine{7118 }
\DoxyCodeLine{7119   \textcolor{keyword}{private}:}
\DoxyCodeLine{7135     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{7136     std::pair<bool, BasicJsonType*> handle\_value(Value\&\& v, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} skip\_callback = \textcolor{keyword}{false})}
\DoxyCodeLine{7137     \{}
\DoxyCodeLine{7138         JSON\_ASSERT(!keep\_stack.empty());}
\DoxyCodeLine{7139 }
\DoxyCodeLine{7140         \textcolor{comment}{// do not handle this value if we know it would be added to a discarded}}
\DoxyCodeLine{7141         \textcolor{comment}{// container}}
\DoxyCodeLine{7142         \textcolor{keywordflow}{if} (!keep\_stack.back())}
\DoxyCodeLine{7143         \{}
\DoxyCodeLine{7144             \textcolor{keywordflow}{return} \{\textcolor{keyword}{false}, \textcolor{keyword}{nullptr}\};}
\DoxyCodeLine{7145         \}}
\DoxyCodeLine{7146 }
\DoxyCodeLine{7147         \textcolor{comment}{// create value}}
\DoxyCodeLine{7148         \textcolor{keyword}{auto} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} = BasicJsonType(std::forward<Value>(v));}
\DoxyCodeLine{7149 }
\DoxyCodeLine{7150         \textcolor{comment}{// check callback}}
\DoxyCodeLine{7151         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} keep = skip\_callback || callback(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(ref\_stack.size()), parse\_event\_t::value, \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}});}
\DoxyCodeLine{7152 }
\DoxyCodeLine{7153         \textcolor{comment}{// do not handle this value if we just learnt it shall be discarded}}
\DoxyCodeLine{7154         \textcolor{keywordflow}{if} (!keep)}
\DoxyCodeLine{7155         \{}
\DoxyCodeLine{7156             \textcolor{keywordflow}{return} \{\textcolor{keyword}{false}, \textcolor{keyword}{nullptr}\};}
\DoxyCodeLine{7157         \}}
\DoxyCodeLine{7158 }
\DoxyCodeLine{7159         \textcolor{keywordflow}{if} (ref\_stack.empty())}
\DoxyCodeLine{7160         \{}
\DoxyCodeLine{7161             root = std::move(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}});}
\DoxyCodeLine{7162             \textcolor{keywordflow}{return} \{\textcolor{keyword}{true}, \&root\};}
\DoxyCodeLine{7163         \}}
\DoxyCodeLine{7164 }
\DoxyCodeLine{7165         \textcolor{comment}{// skip this value if we already decided to skip the parent}}
\DoxyCodeLine{7166         \textcolor{comment}{// (https://github.com/nlohmann/json/issues/971\#issuecomment-\/413678360)}}
\DoxyCodeLine{7167         \textcolor{keywordflow}{if} (!ref\_stack.back())}
\DoxyCodeLine{7168         \{}
\DoxyCodeLine{7169             \textcolor{keywordflow}{return} \{\textcolor{keyword}{false}, \textcolor{keyword}{nullptr}\};}
\DoxyCodeLine{7170         \}}
\DoxyCodeLine{7171 }
\DoxyCodeLine{7172         \textcolor{comment}{// we now only expect arrays and objects}}
\DoxyCodeLine{7173         JSON\_ASSERT(ref\_stack.back()-\/>is\_array() || ref\_stack.back()-\/>is\_object());}
\DoxyCodeLine{7174 }
\DoxyCodeLine{7175         \textcolor{comment}{// array}}
\DoxyCodeLine{7176         \textcolor{keywordflow}{if} (ref\_stack.back()-\/>is\_array())}
\DoxyCodeLine{7177         \{}
\DoxyCodeLine{7178             ref\_stack.back()-\/>m\_value.array-\/>emplace\_back(std::move(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}));}
\DoxyCodeLine{7179             \textcolor{keywordflow}{return} \{\textcolor{keyword}{true}, \&(ref\_stack.back()-\/>m\_value.array-\/>back())\};}
\DoxyCodeLine{7180         \}}
\DoxyCodeLine{7181 }
\DoxyCodeLine{7182         \textcolor{comment}{// object}}
\DoxyCodeLine{7183         JSON\_ASSERT(ref\_stack.back()-\/>is\_object());}
\DoxyCodeLine{7184         \textcolor{comment}{// check if we should store an element for the current key}}
\DoxyCodeLine{7185         JSON\_ASSERT(!key\_keep\_stack.empty());}
\DoxyCodeLine{7186         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} store\_element = key\_keep\_stack.back();}
\DoxyCodeLine{7187         key\_keep\_stack.pop\_back();}
\DoxyCodeLine{7188 }
\DoxyCodeLine{7189         \textcolor{keywordflow}{if} (!store\_element)}
\DoxyCodeLine{7190         \{}
\DoxyCodeLine{7191             \textcolor{keywordflow}{return} \{\textcolor{keyword}{false}, \textcolor{keyword}{nullptr}\};}
\DoxyCodeLine{7192         \}}
\DoxyCodeLine{7193 }
\DoxyCodeLine{7194         JSON\_ASSERT(object\_element);}
\DoxyCodeLine{7195         *object\_element = std::move(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}});}
\DoxyCodeLine{7196         \textcolor{keywordflow}{return} \{\textcolor{keyword}{true}, object\_element\};}
\DoxyCodeLine{7197     \}}
\DoxyCodeLine{7198 }
\DoxyCodeLine{7200     BasicJsonType\& root;}
\DoxyCodeLine{7202     std::vector<BasicJsonType*> ref\_stack \{\};}
\DoxyCodeLine{7204     std::vector<bool> keep\_stack \{\};}
\DoxyCodeLine{7206     std::vector<bool> key\_keep\_stack \{\};}
\DoxyCodeLine{7208     BasicJsonType* object\_element = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{7210     \textcolor{keywordtype}{bool} errored = \textcolor{keyword}{false};}
\DoxyCodeLine{7212     \textcolor{keyword}{const} parser\_callback\_t callback = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{7214     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true};}
\DoxyCodeLine{7216     BasicJsonType \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{discarded}} = BasicJsonType::value\_t::discarded;}
\DoxyCodeLine{7217 \};}
\DoxyCodeLine{7218 }
\DoxyCodeLine{7219 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{7220 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1json__sax__acceptor}{json\_sax\_acceptor}}}
\DoxyCodeLine{7221 \{}
\DoxyCodeLine{7222   \textcolor{keyword}{public}:}
\DoxyCodeLine{7223     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{7224     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{7225     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{7226     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{7227     \textcolor{keyword}{using }binary\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t;}
\DoxyCodeLine{7228 }
\DoxyCodeLine{7229     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_acbcc09c0ada2782cd73cc4135823181d}{null}}()}
\DoxyCodeLine{7230     \{}
\DoxyCodeLine{7231         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7232     \}}
\DoxyCodeLine{7233 }
\DoxyCodeLine{7234     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_ab89f75382c0fd7fe81c95fc84cfa3150}{boolean}}(\textcolor{keywordtype}{bool} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{7235     \{}
\DoxyCodeLine{7236         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7237     \}}
\DoxyCodeLine{7238 }
\DoxyCodeLine{7239     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a46cc306b7677553d8f6bd8c9592eb1bd}{number\_integer}}(number\_integer\_t \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{7240     \{}
\DoxyCodeLine{7241         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7242     \}}
\DoxyCodeLine{7243 }
\DoxyCodeLine{7244     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a32f8a32794cb384f0de3d3a96a6bb696}{number\_unsigned}}(number\_unsigned\_t \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{7245     \{}
\DoxyCodeLine{7246         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7247     \}}
\DoxyCodeLine{7248 }
\DoxyCodeLine{7249     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a19eafa3a92fc75e0258a842283396aa9}{number\_float}}(number\_float\_t \textcolor{comment}{/*unused*/}, \textcolor{keyword}{const} string\_t\& \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{7250     \{}
\DoxyCodeLine{7251         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7252     \}}
\DoxyCodeLine{7253 }
\DoxyCodeLine{7254     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a3da9ee0c61f1a37e6c6a3d2dccb16765}{string}}(string\_t\& \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{7255     \{}
\DoxyCodeLine{7256         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7257     \}}
\DoxyCodeLine{7258 }
\DoxyCodeLine{7259     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}}(binary\_t\& \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{7260     \{}
\DoxyCodeLine{7261         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7262     \}}
\DoxyCodeLine{7263 }
\DoxyCodeLine{7264     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a54a0883df64f40664395e3dad674aaa5}{start\_object}}(std::size\_t \textcolor{comment}{/*unused*/} = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))}
\DoxyCodeLine{7265     \{}
\DoxyCodeLine{7266         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7267     \}}
\DoxyCodeLine{7268 }
\DoxyCodeLine{7269     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}(string\_t\& \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{7270     \{}
\DoxyCodeLine{7271         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7272     \}}
\DoxyCodeLine{7273 }
\DoxyCodeLine{7274     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_ac34854cab5e023c5d0e8b381a11aba5b}{end\_object}}()}
\DoxyCodeLine{7275     \{}
\DoxyCodeLine{7276         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7277     \}}
\DoxyCodeLine{7278 }
\DoxyCodeLine{7279     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_afc4d5c0d123f2e3c939060a778c4f22c}{start\_array}}(std::size\_t \textcolor{comment}{/*unused*/} = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))}
\DoxyCodeLine{7280     \{}
\DoxyCodeLine{7281         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7282     \}}
\DoxyCodeLine{7283 }
\DoxyCodeLine{7284     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_a81fbddbf7dc96eab21ef916625ad5f3b}{end\_array}}()}
\DoxyCodeLine{7285     \{}
\DoxyCodeLine{7286         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7287     \}}
\DoxyCodeLine{7288 }
\DoxyCodeLine{7289     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structjson__sax_af165920966b60b78e57a2e4d92a63897}{parse\_error}}(std::size\_t \textcolor{comment}{/*unused*/}, \textcolor{keyword}{const} std::string\& \textcolor{comment}{/*unused*/}, \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1exception}{detail::exception}}\& \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{7290     \{}
\DoxyCodeLine{7291         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{7292     \}}
\DoxyCodeLine{7293 \};}
\DoxyCodeLine{7294 }
\DoxyCodeLine{7295 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{7296 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{7297 }
\DoxyCodeLine{7298 \textcolor{comment}{// \#include <nlohmann/detail/input/lexer.hpp>}}
\DoxyCodeLine{7299 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{7300 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{7301 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{7302 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{7303 \textcolor{comment}{//}}
\DoxyCodeLine{7304 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{7305 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{7306 }
\DoxyCodeLine{7307 }
\DoxyCodeLine{7308 }
\DoxyCodeLine{7309 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{7310 \textcolor{preprocessor}{\#include <clocale>} \textcolor{comment}{// localeconv}}
\DoxyCodeLine{7311 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{7312 \textcolor{preprocessor}{\#include <cstdio>} \textcolor{comment}{// snprintf}}
\DoxyCodeLine{7313 \textcolor{preprocessor}{\#include <cstdlib>} \textcolor{comment}{// strtof, strtod, strtold, strtoll, strtoull}}
\DoxyCodeLine{7314 \textcolor{preprocessor}{\#include <initializer\_list>} \textcolor{comment}{// initializer\_list}}
\DoxyCodeLine{7315 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// char\_traits, string}}
\DoxyCodeLine{7316 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// move}}
\DoxyCodeLine{7317 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{7318 }
\DoxyCodeLine{7319 \textcolor{comment}{// \#include <nlohmann/detail/input/input\_adapters.hpp>}}
\DoxyCodeLine{7320 }
\DoxyCodeLine{7321 \textcolor{comment}{// \#include <nlohmann/detail/input/position\_t.hpp>}}
\DoxyCodeLine{7322 }
\DoxyCodeLine{7323 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{7324 }
\DoxyCodeLine{7325 }
\DoxyCodeLine{7326 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{7327 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{7328 \{}
\DoxyCodeLine{7329 }
\DoxyCodeLine{7331 \textcolor{comment}{// lexer //}}
\DoxyCodeLine{7333 \textcolor{comment}{}}
\DoxyCodeLine{7334 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{7335 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1lexer__base}{lexer\_base}}}
\DoxyCodeLine{7336 \{}
\DoxyCodeLine{7337   \textcolor{keyword}{public}:}
\DoxyCodeLine{7339     \textcolor{keyword}{enum class} \mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{token\_type}}}
\DoxyCodeLine{7340     \{}
\DoxyCodeLine{7341         uninitialized,    }
\DoxyCodeLine{7342         literal\_true,     }
\DoxyCodeLine{7343         literal\_false,    }
\DoxyCodeLine{7344         literal\_null,     }
\DoxyCodeLine{7345         value\_string,     }
\DoxyCodeLine{7346         value\_unsigned,   }
\DoxyCodeLine{7347         value\_integer,    }
\DoxyCodeLine{7348         value\_float,      }
\DoxyCodeLine{7349         begin\_array,      }
\DoxyCodeLine{7350         begin\_object,     }
\DoxyCodeLine{7351         \mbox{\hyperlink{structjson__sax_a81fbddbf7dc96eab21ef916625ad5f3b}{end\_array}},        }
\DoxyCodeLine{7352         \mbox{\hyperlink{structjson__sax_ac34854cab5e023c5d0e8b381a11aba5b}{end\_object}},       }
\DoxyCodeLine{7353         name\_separator,   }
\DoxyCodeLine{7354         value\_separator,  }
\DoxyCodeLine{7355         \mbox{\hyperlink{structjson__sax_af165920966b60b78e57a2e4d92a63897}{parse\_error}},      }
\DoxyCodeLine{7356         end\_of\_input,     }
\DoxyCodeLine{7357         literal\_or\_value  }
\DoxyCodeLine{7358     \};}
\DoxyCodeLine{7359 }
\DoxyCodeLine{7361     JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{7362     JSON\_HEDLEY\_CONST}
\DoxyCodeLine{7363     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \mbox{\hyperlink{classdetail_1_1lexer__base_aadef66e89ad828e5f69479c85887fa6d}{token\_type\_name}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{token\_type}} t) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{7364     \{}
\DoxyCodeLine{7365         \textcolor{keywordflow}{switch} (t)}
\DoxyCodeLine{7366         \{}
\DoxyCodeLine{7367             \textcolor{keywordflow}{case} token\_type::uninitialized:}
\DoxyCodeLine{7368                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}<uninitialized>"{}};}
\DoxyCodeLine{7369             \textcolor{keywordflow}{case} token\_type::literal\_true:}
\DoxyCodeLine{7370                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}true literal"{}};}
\DoxyCodeLine{7371             \textcolor{keywordflow}{case} token\_type::literal\_false:}
\DoxyCodeLine{7372                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}false literal"{}};}
\DoxyCodeLine{7373             \textcolor{keywordflow}{case} token\_type::literal\_null:}
\DoxyCodeLine{7374                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}null literal"{}};}
\DoxyCodeLine{7375             \textcolor{keywordflow}{case} token\_type::value\_string:}
\DoxyCodeLine{7376                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}string literal"{}};}
\DoxyCodeLine{7377             \textcolor{keywordflow}{case} token\_type::value\_unsigned:}
\DoxyCodeLine{7378             \textcolor{keywordflow}{case} token\_type::value\_integer:}
\DoxyCodeLine{7379             \textcolor{keywordflow}{case} token\_type::value\_float:}
\DoxyCodeLine{7380                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}number literal"{}};}
\DoxyCodeLine{7381             \textcolor{keywordflow}{case} token\_type::begin\_array:}
\DoxyCodeLine{7382                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'['"{}};}
\DoxyCodeLine{7383             \textcolor{keywordflow}{case} token\_type::begin\_object:}
\DoxyCodeLine{7384                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\{'"{}};}
\DoxyCodeLine{7385             \textcolor{keywordflow}{case} token\_type::end\_array:}
\DoxyCodeLine{7386                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}']'"{}};}
\DoxyCodeLine{7387             \textcolor{keywordflow}{case} token\_type::end\_object:}
\DoxyCodeLine{7388                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\}'"{}};}
\DoxyCodeLine{7389             \textcolor{keywordflow}{case} token\_type::name\_separator:}
\DoxyCodeLine{7390                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}':'"{}};}
\DoxyCodeLine{7391             \textcolor{keywordflow}{case} token\_type::value\_separator:}
\DoxyCodeLine{7392                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}','"{}};}
\DoxyCodeLine{7393             \textcolor{keywordflow}{case} token\_type::parse\_error:}
\DoxyCodeLine{7394                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}<parse error>"{}};}
\DoxyCodeLine{7395             \textcolor{keywordflow}{case} token\_type::end\_of\_input:}
\DoxyCodeLine{7396                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}end of input"{}};}
\DoxyCodeLine{7397             \textcolor{keywordflow}{case} token\_type::literal\_or\_value:}
\DoxyCodeLine{7398                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'[', '\{', or a literal"{}};}
\DoxyCodeLine{7399             \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{7400             \textcolor{keywordflow}{default}: \textcolor{comment}{// catch non-\/enum values}}
\DoxyCodeLine{7401                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}unknown token"{}};}
\DoxyCodeLine{7402                 \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{7403         \}}
\DoxyCodeLine{7404     \}}
\DoxyCodeLine{7405 \};}
\DoxyCodeLine{7411 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} InputAdapterType>}
\DoxyCodeLine{7412 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1lexer}{lexer}} : \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1lexer__base}{lexer\_base}}<BasicJsonType>}
\DoxyCodeLine{7413 \{}
\DoxyCodeLine{7414     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{7415     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{7416     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{7417     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{7418     \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} InputAdapterType::char\_type;}
\DoxyCodeLine{7419     \textcolor{keyword}{using }char\_int\_type = \textcolor{keyword}{typename} std::char\_traits<char\_type>::int\_type;}
\DoxyCodeLine{7420 }
\DoxyCodeLine{7421   \textcolor{keyword}{public}:}
\DoxyCodeLine{7422     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{token\_type}} = \textcolor{keyword}{typename} \mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{lexer\_base<BasicJsonType>::token\_type}};}
\DoxyCodeLine{7423 }
\DoxyCodeLine{7424     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1lexer}{lexer}}(InputAdapterType\&\& adapter, \textcolor{keywordtype}{bool} ignore\_comments\_ = \textcolor{keyword}{false}) noexcept}
\DoxyCodeLine{7425         : ia(std::move(adapter))}
\DoxyCodeLine{7426         , ignore\_comments(ignore\_comments\_)}
\DoxyCodeLine{7427         , decimal\_point\_char(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(get\_decimal\_point()))}
\DoxyCodeLine{7428     \{\}}
\DoxyCodeLine{7429 }
\DoxyCodeLine{7430     \textcolor{comment}{// delete because of pointer members}}
\DoxyCodeLine{7431     \mbox{\hyperlink{classdetail_1_1lexer}{lexer}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1lexer}{lexer}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{7432     \mbox{\hyperlink{classdetail_1_1lexer}{lexer}}(\mbox{\hyperlink{classdetail_1_1lexer}{lexer}}\&\&) = \textcolor{keywordflow}{default}; \textcolor{comment}{// NOLINT(hicpp-\/noexcept-\/move,performance-\/noexcept-\/move-\/constructor)}}
\DoxyCodeLine{7433     \mbox{\hyperlink{classdetail_1_1lexer}{lexer}}\& operator=(\mbox{\hyperlink{classdetail_1_1lexer}{lexer}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{7434     \mbox{\hyperlink{classdetail_1_1lexer}{lexer}}\& operator=(\mbox{\hyperlink{classdetail_1_1lexer}{lexer}}\&\&) = \textcolor{keywordflow}{default}; \textcolor{comment}{// NOLINT(hicpp-\/noexcept-\/move,performance-\/noexcept-\/move-\/constructor)}}
\DoxyCodeLine{7435     \mbox{\hyperlink{classdetail_1_1lexer}{\string~lexer}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{7436 }
\DoxyCodeLine{7437   \textcolor{keyword}{private}:}
\DoxyCodeLine{7439     \textcolor{comment}{// locales}}
\DoxyCodeLine{7441 \textcolor{comment}{}}
\DoxyCodeLine{7443     JSON\_HEDLEY\_PURE}
\DoxyCodeLine{7444     \textcolor{keyword}{static} \textcolor{keywordtype}{char} get\_decimal\_point() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{7445     \{}
\DoxyCodeLine{7446         \textcolor{keyword}{const} \textcolor{keyword}{auto}* loc = localeconv();}
\DoxyCodeLine{7447         JSON\_ASSERT(loc != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{7448         \textcolor{keywordflow}{return} (loc-\/>decimal\_point == \textcolor{keyword}{nullptr}) ? \textcolor{charliteral}{'.'} : *(loc-\/>decimal\_point);}
\DoxyCodeLine{7449     \}}
\DoxyCodeLine{7450 }
\DoxyCodeLine{7452     \textcolor{comment}{// scan functions}}
\DoxyCodeLine{7454 \textcolor{comment}{}}
\DoxyCodeLine{7470     \textcolor{keywordtype}{int} get\_codepoint()}
\DoxyCodeLine{7471     \{}
\DoxyCodeLine{7472         \textcolor{comment}{// this function only makes sense after reading `\(\backslash\)u`}}
\DoxyCodeLine{7473         JSON\_ASSERT(current == \textcolor{charliteral}{'u'});}
\DoxyCodeLine{7474         \textcolor{keywordtype}{int} codepoint = 0;}
\DoxyCodeLine{7475 }
\DoxyCodeLine{7476         \textcolor{keyword}{const} \textcolor{keyword}{auto} factors = \{ 12u, 8u, 4u, 0u \};}
\DoxyCodeLine{7477         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto} factor : factors)}
\DoxyCodeLine{7478         \{}
\DoxyCodeLine{7479             get();}
\DoxyCodeLine{7480 }
\DoxyCodeLine{7481             \textcolor{keywordflow}{if} (current >= \textcolor{charliteral}{'0'} \&\& current <= \textcolor{charliteral}{'9'})}
\DoxyCodeLine{7482             \{}
\DoxyCodeLine{7483                 codepoint += \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) -\/ 0x30u) << factor);}
\DoxyCodeLine{7484             \}}
\DoxyCodeLine{7485             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (current >= \textcolor{charliteral}{'A'} \&\& current <= \textcolor{charliteral}{'F'})}
\DoxyCodeLine{7486             \{}
\DoxyCodeLine{7487                 codepoint += \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) -\/ 0x37u) << factor);}
\DoxyCodeLine{7488             \}}
\DoxyCodeLine{7489             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (current >= \textcolor{charliteral}{'a'} \&\& current <= \textcolor{charliteral}{'f'})}
\DoxyCodeLine{7490             \{}
\DoxyCodeLine{7491                 codepoint += \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) -\/ 0x57u) << factor);}
\DoxyCodeLine{7492             \}}
\DoxyCodeLine{7493             \textcolor{keywordflow}{else}}
\DoxyCodeLine{7494             \{}
\DoxyCodeLine{7495                 \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{7496             \}}
\DoxyCodeLine{7497         \}}
\DoxyCodeLine{7498 }
\DoxyCodeLine{7499         JSON\_ASSERT(0x0000 <= codepoint \&\& codepoint <= 0xFFFF);}
\DoxyCodeLine{7500         \textcolor{keywordflow}{return} codepoint;}
\DoxyCodeLine{7501     \}}
\DoxyCodeLine{7502 }
\DoxyCodeLine{7518     \textcolor{keywordtype}{bool} next\_byte\_in\_range(std::initializer\_list<char\_int\_type> ranges)}
\DoxyCodeLine{7519     \{}
\DoxyCodeLine{7520         JSON\_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);}
\DoxyCodeLine{7521         add(current);}
\DoxyCodeLine{7522 }
\DoxyCodeLine{7523         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} range = ranges.begin(); range != ranges.end(); ++range)}
\DoxyCodeLine{7524         \{}
\DoxyCodeLine{7525             get();}
\DoxyCodeLine{7526             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(*range <= current \&\& current <= *(++range)))}
\DoxyCodeLine{7527             \{}
\DoxyCodeLine{7528                 add(current);}
\DoxyCodeLine{7529             \}}
\DoxyCodeLine{7530             \textcolor{keywordflow}{else}}
\DoxyCodeLine{7531             \{}
\DoxyCodeLine{7532                 error\_message = \textcolor{stringliteral}{"{}invalid string: ill-\/formed UTF-\/8 byte"{}};}
\DoxyCodeLine{7533                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{7534             \}}
\DoxyCodeLine{7535         \}}
\DoxyCodeLine{7536 }
\DoxyCodeLine{7537         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7538     \}}
\DoxyCodeLine{7539 }
\DoxyCodeLine{7555     \mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{token\_type}} scan\_string()}
\DoxyCodeLine{7556     \{}
\DoxyCodeLine{7557         \textcolor{comment}{// reset token\_buffer (ignore opening quote)}}
\DoxyCodeLine{7558         reset();}
\DoxyCodeLine{7559 }
\DoxyCodeLine{7560         \textcolor{comment}{// we entered the function by reading an open quote}}
\DoxyCodeLine{7561         JSON\_ASSERT(current == \textcolor{charliteral}{'\(\backslash\)"{}'});}
\DoxyCodeLine{7562 }
\DoxyCodeLine{7563         \textcolor{keywordflow}{while} (\textcolor{keyword}{true})}
\DoxyCodeLine{7564         \{}
\DoxyCodeLine{7565             \textcolor{comment}{// get next character}}
\DoxyCodeLine{7566             \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{7567             \{}
\DoxyCodeLine{7568                 \textcolor{comment}{// end of file while parsing string}}
\DoxyCodeLine{7569                 \textcolor{keywordflow}{case} std::char\_traits<char\_type>::eof():}
\DoxyCodeLine{7570                 \{}
\DoxyCodeLine{7571                     error\_message = \textcolor{stringliteral}{"{}invalid string: missing closing quote"{}};}
\DoxyCodeLine{7572                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7573                 \}}
\DoxyCodeLine{7574 }
\DoxyCodeLine{7575                 \textcolor{comment}{// closing quote}}
\DoxyCodeLine{7576                 \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)"{}'}:}
\DoxyCodeLine{7577                 \{}
\DoxyCodeLine{7578                     \textcolor{keywordflow}{return} token\_type::value\_string;}
\DoxyCodeLine{7579                 \}}
\DoxyCodeLine{7580 }
\DoxyCodeLine{7581                 \textcolor{comment}{// escapes}}
\DoxyCodeLine{7582                 \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}:}
\DoxyCodeLine{7583                 \{}
\DoxyCodeLine{7584                     \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{7585                     \{}
\DoxyCodeLine{7586                         \textcolor{comment}{// quotation mark}}
\DoxyCodeLine{7587                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)"{}'}:}
\DoxyCodeLine{7588                             add(\textcolor{charliteral}{'\(\backslash\)"{}'});}
\DoxyCodeLine{7589                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7590                         \textcolor{comment}{// reverse solidus}}
\DoxyCodeLine{7591                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}:}
\DoxyCodeLine{7592                             add(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{7593                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7594                         \textcolor{comment}{// solidus}}
\DoxyCodeLine{7595                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'/'}:}
\DoxyCodeLine{7596                             add(\textcolor{charliteral}{'/'});}
\DoxyCodeLine{7597                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7598                         \textcolor{comment}{// backspace}}
\DoxyCodeLine{7599                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'b'}:}
\DoxyCodeLine{7600                             add(\textcolor{charliteral}{'\(\backslash\)b'});}
\DoxyCodeLine{7601                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7602                         \textcolor{comment}{// form feed}}
\DoxyCodeLine{7603                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'}:}
\DoxyCodeLine{7604                             add(\textcolor{charliteral}{'\(\backslash\)f'});}
\DoxyCodeLine{7605                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7606                         \textcolor{comment}{// line feed}}
\DoxyCodeLine{7607                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'n'}:}
\DoxyCodeLine{7608                             add(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{7609                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7610                         \textcolor{comment}{// carriage return}}
\DoxyCodeLine{7611                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'r'}:}
\DoxyCodeLine{7612                             add(\textcolor{charliteral}{'\(\backslash\)r'});}
\DoxyCodeLine{7613                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7614                         \textcolor{comment}{// tab}}
\DoxyCodeLine{7615                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'t'}:}
\DoxyCodeLine{7616                             add(\textcolor{charliteral}{'\(\backslash\)t'});}
\DoxyCodeLine{7617                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7618 }
\DoxyCodeLine{7619                         \textcolor{comment}{// unicode escapes}}
\DoxyCodeLine{7620                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{7621                         \{}
\DoxyCodeLine{7622                             \textcolor{keyword}{const} \textcolor{keywordtype}{int} codepoint1 = get\_codepoint();}
\DoxyCodeLine{7623                             \textcolor{keywordtype}{int} codepoint = codepoint1; \textcolor{comment}{// start with codepoint1}}
\DoxyCodeLine{7624 }
\DoxyCodeLine{7625                             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(codepoint1 == -\/1))}
\DoxyCodeLine{7626                             \{}
\DoxyCodeLine{7627                                 error\_message = \textcolor{stringliteral}{"{}invalid string: '\(\backslash\)\(\backslash\)u' must be followed by 4 hex digits"{}};}
\DoxyCodeLine{7628                                 \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7629                             \}}
\DoxyCodeLine{7630 }
\DoxyCodeLine{7631                             \textcolor{comment}{// check if code point is a high surrogate}}
\DoxyCodeLine{7632                             \textcolor{keywordflow}{if} (0xD800 <= codepoint1 \&\& codepoint1 <= 0xDBFF)}
\DoxyCodeLine{7633                             \{}
\DoxyCodeLine{7634                                 \textcolor{comment}{// expect next \(\backslash\)uxxxx entry}}
\DoxyCodeLine{7635                                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(get() == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} \&\& get() == \textcolor{charliteral}{'u'}))}
\DoxyCodeLine{7636                                 \{}
\DoxyCodeLine{7637                                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} codepoint2 = get\_codepoint();}
\DoxyCodeLine{7638 }
\DoxyCodeLine{7639                                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(codepoint2 == -\/1))}
\DoxyCodeLine{7640                                     \{}
\DoxyCodeLine{7641                                         error\_message = \textcolor{stringliteral}{"{}invalid string: '\(\backslash\)\(\backslash\)u' must be followed by 4 hex digits"{}};}
\DoxyCodeLine{7642                                         \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7643                                     \}}
\DoxyCodeLine{7644 }
\DoxyCodeLine{7645                                     \textcolor{comment}{// check if codepoint2 is a low surrogate}}
\DoxyCodeLine{7646                                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(0xDC00 <= codepoint2 \&\& codepoint2 <= 0xDFFF))}
\DoxyCodeLine{7647                                     \{}
\DoxyCodeLine{7648                                         \textcolor{comment}{// overwrite codepoint}}
\DoxyCodeLine{7649                                         codepoint = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(}
\DoxyCodeLine{7650                                                         \textcolor{comment}{// high surrogate occupies the most significant 22 bits}}
\DoxyCodeLine{7651                                                         (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint1) << 10u)}
\DoxyCodeLine{7652                                                         \textcolor{comment}{// low surrogate occupies the least significant 15 bits}}
\DoxyCodeLine{7653                                                         + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint2)}
\DoxyCodeLine{7654                                                         \textcolor{comment}{// there is still the 0xD800, 0xDC00 and 0x10000 noise}}
\DoxyCodeLine{7655                                                         \textcolor{comment}{// in the result, so we have to subtract with:}}
\DoxyCodeLine{7656                                                         \textcolor{comment}{// (0xD800 << 10) + DC00 -\/ 0x10000 = 0x35FDC00}}
\DoxyCodeLine{7657                                                         -\/ 0x35FDC00u);}
\DoxyCodeLine{7658                                     \}}
\DoxyCodeLine{7659                                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{7660                                     \{}
\DoxyCodeLine{7661                                         error\_message = \textcolor{stringliteral}{"{}invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF"{}};}
\DoxyCodeLine{7662                                         \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7663                                     \}}
\DoxyCodeLine{7664                                 \}}
\DoxyCodeLine{7665                                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{7666                                 \{}
\DoxyCodeLine{7667                                     error\_message = \textcolor{stringliteral}{"{}invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF"{}};}
\DoxyCodeLine{7668                                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7669                                 \}}
\DoxyCodeLine{7670                             \}}
\DoxyCodeLine{7671                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{7672                             \{}
\DoxyCodeLine{7673                                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(0xDC00 <= codepoint1 \&\& codepoint1 <= 0xDFFF))}
\DoxyCodeLine{7674                                 \{}
\DoxyCodeLine{7675                                     error\_message = \textcolor{stringliteral}{"{}invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF"{}};}
\DoxyCodeLine{7676                                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7677                                 \}}
\DoxyCodeLine{7678                             \}}
\DoxyCodeLine{7679 }
\DoxyCodeLine{7680                             \textcolor{comment}{// result of the above calculation yields a proper codepoint}}
\DoxyCodeLine{7681                             JSON\_ASSERT(0x00 <= codepoint \&\& codepoint <= 0x10FFFF);}
\DoxyCodeLine{7682 }
\DoxyCodeLine{7683                             \textcolor{comment}{// translate codepoint into bytes}}
\DoxyCodeLine{7684                             \textcolor{keywordflow}{if} (codepoint < 0x80)}
\DoxyCodeLine{7685                             \{}
\DoxyCodeLine{7686                                 \textcolor{comment}{// 1-\/byte characters: 0xxxxxxx (ASCII)}}
\DoxyCodeLine{7687                                 add(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(codepoint));}
\DoxyCodeLine{7688                             \}}
\DoxyCodeLine{7689                             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (codepoint <= 0x7FF)}
\DoxyCodeLine{7690                             \{}
\DoxyCodeLine{7691                                 \textcolor{comment}{// 2-\/byte characters: 110xxxxx 10xxxxxx}}
\DoxyCodeLine{7692                                 add(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(0xC0u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint) >> 6u)));}
\DoxyCodeLine{7693                                 add(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint) \& 0x3Fu)));}
\DoxyCodeLine{7694                             \}}
\DoxyCodeLine{7695                             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (codepoint <= 0xFFFF)}
\DoxyCodeLine{7696                             \{}
\DoxyCodeLine{7697                                 \textcolor{comment}{// 3-\/byte characters: 1110xxxx 10xxxxxx 10xxxxxx}}
\DoxyCodeLine{7698                                 add(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(0xE0u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint) >> 12u)));}
\DoxyCodeLine{7699                                 add(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint) >> 6u) \& 0x3Fu)));}
\DoxyCodeLine{7700                                 add(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint) \& 0x3Fu)));}
\DoxyCodeLine{7701                             \}}
\DoxyCodeLine{7702                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{7703                             \{}
\DoxyCodeLine{7704                                 \textcolor{comment}{// 4-\/byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx}}
\DoxyCodeLine{7705                                 add(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(0xF0u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint) >> 18u)));}
\DoxyCodeLine{7706                                 add(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint) >> 12u) \& 0x3Fu)));}
\DoxyCodeLine{7707                                 add(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(0x80u | ((\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint) >> 6u) \& 0x3Fu)));}
\DoxyCodeLine{7708                                 add(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(0x80u | (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(codepoint) \& 0x3Fu)));}
\DoxyCodeLine{7709                             \}}
\DoxyCodeLine{7710 }
\DoxyCodeLine{7711                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{7712                         \}}
\DoxyCodeLine{7713 }
\DoxyCodeLine{7714                         \textcolor{comment}{// other characters after escape}}
\DoxyCodeLine{7715                         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{7716                             error\_message = \textcolor{stringliteral}{"{}invalid string: forbidden character after backslash"{}};}
\DoxyCodeLine{7717                             \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7718                     \}}
\DoxyCodeLine{7719 }
\DoxyCodeLine{7720                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{7721                 \}}
\DoxyCodeLine{7722 }
\DoxyCodeLine{7723                 \textcolor{comment}{// invalid control characters}}
\DoxyCodeLine{7724                 \textcolor{keywordflow}{case} 0x00:}
\DoxyCodeLine{7725                 \{}
\DoxyCodeLine{7726                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0000 (NUL) must be escaped to \(\backslash\)\(\backslash\)u0000"{}};}
\DoxyCodeLine{7727                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7728                 \}}
\DoxyCodeLine{7729 }
\DoxyCodeLine{7730                 \textcolor{keywordflow}{case} 0x01:}
\DoxyCodeLine{7731                 \{}
\DoxyCodeLine{7732                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0001 (SOH) must be escaped to \(\backslash\)\(\backslash\)u0001"{}};}
\DoxyCodeLine{7733                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7734                 \}}
\DoxyCodeLine{7735 }
\DoxyCodeLine{7736                 \textcolor{keywordflow}{case} 0x02:}
\DoxyCodeLine{7737                 \{}
\DoxyCodeLine{7738                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0002 (STX) must be escaped to \(\backslash\)\(\backslash\)u0002"{}};}
\DoxyCodeLine{7739                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7740                 \}}
\DoxyCodeLine{7741 }
\DoxyCodeLine{7742                 \textcolor{keywordflow}{case} 0x03:}
\DoxyCodeLine{7743                 \{}
\DoxyCodeLine{7744                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0003 (ETX) must be escaped to \(\backslash\)\(\backslash\)u0003"{}};}
\DoxyCodeLine{7745                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7746                 \}}
\DoxyCodeLine{7747 }
\DoxyCodeLine{7748                 \textcolor{keywordflow}{case} 0x04:}
\DoxyCodeLine{7749                 \{}
\DoxyCodeLine{7750                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0004 (EOT) must be escaped to \(\backslash\)\(\backslash\)u0004"{}};}
\DoxyCodeLine{7751                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7752                 \}}
\DoxyCodeLine{7753 }
\DoxyCodeLine{7754                 \textcolor{keywordflow}{case} 0x05:}
\DoxyCodeLine{7755                 \{}
\DoxyCodeLine{7756                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0005 (ENQ) must be escaped to \(\backslash\)\(\backslash\)u0005"{}};}
\DoxyCodeLine{7757                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7758                 \}}
\DoxyCodeLine{7759 }
\DoxyCodeLine{7760                 \textcolor{keywordflow}{case} 0x06:}
\DoxyCodeLine{7761                 \{}
\DoxyCodeLine{7762                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0006 (ACK) must be escaped to \(\backslash\)\(\backslash\)u0006"{}};}
\DoxyCodeLine{7763                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7764                 \}}
\DoxyCodeLine{7765 }
\DoxyCodeLine{7766                 \textcolor{keywordflow}{case} 0x07:}
\DoxyCodeLine{7767                 \{}
\DoxyCodeLine{7768                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0007 (BEL) must be escaped to \(\backslash\)\(\backslash\)u0007"{}};}
\DoxyCodeLine{7769                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7770                 \}}
\DoxyCodeLine{7771 }
\DoxyCodeLine{7772                 \textcolor{keywordflow}{case} 0x08:}
\DoxyCodeLine{7773                 \{}
\DoxyCodeLine{7774                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0008 (BS) must be escaped to \(\backslash\)\(\backslash\)u0008 or \(\backslash\)\(\backslash\)b"{}};}
\DoxyCodeLine{7775                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7776                 \}}
\DoxyCodeLine{7777 }
\DoxyCodeLine{7778                 \textcolor{keywordflow}{case} 0x09:}
\DoxyCodeLine{7779                 \{}
\DoxyCodeLine{7780                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0009 (HT) must be escaped to \(\backslash\)\(\backslash\)u0009 or \(\backslash\)\(\backslash\)t"{}};}
\DoxyCodeLine{7781                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7782                 \}}
\DoxyCodeLine{7783 }
\DoxyCodeLine{7784                 \textcolor{keywordflow}{case} 0x0A:}
\DoxyCodeLine{7785                 \{}
\DoxyCodeLine{7786                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+000A (LF) must be escaped to \(\backslash\)\(\backslash\)u000A or \(\backslash\)\(\backslash\)n"{}};}
\DoxyCodeLine{7787                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7788                 \}}
\DoxyCodeLine{7789 }
\DoxyCodeLine{7790                 \textcolor{keywordflow}{case} 0x0B:}
\DoxyCodeLine{7791                 \{}
\DoxyCodeLine{7792                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+000B (VT) must be escaped to \(\backslash\)\(\backslash\)u000B"{}};}
\DoxyCodeLine{7793                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7794                 \}}
\DoxyCodeLine{7795 }
\DoxyCodeLine{7796                 \textcolor{keywordflow}{case} 0x0C:}
\DoxyCodeLine{7797                 \{}
\DoxyCodeLine{7798                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+000C (FF) must be escaped to \(\backslash\)\(\backslash\)u000C or \(\backslash\)\(\backslash\)f"{}};}
\DoxyCodeLine{7799                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7800                 \}}
\DoxyCodeLine{7801 }
\DoxyCodeLine{7802                 \textcolor{keywordflow}{case} 0x0D:}
\DoxyCodeLine{7803                 \{}
\DoxyCodeLine{7804                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+000D (CR) must be escaped to \(\backslash\)\(\backslash\)u000D or \(\backslash\)\(\backslash\)r"{}};}
\DoxyCodeLine{7805                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7806                 \}}
\DoxyCodeLine{7807 }
\DoxyCodeLine{7808                 \textcolor{keywordflow}{case} 0x0E:}
\DoxyCodeLine{7809                 \{}
\DoxyCodeLine{7810                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+000E (SO) must be escaped to \(\backslash\)\(\backslash\)u000E"{}};}
\DoxyCodeLine{7811                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7812                 \}}
\DoxyCodeLine{7813 }
\DoxyCodeLine{7814                 \textcolor{keywordflow}{case} 0x0F:}
\DoxyCodeLine{7815                 \{}
\DoxyCodeLine{7816                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+000F (SI) must be escaped to \(\backslash\)\(\backslash\)u000F"{}};}
\DoxyCodeLine{7817                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7818                 \}}
\DoxyCodeLine{7819 }
\DoxyCodeLine{7820                 \textcolor{keywordflow}{case} 0x10:}
\DoxyCodeLine{7821                 \{}
\DoxyCodeLine{7822                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0010 (DLE) must be escaped to \(\backslash\)\(\backslash\)u0010"{}};}
\DoxyCodeLine{7823                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7824                 \}}
\DoxyCodeLine{7825 }
\DoxyCodeLine{7826                 \textcolor{keywordflow}{case} 0x11:}
\DoxyCodeLine{7827                 \{}
\DoxyCodeLine{7828                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0011 (DC1) must be escaped to \(\backslash\)\(\backslash\)u0011"{}};}
\DoxyCodeLine{7829                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7830                 \}}
\DoxyCodeLine{7831 }
\DoxyCodeLine{7832                 \textcolor{keywordflow}{case} 0x12:}
\DoxyCodeLine{7833                 \{}
\DoxyCodeLine{7834                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0012 (DC2) must be escaped to \(\backslash\)\(\backslash\)u0012"{}};}
\DoxyCodeLine{7835                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7836                 \}}
\DoxyCodeLine{7837 }
\DoxyCodeLine{7838                 \textcolor{keywordflow}{case} 0x13:}
\DoxyCodeLine{7839                 \{}
\DoxyCodeLine{7840                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0013 (DC3) must be escaped to \(\backslash\)\(\backslash\)u0013"{}};}
\DoxyCodeLine{7841                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7842                 \}}
\DoxyCodeLine{7843 }
\DoxyCodeLine{7844                 \textcolor{keywordflow}{case} 0x14:}
\DoxyCodeLine{7845                 \{}
\DoxyCodeLine{7846                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0014 (DC4) must be escaped to \(\backslash\)\(\backslash\)u0014"{}};}
\DoxyCodeLine{7847                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7848                 \}}
\DoxyCodeLine{7849 }
\DoxyCodeLine{7850                 \textcolor{keywordflow}{case} 0x15:}
\DoxyCodeLine{7851                 \{}
\DoxyCodeLine{7852                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0015 (NAK) must be escaped to \(\backslash\)\(\backslash\)u0015"{}};}
\DoxyCodeLine{7853                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7854                 \}}
\DoxyCodeLine{7855 }
\DoxyCodeLine{7856                 \textcolor{keywordflow}{case} 0x16:}
\DoxyCodeLine{7857                 \{}
\DoxyCodeLine{7858                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0016 (SYN) must be escaped to \(\backslash\)\(\backslash\)u0016"{}};}
\DoxyCodeLine{7859                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7860                 \}}
\DoxyCodeLine{7861 }
\DoxyCodeLine{7862                 \textcolor{keywordflow}{case} 0x17:}
\DoxyCodeLine{7863                 \{}
\DoxyCodeLine{7864                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0017 (ETB) must be escaped to \(\backslash\)\(\backslash\)u0017"{}};}
\DoxyCodeLine{7865                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7866                 \}}
\DoxyCodeLine{7867 }
\DoxyCodeLine{7868                 \textcolor{keywordflow}{case} 0x18:}
\DoxyCodeLine{7869                 \{}
\DoxyCodeLine{7870                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0018 (CAN) must be escaped to \(\backslash\)\(\backslash\)u0018"{}};}
\DoxyCodeLine{7871                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7872                 \}}
\DoxyCodeLine{7873 }
\DoxyCodeLine{7874                 \textcolor{keywordflow}{case} 0x19:}
\DoxyCodeLine{7875                 \{}
\DoxyCodeLine{7876                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+0019 (EM) must be escaped to \(\backslash\)\(\backslash\)u0019"{}};}
\DoxyCodeLine{7877                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7878                 \}}
\DoxyCodeLine{7879 }
\DoxyCodeLine{7880                 \textcolor{keywordflow}{case} 0x1A:}
\DoxyCodeLine{7881                 \{}
\DoxyCodeLine{7882                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+001A (SUB) must be escaped to \(\backslash\)\(\backslash\)u001A"{}};}
\DoxyCodeLine{7883                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7884                 \}}
\DoxyCodeLine{7885 }
\DoxyCodeLine{7886                 \textcolor{keywordflow}{case} 0x1B:}
\DoxyCodeLine{7887                 \{}
\DoxyCodeLine{7888                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+001B (ESC) must be escaped to \(\backslash\)\(\backslash\)u001B"{}};}
\DoxyCodeLine{7889                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7890                 \}}
\DoxyCodeLine{7891 }
\DoxyCodeLine{7892                 \textcolor{keywordflow}{case} 0x1C:}
\DoxyCodeLine{7893                 \{}
\DoxyCodeLine{7894                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+001C (FS) must be escaped to \(\backslash\)\(\backslash\)u001C"{}};}
\DoxyCodeLine{7895                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7896                 \}}
\DoxyCodeLine{7897 }
\DoxyCodeLine{7898                 \textcolor{keywordflow}{case} 0x1D:}
\DoxyCodeLine{7899                 \{}
\DoxyCodeLine{7900                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+001D (GS) must be escaped to \(\backslash\)\(\backslash\)u001D"{}};}
\DoxyCodeLine{7901                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7902                 \}}
\DoxyCodeLine{7903 }
\DoxyCodeLine{7904                 \textcolor{keywordflow}{case} 0x1E:}
\DoxyCodeLine{7905                 \{}
\DoxyCodeLine{7906                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+001E (RS) must be escaped to \(\backslash\)\(\backslash\)u001E"{}};}
\DoxyCodeLine{7907                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7908                 \}}
\DoxyCodeLine{7909 }
\DoxyCodeLine{7910                 \textcolor{keywordflow}{case} 0x1F:}
\DoxyCodeLine{7911                 \{}
\DoxyCodeLine{7912                     error\_message = \textcolor{stringliteral}{"{}invalid string: control character U+001F (US) must be escaped to \(\backslash\)\(\backslash\)u001F"{}};}
\DoxyCodeLine{7913                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{7914                 \}}
\DoxyCodeLine{7915 }
\DoxyCodeLine{7916                 \textcolor{comment}{// U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))}}
\DoxyCodeLine{7917                 \textcolor{keywordflow}{case} 0x20:}
\DoxyCodeLine{7918                 \textcolor{keywordflow}{case} 0x21:}
\DoxyCodeLine{7919                 \textcolor{keywordflow}{case} 0x23:}
\DoxyCodeLine{7920                 \textcolor{keywordflow}{case} 0x24:}
\DoxyCodeLine{7921                 \textcolor{keywordflow}{case} 0x25:}
\DoxyCodeLine{7922                 \textcolor{keywordflow}{case} 0x26:}
\DoxyCodeLine{7923                 \textcolor{keywordflow}{case} 0x27:}
\DoxyCodeLine{7924                 \textcolor{keywordflow}{case} 0x28:}
\DoxyCodeLine{7925                 \textcolor{keywordflow}{case} 0x29:}
\DoxyCodeLine{7926                 \textcolor{keywordflow}{case} 0x2A:}
\DoxyCodeLine{7927                 \textcolor{keywordflow}{case} 0x2B:}
\DoxyCodeLine{7928                 \textcolor{keywordflow}{case} 0x2C:}
\DoxyCodeLine{7929                 \textcolor{keywordflow}{case} 0x2D:}
\DoxyCodeLine{7930                 \textcolor{keywordflow}{case} 0x2E:}
\DoxyCodeLine{7931                 \textcolor{keywordflow}{case} 0x2F:}
\DoxyCodeLine{7932                 \textcolor{keywordflow}{case} 0x30:}
\DoxyCodeLine{7933                 \textcolor{keywordflow}{case} 0x31:}
\DoxyCodeLine{7934                 \textcolor{keywordflow}{case} 0x32:}
\DoxyCodeLine{7935                 \textcolor{keywordflow}{case} 0x33:}
\DoxyCodeLine{7936                 \textcolor{keywordflow}{case} 0x34:}
\DoxyCodeLine{7937                 \textcolor{keywordflow}{case} 0x35:}
\DoxyCodeLine{7938                 \textcolor{keywordflow}{case} 0x36:}
\DoxyCodeLine{7939                 \textcolor{keywordflow}{case} 0x37:}
\DoxyCodeLine{7940                 \textcolor{keywordflow}{case} 0x38:}
\DoxyCodeLine{7941                 \textcolor{keywordflow}{case} 0x39:}
\DoxyCodeLine{7942                 \textcolor{keywordflow}{case} 0x3A:}
\DoxyCodeLine{7943                 \textcolor{keywordflow}{case} 0x3B:}
\DoxyCodeLine{7944                 \textcolor{keywordflow}{case} 0x3C:}
\DoxyCodeLine{7945                 \textcolor{keywordflow}{case} 0x3D:}
\DoxyCodeLine{7946                 \textcolor{keywordflow}{case} 0x3E:}
\DoxyCodeLine{7947                 \textcolor{keywordflow}{case} 0x3F:}
\DoxyCodeLine{7948                 \textcolor{keywordflow}{case} 0x40:}
\DoxyCodeLine{7949                 \textcolor{keywordflow}{case} 0x41:}
\DoxyCodeLine{7950                 \textcolor{keywordflow}{case} 0x42:}
\DoxyCodeLine{7951                 \textcolor{keywordflow}{case} 0x43:}
\DoxyCodeLine{7952                 \textcolor{keywordflow}{case} 0x44:}
\DoxyCodeLine{7953                 \textcolor{keywordflow}{case} 0x45:}
\DoxyCodeLine{7954                 \textcolor{keywordflow}{case} 0x46:}
\DoxyCodeLine{7955                 \textcolor{keywordflow}{case} 0x47:}
\DoxyCodeLine{7956                 \textcolor{keywordflow}{case} 0x48:}
\DoxyCodeLine{7957                 \textcolor{keywordflow}{case} 0x49:}
\DoxyCodeLine{7958                 \textcolor{keywordflow}{case} 0x4A:}
\DoxyCodeLine{7959                 \textcolor{keywordflow}{case} 0x4B:}
\DoxyCodeLine{7960                 \textcolor{keywordflow}{case} 0x4C:}
\DoxyCodeLine{7961                 \textcolor{keywordflow}{case} 0x4D:}
\DoxyCodeLine{7962                 \textcolor{keywordflow}{case} 0x4E:}
\DoxyCodeLine{7963                 \textcolor{keywordflow}{case} 0x4F:}
\DoxyCodeLine{7964                 \textcolor{keywordflow}{case} 0x50:}
\DoxyCodeLine{7965                 \textcolor{keywordflow}{case} 0x51:}
\DoxyCodeLine{7966                 \textcolor{keywordflow}{case} 0x52:}
\DoxyCodeLine{7967                 \textcolor{keywordflow}{case} 0x53:}
\DoxyCodeLine{7968                 \textcolor{keywordflow}{case} 0x54:}
\DoxyCodeLine{7969                 \textcolor{keywordflow}{case} 0x55:}
\DoxyCodeLine{7970                 \textcolor{keywordflow}{case} 0x56:}
\DoxyCodeLine{7971                 \textcolor{keywordflow}{case} 0x57:}
\DoxyCodeLine{7972                 \textcolor{keywordflow}{case} 0x58:}
\DoxyCodeLine{7973                 \textcolor{keywordflow}{case} 0x59:}
\DoxyCodeLine{7974                 \textcolor{keywordflow}{case} 0x5A:}
\DoxyCodeLine{7975                 \textcolor{keywordflow}{case} 0x5B:}
\DoxyCodeLine{7976                 \textcolor{keywordflow}{case} 0x5D:}
\DoxyCodeLine{7977                 \textcolor{keywordflow}{case} 0x5E:}
\DoxyCodeLine{7978                 \textcolor{keywordflow}{case} 0x5F:}
\DoxyCodeLine{7979                 \textcolor{keywordflow}{case} 0x60:}
\DoxyCodeLine{7980                 \textcolor{keywordflow}{case} 0x61:}
\DoxyCodeLine{7981                 \textcolor{keywordflow}{case} 0x62:}
\DoxyCodeLine{7982                 \textcolor{keywordflow}{case} 0x63:}
\DoxyCodeLine{7983                 \textcolor{keywordflow}{case} 0x64:}
\DoxyCodeLine{7984                 \textcolor{keywordflow}{case} 0x65:}
\DoxyCodeLine{7985                 \textcolor{keywordflow}{case} 0x66:}
\DoxyCodeLine{7986                 \textcolor{keywordflow}{case} 0x67:}
\DoxyCodeLine{7987                 \textcolor{keywordflow}{case} 0x68:}
\DoxyCodeLine{7988                 \textcolor{keywordflow}{case} 0x69:}
\DoxyCodeLine{7989                 \textcolor{keywordflow}{case} 0x6A:}
\DoxyCodeLine{7990                 \textcolor{keywordflow}{case} 0x6B:}
\DoxyCodeLine{7991                 \textcolor{keywordflow}{case} 0x6C:}
\DoxyCodeLine{7992                 \textcolor{keywordflow}{case} 0x6D:}
\DoxyCodeLine{7993                 \textcolor{keywordflow}{case} 0x6E:}
\DoxyCodeLine{7994                 \textcolor{keywordflow}{case} 0x6F:}
\DoxyCodeLine{7995                 \textcolor{keywordflow}{case} 0x70:}
\DoxyCodeLine{7996                 \textcolor{keywordflow}{case} 0x71:}
\DoxyCodeLine{7997                 \textcolor{keywordflow}{case} 0x72:}
\DoxyCodeLine{7998                 \textcolor{keywordflow}{case} 0x73:}
\DoxyCodeLine{7999                 \textcolor{keywordflow}{case} 0x74:}
\DoxyCodeLine{8000                 \textcolor{keywordflow}{case} 0x75:}
\DoxyCodeLine{8001                 \textcolor{keywordflow}{case} 0x76:}
\DoxyCodeLine{8002                 \textcolor{keywordflow}{case} 0x77:}
\DoxyCodeLine{8003                 \textcolor{keywordflow}{case} 0x78:}
\DoxyCodeLine{8004                 \textcolor{keywordflow}{case} 0x79:}
\DoxyCodeLine{8005                 \textcolor{keywordflow}{case} 0x7A:}
\DoxyCodeLine{8006                 \textcolor{keywordflow}{case} 0x7B:}
\DoxyCodeLine{8007                 \textcolor{keywordflow}{case} 0x7C:}
\DoxyCodeLine{8008                 \textcolor{keywordflow}{case} 0x7D:}
\DoxyCodeLine{8009                 \textcolor{keywordflow}{case} 0x7E:}
\DoxyCodeLine{8010                 \textcolor{keywordflow}{case} 0x7F:}
\DoxyCodeLine{8011                 \{}
\DoxyCodeLine{8012                     add(current);}
\DoxyCodeLine{8013                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{8014                 \}}
\DoxyCodeLine{8015 }
\DoxyCodeLine{8016                 \textcolor{comment}{// U+0080..U+07FF: bytes C2..DF 80..BF}}
\DoxyCodeLine{8017                 \textcolor{keywordflow}{case} 0xC2:}
\DoxyCodeLine{8018                 \textcolor{keywordflow}{case} 0xC3:}
\DoxyCodeLine{8019                 \textcolor{keywordflow}{case} 0xC4:}
\DoxyCodeLine{8020                 \textcolor{keywordflow}{case} 0xC5:}
\DoxyCodeLine{8021                 \textcolor{keywordflow}{case} 0xC6:}
\DoxyCodeLine{8022                 \textcolor{keywordflow}{case} 0xC7:}
\DoxyCodeLine{8023                 \textcolor{keywordflow}{case} 0xC8:}
\DoxyCodeLine{8024                 \textcolor{keywordflow}{case} 0xC9:}
\DoxyCodeLine{8025                 \textcolor{keywordflow}{case} 0xCA:}
\DoxyCodeLine{8026                 \textcolor{keywordflow}{case} 0xCB:}
\DoxyCodeLine{8027                 \textcolor{keywordflow}{case} 0xCC:}
\DoxyCodeLine{8028                 \textcolor{keywordflow}{case} 0xCD:}
\DoxyCodeLine{8029                 \textcolor{keywordflow}{case} 0xCE:}
\DoxyCodeLine{8030                 \textcolor{keywordflow}{case} 0xCF:}
\DoxyCodeLine{8031                 \textcolor{keywordflow}{case} 0xD0:}
\DoxyCodeLine{8032                 \textcolor{keywordflow}{case} 0xD1:}
\DoxyCodeLine{8033                 \textcolor{keywordflow}{case} 0xD2:}
\DoxyCodeLine{8034                 \textcolor{keywordflow}{case} 0xD3:}
\DoxyCodeLine{8035                 \textcolor{keywordflow}{case} 0xD4:}
\DoxyCodeLine{8036                 \textcolor{keywordflow}{case} 0xD5:}
\DoxyCodeLine{8037                 \textcolor{keywordflow}{case} 0xD6:}
\DoxyCodeLine{8038                 \textcolor{keywordflow}{case} 0xD7:}
\DoxyCodeLine{8039                 \textcolor{keywordflow}{case} 0xD8:}
\DoxyCodeLine{8040                 \textcolor{keywordflow}{case} 0xD9:}
\DoxyCodeLine{8041                 \textcolor{keywordflow}{case} 0xDA:}
\DoxyCodeLine{8042                 \textcolor{keywordflow}{case} 0xDB:}
\DoxyCodeLine{8043                 \textcolor{keywordflow}{case} 0xDC:}
\DoxyCodeLine{8044                 \textcolor{keywordflow}{case} 0xDD:}
\DoxyCodeLine{8045                 \textcolor{keywordflow}{case} 0xDE:}
\DoxyCodeLine{8046                 \textcolor{keywordflow}{case} 0xDF:}
\DoxyCodeLine{8047                 \{}
\DoxyCodeLine{8048                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!next\_byte\_in\_range(\{0x80, 0xBF\})))}
\DoxyCodeLine{8049                     \{}
\DoxyCodeLine{8050                         \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8051                     \}}
\DoxyCodeLine{8052                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{8053                 \}}
\DoxyCodeLine{8054 }
\DoxyCodeLine{8055                 \textcolor{comment}{// U+0800..U+0FFF: bytes E0 A0..BF 80..BF}}
\DoxyCodeLine{8056                 \textcolor{keywordflow}{case} 0xE0:}
\DoxyCodeLine{8057                 \{}
\DoxyCodeLine{8058                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(next\_byte\_in\_range(\{0xA0, 0xBF, 0x80, 0xBF\}))))}
\DoxyCodeLine{8059                     \{}
\DoxyCodeLine{8060                         \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8061                     \}}
\DoxyCodeLine{8062                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{8063                 \}}
\DoxyCodeLine{8064 }
\DoxyCodeLine{8065                 \textcolor{comment}{// U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF}}
\DoxyCodeLine{8066                 \textcolor{comment}{// U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF}}
\DoxyCodeLine{8067                 \textcolor{keywordflow}{case} 0xE1:}
\DoxyCodeLine{8068                 \textcolor{keywordflow}{case} 0xE2:}
\DoxyCodeLine{8069                 \textcolor{keywordflow}{case} 0xE3:}
\DoxyCodeLine{8070                 \textcolor{keywordflow}{case} 0xE4:}
\DoxyCodeLine{8071                 \textcolor{keywordflow}{case} 0xE5:}
\DoxyCodeLine{8072                 \textcolor{keywordflow}{case} 0xE6:}
\DoxyCodeLine{8073                 \textcolor{keywordflow}{case} 0xE7:}
\DoxyCodeLine{8074                 \textcolor{keywordflow}{case} 0xE8:}
\DoxyCodeLine{8075                 \textcolor{keywordflow}{case} 0xE9:}
\DoxyCodeLine{8076                 \textcolor{keywordflow}{case} 0xEA:}
\DoxyCodeLine{8077                 \textcolor{keywordflow}{case} 0xEB:}
\DoxyCodeLine{8078                 \textcolor{keywordflow}{case} 0xEC:}
\DoxyCodeLine{8079                 \textcolor{keywordflow}{case} 0xEE:}
\DoxyCodeLine{8080                 \textcolor{keywordflow}{case} 0xEF:}
\DoxyCodeLine{8081                 \{}
\DoxyCodeLine{8082                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(next\_byte\_in\_range(\{0x80, 0xBF, 0x80, 0xBF\}))))}
\DoxyCodeLine{8083                     \{}
\DoxyCodeLine{8084                         \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8085                     \}}
\DoxyCodeLine{8086                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{8087                 \}}
\DoxyCodeLine{8088 }
\DoxyCodeLine{8089                 \textcolor{comment}{// U+D000..U+D7FF: bytes ED 80..9F 80..BF}}
\DoxyCodeLine{8090                 \textcolor{keywordflow}{case} 0xED:}
\DoxyCodeLine{8091                 \{}
\DoxyCodeLine{8092                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(next\_byte\_in\_range(\{0x80, 0x9F, 0x80, 0xBF\}))))}
\DoxyCodeLine{8093                     \{}
\DoxyCodeLine{8094                         \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8095                     \}}
\DoxyCodeLine{8096                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{8097                 \}}
\DoxyCodeLine{8098 }
\DoxyCodeLine{8099                 \textcolor{comment}{// U+10000..U+3FFFF F0 90..BF 80..BF 80..BF}}
\DoxyCodeLine{8100                 \textcolor{keywordflow}{case} 0xF0:}
\DoxyCodeLine{8101                 \{}
\DoxyCodeLine{8102                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(next\_byte\_in\_range(\{0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF\}))))}
\DoxyCodeLine{8103                     \{}
\DoxyCodeLine{8104                         \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8105                     \}}
\DoxyCodeLine{8106                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{8107                 \}}
\DoxyCodeLine{8108 }
\DoxyCodeLine{8109                 \textcolor{comment}{// U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF}}
\DoxyCodeLine{8110                 \textcolor{keywordflow}{case} 0xF1:}
\DoxyCodeLine{8111                 \textcolor{keywordflow}{case} 0xF2:}
\DoxyCodeLine{8112                 \textcolor{keywordflow}{case} 0xF3:}
\DoxyCodeLine{8113                 \{}
\DoxyCodeLine{8114                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(next\_byte\_in\_range(\{0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF\}))))}
\DoxyCodeLine{8115                     \{}
\DoxyCodeLine{8116                         \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8117                     \}}
\DoxyCodeLine{8118                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{8119                 \}}
\DoxyCodeLine{8120 }
\DoxyCodeLine{8121                 \textcolor{comment}{// U+100000..U+10FFFF F4 80..8F 80..BF 80..BF}}
\DoxyCodeLine{8122                 \textcolor{keywordflow}{case} 0xF4:}
\DoxyCodeLine{8123                 \{}
\DoxyCodeLine{8124                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(next\_byte\_in\_range(\{0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF\}))))}
\DoxyCodeLine{8125                     \{}
\DoxyCodeLine{8126                         \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8127                     \}}
\DoxyCodeLine{8128                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{8129                 \}}
\DoxyCodeLine{8130 }
\DoxyCodeLine{8131                 \textcolor{comment}{// remaining bytes (80..C1 and F5..FF) are ill-\/formed}}
\DoxyCodeLine{8132                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8133                 \{}
\DoxyCodeLine{8134                     error\_message = \textcolor{stringliteral}{"{}invalid string: ill-\/formed UTF-\/8 byte"{}};}
\DoxyCodeLine{8135                     \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8136                 \}}
\DoxyCodeLine{8137             \}}
\DoxyCodeLine{8138         \}}
\DoxyCodeLine{8139     \}}
\DoxyCodeLine{8140 }
\DoxyCodeLine{8145     \textcolor{keywordtype}{bool} scan\_comment()}
\DoxyCodeLine{8146     \{}
\DoxyCodeLine{8147         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8148         \{}
\DoxyCodeLine{8149             \textcolor{comment}{// single-\/line comments skip input until a newline or EOF is read}}
\DoxyCodeLine{8150             \textcolor{keywordflow}{case} \textcolor{charliteral}{'/'}:}
\DoxyCodeLine{8151             \{}
\DoxyCodeLine{8152                 \textcolor{keywordflow}{while} (\textcolor{keyword}{true})}
\DoxyCodeLine{8153                 \{}
\DoxyCodeLine{8154                     \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8155                     \{}
\DoxyCodeLine{8156                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)n'}:}
\DoxyCodeLine{8157                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)r'}:}
\DoxyCodeLine{8158                         \textcolor{keywordflow}{case} std::char\_traits<char\_type>::eof():}
\DoxyCodeLine{8159                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)0'}:}
\DoxyCodeLine{8160                             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{8161 }
\DoxyCodeLine{8162                         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8163                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{8164                     \}}
\DoxyCodeLine{8165                 \}}
\DoxyCodeLine{8166             \}}
\DoxyCodeLine{8167 }
\DoxyCodeLine{8168             \textcolor{comment}{// multi-\/line comments skip input until */ is read}}
\DoxyCodeLine{8169             \textcolor{keywordflow}{case} \textcolor{charliteral}{'*'}:}
\DoxyCodeLine{8170             \{}
\DoxyCodeLine{8171                 \textcolor{keywordflow}{while} (\textcolor{keyword}{true})}
\DoxyCodeLine{8172                 \{}
\DoxyCodeLine{8173                     \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8174                     \{}
\DoxyCodeLine{8175                         \textcolor{keywordflow}{case} std::char\_traits<char\_type>::eof():}
\DoxyCodeLine{8176                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)0'}:}
\DoxyCodeLine{8177                         \{}
\DoxyCodeLine{8178                             error\_message = \textcolor{stringliteral}{"{}invalid comment; missing closing '*/'"{}};}
\DoxyCodeLine{8179                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{8180                         \}}
\DoxyCodeLine{8181 }
\DoxyCodeLine{8182                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'*'}:}
\DoxyCodeLine{8183                         \{}
\DoxyCodeLine{8184                             \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8185                             \{}
\DoxyCodeLine{8186                                 \textcolor{keywordflow}{case} \textcolor{charliteral}{'/'}:}
\DoxyCodeLine{8187                                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{8188 }
\DoxyCodeLine{8189                                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8190                                 \{}
\DoxyCodeLine{8191                                     unget();}
\DoxyCodeLine{8192                                     \textcolor{keywordflow}{continue};}
\DoxyCodeLine{8193                                 \}}
\DoxyCodeLine{8194                             \}}
\DoxyCodeLine{8195                         \}}
\DoxyCodeLine{8196 }
\DoxyCodeLine{8197                         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8198                             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{8199                     \}}
\DoxyCodeLine{8200                 \}}
\DoxyCodeLine{8201             \}}
\DoxyCodeLine{8202 }
\DoxyCodeLine{8203             \textcolor{comment}{// unexpected character after reading '/'}}
\DoxyCodeLine{8204             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8205             \{}
\DoxyCodeLine{8206                 error\_message = \textcolor{stringliteral}{"{}invalid comment; expecting '/' or '*' after '/'"{}};}
\DoxyCodeLine{8207                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{8208             \}}
\DoxyCodeLine{8209         \}}
\DoxyCodeLine{8210     \}}
\DoxyCodeLine{8211 }
\DoxyCodeLine{8212     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{8213     \textcolor{keyword}{static} \textcolor{keywordtype}{void} strtof(\textcolor{keywordtype}{float}\& f, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \textcolor{keywordtype}{char}** endptr) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{8214     \{}
\DoxyCodeLine{8215         f = std::strtof(str, endptr);}
\DoxyCodeLine{8216     \}}
\DoxyCodeLine{8217 }
\DoxyCodeLine{8218     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{8219     \textcolor{keyword}{static} \textcolor{keywordtype}{void} strtof(\textcolor{keywordtype}{double}\& f, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \textcolor{keywordtype}{char}** endptr) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{8220     \{}
\DoxyCodeLine{8221         f = std::strtod(str, endptr);}
\DoxyCodeLine{8222     \}}
\DoxyCodeLine{8223 }
\DoxyCodeLine{8224     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{8225     \textcolor{keyword}{static} \textcolor{keywordtype}{void} strtof(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double}\& f, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* str, \textcolor{keywordtype}{char}** endptr) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{8226     \{}
\DoxyCodeLine{8227         f = std::strtold(str, endptr);}
\DoxyCodeLine{8228     \}}
\DoxyCodeLine{8229 }
\DoxyCodeLine{8270     \mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{token\_type}} scan\_number()  \textcolor{comment}{// lgtm [cpp/use-\/of-\/goto]}}
\DoxyCodeLine{8271     \{}
\DoxyCodeLine{8272         \textcolor{comment}{// reset token\_buffer to store the number's bytes}}
\DoxyCodeLine{8273         reset();}
\DoxyCodeLine{8274 }
\DoxyCodeLine{8275         \textcolor{comment}{// the type of the parsed number; initially set to unsigned; will be}}
\DoxyCodeLine{8276         \textcolor{comment}{// changed if minus sign, decimal point or exponent is read}}
\DoxyCodeLine{8277         \mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{token\_type}} number\_type = token\_type::value\_unsigned;}
\DoxyCodeLine{8278 }
\DoxyCodeLine{8279         \textcolor{comment}{// state (init): we just found out we need to scan a number}}
\DoxyCodeLine{8280         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{8281         \{}
\DoxyCodeLine{8282             \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}:}
\DoxyCodeLine{8283             \{}
\DoxyCodeLine{8284                 add(current);}
\DoxyCodeLine{8285                 \textcolor{keywordflow}{goto} scan\_number\_minus;}
\DoxyCodeLine{8286             \}}
\DoxyCodeLine{8287 }
\DoxyCodeLine{8288             \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{8289             \{}
\DoxyCodeLine{8290                 add(current);}
\DoxyCodeLine{8291                 \textcolor{keywordflow}{goto} scan\_number\_zero;}
\DoxyCodeLine{8292             \}}
\DoxyCodeLine{8293 }
\DoxyCodeLine{8294             \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:}
\DoxyCodeLine{8295             \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:}
\DoxyCodeLine{8296             \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:}
\DoxyCodeLine{8297             \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:}
\DoxyCodeLine{8298             \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:}
\DoxyCodeLine{8299             \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:}
\DoxyCodeLine{8300             \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:}
\DoxyCodeLine{8301             \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:}
\DoxyCodeLine{8302             \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:}
\DoxyCodeLine{8303             \{}
\DoxyCodeLine{8304                 add(current);}
\DoxyCodeLine{8305                 \textcolor{keywordflow}{goto} scan\_number\_any1;}
\DoxyCodeLine{8306             \}}
\DoxyCodeLine{8307 }
\DoxyCodeLine{8308             \textcolor{comment}{// all other characters are rejected outside scan\_number()}}
\DoxyCodeLine{8309             \textcolor{keywordflow}{default}:            \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{8310                 JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{8311         \}}
\DoxyCodeLine{8312 }
\DoxyCodeLine{8313 scan\_number\_minus:}
\DoxyCodeLine{8314         \textcolor{comment}{// state: we just parsed a leading minus sign}}
\DoxyCodeLine{8315         number\_type = token\_type::value\_integer;}
\DoxyCodeLine{8316         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8317         \{}
\DoxyCodeLine{8318             \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{8319             \{}
\DoxyCodeLine{8320                 add(current);}
\DoxyCodeLine{8321                 \textcolor{keywordflow}{goto} scan\_number\_zero;}
\DoxyCodeLine{8322             \}}
\DoxyCodeLine{8323 }
\DoxyCodeLine{8324             \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:}
\DoxyCodeLine{8325             \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:}
\DoxyCodeLine{8326             \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:}
\DoxyCodeLine{8327             \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:}
\DoxyCodeLine{8328             \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:}
\DoxyCodeLine{8329             \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:}
\DoxyCodeLine{8330             \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:}
\DoxyCodeLine{8331             \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:}
\DoxyCodeLine{8332             \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:}
\DoxyCodeLine{8333             \{}
\DoxyCodeLine{8334                 add(current);}
\DoxyCodeLine{8335                 \textcolor{keywordflow}{goto} scan\_number\_any1;}
\DoxyCodeLine{8336             \}}
\DoxyCodeLine{8337 }
\DoxyCodeLine{8338             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8339             \{}
\DoxyCodeLine{8340                 error\_message = \textcolor{stringliteral}{"{}invalid number; expected digit after '-\/'"{}};}
\DoxyCodeLine{8341                 \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8342             \}}
\DoxyCodeLine{8343         \}}
\DoxyCodeLine{8344 }
\DoxyCodeLine{8345 scan\_number\_zero:}
\DoxyCodeLine{8346         \textcolor{comment}{// state: we just parse a zero (maybe with a leading minus sign)}}
\DoxyCodeLine{8347         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8348         \{}
\DoxyCodeLine{8349             \textcolor{keywordflow}{case} \textcolor{charliteral}{'.'}:}
\DoxyCodeLine{8350             \{}
\DoxyCodeLine{8351                 add(decimal\_point\_char);}
\DoxyCodeLine{8352                 \textcolor{keywordflow}{goto} scan\_number\_decimal1;}
\DoxyCodeLine{8353             \}}
\DoxyCodeLine{8354 }
\DoxyCodeLine{8355             \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}:}
\DoxyCodeLine{8356             \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}:}
\DoxyCodeLine{8357             \{}
\DoxyCodeLine{8358                 add(current);}
\DoxyCodeLine{8359                 \textcolor{keywordflow}{goto} scan\_number\_exponent;}
\DoxyCodeLine{8360             \}}
\DoxyCodeLine{8361 }
\DoxyCodeLine{8362             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8363                 \textcolor{keywordflow}{goto} scan\_number\_done;}
\DoxyCodeLine{8364         \}}
\DoxyCodeLine{8365 }
\DoxyCodeLine{8366 scan\_number\_any1:}
\DoxyCodeLine{8367         \textcolor{comment}{// state: we just parsed a number 0-\/9 (maybe with a leading minus sign)}}
\DoxyCodeLine{8368         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8369         \{}
\DoxyCodeLine{8370             \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{8371             \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:}
\DoxyCodeLine{8372             \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:}
\DoxyCodeLine{8373             \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:}
\DoxyCodeLine{8374             \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:}
\DoxyCodeLine{8375             \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:}
\DoxyCodeLine{8376             \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:}
\DoxyCodeLine{8377             \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:}
\DoxyCodeLine{8378             \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:}
\DoxyCodeLine{8379             \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:}
\DoxyCodeLine{8380             \{}
\DoxyCodeLine{8381                 add(current);}
\DoxyCodeLine{8382                 \textcolor{keywordflow}{goto} scan\_number\_any1;}
\DoxyCodeLine{8383             \}}
\DoxyCodeLine{8384 }
\DoxyCodeLine{8385             \textcolor{keywordflow}{case} \textcolor{charliteral}{'.'}:}
\DoxyCodeLine{8386             \{}
\DoxyCodeLine{8387                 add(decimal\_point\_char);}
\DoxyCodeLine{8388                 \textcolor{keywordflow}{goto} scan\_number\_decimal1;}
\DoxyCodeLine{8389             \}}
\DoxyCodeLine{8390 }
\DoxyCodeLine{8391             \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}:}
\DoxyCodeLine{8392             \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}:}
\DoxyCodeLine{8393             \{}
\DoxyCodeLine{8394                 add(current);}
\DoxyCodeLine{8395                 \textcolor{keywordflow}{goto} scan\_number\_exponent;}
\DoxyCodeLine{8396             \}}
\DoxyCodeLine{8397 }
\DoxyCodeLine{8398             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8399                 \textcolor{keywordflow}{goto} scan\_number\_done;}
\DoxyCodeLine{8400         \}}
\DoxyCodeLine{8401 }
\DoxyCodeLine{8402 scan\_number\_decimal1:}
\DoxyCodeLine{8403         \textcolor{comment}{// state: we just parsed a decimal point}}
\DoxyCodeLine{8404         number\_type = token\_type::value\_float;}
\DoxyCodeLine{8405         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8406         \{}
\DoxyCodeLine{8407             \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{8408             \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:}
\DoxyCodeLine{8409             \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:}
\DoxyCodeLine{8410             \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:}
\DoxyCodeLine{8411             \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:}
\DoxyCodeLine{8412             \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:}
\DoxyCodeLine{8413             \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:}
\DoxyCodeLine{8414             \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:}
\DoxyCodeLine{8415             \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:}
\DoxyCodeLine{8416             \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:}
\DoxyCodeLine{8417             \{}
\DoxyCodeLine{8418                 add(current);}
\DoxyCodeLine{8419                 \textcolor{keywordflow}{goto} scan\_number\_decimal2;}
\DoxyCodeLine{8420             \}}
\DoxyCodeLine{8421 }
\DoxyCodeLine{8422             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8423             \{}
\DoxyCodeLine{8424                 error\_message = \textcolor{stringliteral}{"{}invalid number; expected digit after '.'"{}};}
\DoxyCodeLine{8425                 \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8426             \}}
\DoxyCodeLine{8427         \}}
\DoxyCodeLine{8428 }
\DoxyCodeLine{8429 scan\_number\_decimal2:}
\DoxyCodeLine{8430         \textcolor{comment}{// we just parsed at least one number after a decimal point}}
\DoxyCodeLine{8431         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8432         \{}
\DoxyCodeLine{8433             \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{8434             \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:}
\DoxyCodeLine{8435             \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:}
\DoxyCodeLine{8436             \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:}
\DoxyCodeLine{8437             \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:}
\DoxyCodeLine{8438             \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:}
\DoxyCodeLine{8439             \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:}
\DoxyCodeLine{8440             \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:}
\DoxyCodeLine{8441             \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:}
\DoxyCodeLine{8442             \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:}
\DoxyCodeLine{8443             \{}
\DoxyCodeLine{8444                 add(current);}
\DoxyCodeLine{8445                 \textcolor{keywordflow}{goto} scan\_number\_decimal2;}
\DoxyCodeLine{8446             \}}
\DoxyCodeLine{8447 }
\DoxyCodeLine{8448             \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}:}
\DoxyCodeLine{8449             \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}:}
\DoxyCodeLine{8450             \{}
\DoxyCodeLine{8451                 add(current);}
\DoxyCodeLine{8452                 \textcolor{keywordflow}{goto} scan\_number\_exponent;}
\DoxyCodeLine{8453             \}}
\DoxyCodeLine{8454 }
\DoxyCodeLine{8455             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8456                 \textcolor{keywordflow}{goto} scan\_number\_done;}
\DoxyCodeLine{8457         \}}
\DoxyCodeLine{8458 }
\DoxyCodeLine{8459 scan\_number\_exponent:}
\DoxyCodeLine{8460         \textcolor{comment}{// we just parsed an exponent}}
\DoxyCodeLine{8461         number\_type = token\_type::value\_float;}
\DoxyCodeLine{8462         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8463         \{}
\DoxyCodeLine{8464             \textcolor{keywordflow}{case} \textcolor{charliteral}{'+'}:}
\DoxyCodeLine{8465             \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}:}
\DoxyCodeLine{8466             \{}
\DoxyCodeLine{8467                 add(current);}
\DoxyCodeLine{8468                 \textcolor{keywordflow}{goto} scan\_number\_sign;}
\DoxyCodeLine{8469             \}}
\DoxyCodeLine{8470 }
\DoxyCodeLine{8471             \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{8472             \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:}
\DoxyCodeLine{8473             \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:}
\DoxyCodeLine{8474             \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:}
\DoxyCodeLine{8475             \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:}
\DoxyCodeLine{8476             \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:}
\DoxyCodeLine{8477             \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:}
\DoxyCodeLine{8478             \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:}
\DoxyCodeLine{8479             \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:}
\DoxyCodeLine{8480             \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:}
\DoxyCodeLine{8481             \{}
\DoxyCodeLine{8482                 add(current);}
\DoxyCodeLine{8483                 \textcolor{keywordflow}{goto} scan\_number\_any2;}
\DoxyCodeLine{8484             \}}
\DoxyCodeLine{8485 }
\DoxyCodeLine{8486             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8487             \{}
\DoxyCodeLine{8488                 error\_message =}
\DoxyCodeLine{8489                     \textcolor{stringliteral}{"{}invalid number; expected '+', '-\/', or digit after exponent"{}};}
\DoxyCodeLine{8490                 \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8491             \}}
\DoxyCodeLine{8492         \}}
\DoxyCodeLine{8493 }
\DoxyCodeLine{8494 scan\_number\_sign:}
\DoxyCodeLine{8495         \textcolor{comment}{// we just parsed an exponent sign}}
\DoxyCodeLine{8496         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8497         \{}
\DoxyCodeLine{8498             \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{8499             \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:}
\DoxyCodeLine{8500             \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:}
\DoxyCodeLine{8501             \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:}
\DoxyCodeLine{8502             \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:}
\DoxyCodeLine{8503             \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:}
\DoxyCodeLine{8504             \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:}
\DoxyCodeLine{8505             \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:}
\DoxyCodeLine{8506             \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:}
\DoxyCodeLine{8507             \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:}
\DoxyCodeLine{8508             \{}
\DoxyCodeLine{8509                 add(current);}
\DoxyCodeLine{8510                 \textcolor{keywordflow}{goto} scan\_number\_any2;}
\DoxyCodeLine{8511             \}}
\DoxyCodeLine{8512 }
\DoxyCodeLine{8513             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8514             \{}
\DoxyCodeLine{8515                 error\_message = \textcolor{stringliteral}{"{}invalid number; expected digit after exponent sign"{}};}
\DoxyCodeLine{8516                 \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8517             \}}
\DoxyCodeLine{8518         \}}
\DoxyCodeLine{8519 }
\DoxyCodeLine{8520 scan\_number\_any2:}
\DoxyCodeLine{8521         \textcolor{comment}{// we just parsed a number after the exponent or exponent sign}}
\DoxyCodeLine{8522         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{8523         \{}
\DoxyCodeLine{8524             \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{8525             \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:}
\DoxyCodeLine{8526             \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:}
\DoxyCodeLine{8527             \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:}
\DoxyCodeLine{8528             \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:}
\DoxyCodeLine{8529             \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:}
\DoxyCodeLine{8530             \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:}
\DoxyCodeLine{8531             \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:}
\DoxyCodeLine{8532             \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:}
\DoxyCodeLine{8533             \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:}
\DoxyCodeLine{8534             \{}
\DoxyCodeLine{8535                 add(current);}
\DoxyCodeLine{8536                 \textcolor{keywordflow}{goto} scan\_number\_any2;}
\DoxyCodeLine{8537             \}}
\DoxyCodeLine{8538 }
\DoxyCodeLine{8539             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8540                 \textcolor{keywordflow}{goto} scan\_number\_done;}
\DoxyCodeLine{8541         \}}
\DoxyCodeLine{8542 }
\DoxyCodeLine{8543 scan\_number\_done:}
\DoxyCodeLine{8544         \textcolor{comment}{// unget the character after the number (we only read it to know that}}
\DoxyCodeLine{8545         \textcolor{comment}{// we are done scanning a number)}}
\DoxyCodeLine{8546         unget();}
\DoxyCodeLine{8547 }
\DoxyCodeLine{8548         \textcolor{keywordtype}{char}* endptr = \textcolor{keyword}{nullptr}; \textcolor{comment}{// NOLINT(cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{8549         errno = 0;}
\DoxyCodeLine{8550 }
\DoxyCodeLine{8551         \textcolor{comment}{// try to parse integers first and fall back to floats}}
\DoxyCodeLine{8552         \textcolor{keywordflow}{if} (number\_type == token\_type::value\_unsigned)}
\DoxyCodeLine{8553         \{}
\DoxyCodeLine{8554             \textcolor{keyword}{const} \textcolor{keyword}{auto} x = std::strtoull(token\_buffer.data(), \&endptr, 10);}
\DoxyCodeLine{8555 }
\DoxyCodeLine{8556             \textcolor{comment}{// we checked the number format before}}
\DoxyCodeLine{8557             JSON\_ASSERT(endptr == token\_buffer.data() + token\_buffer.size());}
\DoxyCodeLine{8558 }
\DoxyCodeLine{8559             \textcolor{keywordflow}{if} (errno == 0)}
\DoxyCodeLine{8560             \{}
\DoxyCodeLine{8561                 value\_unsigned = \textcolor{keyword}{static\_cast<}number\_unsigned\_t\textcolor{keyword}{>}(x);}
\DoxyCodeLine{8562                 \textcolor{keywordflow}{if} (value\_unsigned == x)}
\DoxyCodeLine{8563                 \{}
\DoxyCodeLine{8564                     \textcolor{keywordflow}{return} token\_type::value\_unsigned;}
\DoxyCodeLine{8565                 \}}
\DoxyCodeLine{8566             \}}
\DoxyCodeLine{8567         \}}
\DoxyCodeLine{8568         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (number\_type == token\_type::value\_integer)}
\DoxyCodeLine{8569         \{}
\DoxyCodeLine{8570             \textcolor{keyword}{const} \textcolor{keyword}{auto} x = std::strtoll(token\_buffer.data(), \&endptr, 10);}
\DoxyCodeLine{8571 }
\DoxyCodeLine{8572             \textcolor{comment}{// we checked the number format before}}
\DoxyCodeLine{8573             JSON\_ASSERT(endptr == token\_buffer.data() + token\_buffer.size());}
\DoxyCodeLine{8574 }
\DoxyCodeLine{8575             \textcolor{keywordflow}{if} (errno == 0)}
\DoxyCodeLine{8576             \{}
\DoxyCodeLine{8577                 value\_integer = \textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(x);}
\DoxyCodeLine{8578                 \textcolor{keywordflow}{if} (value\_integer == x)}
\DoxyCodeLine{8579                 \{}
\DoxyCodeLine{8580                     \textcolor{keywordflow}{return} token\_type::value\_integer;}
\DoxyCodeLine{8581                 \}}
\DoxyCodeLine{8582             \}}
\DoxyCodeLine{8583         \}}
\DoxyCodeLine{8584 }
\DoxyCodeLine{8585         \textcolor{comment}{// this code is reached if we parse a floating-\/point number or if an}}
\DoxyCodeLine{8586         \textcolor{comment}{// integer conversion above failed}}
\DoxyCodeLine{8587         strtof(value\_float, token\_buffer.data(), \&endptr);}
\DoxyCodeLine{8588 }
\DoxyCodeLine{8589         \textcolor{comment}{// we checked the number format before}}
\DoxyCodeLine{8590         JSON\_ASSERT(endptr == token\_buffer.data() + token\_buffer.size());}
\DoxyCodeLine{8591 }
\DoxyCodeLine{8592         \textcolor{keywordflow}{return} token\_type::value\_float;}
\DoxyCodeLine{8593     \}}
\DoxyCodeLine{8594 }
\DoxyCodeLine{8600     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{8601     \mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{token\_type}} scan\_literal(\textcolor{keyword}{const} char\_type* literal\_text, \textcolor{keyword}{const} std::size\_t length,}
\DoxyCodeLine{8602                             \mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{token\_type}} return\_type)}
\DoxyCodeLine{8603     \{}
\DoxyCodeLine{8604         JSON\_ASSERT(std::char\_traits<char\_type>::to\_char\_type(current) == literal\_text[0]);}
\DoxyCodeLine{8605         \textcolor{keywordflow}{for} (std::size\_t i = 1; i < length; ++i)}
\DoxyCodeLine{8606         \{}
\DoxyCodeLine{8607             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(std::char\_traits<char\_type>::to\_char\_type(get()) != literal\_text[i]))}
\DoxyCodeLine{8608             \{}
\DoxyCodeLine{8609                 error\_message = \textcolor{stringliteral}{"{}invalid literal"{}};}
\DoxyCodeLine{8610                 \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8611             \}}
\DoxyCodeLine{8612         \}}
\DoxyCodeLine{8613         \textcolor{keywordflow}{return} return\_type;}
\DoxyCodeLine{8614     \}}
\DoxyCodeLine{8615 }
\DoxyCodeLine{8617     \textcolor{comment}{// input management}}
\DoxyCodeLine{8619 \textcolor{comment}{}}
\DoxyCodeLine{8621     \textcolor{keywordtype}{void} reset() \textcolor{keyword}{noexcept}}
\DoxyCodeLine{8622     \{}
\DoxyCodeLine{8623         token\_buffer.clear();}
\DoxyCodeLine{8624         token\_string.clear();}
\DoxyCodeLine{8625         token\_string.push\_back(std::char\_traits<char\_type>::to\_char\_type(current));}
\DoxyCodeLine{8626     \}}
\DoxyCodeLine{8627 }
\DoxyCodeLine{8628     \textcolor{comment}{/*}}
\DoxyCodeLine{8629 \textcolor{comment}{    @brief get next character from the input}}
\DoxyCodeLine{8630 \textcolor{comment}{}}
\DoxyCodeLine{8631 \textcolor{comment}{    This function provides the interface to the used input adapter. It does}}
\DoxyCodeLine{8632 \textcolor{comment}{    not throw in case the input reached EOF, but returns a}}
\DoxyCodeLine{8633 \textcolor{comment}{    `std::char\_traits<char>::eof()` in that case.  Stores the scanned characters}}
\DoxyCodeLine{8634 \textcolor{comment}{    for use in error messages.}}
\DoxyCodeLine{8635 \textcolor{comment}{}}
\DoxyCodeLine{8636 \textcolor{comment}{    @return character read from the input}}
\DoxyCodeLine{8637 \textcolor{comment}{    */}}
\DoxyCodeLine{8638     char\_int\_type get()}
\DoxyCodeLine{8639     \{}
\DoxyCodeLine{8640         ++position.chars\_read\_total;}
\DoxyCodeLine{8641         ++position.chars\_read\_current\_line;}
\DoxyCodeLine{8642 }
\DoxyCodeLine{8643         \textcolor{keywordflow}{if} (next\_unget)}
\DoxyCodeLine{8644         \{}
\DoxyCodeLine{8645             \textcolor{comment}{// just reset the next\_unget variable and work with current}}
\DoxyCodeLine{8646             next\_unget = \textcolor{keyword}{false};}
\DoxyCodeLine{8647         \}}
\DoxyCodeLine{8648         \textcolor{keywordflow}{else}}
\DoxyCodeLine{8649         \{}
\DoxyCodeLine{8650             current = ia.get\_character();}
\DoxyCodeLine{8651         \}}
\DoxyCodeLine{8652 }
\DoxyCodeLine{8653         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(current != std::char\_traits<char\_type>::eof()))}
\DoxyCodeLine{8654         \{}
\DoxyCodeLine{8655             token\_string.push\_back(std::char\_traits<char\_type>::to\_char\_type(current));}
\DoxyCodeLine{8656         \}}
\DoxyCodeLine{8657 }
\DoxyCodeLine{8658         \textcolor{keywordflow}{if} (current == \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{8659         \{}
\DoxyCodeLine{8660             ++position.lines\_read;}
\DoxyCodeLine{8661             position.chars\_read\_current\_line = 0;}
\DoxyCodeLine{8662         \}}
\DoxyCodeLine{8663 }
\DoxyCodeLine{8664         \textcolor{keywordflow}{return} current;}
\DoxyCodeLine{8665     \}}
\DoxyCodeLine{8666 }
\DoxyCodeLine{8675     \textcolor{keywordtype}{void} unget()}
\DoxyCodeLine{8676     \{}
\DoxyCodeLine{8677         next\_unget = \textcolor{keyword}{true};}
\DoxyCodeLine{8678 }
\DoxyCodeLine{8679         -\/-\/position.chars\_read\_total;}
\DoxyCodeLine{8680 }
\DoxyCodeLine{8681         \textcolor{comment}{// in case we "{}unget"{} a newline, we have to also decrement the lines\_read}}
\DoxyCodeLine{8682         \textcolor{keywordflow}{if} (position.chars\_read\_current\_line == 0)}
\DoxyCodeLine{8683         \{}
\DoxyCodeLine{8684             \textcolor{keywordflow}{if} (position.lines\_read > 0)}
\DoxyCodeLine{8685             \{}
\DoxyCodeLine{8686                 -\/-\/position.lines\_read;}
\DoxyCodeLine{8687             \}}
\DoxyCodeLine{8688         \}}
\DoxyCodeLine{8689         \textcolor{keywordflow}{else}}
\DoxyCodeLine{8690         \{}
\DoxyCodeLine{8691             -\/-\/position.chars\_read\_current\_line;}
\DoxyCodeLine{8692         \}}
\DoxyCodeLine{8693 }
\DoxyCodeLine{8694         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(current != std::char\_traits<char\_type>::eof()))}
\DoxyCodeLine{8695         \{}
\DoxyCodeLine{8696             JSON\_ASSERT(!token\_string.empty());}
\DoxyCodeLine{8697             token\_string.pop\_back();}
\DoxyCodeLine{8698         \}}
\DoxyCodeLine{8699     \}}
\DoxyCodeLine{8700 }
\DoxyCodeLine{8702     \textcolor{keywordtype}{void} add(char\_int\_type c)}
\DoxyCodeLine{8703     \{}
\DoxyCodeLine{8704         token\_buffer.push\_back(\textcolor{keyword}{static\_cast<}typename string\_t::value\_type\textcolor{keyword}{>}(c));}
\DoxyCodeLine{8705     \}}
\DoxyCodeLine{8706 }
\DoxyCodeLine{8707   \textcolor{keyword}{public}:}
\DoxyCodeLine{8709     \textcolor{comment}{// value getters}}
\DoxyCodeLine{8711 \textcolor{comment}{}}
\DoxyCodeLine{8713     \textcolor{keyword}{constexpr} number\_integer\_t \mbox{\hyperlink{classdetail_1_1lexer_a4227de7d0382fb4d3e18b119f0cc87d7}{get\_number\_integer}}() const noexcept}
\DoxyCodeLine{8714     \{}
\DoxyCodeLine{8715         \textcolor{keywordflow}{return} value\_integer;}
\DoxyCodeLine{8716     \}}
\DoxyCodeLine{8717 }
\DoxyCodeLine{8719     \textcolor{keyword}{constexpr} number\_unsigned\_t \mbox{\hyperlink{classdetail_1_1lexer_a65495d5d60a279adb009efa728708441}{get\_number\_unsigned}}() const noexcept}
\DoxyCodeLine{8720     \{}
\DoxyCodeLine{8721         \textcolor{keywordflow}{return} value\_unsigned;}
\DoxyCodeLine{8722     \}}
\DoxyCodeLine{8723 }
\DoxyCodeLine{8725     \textcolor{keyword}{constexpr} number\_float\_t \mbox{\hyperlink{classdetail_1_1lexer_af2e903d32a7e3705c66539ea1e30ce59}{get\_number\_float}}() const noexcept}
\DoxyCodeLine{8726     \{}
\DoxyCodeLine{8727         \textcolor{keywordflow}{return} value\_float;}
\DoxyCodeLine{8728     \}}
\DoxyCodeLine{8729 }
\DoxyCodeLine{8731     string\_t\& \mbox{\hyperlink{classdetail_1_1lexer_aae63a63a83ae7e7bd5dc1a83669ba281}{get\_string}}()}
\DoxyCodeLine{8732     \{}
\DoxyCodeLine{8733         \textcolor{keywordflow}{return} token\_buffer;}
\DoxyCodeLine{8734     \}}
\DoxyCodeLine{8735 }
\DoxyCodeLine{8737     \textcolor{comment}{// diagnostics}}
\DoxyCodeLine{8739 \textcolor{comment}{}}
\DoxyCodeLine{8741     \textcolor{keyword}{constexpr} \mbox{\hyperlink{structdetail_1_1position__t}{position\_t}} \mbox{\hyperlink{classdetail_1_1lexer_a569266654a88a2dc6f0e9a587067fc9d}{get\_position}}() const noexcept}
\DoxyCodeLine{8742     \{}
\DoxyCodeLine{8743         \textcolor{keywordflow}{return} position;}
\DoxyCodeLine{8744     \}}
\DoxyCodeLine{8745 }
\DoxyCodeLine{8749     std::string \mbox{\hyperlink{classdetail_1_1lexer_a41481d87dc1bcaaf532f529fbc0e690b}{get\_token\_string}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{8750 \textcolor{keyword}{    }\{}
\DoxyCodeLine{8751         \textcolor{comment}{// escape control characters}}
\DoxyCodeLine{8752         std::string result;}
\DoxyCodeLine{8753         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto} c : token\_string)}
\DoxyCodeLine{8754         \{}
\DoxyCodeLine{8755             \textcolor{keywordflow}{if} (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(c) <= \textcolor{stringliteral}{'\(\backslash\)x1F'})}
\DoxyCodeLine{8756             \{}
\DoxyCodeLine{8757                 \textcolor{comment}{// escape control characters}}
\DoxyCodeLine{8758                 std::array<char, 9> cs\{\{\}\};}
\DoxyCodeLine{8759                 \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}((std::snprintf)(cs.data(), cs.size(), \textcolor{stringliteral}{"{}<U+\%.4X>"{}}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(c))); \textcolor{comment}{// NOLINT(cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{8760                 result += cs.data();}
\DoxyCodeLine{8761             \}}
\DoxyCodeLine{8762             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8763             \{}
\DoxyCodeLine{8764                 \textcolor{comment}{// add character as is}}
\DoxyCodeLine{8765                 result.push\_back(\textcolor{keyword}{static\_cast<}std::string::value\_type\textcolor{keyword}{>}(c));}
\DoxyCodeLine{8766             \}}
\DoxyCodeLine{8767         \}}
\DoxyCodeLine{8768 }
\DoxyCodeLine{8769         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{8770     \}}
\DoxyCodeLine{8771 }
\DoxyCodeLine{8773     JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{8774     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \mbox{\hyperlink{classdetail_1_1lexer_a412c108d8b931630d54e42fbbf764fc4}{get\_error\_message}}() const noexcept}
\DoxyCodeLine{8775     \{}
\DoxyCodeLine{8776         \textcolor{keywordflow}{return} error\_message;}
\DoxyCodeLine{8777     \}}
\DoxyCodeLine{8778 }
\DoxyCodeLine{8780     \textcolor{comment}{// actual scanner}}
\DoxyCodeLine{8782 \textcolor{comment}{}}
\DoxyCodeLine{8787     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1lexer_a04ae0c7807a761f4162ff42290be5490}{skip\_bom}}()}
\DoxyCodeLine{8788     \{}
\DoxyCodeLine{8789         \textcolor{keywordflow}{if} (get() == 0xEF)}
\DoxyCodeLine{8790         \{}
\DoxyCodeLine{8791             \textcolor{comment}{// check if we completely parse the BOM}}
\DoxyCodeLine{8792             \textcolor{keywordflow}{return} get() == 0xBB \&\& get() == 0xBF;}
\DoxyCodeLine{8793         \}}
\DoxyCodeLine{8794 }
\DoxyCodeLine{8795         \textcolor{comment}{// the first character is not the beginning of the BOM; unget it to}}
\DoxyCodeLine{8796         \textcolor{comment}{// process is later}}
\DoxyCodeLine{8797         unget();}
\DoxyCodeLine{8798         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{8799     \}}
\DoxyCodeLine{8800 }
\DoxyCodeLine{8801     \textcolor{keywordtype}{void} skip\_whitespace()}
\DoxyCodeLine{8802     \{}
\DoxyCodeLine{8803         \textcolor{keywordflow}{do}}
\DoxyCodeLine{8804         \{}
\DoxyCodeLine{8805             get();}
\DoxyCodeLine{8806         \}}
\DoxyCodeLine{8807         \textcolor{keywordflow}{while} (current == \textcolor{charliteral}{' '} || current == \textcolor{charliteral}{'\(\backslash\)t'} || current == \textcolor{charliteral}{'\(\backslash\)n'} || current == \textcolor{charliteral}{'\(\backslash\)r'});}
\DoxyCodeLine{8808     \}}
\DoxyCodeLine{8809 }
\DoxyCodeLine{8810     token\_type scan()}
\DoxyCodeLine{8811     \{}
\DoxyCodeLine{8812         \textcolor{comment}{// initially, skip the BOM}}
\DoxyCodeLine{8813         \textcolor{keywordflow}{if} (position.chars\_read\_total == 0 \&\& !skip\_bom())}
\DoxyCodeLine{8814         \{}
\DoxyCodeLine{8815             error\_message = \textcolor{stringliteral}{"{}invalid BOM; must be 0xEF 0xBB 0xBF if given"{}};}
\DoxyCodeLine{8816             \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8817         \}}
\DoxyCodeLine{8818 }
\DoxyCodeLine{8819         \textcolor{comment}{// read next character and ignore whitespace}}
\DoxyCodeLine{8820         skip\_whitespace();}
\DoxyCodeLine{8821 }
\DoxyCodeLine{8822         \textcolor{comment}{// ignore comments}}
\DoxyCodeLine{8823         \textcolor{keywordflow}{while} (ignore\_comments \&\& current == \textcolor{charliteral}{'/'})}
\DoxyCodeLine{8824         \{}
\DoxyCodeLine{8825             \textcolor{keywordflow}{if} (!scan\_comment())}
\DoxyCodeLine{8826             \{}
\DoxyCodeLine{8827                 \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8828             \}}
\DoxyCodeLine{8829 }
\DoxyCodeLine{8830             \textcolor{comment}{// skip following whitespace}}
\DoxyCodeLine{8831             skip\_whitespace();}
\DoxyCodeLine{8832         \}}
\DoxyCodeLine{8833 }
\DoxyCodeLine{8834         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{8835         \{}
\DoxyCodeLine{8836             \textcolor{comment}{// structural characters}}
\DoxyCodeLine{8837             \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:}
\DoxyCodeLine{8838                 \textcolor{keywordflow}{return} token\_type::begin\_array;}
\DoxyCodeLine{8839             \textcolor{keywordflow}{case} \textcolor{charliteral}{']'}:}
\DoxyCodeLine{8840                 \textcolor{keywordflow}{return} token\_type::end\_array;}
\DoxyCodeLine{8841             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\{'}:}
\DoxyCodeLine{8842                 \textcolor{keywordflow}{return} token\_type::begin\_object;}
\DoxyCodeLine{8843             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\}'}:}
\DoxyCodeLine{8844                 \textcolor{keywordflow}{return} token\_type::end\_object;}
\DoxyCodeLine{8845             \textcolor{keywordflow}{case} \textcolor{charliteral}{':'}:}
\DoxyCodeLine{8846                 \textcolor{keywordflow}{return} token\_type::name\_separator;}
\DoxyCodeLine{8847             \textcolor{keywordflow}{case} \textcolor{charliteral}{','}:}
\DoxyCodeLine{8848                 \textcolor{keywordflow}{return} token\_type::value\_separator;}
\DoxyCodeLine{8849 }
\DoxyCodeLine{8850             \textcolor{comment}{// literals}}
\DoxyCodeLine{8851             \textcolor{keywordflow}{case} \textcolor{charliteral}{'t'}:}
\DoxyCodeLine{8852             \{}
\DoxyCodeLine{8853                 std::array<char\_type, 4> true\_literal = \{\{\textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'t'}), \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'r'}), \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'u'}), \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'e'})\}\};}
\DoxyCodeLine{8854                 \textcolor{keywordflow}{return} scan\_literal(true\_literal.data(), true\_literal.size(), token\_type::literal\_true);}
\DoxyCodeLine{8855             \}}
\DoxyCodeLine{8856             \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'}:}
\DoxyCodeLine{8857             \{}
\DoxyCodeLine{8858                 std::array<char\_type, 5> false\_literal = \{\{\textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'f'}), \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'a'}), \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'l'}), \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'s'}), \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'e'})\}\};}
\DoxyCodeLine{8859                 \textcolor{keywordflow}{return} scan\_literal(false\_literal.data(), false\_literal.size(), token\_type::literal\_false);}
\DoxyCodeLine{8860             \}}
\DoxyCodeLine{8861             \textcolor{keywordflow}{case} \textcolor{charliteral}{'n'}:}
\DoxyCodeLine{8862             \{}
\DoxyCodeLine{8863                 std::array<char\_type, 4> null\_literal = \{\{\textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'n'}), \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'u'}), \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'l'}), \textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(\textcolor{charliteral}{'l'})\}\};}
\DoxyCodeLine{8864                 \textcolor{keywordflow}{return} scan\_literal(null\_literal.data(), null\_literal.size(), token\_type::literal\_null);}
\DoxyCodeLine{8865             \}}
\DoxyCodeLine{8866 }
\DoxyCodeLine{8867             \textcolor{comment}{// string}}
\DoxyCodeLine{8868             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)"{}'}:}
\DoxyCodeLine{8869                 \textcolor{keywordflow}{return} scan\_string();}
\DoxyCodeLine{8870 }
\DoxyCodeLine{8871             \textcolor{comment}{// number}}
\DoxyCodeLine{8872             \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}:}
\DoxyCodeLine{8873             \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{8874             \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:}
\DoxyCodeLine{8875             \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:}
\DoxyCodeLine{8876             \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:}
\DoxyCodeLine{8877             \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:}
\DoxyCodeLine{8878             \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:}
\DoxyCodeLine{8879             \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:}
\DoxyCodeLine{8880             \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:}
\DoxyCodeLine{8881             \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:}
\DoxyCodeLine{8882             \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:}
\DoxyCodeLine{8883                 \textcolor{keywordflow}{return} scan\_number();}
\DoxyCodeLine{8884 }
\DoxyCodeLine{8885             \textcolor{comment}{// end of input (the null byte is needed when parsing from}}
\DoxyCodeLine{8886             \textcolor{comment}{// string literals)}}
\DoxyCodeLine{8887             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)0'}:}
\DoxyCodeLine{8888             \textcolor{keywordflow}{case} std::char\_traits<char\_type>::eof():}
\DoxyCodeLine{8889                 return token\_type::end\_of\_input;}
\DoxyCodeLine{8890 }
\DoxyCodeLine{8891             \textcolor{comment}{// error}}
\DoxyCodeLine{8892             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{8893                 error\_message = \textcolor{stringliteral}{"{}invalid literal"{}};}
\DoxyCodeLine{8894                 \textcolor{keywordflow}{return} token\_type::parse\_error;}
\DoxyCodeLine{8895         \}}
\DoxyCodeLine{8896     \}}
\DoxyCodeLine{8897 }
\DoxyCodeLine{8898   \textcolor{keyword}{private}:}
\DoxyCodeLine{8900     InputAdapterType ia;}
\DoxyCodeLine{8901 }
\DoxyCodeLine{8903     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ignore\_comments = \textcolor{keyword}{false};}
\DoxyCodeLine{8904 }
\DoxyCodeLine{8906     char\_int\_type current = std::char\_traits<char\_type>::eof();}
\DoxyCodeLine{8907 }
\DoxyCodeLine{8909     \textcolor{keywordtype}{bool} next\_unget = \textcolor{keyword}{false};}
\DoxyCodeLine{8910 }
\DoxyCodeLine{8912     position\_t position \{\};}
\DoxyCodeLine{8913 }
\DoxyCodeLine{8915     std::vector<char\_type> token\_string \{\};}
\DoxyCodeLine{8916 }
\DoxyCodeLine{8918     string\_t token\_buffer \{\};}
\DoxyCodeLine{8919 }
\DoxyCodeLine{8921     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* error\_message = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{8922 }
\DoxyCodeLine{8923     \textcolor{comment}{// number values}}
\DoxyCodeLine{8924     number\_integer\_t value\_integer = 0;}
\DoxyCodeLine{8925     number\_unsigned\_t value\_unsigned = 0;}
\DoxyCodeLine{8926     number\_float\_t value\_float = 0;}
\DoxyCodeLine{8927 }
\DoxyCodeLine{8929     \textcolor{keyword}{const} char\_int\_type decimal\_point\_char = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{8930 \};}
\DoxyCodeLine{8931 }
\DoxyCodeLine{8932 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{8933 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{8934 }
\DoxyCodeLine{8935 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{8936 }
\DoxyCodeLine{8937 \textcolor{comment}{// \#include <nlohmann/detail/meta/is\_sax.hpp>}}
\DoxyCodeLine{8938 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{8939 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{8940 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{8941 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{8942 \textcolor{comment}{//}}
\DoxyCodeLine{8943 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{8944 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{8945 }
\DoxyCodeLine{8946 }
\DoxyCodeLine{8947 }
\DoxyCodeLine{8948 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{8949 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// declval}}
\DoxyCodeLine{8950 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{8951 }
\DoxyCodeLine{8952 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{8953 }
\DoxyCodeLine{8954 \textcolor{comment}{// \#include <nlohmann/detail/meta/detected.hpp>}}
\DoxyCodeLine{8955 }
\DoxyCodeLine{8956 \textcolor{comment}{// \#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{8957 }
\DoxyCodeLine{8958 }
\DoxyCodeLine{8959 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{8960 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{8961 \{}
\DoxyCodeLine{8962 }
\DoxyCodeLine{8963 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{8964 \textcolor{keyword}{using }null\_function\_t = \textcolor{keyword}{decltype}(std::declval<T\&>().null());}
\DoxyCodeLine{8965 }
\DoxyCodeLine{8966 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{8967 \textcolor{keyword}{using }boolean\_function\_t =}
\DoxyCodeLine{8968     \textcolor{keyword}{decltype}(std::declval<T\&>().boolean(std::declval<bool>()));}
\DoxyCodeLine{8969 }
\DoxyCodeLine{8970 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Integer>}
\DoxyCodeLine{8971 \textcolor{keyword}{using }number\_integer\_function\_t =}
\DoxyCodeLine{8972     \textcolor{keyword}{decltype}(std::declval<T\&>().number\_integer(std::declval<Integer>()));}
\DoxyCodeLine{8973 }
\DoxyCodeLine{8974 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Un\textcolor{keywordtype}{signed}>}
\DoxyCodeLine{8975 \textcolor{keyword}{using }number\_unsigned\_function\_t =}
\DoxyCodeLine{8976     \textcolor{keyword}{decltype}(std::declval<T\&>().number\_unsigned(std::declval<Unsigned>()));}
\DoxyCodeLine{8977 }
\DoxyCodeLine{8978 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Float, \textcolor{keyword}{typename} String>}
\DoxyCodeLine{8979 \textcolor{keyword}{using }number\_float\_function\_t = \textcolor{keyword}{decltype}(std::declval<T\&>().number\_float(}
\DoxyCodeLine{8980                                     std::declval<Float>(), std::declval<const String\&>()));}
\DoxyCodeLine{8981 }
\DoxyCodeLine{8982 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} String>}
\DoxyCodeLine{8983 \textcolor{keyword}{using }string\_function\_t =}
\DoxyCodeLine{8984     \textcolor{keyword}{decltype}(std::declval<T\&>().string(std::declval<String\&>()));}
\DoxyCodeLine{8985 }
\DoxyCodeLine{8986 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Binary>}
\DoxyCodeLine{8987 \textcolor{keyword}{using }binary\_function\_t =}
\DoxyCodeLine{8988     \textcolor{keyword}{decltype}(std::declval<T\&>().binary(std::declval<Binary\&>()));}
\DoxyCodeLine{8989 }
\DoxyCodeLine{8990 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{8991 \textcolor{keyword}{using }start\_object\_function\_t =}
\DoxyCodeLine{8992     \textcolor{keyword}{decltype}(std::declval<T\&>().start\_object(std::declval<std::size\_t>()));}
\DoxyCodeLine{8993 }
\DoxyCodeLine{8994 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} String>}
\DoxyCodeLine{8995 \textcolor{keyword}{using }key\_function\_t =}
\DoxyCodeLine{8996     \textcolor{keyword}{decltype}(std::declval<T\&>().key(std::declval<String\&>()));}
\DoxyCodeLine{8997 }
\DoxyCodeLine{8998 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{8999 \textcolor{keyword}{using }end\_object\_function\_t = \textcolor{keyword}{decltype}(std::declval<T\&>().end\_object());}
\DoxyCodeLine{9000 }
\DoxyCodeLine{9001 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9002 \textcolor{keyword}{using }start\_array\_function\_t =}
\DoxyCodeLine{9003     \textcolor{keyword}{decltype}(std::declval<T\&>().start\_array(std::declval<std::size\_t>()));}
\DoxyCodeLine{9004 }
\DoxyCodeLine{9005 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9006 \textcolor{keyword}{using }end\_array\_function\_t = \textcolor{keyword}{decltype}(std::declval<T\&>().end\_array());}
\DoxyCodeLine{9007 }
\DoxyCodeLine{9008 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Exception>}
\DoxyCodeLine{9009 \textcolor{keyword}{using }parse\_error\_function\_t = \textcolor{keyword}{decltype}(std::declval<T\&>().parse\_error(}
\DoxyCodeLine{9010         std::declval<std::size\_t>(), std::declval<const std::string\&>(),}
\DoxyCodeLine{9011         std::declval<const Exception\&>()));}
\DoxyCodeLine{9012 }
\DoxyCodeLine{9013 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SAX, \textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{9014 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__sax}{is\_sax}}}
\DoxyCodeLine{9015 \{}
\DoxyCodeLine{9016   \textcolor{keyword}{private}:}
\DoxyCodeLine{9017     \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structdetail_1_1is__basic__json}{is\_basic\_json<BasicJsonType>::value}},}
\DoxyCodeLine{9018                   \textcolor{stringliteral}{"{}BasicJsonType must be of type basic\_json<...>"{}});}
\DoxyCodeLine{9019 }
\DoxyCodeLine{9020     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{9021     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{9022     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{9023     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{9024     \textcolor{keyword}{using }binary\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t;}
\DoxyCodeLine{9025     \textcolor{keyword}{using }exception\_t = \textcolor{keyword}{typename} BasicJsonType::exception;}
\DoxyCodeLine{9026 }
\DoxyCodeLine{9027   \textcolor{keyword}{public}:}
\DoxyCodeLine{9028     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} =}
\DoxyCodeLine{9029         is\_detected\_exact<bool, null\_function\_t, SAX>::value \&\&}
\DoxyCodeLine{9030         is\_detected\_exact<bool, boolean\_function\_t, SAX>::value \&\&}
\DoxyCodeLine{9031         is\_detected\_exact<bool, number\_integer\_function\_t, SAX, number\_integer\_t>::value \&\&}
\DoxyCodeLine{9032         is\_detected\_exact<bool, number\_unsigned\_function\_t, SAX, number\_unsigned\_t>::value \&\&}
\DoxyCodeLine{9033         is\_detected\_exact<bool, number\_float\_function\_t, SAX, number\_float\_t, string\_t>::value \&\&}
\DoxyCodeLine{9034         is\_detected\_exact<bool, string\_function\_t, SAX, string\_t>::value \&\&}
\DoxyCodeLine{9035         is\_detected\_exact<bool, binary\_function\_t, SAX, binary\_t>::value \&\&}
\DoxyCodeLine{9036         is\_detected\_exact<bool, start\_object\_function\_t, SAX>::value \&\&}
\DoxyCodeLine{9037         is\_detected\_exact<bool, key\_function\_t, SAX, string\_t>::value \&\&}
\DoxyCodeLine{9038         is\_detected\_exact<bool, end\_object\_function\_t, SAX>::value \&\&}
\DoxyCodeLine{9039         is\_detected\_exact<bool, start\_array\_function\_t, SAX>::value \&\&}
\DoxyCodeLine{9040         is\_detected\_exact<bool, end\_array\_function\_t, SAX>::value \&\&}
\DoxyCodeLine{9041         is\_detected\_exact<bool, parse\_error\_function\_t, SAX, exception\_t>::value;}
\DoxyCodeLine{9042 \};}
\DoxyCodeLine{9043 }
\DoxyCodeLine{9044 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SAX, \textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{9045 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__sax__static__asserts}{is\_sax\_static\_asserts}}}
\DoxyCodeLine{9046 \{}
\DoxyCodeLine{9047   \textcolor{keyword}{private}:}
\DoxyCodeLine{9048     \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structdetail_1_1is__basic__json}{is\_basic\_json<BasicJsonType>::value}},}
\DoxyCodeLine{9049                   \textcolor{stringliteral}{"{}BasicJsonType must be of type basic\_json<...>"{}});}
\DoxyCodeLine{9050 }
\DoxyCodeLine{9051     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{9052     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{9053     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{9054     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{9055     \textcolor{keyword}{using }binary\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t;}
\DoxyCodeLine{9056     \textcolor{keyword}{using }exception\_t = \textcolor{keyword}{typename} BasicJsonType::exception;}
\DoxyCodeLine{9057 }
\DoxyCodeLine{9058   \textcolor{keyword}{public}:}
\DoxyCodeLine{9059     \textcolor{keyword}{static\_assert}(is\_detected\_exact<bool, null\_function\_t, SAX>::value,}
\DoxyCodeLine{9060                   \textcolor{stringliteral}{"{}Missing/invalid function: bool null()"{}});}
\DoxyCodeLine{9061     \textcolor{keyword}{static\_assert}(is\_detected\_exact<bool, boolean\_function\_t, SAX>::value,}
\DoxyCodeLine{9062                   \textcolor{stringliteral}{"{}Missing/invalid function: bool boolean(bool)"{}});}
\DoxyCodeLine{9063     \textcolor{keyword}{static\_assert}(is\_detected\_exact<bool, boolean\_function\_t, SAX>::value,}
\DoxyCodeLine{9064                   \textcolor{stringliteral}{"{}Missing/invalid function: bool boolean(bool)"{}});}
\DoxyCodeLine{9065     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{9066         is\_detected\_exact<bool, number\_integer\_function\_t, SAX,}
\DoxyCodeLine{9067         number\_integer\_t>::value,}
\DoxyCodeLine{9068         \textcolor{stringliteral}{"{}Missing/invalid function: bool number\_integer(number\_integer\_t)"{}});}
\DoxyCodeLine{9069     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{9070         is\_detected\_exact<bool, number\_unsigned\_function\_t, SAX,}
\DoxyCodeLine{9071         number\_unsigned\_t>::value,}
\DoxyCodeLine{9072         \textcolor{stringliteral}{"{}Missing/invalid function: bool number\_unsigned(number\_unsigned\_t)"{}});}
\DoxyCodeLine{9073     \textcolor{keyword}{static\_assert}(is\_detected\_exact<bool, number\_float\_function\_t, SAX,}
\DoxyCodeLine{9074                   number\_float\_t, string\_t>::value,}
\DoxyCodeLine{9075                   \textcolor{stringliteral}{"{}Missing/invalid function: bool number\_float(number\_float\_t, const string\_t\&)"{}});}
\DoxyCodeLine{9076     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{9077         is\_detected\_exact<bool, string\_function\_t, SAX, string\_t>::value,}
\DoxyCodeLine{9078         \textcolor{stringliteral}{"{}Missing/invalid function: bool string(string\_t\&)"{}});}
\DoxyCodeLine{9079     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{9080         is\_detected\_exact<bool, binary\_function\_t, SAX, binary\_t>::value,}
\DoxyCodeLine{9081         \textcolor{stringliteral}{"{}Missing/invalid function: bool binary(binary\_t\&)"{}});}
\DoxyCodeLine{9082     \textcolor{keyword}{static\_assert}(is\_detected\_exact<bool, start\_object\_function\_t, SAX>::value,}
\DoxyCodeLine{9083                   \textcolor{stringliteral}{"{}Missing/invalid function: bool start\_object(std::size\_t)"{}});}
\DoxyCodeLine{9084     \textcolor{keyword}{static\_assert}(is\_detected\_exact<bool, key\_function\_t, SAX, string\_t>::value,}
\DoxyCodeLine{9085                   \textcolor{stringliteral}{"{}Missing/invalid function: bool key(string\_t\&)"{}});}
\DoxyCodeLine{9086     \textcolor{keyword}{static\_assert}(is\_detected\_exact<bool, end\_object\_function\_t, SAX>::value,}
\DoxyCodeLine{9087                   \textcolor{stringliteral}{"{}Missing/invalid function: bool end\_object()"{}});}
\DoxyCodeLine{9088     \textcolor{keyword}{static\_assert}(is\_detected\_exact<bool, start\_array\_function\_t, SAX>::value,}
\DoxyCodeLine{9089                   \textcolor{stringliteral}{"{}Missing/invalid function: bool start\_array(std::size\_t)"{}});}
\DoxyCodeLine{9090     \textcolor{keyword}{static\_assert}(is\_detected\_exact<bool, end\_array\_function\_t, SAX>::value,}
\DoxyCodeLine{9091                   \textcolor{stringliteral}{"{}Missing/invalid function: bool end\_array()"{}});}
\DoxyCodeLine{9092     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{9093         is\_detected\_exact<bool, parse\_error\_function\_t, SAX, exception\_t>::value,}
\DoxyCodeLine{9094         \textcolor{stringliteral}{"{}Missing/invalid function: bool parse\_error(std::size\_t, const "{}}}
\DoxyCodeLine{9095         \textcolor{stringliteral}{"{}std::string\&, const exception\&)"{}});}
\DoxyCodeLine{9096 \};}
\DoxyCodeLine{9097 }
\DoxyCodeLine{9098 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{9099 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{9100 }
\DoxyCodeLine{9101 \textcolor{comment}{// \#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{9102 }
\DoxyCodeLine{9103 \textcolor{comment}{// \#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{9104 }
\DoxyCodeLine{9105 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{9106 }
\DoxyCodeLine{9107 }
\DoxyCodeLine{9108 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{9109 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{9110 \{}
\DoxyCodeLine{9111 }
\DoxyCodeLine{9113 \textcolor{keyword}{enum class} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}}}
\DoxyCodeLine{9114 \{}
\DoxyCodeLine{9115     \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282}{error}},   }
\DoxyCodeLine{9116     \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592a567bc1d268f135496de3d5b946b691f3}{ignore}},  }
\DoxyCodeLine{9117     \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592a8cd892b7b97ef9489ae4479d3f4ef0fc}{store}}    }
\DoxyCodeLine{9118 \};}
\DoxyCodeLine{9119 }
\DoxyCodeLine{9127 \textcolor{keyword}{static} \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} little\_endianness(\textcolor{keywordtype}{int} num = 1) noexcept}
\DoxyCodeLine{9128 \{}
\DoxyCodeLine{9129     \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&num) == 1;}
\DoxyCodeLine{9130 \}}
\DoxyCodeLine{9131 }
\DoxyCodeLine{9132 }
\DoxyCodeLine{9134 \textcolor{comment}{// binary reader //}}
\DoxyCodeLine{9136 \textcolor{comment}{}}
\DoxyCodeLine{9140 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} InputAdapterType, \textcolor{keyword}{typename} SAX = json\_sax\_dom\_parser<BasicJsonType>>}
\DoxyCodeLine{9141 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}}
\DoxyCodeLine{9142 \{}
\DoxyCodeLine{9143     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{9144     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{9145     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{9146     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{9147     \textcolor{keyword}{using }binary\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t;}
\DoxyCodeLine{9148     \textcolor{keyword}{using }json\_sax\_t = SAX;}
\DoxyCodeLine{9149     \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} InputAdapterType::char\_type;}
\DoxyCodeLine{9150     \textcolor{keyword}{using }char\_int\_type = \textcolor{keyword}{typename} std::char\_traits<char\_type>::int\_type;}
\DoxyCodeLine{9151 }
\DoxyCodeLine{9152   \textcolor{keyword}{public}:}
\DoxyCodeLine{9158     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1binary__reader_a5dc3e9216177efe30686876d3faccf52}{binary\_reader}}(InputAdapterType\&\& adapter, \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format = input\_format\_t::json) noexcept : ia(std::move(adapter)), input\_format(format)}
\DoxyCodeLine{9159     \{}
\DoxyCodeLine{9160         (void)\mbox{\hyperlink{structdetail_1_1is__sax__static__asserts}{detail::is\_sax\_static\_asserts<SAX, BasicJsonType>}} \{\};}
\DoxyCodeLine{9161     \}}
\DoxyCodeLine{9162 }
\DoxyCodeLine{9163     \textcolor{comment}{// make class move-\/only}}
\DoxyCodeLine{9164     \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9165     \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}(\mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\&\&) = \textcolor{keywordflow}{default}; \textcolor{comment}{// NOLINT(hicpp-\/noexcept-\/move,performance-\/noexcept-\/move-\/constructor)}}
\DoxyCodeLine{9166     \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9167     \mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\& operator=(\mbox{\hyperlink{classdetail_1_1binary__reader}{binary\_reader}}\&\&) = \textcolor{keywordflow}{default}; \textcolor{comment}{// NOLINT(hicpp-\/noexcept-\/move,performance-\/noexcept-\/move-\/constructor)}}
\DoxyCodeLine{9168     \mbox{\hyperlink{classdetail_1_1binary__reader}{\string~binary\_reader}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9169 }
\DoxyCodeLine{9178     JSON\_HEDLEY\_NON\_NULL(3)}
\DoxyCodeLine{9179     bool sax\_parse(const \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format,}
\DoxyCodeLine{9180                    json\_sax\_t* sax\_,}
\DoxyCodeLine{9181                    const \textcolor{keywordtype}{bool} strict = true,}
\DoxyCodeLine{9182                    const \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}} tag\_handler = \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}}::error)}
\DoxyCodeLine{9183     \{}
\DoxyCodeLine{9184         sax = sax\_;}
\DoxyCodeLine{9185         \textcolor{keywordtype}{bool} result = \textcolor{keyword}{false};}
\DoxyCodeLine{9186 }
\DoxyCodeLine{9187         \textcolor{keywordflow}{switch} (format)}
\DoxyCodeLine{9188         \{}
\DoxyCodeLine{9189             \textcolor{keywordflow}{case} input\_format\_t::bson:}
\DoxyCodeLine{9190                 result = parse\_bson\_internal();}
\DoxyCodeLine{9191                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9192 }
\DoxyCodeLine{9193             \textcolor{keywordflow}{case} input\_format\_t::cbor:}
\DoxyCodeLine{9194                 result = parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler);}
\DoxyCodeLine{9195                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9196 }
\DoxyCodeLine{9197             \textcolor{keywordflow}{case} input\_format\_t::msgpack:}
\DoxyCodeLine{9198                 result = parse\_msgpack\_internal();}
\DoxyCodeLine{9199                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9200 }
\DoxyCodeLine{9201             \textcolor{keywordflow}{case} input\_format\_t::ubjson:}
\DoxyCodeLine{9202             \textcolor{keywordflow}{case} input\_format\_t::bjdata:}
\DoxyCodeLine{9203                 result = parse\_ubjson\_internal();}
\DoxyCodeLine{9204                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9205 }
\DoxyCodeLine{9206             \textcolor{keywordflow}{case} input\_format\_t::json: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{9207             \textcolor{keywordflow}{default}:            \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{9208                 JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{9209         \}}
\DoxyCodeLine{9210 }
\DoxyCodeLine{9211         \textcolor{comment}{// strict mode: next byte must be EOF}}
\DoxyCodeLine{9212         \textcolor{keywordflow}{if} (result \&\& \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298a2133fd717402a7966ee88d06f9e0b792}{strict}})}
\DoxyCodeLine{9213         \{}
\DoxyCodeLine{9214             \textcolor{keywordflow}{if} (input\_format == input\_format\_t::ubjson || input\_format == input\_format\_t::bjdata)}
\DoxyCodeLine{9215             \{}
\DoxyCodeLine{9216                 get\_ignore\_noop();}
\DoxyCodeLine{9217             \}}
\DoxyCodeLine{9218             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9219             \{}
\DoxyCodeLine{9220                 get();}
\DoxyCodeLine{9221             \}}
\DoxyCodeLine{9222 }
\DoxyCodeLine{9223             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(current != std::char\_traits<char\_type>::eof()))}
\DoxyCodeLine{9224             \{}
\DoxyCodeLine{9225                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), parse\_error::create(110, chars\_read,}
\DoxyCodeLine{9226                                         exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}expected end of input; last byte: 0x"{}}, get\_token\_string()), \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{9227             \}}
\DoxyCodeLine{9228         \}}
\DoxyCodeLine{9229 }
\DoxyCodeLine{9230         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9231     \}}
\DoxyCodeLine{9232 }
\DoxyCodeLine{9233   \textcolor{keyword}{private}:}
\DoxyCodeLine{9235     \textcolor{comment}{// BSON //}}
\DoxyCodeLine{9237 \textcolor{comment}{}}
\DoxyCodeLine{9242     \textcolor{keywordtype}{bool} parse\_bson\_internal()}
\DoxyCodeLine{9243     \{}
\DoxyCodeLine{9244         std::int32\_t document\_size\{\};}
\DoxyCodeLine{9245         get\_number<std::int32\_t, true>(input\_format\_t::bson, document\_size);}
\DoxyCodeLine{9246 }
\DoxyCodeLine{9247         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))))}
\DoxyCodeLine{9248         \{}
\DoxyCodeLine{9249             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9250         \}}
\DoxyCodeLine{9251 }
\DoxyCodeLine{9252         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_bson\_element\_list(\textcolor{comment}{/*is\_array*/}\textcolor{keyword}{false})))}
\DoxyCodeLine{9253         \{}
\DoxyCodeLine{9254             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9255         \}}
\DoxyCodeLine{9256 }
\DoxyCodeLine{9257         \textcolor{keywordflow}{return} sax-\/>end\_object();}
\DoxyCodeLine{9258     \}}
\DoxyCodeLine{9259 }
\DoxyCodeLine{9267     \textcolor{keywordtype}{bool} get\_bson\_cstr(string\_t\& result)}
\DoxyCodeLine{9268     \{}
\DoxyCodeLine{9269         \textcolor{keyword}{auto} out = std::back\_inserter(result);}
\DoxyCodeLine{9270         \textcolor{keywordflow}{while} (\textcolor{keyword}{true})}
\DoxyCodeLine{9271         \{}
\DoxyCodeLine{9272             get();}
\DoxyCodeLine{9273             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::bson, \textcolor{stringliteral}{"{}cstring"{}})))}
\DoxyCodeLine{9274             \{}
\DoxyCodeLine{9275                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9276             \}}
\DoxyCodeLine{9277             \textcolor{keywordflow}{if} (current == 0x00)}
\DoxyCodeLine{9278             \{}
\DoxyCodeLine{9279                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{9280             \}}
\DoxyCodeLine{9281             *out++ = \textcolor{keyword}{static\_cast<}typename string\_t::value\_type\textcolor{keyword}{>}(current);}
\DoxyCodeLine{9282         \}}
\DoxyCodeLine{9283     \}}
\DoxyCodeLine{9284 }
\DoxyCodeLine{9296     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType>}
\DoxyCodeLine{9297     \textcolor{keywordtype}{bool} get\_bson\_string(\textcolor{keyword}{const} NumberType len, string\_t\& result)}
\DoxyCodeLine{9298     \{}
\DoxyCodeLine{9299         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(len < 1))}
\DoxyCodeLine{9300         \{}
\DoxyCodeLine{9301             \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{9302             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(112, chars\_read,}
\DoxyCodeLine{9303                                     exception\_message(input\_format\_t::bson, concat(\textcolor{stringliteral}{"{}string length must be at least 1, is "{}}, std::to\_string(len)), \textcolor{stringliteral}{"{}string"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{9304         \}}
\DoxyCodeLine{9305 }
\DoxyCodeLine{9306         \textcolor{keywordflow}{return} get\_string(input\_format\_t::bson, len -\/ \textcolor{keyword}{static\_cast<}NumberType\textcolor{keyword}{>}(1), result) \&\& get() != std::char\_traits<char\_type>::eof();}
\DoxyCodeLine{9307     \}}
\DoxyCodeLine{9308 }
\DoxyCodeLine{9318     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType>}
\DoxyCodeLine{9319     \textcolor{keywordtype}{bool} get\_bson\_binary(\textcolor{keyword}{const} NumberType len, binary\_t\& result)}
\DoxyCodeLine{9320     \{}
\DoxyCodeLine{9321         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(len < 0))}
\DoxyCodeLine{9322         \{}
\DoxyCodeLine{9323             \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{9324             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(112, chars\_read,}
\DoxyCodeLine{9325                                     exception\_message(input\_format\_t::bson, concat(\textcolor{stringliteral}{"{}byte array length cannot be negative, is "{}}, std::to\_string(len)), \textcolor{stringliteral}{"{}binary"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{9326         \}}
\DoxyCodeLine{9327 }
\DoxyCodeLine{9328         \textcolor{comment}{// All BSON binary values have a subtype}}
\DoxyCodeLine{9329         std::uint8\_t subtype\{\};}
\DoxyCodeLine{9330         get\_number<std::uint8\_t>(input\_format\_t::bson, subtype);}
\DoxyCodeLine{9331         result.set\_subtype(subtype);}
\DoxyCodeLine{9332 }
\DoxyCodeLine{9333         \textcolor{keywordflow}{return} get\_binary(input\_format\_t::bson, len, result);}
\DoxyCodeLine{9334     \}}
\DoxyCodeLine{9335 }
\DoxyCodeLine{9346     \textcolor{keywordtype}{bool} parse\_bson\_element\_internal(\textcolor{keyword}{const} char\_int\_type element\_type,}
\DoxyCodeLine{9347                                      \textcolor{keyword}{const} std::size\_t element\_type\_parse\_position)}
\DoxyCodeLine{9348     \{}
\DoxyCodeLine{9349         \textcolor{keywordflow}{switch} (element\_type)}
\DoxyCodeLine{9350         \{}
\DoxyCodeLine{9351             \textcolor{keywordflow}{case} 0x01: \textcolor{comment}{// double}}
\DoxyCodeLine{9352             \{}
\DoxyCodeLine{9353                 \textcolor{keywordtype}{double} number\{\};}
\DoxyCodeLine{9354                 \textcolor{keywordflow}{return} get\_number<double, true>(input\_format\_t::bson, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{9355             \}}
\DoxyCodeLine{9356 }
\DoxyCodeLine{9357             \textcolor{keywordflow}{case} 0x02: \textcolor{comment}{// string}}
\DoxyCodeLine{9358             \{}
\DoxyCodeLine{9359                 std::int32\_t len\{\};}
\DoxyCodeLine{9360                 string\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}};}
\DoxyCodeLine{9361                 \textcolor{keywordflow}{return} get\_number<std::int32\_t, true>(input\_format\_t::bson, len) \&\& get\_bson\_string(len, value) \&\& sax-\/>string(value);}
\DoxyCodeLine{9362             \}}
\DoxyCodeLine{9363 }
\DoxyCodeLine{9364             \textcolor{keywordflow}{case} 0x03: \textcolor{comment}{// object}}
\DoxyCodeLine{9365             \{}
\DoxyCodeLine{9366                 \textcolor{keywordflow}{return} parse\_bson\_internal();}
\DoxyCodeLine{9367             \}}
\DoxyCodeLine{9368 }
\DoxyCodeLine{9369             \textcolor{keywordflow}{case} 0x04: \textcolor{comment}{// array}}
\DoxyCodeLine{9370             \{}
\DoxyCodeLine{9371                 \textcolor{keywordflow}{return} parse\_bson\_array();}
\DoxyCodeLine{9372             \}}
\DoxyCodeLine{9373 }
\DoxyCodeLine{9374             \textcolor{keywordflow}{case} 0x05: \textcolor{comment}{// binary}}
\DoxyCodeLine{9375             \{}
\DoxyCodeLine{9376                 std::int32\_t len\{\};}
\DoxyCodeLine{9377                 binary\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}};}
\DoxyCodeLine{9378                 \textcolor{keywordflow}{return} get\_number<std::int32\_t, true>(input\_format\_t::bson, len) \&\& get\_bson\_binary(len, value) \&\& sax-\/>binary(value);}
\DoxyCodeLine{9379             \}}
\DoxyCodeLine{9380 }
\DoxyCodeLine{9381             \textcolor{keywordflow}{case} 0x08: \textcolor{comment}{// boolean}}
\DoxyCodeLine{9382             \{}
\DoxyCodeLine{9383                 \textcolor{keywordflow}{return} sax-\/>boolean(get() != 0);}
\DoxyCodeLine{9384             \}}
\DoxyCodeLine{9385 }
\DoxyCodeLine{9386             \textcolor{keywordflow}{case} 0x0A: \textcolor{comment}{// null}}
\DoxyCodeLine{9387             \{}
\DoxyCodeLine{9388                 \textcolor{keywordflow}{return} sax-\/>null();}
\DoxyCodeLine{9389             \}}
\DoxyCodeLine{9390 }
\DoxyCodeLine{9391             \textcolor{keywordflow}{case} 0x10: \textcolor{comment}{// int32}}
\DoxyCodeLine{9392             \{}
\DoxyCodeLine{9393                 std::int32\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}\{\};}
\DoxyCodeLine{9394                 \textcolor{keywordflow}{return} get\_number<std::int32\_t, true>(input\_format\_t::bson, value) \&\& sax-\/>number\_integer(value);}
\DoxyCodeLine{9395             \}}
\DoxyCodeLine{9396 }
\DoxyCodeLine{9397             \textcolor{keywordflow}{case} 0x12: \textcolor{comment}{// int64}}
\DoxyCodeLine{9398             \{}
\DoxyCodeLine{9399                 std::int64\_t \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}\{\};}
\DoxyCodeLine{9400                 \textcolor{keywordflow}{return} get\_number<std::int64\_t, true>(input\_format\_t::bson, value) \&\& sax-\/>number\_integer(value);}
\DoxyCodeLine{9401             \}}
\DoxyCodeLine{9402 }
\DoxyCodeLine{9403             \textcolor{keywordflow}{default}: \textcolor{comment}{// anything else not supported (yet)}}
\DoxyCodeLine{9404             \{}
\DoxyCodeLine{9405                 std::array<char, 3> cr\{\{\}\};}
\DoxyCodeLine{9406                 \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}((std::snprintf)(cr.data(), cr.size(), \textcolor{stringliteral}{"{}\%.2hhX"{}}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(element\_type))); \textcolor{comment}{// NOLINT(cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{9407                 std::string cr\_str\{cr.data()\};}
\DoxyCodeLine{9408                 \textcolor{keywordflow}{return} sax-\/>parse\_error(element\_type\_parse\_position, cr\_str,}
\DoxyCodeLine{9409                                         parse\_error::create(114, element\_type\_parse\_position, concat(\textcolor{stringliteral}{"{}Unsupported BSON record type 0x"{}}, cr\_str), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{9410             \}}
\DoxyCodeLine{9411         \}}
\DoxyCodeLine{9412     \}}
\DoxyCodeLine{9413 }
\DoxyCodeLine{9426     \textcolor{keywordtype}{bool} parse\_bson\_element\_list(\textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_array)}
\DoxyCodeLine{9427     \{}
\DoxyCodeLine{9428         string\_t \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}};}
\DoxyCodeLine{9429 }
\DoxyCodeLine{9430         \textcolor{keywordflow}{while} (\textcolor{keyword}{auto} element\_type = get())}
\DoxyCodeLine{9431         \{}
\DoxyCodeLine{9432             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::bson, \textcolor{stringliteral}{"{}element list"{}})))}
\DoxyCodeLine{9433             \{}
\DoxyCodeLine{9434                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9435             \}}
\DoxyCodeLine{9436 }
\DoxyCodeLine{9437             \textcolor{keyword}{const} std::size\_t element\_type\_parse\_position = chars\_read;}
\DoxyCodeLine{9438             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_bson\_cstr(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})))}
\DoxyCodeLine{9439             \{}
\DoxyCodeLine{9440                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9441             \}}
\DoxyCodeLine{9442 }
\DoxyCodeLine{9443             \textcolor{keywordflow}{if} (!is\_array \&\& !sax-\/>key(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{9444             \{}
\DoxyCodeLine{9445                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9446             \}}
\DoxyCodeLine{9447 }
\DoxyCodeLine{9448             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_bson\_element\_internal(element\_type, element\_type\_parse\_position)))}
\DoxyCodeLine{9449             \{}
\DoxyCodeLine{9450                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9451             \}}
\DoxyCodeLine{9452 }
\DoxyCodeLine{9453             \textcolor{comment}{// get\_bson\_cstr only appends}}
\DoxyCodeLine{9454             \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}.clear();}
\DoxyCodeLine{9455         \}}
\DoxyCodeLine{9456 }
\DoxyCodeLine{9457         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{9458     \}}
\DoxyCodeLine{9459 }
\DoxyCodeLine{9464     \textcolor{keywordtype}{bool} parse\_bson\_array()}
\DoxyCodeLine{9465     \{}
\DoxyCodeLine{9466         std::int32\_t document\_size\{\};}
\DoxyCodeLine{9467         get\_number<std::int32\_t, true>(input\_format\_t::bson, document\_size);}
\DoxyCodeLine{9468 }
\DoxyCodeLine{9469         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))))}
\DoxyCodeLine{9470         \{}
\DoxyCodeLine{9471             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9472         \}}
\DoxyCodeLine{9473 }
\DoxyCodeLine{9474         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_bson\_element\_list(\textcolor{comment}{/*is\_array*/}\textcolor{keyword}{true})))}
\DoxyCodeLine{9475         \{}
\DoxyCodeLine{9476             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9477         \}}
\DoxyCodeLine{9478 }
\DoxyCodeLine{9479         \textcolor{keywordflow}{return} sax-\/>end\_array();}
\DoxyCodeLine{9480     \}}
\DoxyCodeLine{9481 }
\DoxyCodeLine{9483     \textcolor{comment}{// CBOR //}}
\DoxyCodeLine{9485 \textcolor{comment}{}}
\DoxyCodeLine{9494     \textcolor{keywordtype}{bool} parse\_cbor\_internal(\textcolor{keyword}{const} \textcolor{keywordtype}{bool} get\_char,}
\DoxyCodeLine{9495                              \textcolor{keyword}{const} cbor\_tag\_handler\_t tag\_handler)}
\DoxyCodeLine{9496     \{}
\DoxyCodeLine{9497         \textcolor{keywordflow}{switch} (get\_char ? get() : current)}
\DoxyCodeLine{9498         \{}
\DoxyCodeLine{9499             \textcolor{comment}{// EOF}}
\DoxyCodeLine{9500             \textcolor{keywordflow}{case} std::char\_traits<char\_type>::eof():}
\DoxyCodeLine{9501                 return unexpect\_eof(\mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}}::cbor, \textcolor{stringliteral}{"{}value"{}});}
\DoxyCodeLine{9502 }
\DoxyCodeLine{9503             \textcolor{comment}{// Integer 0x00..0x17 (0..23)}}
\DoxyCodeLine{9504             \textcolor{keywordflow}{case} 0x00:}
\DoxyCodeLine{9505             \textcolor{keywordflow}{case} 0x01:}
\DoxyCodeLine{9506             \textcolor{keywordflow}{case} 0x02:}
\DoxyCodeLine{9507             \textcolor{keywordflow}{case} 0x03:}
\DoxyCodeLine{9508             \textcolor{keywordflow}{case} 0x04:}
\DoxyCodeLine{9509             \textcolor{keywordflow}{case} 0x05:}
\DoxyCodeLine{9510             \textcolor{keywordflow}{case} 0x06:}
\DoxyCodeLine{9511             \textcolor{keywordflow}{case} 0x07:}
\DoxyCodeLine{9512             \textcolor{keywordflow}{case} 0x08:}
\DoxyCodeLine{9513             \textcolor{keywordflow}{case} 0x09:}
\DoxyCodeLine{9514             \textcolor{keywordflow}{case} 0x0A:}
\DoxyCodeLine{9515             \textcolor{keywordflow}{case} 0x0B:}
\DoxyCodeLine{9516             \textcolor{keywordflow}{case} 0x0C:}
\DoxyCodeLine{9517             \textcolor{keywordflow}{case} 0x0D:}
\DoxyCodeLine{9518             \textcolor{keywordflow}{case} 0x0E:}
\DoxyCodeLine{9519             \textcolor{keywordflow}{case} 0x0F:}
\DoxyCodeLine{9520             \textcolor{keywordflow}{case} 0x10:}
\DoxyCodeLine{9521             \textcolor{keywordflow}{case} 0x11:}
\DoxyCodeLine{9522             \textcolor{keywordflow}{case} 0x12:}
\DoxyCodeLine{9523             \textcolor{keywordflow}{case} 0x13:}
\DoxyCodeLine{9524             \textcolor{keywordflow}{case} 0x14:}
\DoxyCodeLine{9525             \textcolor{keywordflow}{case} 0x15:}
\DoxyCodeLine{9526             \textcolor{keywordflow}{case} 0x16:}
\DoxyCodeLine{9527             \textcolor{keywordflow}{case} 0x17:}
\DoxyCodeLine{9528                 \textcolor{keywordflow}{return} sax-\/>number\_unsigned(\textcolor{keyword}{static\_cast<}number\_unsigned\_t\textcolor{keyword}{>}(current));}
\DoxyCodeLine{9529 }
\DoxyCodeLine{9530             \textcolor{keywordflow}{case} 0x18: \textcolor{comment}{// Unsigned integer (one-\/byte uint8\_t follows)}}
\DoxyCodeLine{9531             \{}
\DoxyCodeLine{9532                 std::uint8\_t number\{\};}
\DoxyCodeLine{9533                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{9534             \}}
\DoxyCodeLine{9535 }
\DoxyCodeLine{9536             \textcolor{keywordflow}{case} 0x19: \textcolor{comment}{// Unsigned integer (two-\/byte uint16\_t follows)}}
\DoxyCodeLine{9537             \{}
\DoxyCodeLine{9538                 std::uint16\_t number\{\};}
\DoxyCodeLine{9539                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{9540             \}}
\DoxyCodeLine{9541 }
\DoxyCodeLine{9542             \textcolor{keywordflow}{case} 0x1A: \textcolor{comment}{// Unsigned integer (four-\/byte uint32\_t follows)}}
\DoxyCodeLine{9543             \{}
\DoxyCodeLine{9544                 std::uint32\_t number\{\};}
\DoxyCodeLine{9545                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{9546             \}}
\DoxyCodeLine{9547 }
\DoxyCodeLine{9548             \textcolor{keywordflow}{case} 0x1B: \textcolor{comment}{// Unsigned integer (eight-\/byte uint64\_t follows)}}
\DoxyCodeLine{9549             \{}
\DoxyCodeLine{9550                 std::uint64\_t number\{\};}
\DoxyCodeLine{9551                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{9552             \}}
\DoxyCodeLine{9553 }
\DoxyCodeLine{9554             \textcolor{comment}{// Negative integer -\/1-\/0x00..-\/1-\/0x17 (-\/1..-\/24)}}
\DoxyCodeLine{9555             \textcolor{keywordflow}{case} 0x20:}
\DoxyCodeLine{9556             \textcolor{keywordflow}{case} 0x21:}
\DoxyCodeLine{9557             \textcolor{keywordflow}{case} 0x22:}
\DoxyCodeLine{9558             \textcolor{keywordflow}{case} 0x23:}
\DoxyCodeLine{9559             \textcolor{keywordflow}{case} 0x24:}
\DoxyCodeLine{9560             \textcolor{keywordflow}{case} 0x25:}
\DoxyCodeLine{9561             \textcolor{keywordflow}{case} 0x26:}
\DoxyCodeLine{9562             \textcolor{keywordflow}{case} 0x27:}
\DoxyCodeLine{9563             \textcolor{keywordflow}{case} 0x28:}
\DoxyCodeLine{9564             \textcolor{keywordflow}{case} 0x29:}
\DoxyCodeLine{9565             \textcolor{keywordflow}{case} 0x2A:}
\DoxyCodeLine{9566             \textcolor{keywordflow}{case} 0x2B:}
\DoxyCodeLine{9567             \textcolor{keywordflow}{case} 0x2C:}
\DoxyCodeLine{9568             \textcolor{keywordflow}{case} 0x2D:}
\DoxyCodeLine{9569             \textcolor{keywordflow}{case} 0x2E:}
\DoxyCodeLine{9570             \textcolor{keywordflow}{case} 0x2F:}
\DoxyCodeLine{9571             \textcolor{keywordflow}{case} 0x30:}
\DoxyCodeLine{9572             \textcolor{keywordflow}{case} 0x31:}
\DoxyCodeLine{9573             \textcolor{keywordflow}{case} 0x32:}
\DoxyCodeLine{9574             \textcolor{keywordflow}{case} 0x33:}
\DoxyCodeLine{9575             \textcolor{keywordflow}{case} 0x34:}
\DoxyCodeLine{9576             \textcolor{keywordflow}{case} 0x35:}
\DoxyCodeLine{9577             \textcolor{keywordflow}{case} 0x36:}
\DoxyCodeLine{9578             \textcolor{keywordflow}{case} 0x37:}
\DoxyCodeLine{9579                 \textcolor{keywordflow}{return} sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}std::int8\_t\textcolor{keyword}{>}(0x20 -\/ 1 -\/ current));}
\DoxyCodeLine{9580 }
\DoxyCodeLine{9581             \textcolor{keywordflow}{case} 0x38: \textcolor{comment}{// Negative integer (one-\/byte uint8\_t follows)}}
\DoxyCodeLine{9582             \{}
\DoxyCodeLine{9583                 std::uint8\_t number\{\};}
\DoxyCodeLine{9584                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(-\/1) -\/ number);}
\DoxyCodeLine{9585             \}}
\DoxyCodeLine{9586 }
\DoxyCodeLine{9587             \textcolor{keywordflow}{case} 0x39: \textcolor{comment}{// Negative integer -\/1-\/n (two-\/byte uint16\_t follows)}}
\DoxyCodeLine{9588             \{}
\DoxyCodeLine{9589                 std::uint16\_t number\{\};}
\DoxyCodeLine{9590                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(-\/1) -\/ number);}
\DoxyCodeLine{9591             \}}
\DoxyCodeLine{9592 }
\DoxyCodeLine{9593             \textcolor{keywordflow}{case} 0x3A: \textcolor{comment}{// Negative integer -\/1-\/n (four-\/byte uint32\_t follows)}}
\DoxyCodeLine{9594             \{}
\DoxyCodeLine{9595                 std::uint32\_t number\{\};}
\DoxyCodeLine{9596                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(-\/1) -\/ number);}
\DoxyCodeLine{9597             \}}
\DoxyCodeLine{9598 }
\DoxyCodeLine{9599             \textcolor{keywordflow}{case} 0x3B: \textcolor{comment}{// Negative integer -\/1-\/n (eight-\/byte uint64\_t follows)}}
\DoxyCodeLine{9600             \{}
\DoxyCodeLine{9601                 std::uint64\_t number\{\};}
\DoxyCodeLine{9602                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(-\/1)}
\DoxyCodeLine{9603                         -\/ \textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(number));}
\DoxyCodeLine{9604             \}}
\DoxyCodeLine{9605 }
\DoxyCodeLine{9606             \textcolor{comment}{// Binary data (0x00..0x17 bytes follow)}}
\DoxyCodeLine{9607             \textcolor{keywordflow}{case} 0x40:}
\DoxyCodeLine{9608             \textcolor{keywordflow}{case} 0x41:}
\DoxyCodeLine{9609             \textcolor{keywordflow}{case} 0x42:}
\DoxyCodeLine{9610             \textcolor{keywordflow}{case} 0x43:}
\DoxyCodeLine{9611             \textcolor{keywordflow}{case} 0x44:}
\DoxyCodeLine{9612             \textcolor{keywordflow}{case} 0x45:}
\DoxyCodeLine{9613             \textcolor{keywordflow}{case} 0x46:}
\DoxyCodeLine{9614             \textcolor{keywordflow}{case} 0x47:}
\DoxyCodeLine{9615             \textcolor{keywordflow}{case} 0x48:}
\DoxyCodeLine{9616             \textcolor{keywordflow}{case} 0x49:}
\DoxyCodeLine{9617             \textcolor{keywordflow}{case} 0x4A:}
\DoxyCodeLine{9618             \textcolor{keywordflow}{case} 0x4B:}
\DoxyCodeLine{9619             \textcolor{keywordflow}{case} 0x4C:}
\DoxyCodeLine{9620             \textcolor{keywordflow}{case} 0x4D:}
\DoxyCodeLine{9621             \textcolor{keywordflow}{case} 0x4E:}
\DoxyCodeLine{9622             \textcolor{keywordflow}{case} 0x4F:}
\DoxyCodeLine{9623             \textcolor{keywordflow}{case} 0x50:}
\DoxyCodeLine{9624             \textcolor{keywordflow}{case} 0x51:}
\DoxyCodeLine{9625             \textcolor{keywordflow}{case} 0x52:}
\DoxyCodeLine{9626             \textcolor{keywordflow}{case} 0x53:}
\DoxyCodeLine{9627             \textcolor{keywordflow}{case} 0x54:}
\DoxyCodeLine{9628             \textcolor{keywordflow}{case} 0x55:}
\DoxyCodeLine{9629             \textcolor{keywordflow}{case} 0x56:}
\DoxyCodeLine{9630             \textcolor{keywordflow}{case} 0x57:}
\DoxyCodeLine{9631             \textcolor{keywordflow}{case} 0x58: \textcolor{comment}{// Binary data (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{9632             \textcolor{keywordflow}{case} 0x59: \textcolor{comment}{// Binary data (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{9633             \textcolor{keywordflow}{case} 0x5A: \textcolor{comment}{// Binary data (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{9634             \textcolor{keywordflow}{case} 0x5B: \textcolor{comment}{// Binary data (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{9635             \textcolor{keywordflow}{case} 0x5F: \textcolor{comment}{// Binary data (indefinite length)}}
\DoxyCodeLine{9636             \{}
\DoxyCodeLine{9637                 binary\_t b;}
\DoxyCodeLine{9638                 \textcolor{keywordflow}{return} get\_cbor\_binary(b) \&\& sax-\/>binary(b);}
\DoxyCodeLine{9639             \}}
\DoxyCodeLine{9640 }
\DoxyCodeLine{9641             \textcolor{comment}{// UTF-\/8 string (0x00..0x17 bytes follow)}}
\DoxyCodeLine{9642             \textcolor{keywordflow}{case} 0x60:}
\DoxyCodeLine{9643             \textcolor{keywordflow}{case} 0x61:}
\DoxyCodeLine{9644             \textcolor{keywordflow}{case} 0x62:}
\DoxyCodeLine{9645             \textcolor{keywordflow}{case} 0x63:}
\DoxyCodeLine{9646             \textcolor{keywordflow}{case} 0x64:}
\DoxyCodeLine{9647             \textcolor{keywordflow}{case} 0x65:}
\DoxyCodeLine{9648             \textcolor{keywordflow}{case} 0x66:}
\DoxyCodeLine{9649             \textcolor{keywordflow}{case} 0x67:}
\DoxyCodeLine{9650             \textcolor{keywordflow}{case} 0x68:}
\DoxyCodeLine{9651             \textcolor{keywordflow}{case} 0x69:}
\DoxyCodeLine{9652             \textcolor{keywordflow}{case} 0x6A:}
\DoxyCodeLine{9653             \textcolor{keywordflow}{case} 0x6B:}
\DoxyCodeLine{9654             \textcolor{keywordflow}{case} 0x6C:}
\DoxyCodeLine{9655             \textcolor{keywordflow}{case} 0x6D:}
\DoxyCodeLine{9656             \textcolor{keywordflow}{case} 0x6E:}
\DoxyCodeLine{9657             \textcolor{keywordflow}{case} 0x6F:}
\DoxyCodeLine{9658             \textcolor{keywordflow}{case} 0x70:}
\DoxyCodeLine{9659             \textcolor{keywordflow}{case} 0x71:}
\DoxyCodeLine{9660             \textcolor{keywordflow}{case} 0x72:}
\DoxyCodeLine{9661             \textcolor{keywordflow}{case} 0x73:}
\DoxyCodeLine{9662             \textcolor{keywordflow}{case} 0x74:}
\DoxyCodeLine{9663             \textcolor{keywordflow}{case} 0x75:}
\DoxyCodeLine{9664             \textcolor{keywordflow}{case} 0x76:}
\DoxyCodeLine{9665             \textcolor{keywordflow}{case} 0x77:}
\DoxyCodeLine{9666             \textcolor{keywordflow}{case} 0x78: \textcolor{comment}{// UTF-\/8 string (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{9667             \textcolor{keywordflow}{case} 0x79: \textcolor{comment}{// UTF-\/8 string (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{9668             \textcolor{keywordflow}{case} 0x7A: \textcolor{comment}{// UTF-\/8 string (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{9669             \textcolor{keywordflow}{case} 0x7B: \textcolor{comment}{// UTF-\/8 string (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{9670             \textcolor{keywordflow}{case} 0x7F: \textcolor{comment}{// UTF-\/8 string (indefinite length)}}
\DoxyCodeLine{9671             \{}
\DoxyCodeLine{9672                 string\_t s;}
\DoxyCodeLine{9673                 \textcolor{keywordflow}{return} get\_cbor\_string(s) \&\& sax-\/>string(s);}
\DoxyCodeLine{9674             \}}
\DoxyCodeLine{9675 }
\DoxyCodeLine{9676             \textcolor{comment}{// array (0x00..0x17 data items follow)}}
\DoxyCodeLine{9677             \textcolor{keywordflow}{case} 0x80:}
\DoxyCodeLine{9678             \textcolor{keywordflow}{case} 0x81:}
\DoxyCodeLine{9679             \textcolor{keywordflow}{case} 0x82:}
\DoxyCodeLine{9680             \textcolor{keywordflow}{case} 0x83:}
\DoxyCodeLine{9681             \textcolor{keywordflow}{case} 0x84:}
\DoxyCodeLine{9682             \textcolor{keywordflow}{case} 0x85:}
\DoxyCodeLine{9683             \textcolor{keywordflow}{case} 0x86:}
\DoxyCodeLine{9684             \textcolor{keywordflow}{case} 0x87:}
\DoxyCodeLine{9685             \textcolor{keywordflow}{case} 0x88:}
\DoxyCodeLine{9686             \textcolor{keywordflow}{case} 0x89:}
\DoxyCodeLine{9687             \textcolor{keywordflow}{case} 0x8A:}
\DoxyCodeLine{9688             \textcolor{keywordflow}{case} 0x8B:}
\DoxyCodeLine{9689             \textcolor{keywordflow}{case} 0x8C:}
\DoxyCodeLine{9690             \textcolor{keywordflow}{case} 0x8D:}
\DoxyCodeLine{9691             \textcolor{keywordflow}{case} 0x8E:}
\DoxyCodeLine{9692             \textcolor{keywordflow}{case} 0x8F:}
\DoxyCodeLine{9693             \textcolor{keywordflow}{case} 0x90:}
\DoxyCodeLine{9694             \textcolor{keywordflow}{case} 0x91:}
\DoxyCodeLine{9695             \textcolor{keywordflow}{case} 0x92:}
\DoxyCodeLine{9696             \textcolor{keywordflow}{case} 0x93:}
\DoxyCodeLine{9697             \textcolor{keywordflow}{case} 0x94:}
\DoxyCodeLine{9698             \textcolor{keywordflow}{case} 0x95:}
\DoxyCodeLine{9699             \textcolor{keywordflow}{case} 0x96:}
\DoxyCodeLine{9700             \textcolor{keywordflow}{case} 0x97:}
\DoxyCodeLine{9701                 \textcolor{keywordflow}{return} get\_cbor\_array(}
\DoxyCodeLine{9702                            conditional\_static\_cast<std::size\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x1Fu), tag\_handler);}
\DoxyCodeLine{9703 }
\DoxyCodeLine{9704             \textcolor{keywordflow}{case} 0x98: \textcolor{comment}{// array (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{9705             \{}
\DoxyCodeLine{9706                 std::uint8\_t len\{\};}
\DoxyCodeLine{9707                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len), tag\_handler);}
\DoxyCodeLine{9708             \}}
\DoxyCodeLine{9709 }
\DoxyCodeLine{9710             \textcolor{keywordflow}{case} 0x99: \textcolor{comment}{// array (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{9711             \{}
\DoxyCodeLine{9712                 std::uint16\_t len\{\};}
\DoxyCodeLine{9713                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len), tag\_handler);}
\DoxyCodeLine{9714             \}}
\DoxyCodeLine{9715 }
\DoxyCodeLine{9716             \textcolor{keywordflow}{case} 0x9A: \textcolor{comment}{// array (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{9717             \{}
\DoxyCodeLine{9718                 std::uint32\_t len\{\};}
\DoxyCodeLine{9719                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_array(conditional\_static\_cast<std::size\_t>(len), tag\_handler);}
\DoxyCodeLine{9720             \}}
\DoxyCodeLine{9721 }
\DoxyCodeLine{9722             \textcolor{keywordflow}{case} 0x9B: \textcolor{comment}{// array (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{9723             \{}
\DoxyCodeLine{9724                 std::uint64\_t len\{\};}
\DoxyCodeLine{9725                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_array(conditional\_static\_cast<std::size\_t>(len), tag\_handler);}
\DoxyCodeLine{9726             \}}
\DoxyCodeLine{9727 }
\DoxyCodeLine{9728             \textcolor{keywordflow}{case} 0x9F: \textcolor{comment}{// array (indefinite length)}}
\DoxyCodeLine{9729                 \textcolor{keywordflow}{return} get\_cbor\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1), tag\_handler);}
\DoxyCodeLine{9730 }
\DoxyCodeLine{9731             \textcolor{comment}{// map (0x00..0x17 pairs of data items follow)}}
\DoxyCodeLine{9732             \textcolor{keywordflow}{case} 0xA0:}
\DoxyCodeLine{9733             \textcolor{keywordflow}{case} 0xA1:}
\DoxyCodeLine{9734             \textcolor{keywordflow}{case} 0xA2:}
\DoxyCodeLine{9735             \textcolor{keywordflow}{case} 0xA3:}
\DoxyCodeLine{9736             \textcolor{keywordflow}{case} 0xA4:}
\DoxyCodeLine{9737             \textcolor{keywordflow}{case} 0xA5:}
\DoxyCodeLine{9738             \textcolor{keywordflow}{case} 0xA6:}
\DoxyCodeLine{9739             \textcolor{keywordflow}{case} 0xA7:}
\DoxyCodeLine{9740             \textcolor{keywordflow}{case} 0xA8:}
\DoxyCodeLine{9741             \textcolor{keywordflow}{case} 0xA9:}
\DoxyCodeLine{9742             \textcolor{keywordflow}{case} 0xAA:}
\DoxyCodeLine{9743             \textcolor{keywordflow}{case} 0xAB:}
\DoxyCodeLine{9744             \textcolor{keywordflow}{case} 0xAC:}
\DoxyCodeLine{9745             \textcolor{keywordflow}{case} 0xAD:}
\DoxyCodeLine{9746             \textcolor{keywordflow}{case} 0xAE:}
\DoxyCodeLine{9747             \textcolor{keywordflow}{case} 0xAF:}
\DoxyCodeLine{9748             \textcolor{keywordflow}{case} 0xB0:}
\DoxyCodeLine{9749             \textcolor{keywordflow}{case} 0xB1:}
\DoxyCodeLine{9750             \textcolor{keywordflow}{case} 0xB2:}
\DoxyCodeLine{9751             \textcolor{keywordflow}{case} 0xB3:}
\DoxyCodeLine{9752             \textcolor{keywordflow}{case} 0xB4:}
\DoxyCodeLine{9753             \textcolor{keywordflow}{case} 0xB5:}
\DoxyCodeLine{9754             \textcolor{keywordflow}{case} 0xB6:}
\DoxyCodeLine{9755             \textcolor{keywordflow}{case} 0xB7:}
\DoxyCodeLine{9756                 \textcolor{keywordflow}{return} get\_cbor\_object(conditional\_static\_cast<std::size\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x1Fu), tag\_handler);}
\DoxyCodeLine{9757 }
\DoxyCodeLine{9758             \textcolor{keywordflow}{case} 0xB8: \textcolor{comment}{// map (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{9759             \{}
\DoxyCodeLine{9760                 std::uint8\_t len\{\};}
\DoxyCodeLine{9761                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len), tag\_handler);}
\DoxyCodeLine{9762             \}}
\DoxyCodeLine{9763 }
\DoxyCodeLine{9764             \textcolor{keywordflow}{case} 0xB9: \textcolor{comment}{// map (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{9765             \{}
\DoxyCodeLine{9766                 std::uint16\_t len\{\};}
\DoxyCodeLine{9767                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len), tag\_handler);}
\DoxyCodeLine{9768             \}}
\DoxyCodeLine{9769 }
\DoxyCodeLine{9770             \textcolor{keywordflow}{case} 0xBA: \textcolor{comment}{// map (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{9771             \{}
\DoxyCodeLine{9772                 std::uint32\_t len\{\};}
\DoxyCodeLine{9773                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_object(conditional\_static\_cast<std::size\_t>(len), tag\_handler);}
\DoxyCodeLine{9774             \}}
\DoxyCodeLine{9775 }
\DoxyCodeLine{9776             \textcolor{keywordflow}{case} 0xBB: \textcolor{comment}{// map (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{9777             \{}
\DoxyCodeLine{9778                 std::uint64\_t len\{\};}
\DoxyCodeLine{9779                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_cbor\_object(conditional\_static\_cast<std::size\_t>(len), tag\_handler);}
\DoxyCodeLine{9780             \}}
\DoxyCodeLine{9781 }
\DoxyCodeLine{9782             \textcolor{keywordflow}{case} 0xBF: \textcolor{comment}{// map (indefinite length)}}
\DoxyCodeLine{9783                 \textcolor{keywordflow}{return} get\_cbor\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1), tag\_handler);}
\DoxyCodeLine{9784 }
\DoxyCodeLine{9785             \textcolor{keywordflow}{case} 0xC6: \textcolor{comment}{// tagged item}}
\DoxyCodeLine{9786             \textcolor{keywordflow}{case} 0xC7:}
\DoxyCodeLine{9787             \textcolor{keywordflow}{case} 0xC8:}
\DoxyCodeLine{9788             \textcolor{keywordflow}{case} 0xC9:}
\DoxyCodeLine{9789             \textcolor{keywordflow}{case} 0xCA:}
\DoxyCodeLine{9790             \textcolor{keywordflow}{case} 0xCB:}
\DoxyCodeLine{9791             \textcolor{keywordflow}{case} 0xCC:}
\DoxyCodeLine{9792             \textcolor{keywordflow}{case} 0xCD:}
\DoxyCodeLine{9793             \textcolor{keywordflow}{case} 0xCE:}
\DoxyCodeLine{9794             \textcolor{keywordflow}{case} 0xCF:}
\DoxyCodeLine{9795             \textcolor{keywordflow}{case} 0xD0:}
\DoxyCodeLine{9796             \textcolor{keywordflow}{case} 0xD1:}
\DoxyCodeLine{9797             \textcolor{keywordflow}{case} 0xD2:}
\DoxyCodeLine{9798             \textcolor{keywordflow}{case} 0xD3:}
\DoxyCodeLine{9799             \textcolor{keywordflow}{case} 0xD4:}
\DoxyCodeLine{9800             \textcolor{keywordflow}{case} 0xD8: \textcolor{comment}{// tagged item (1 bytes follow)}}
\DoxyCodeLine{9801             \textcolor{keywordflow}{case} 0xD9: \textcolor{comment}{// tagged item (2 bytes follow)}}
\DoxyCodeLine{9802             \textcolor{keywordflow}{case} 0xDA: \textcolor{comment}{// tagged item (4 bytes follow)}}
\DoxyCodeLine{9803             \textcolor{keywordflow}{case} 0xDB: \textcolor{comment}{// tagged item (8 bytes follow)}}
\DoxyCodeLine{9804             \{}
\DoxyCodeLine{9805                 \textcolor{keywordflow}{switch} (tag\_handler)}
\DoxyCodeLine{9806                 \{}
\DoxyCodeLine{9807                     \textcolor{keywordflow}{case} cbor\_tag\_handler\_t::error:}
\DoxyCodeLine{9808                     \{}
\DoxyCodeLine{9809                         \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{9810                         \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(112, chars\_read,}
\DoxyCodeLine{9811                                                 exception\_message(input\_format\_t::cbor, concat(\textcolor{stringliteral}{"{}invalid byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{9812                     \}}
\DoxyCodeLine{9813 }
\DoxyCodeLine{9814                     \textcolor{keywordflow}{case} cbor\_tag\_handler\_t::ignore:}
\DoxyCodeLine{9815                     \{}
\DoxyCodeLine{9816                         \textcolor{comment}{// ignore binary subtype}}
\DoxyCodeLine{9817                         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{9818                         \{}
\DoxyCodeLine{9819                             \textcolor{keywordflow}{case} 0xD8:}
\DoxyCodeLine{9820                             \{}
\DoxyCodeLine{9821                                 std::uint8\_t subtype\_to\_ignore\{\};}
\DoxyCodeLine{9822                                 get\_number(input\_format\_t::cbor, subtype\_to\_ignore);}
\DoxyCodeLine{9823                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9824                             \}}
\DoxyCodeLine{9825                             \textcolor{keywordflow}{case} 0xD9:}
\DoxyCodeLine{9826                             \{}
\DoxyCodeLine{9827                                 std::uint16\_t subtype\_to\_ignore\{\};}
\DoxyCodeLine{9828                                 get\_number(input\_format\_t::cbor, subtype\_to\_ignore);}
\DoxyCodeLine{9829                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9830                             \}}
\DoxyCodeLine{9831                             \textcolor{keywordflow}{case} 0xDA:}
\DoxyCodeLine{9832                             \{}
\DoxyCodeLine{9833                                 std::uint32\_t subtype\_to\_ignore\{\};}
\DoxyCodeLine{9834                                 get\_number(input\_format\_t::cbor, subtype\_to\_ignore);}
\DoxyCodeLine{9835                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9836                             \}}
\DoxyCodeLine{9837                             \textcolor{keywordflow}{case} 0xDB:}
\DoxyCodeLine{9838                             \{}
\DoxyCodeLine{9839                                 std::uint64\_t subtype\_to\_ignore\{\};}
\DoxyCodeLine{9840                                 get\_number(input\_format\_t::cbor, subtype\_to\_ignore);}
\DoxyCodeLine{9841                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9842                             \}}
\DoxyCodeLine{9843                             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{9844                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9845                         \}}
\DoxyCodeLine{9846                         \textcolor{keywordflow}{return} parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler);}
\DoxyCodeLine{9847                     \}}
\DoxyCodeLine{9848 }
\DoxyCodeLine{9849                     \textcolor{keywordflow}{case} cbor\_tag\_handler\_t::store:}
\DoxyCodeLine{9850                     \{}
\DoxyCodeLine{9851                         binary\_t b;}
\DoxyCodeLine{9852                         \textcolor{comment}{// use binary subtype and store in binary container}}
\DoxyCodeLine{9853                         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{9854                         \{}
\DoxyCodeLine{9855                             \textcolor{keywordflow}{case} 0xD8:}
\DoxyCodeLine{9856                             \{}
\DoxyCodeLine{9857                                 std::uint8\_t subtype\{\};}
\DoxyCodeLine{9858                                 get\_number(input\_format\_t::cbor, subtype);}
\DoxyCodeLine{9859                                 b.set\_subtype(detail::conditional\_static\_cast<typename binary\_t::subtype\_type>(subtype));}
\DoxyCodeLine{9860                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9861                             \}}
\DoxyCodeLine{9862                             \textcolor{keywordflow}{case} 0xD9:}
\DoxyCodeLine{9863                             \{}
\DoxyCodeLine{9864                                 std::uint16\_t subtype\{\};}
\DoxyCodeLine{9865                                 get\_number(input\_format\_t::cbor, subtype);}
\DoxyCodeLine{9866                                 b.set\_subtype(detail::conditional\_static\_cast<typename binary\_t::subtype\_type>(subtype));}
\DoxyCodeLine{9867                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9868                             \}}
\DoxyCodeLine{9869                             \textcolor{keywordflow}{case} 0xDA:}
\DoxyCodeLine{9870                             \{}
\DoxyCodeLine{9871                                 std::uint32\_t subtype\{\};}
\DoxyCodeLine{9872                                 get\_number(input\_format\_t::cbor, subtype);}
\DoxyCodeLine{9873                                 b.set\_subtype(detail::conditional\_static\_cast<typename binary\_t::subtype\_type>(subtype));}
\DoxyCodeLine{9874                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9875                             \}}
\DoxyCodeLine{9876                             \textcolor{keywordflow}{case} 0xDB:}
\DoxyCodeLine{9877                             \{}
\DoxyCodeLine{9878                                 std::uint64\_t subtype\{\};}
\DoxyCodeLine{9879                                 get\_number(input\_format\_t::cbor, subtype);}
\DoxyCodeLine{9880                                 b.set\_subtype(detail::conditional\_static\_cast<typename binary\_t::subtype\_type>(subtype));}
\DoxyCodeLine{9881                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{9882                             \}}
\DoxyCodeLine{9883                             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{9884                                 \textcolor{keywordflow}{return} parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler);}
\DoxyCodeLine{9885                         \}}
\DoxyCodeLine{9886                         get();}
\DoxyCodeLine{9887                         \textcolor{keywordflow}{return} get\_cbor\_binary(b) \&\& sax-\/>binary(b);}
\DoxyCodeLine{9888                     \}}
\DoxyCodeLine{9889 }
\DoxyCodeLine{9890                     \textcolor{keywordflow}{default}:                 \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{9891                         JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{9892                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};        \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{9893                 \}}
\DoxyCodeLine{9894             \}}
\DoxyCodeLine{9895 }
\DoxyCodeLine{9896             \textcolor{keywordflow}{case} 0xF4: \textcolor{comment}{// false}}
\DoxyCodeLine{9897                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{false});}
\DoxyCodeLine{9898 }
\DoxyCodeLine{9899             \textcolor{keywordflow}{case} 0xF5: \textcolor{comment}{// true}}
\DoxyCodeLine{9900                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{true});}
\DoxyCodeLine{9901 }
\DoxyCodeLine{9902             \textcolor{keywordflow}{case} 0xF6: \textcolor{comment}{// null}}
\DoxyCodeLine{9903                 \textcolor{keywordflow}{return} sax-\/>null();}
\DoxyCodeLine{9904 }
\DoxyCodeLine{9905             \textcolor{keywordflow}{case} 0xF9: \textcolor{comment}{// Half-\/Precision Float (two-\/byte IEEE 754)}}
\DoxyCodeLine{9906             \{}
\DoxyCodeLine{9907                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte1\_raw = get();}
\DoxyCodeLine{9908                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::cbor, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{9909                 \{}
\DoxyCodeLine{9910                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9911                 \}}
\DoxyCodeLine{9912                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte2\_raw = get();}
\DoxyCodeLine{9913                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::cbor, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{9914                 \{}
\DoxyCodeLine{9915                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9916                 \}}
\DoxyCodeLine{9917 }
\DoxyCodeLine{9918                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte1 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(byte1\_raw);}
\DoxyCodeLine{9919                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte2 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(byte2\_raw);}
\DoxyCodeLine{9920 }
\DoxyCodeLine{9921                 \textcolor{comment}{// code from RFC 7049, Appendix D, Figure 3:}}
\DoxyCodeLine{9922                 \textcolor{comment}{// As half-\/precision floating-\/point numbers were only added}}
\DoxyCodeLine{9923                 \textcolor{comment}{// to IEEE 754 in 2008, today's programming platforms often}}
\DoxyCodeLine{9924                 \textcolor{comment}{// still only have limited support for them. It is very}}
\DoxyCodeLine{9925                 \textcolor{comment}{// easy to include at least decoding support for them even}}
\DoxyCodeLine{9926                 \textcolor{comment}{// without such support. An example of a small decoder for}}
\DoxyCodeLine{9927                 \textcolor{comment}{// half-\/precision floating-\/point numbers in the C language}}
\DoxyCodeLine{9928                 \textcolor{comment}{// is shown in Fig. 3.}}
\DoxyCodeLine{9929                 \textcolor{keyword}{const} \textcolor{keyword}{auto} half = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}((byte1 << 8u) + byte2);}
\DoxyCodeLine{9930                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} val = [\&half]}
\DoxyCodeLine{9931                 \{}
\DoxyCodeLine{9932                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} exp = (half >> 10u) \& 0x1Fu;}
\DoxyCodeLine{9933                     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mant = half \& 0x3FFu;}
\DoxyCodeLine{9934                     JSON\_ASSERT(0 <= exp\&\& exp <= 32);}
\DoxyCodeLine{9935                     JSON\_ASSERT(mant <= 1024);}
\DoxyCodeLine{9936                     \textcolor{keywordflow}{switch} (exp)}
\DoxyCodeLine{9937                     \{}
\DoxyCodeLine{9938                         \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{9939                             \textcolor{keywordflow}{return} std::ldexp(mant, -\/24);}
\DoxyCodeLine{9940                         \textcolor{keywordflow}{case} 31:}
\DoxyCodeLine{9941                             \textcolor{keywordflow}{return} (mant == 0)}
\DoxyCodeLine{9942                             ? std::numeric\_limits<double>::infinity()}
\DoxyCodeLine{9943                             : std::numeric\_limits<double>::quiet\_NaN();}
\DoxyCodeLine{9944                         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{9945                             \textcolor{keywordflow}{return} std::ldexp(mant + 1024, exp -\/ 25);}
\DoxyCodeLine{9946                     \}}
\DoxyCodeLine{9947                 \}();}
\DoxyCodeLine{9948                 \textcolor{keywordflow}{return} sax-\/>number\_float((half \& 0x8000u) != 0}
\DoxyCodeLine{9949                                          ? \textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(-\/val)}
\DoxyCodeLine{9950                                          : \textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(val), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{9951             \}}
\DoxyCodeLine{9952 }
\DoxyCodeLine{9953             \textcolor{keywordflow}{case} 0xFA: \textcolor{comment}{// Single-\/Precision Float (four-\/byte IEEE 754)}}
\DoxyCodeLine{9954             \{}
\DoxyCodeLine{9955                 \textcolor{keywordtype}{float} number\{\};}
\DoxyCodeLine{9956                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{9957             \}}
\DoxyCodeLine{9958 }
\DoxyCodeLine{9959             \textcolor{keywordflow}{case} 0xFB: \textcolor{comment}{// Double-\/Precision Float (eight-\/byte IEEE 754)}}
\DoxyCodeLine{9960             \{}
\DoxyCodeLine{9961                 \textcolor{keywordtype}{double} number\{\};}
\DoxyCodeLine{9962                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{9963             \}}
\DoxyCodeLine{9964 }
\DoxyCodeLine{9965             \textcolor{keywordflow}{default}: \textcolor{comment}{// anything else (0xFF is handled inside the other types)}}
\DoxyCodeLine{9966             \{}
\DoxyCodeLine{9967                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{9968                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(112, chars\_read,}
\DoxyCodeLine{9969                                         exception\_message(input\_format\_t::cbor, concat(\textcolor{stringliteral}{"{}invalid byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{9970             \}}
\DoxyCodeLine{9971         \}}
\DoxyCodeLine{9972     \}}
\DoxyCodeLine{9973 }
\DoxyCodeLine{9985     \textcolor{keywordtype}{bool} get\_cbor\_string(string\_t\& result)}
\DoxyCodeLine{9986     \{}
\DoxyCodeLine{9987         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::cbor, \textcolor{stringliteral}{"{}string"{}})))}
\DoxyCodeLine{9988         \{}
\DoxyCodeLine{9989             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9990         \}}
\DoxyCodeLine{9991 }
\DoxyCodeLine{9992         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{9993         \{}
\DoxyCodeLine{9994             \textcolor{comment}{// UTF-\/8 string (0x00..0x17 bytes follow)}}
\DoxyCodeLine{9995             \textcolor{keywordflow}{case} 0x60:}
\DoxyCodeLine{9996             \textcolor{keywordflow}{case} 0x61:}
\DoxyCodeLine{9997             \textcolor{keywordflow}{case} 0x62:}
\DoxyCodeLine{9998             \textcolor{keywordflow}{case} 0x63:}
\DoxyCodeLine{9999             \textcolor{keywordflow}{case} 0x64:}
\DoxyCodeLine{10000             \textcolor{keywordflow}{case} 0x65:}
\DoxyCodeLine{10001             \textcolor{keywordflow}{case} 0x66:}
\DoxyCodeLine{10002             \textcolor{keywordflow}{case} 0x67:}
\DoxyCodeLine{10003             \textcolor{keywordflow}{case} 0x68:}
\DoxyCodeLine{10004             \textcolor{keywordflow}{case} 0x69:}
\DoxyCodeLine{10005             \textcolor{keywordflow}{case} 0x6A:}
\DoxyCodeLine{10006             \textcolor{keywordflow}{case} 0x6B:}
\DoxyCodeLine{10007             \textcolor{keywordflow}{case} 0x6C:}
\DoxyCodeLine{10008             \textcolor{keywordflow}{case} 0x6D:}
\DoxyCodeLine{10009             \textcolor{keywordflow}{case} 0x6E:}
\DoxyCodeLine{10010             \textcolor{keywordflow}{case} 0x6F:}
\DoxyCodeLine{10011             \textcolor{keywordflow}{case} 0x70:}
\DoxyCodeLine{10012             \textcolor{keywordflow}{case} 0x71:}
\DoxyCodeLine{10013             \textcolor{keywordflow}{case} 0x72:}
\DoxyCodeLine{10014             \textcolor{keywordflow}{case} 0x73:}
\DoxyCodeLine{10015             \textcolor{keywordflow}{case} 0x74:}
\DoxyCodeLine{10016             \textcolor{keywordflow}{case} 0x75:}
\DoxyCodeLine{10017             \textcolor{keywordflow}{case} 0x76:}
\DoxyCodeLine{10018             \textcolor{keywordflow}{case} 0x77:}
\DoxyCodeLine{10019             \{}
\DoxyCodeLine{10020                 \textcolor{keywordflow}{return} get\_string(input\_format\_t::cbor, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x1Fu, result);}
\DoxyCodeLine{10021             \}}
\DoxyCodeLine{10022 }
\DoxyCodeLine{10023             \textcolor{keywordflow}{case} 0x78: \textcolor{comment}{// UTF-\/8 string (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{10024             \{}
\DoxyCodeLine{10025                 std::uint8\_t len\{\};}
\DoxyCodeLine{10026                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_string(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{10027             \}}
\DoxyCodeLine{10028 }
\DoxyCodeLine{10029             \textcolor{keywordflow}{case} 0x79: \textcolor{comment}{// UTF-\/8 string (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{10030             \{}
\DoxyCodeLine{10031                 std::uint16\_t len\{\};}
\DoxyCodeLine{10032                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_string(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{10033             \}}
\DoxyCodeLine{10034 }
\DoxyCodeLine{10035             \textcolor{keywordflow}{case} 0x7A: \textcolor{comment}{// UTF-\/8 string (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{10036             \{}
\DoxyCodeLine{10037                 std::uint32\_t len\{\};}
\DoxyCodeLine{10038                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_string(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{10039             \}}
\DoxyCodeLine{10040 }
\DoxyCodeLine{10041             \textcolor{keywordflow}{case} 0x7B: \textcolor{comment}{// UTF-\/8 string (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{10042             \{}
\DoxyCodeLine{10043                 std::uint64\_t len\{\};}
\DoxyCodeLine{10044                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\& get\_string(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{10045             \}}
\DoxyCodeLine{10046 }
\DoxyCodeLine{10047             \textcolor{keywordflow}{case} 0x7F: \textcolor{comment}{// UTF-\/8 string (indefinite length)}}
\DoxyCodeLine{10048             \{}
\DoxyCodeLine{10049                 \textcolor{keywordflow}{while} (get() != 0xFF)}
\DoxyCodeLine{10050                 \{}
\DoxyCodeLine{10051                     string\_t chunk;}
\DoxyCodeLine{10052                     \textcolor{keywordflow}{if} (!get\_cbor\_string(chunk))}
\DoxyCodeLine{10053                     \{}
\DoxyCodeLine{10054                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10055                     \}}
\DoxyCodeLine{10056                     result.append(chunk);}
\DoxyCodeLine{10057                 \}}
\DoxyCodeLine{10058                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{10059             \}}
\DoxyCodeLine{10060 }
\DoxyCodeLine{10061             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{10062             \{}
\DoxyCodeLine{10063                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{10064                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(113, chars\_read,}
\DoxyCodeLine{10065                                         exception\_message(input\_format\_t::cbor, concat(\textcolor{stringliteral}{"{}expected length specification (0x60-\/0x7B) or indefinite string type (0x7F); last byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}string"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{10066             \}}
\DoxyCodeLine{10067         \}}
\DoxyCodeLine{10068     \}}
\DoxyCodeLine{10069 }
\DoxyCodeLine{10081     \textcolor{keywordtype}{bool} get\_cbor\_binary(binary\_t\& result)}
\DoxyCodeLine{10082     \{}
\DoxyCodeLine{10083         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::cbor, \textcolor{stringliteral}{"{}binary"{}})))}
\DoxyCodeLine{10084         \{}
\DoxyCodeLine{10085             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10086         \}}
\DoxyCodeLine{10087 }
\DoxyCodeLine{10088         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{10089         \{}
\DoxyCodeLine{10090             \textcolor{comment}{// Binary data (0x00..0x17 bytes follow)}}
\DoxyCodeLine{10091             \textcolor{keywordflow}{case} 0x40:}
\DoxyCodeLine{10092             \textcolor{keywordflow}{case} 0x41:}
\DoxyCodeLine{10093             \textcolor{keywordflow}{case} 0x42:}
\DoxyCodeLine{10094             \textcolor{keywordflow}{case} 0x43:}
\DoxyCodeLine{10095             \textcolor{keywordflow}{case} 0x44:}
\DoxyCodeLine{10096             \textcolor{keywordflow}{case} 0x45:}
\DoxyCodeLine{10097             \textcolor{keywordflow}{case} 0x46:}
\DoxyCodeLine{10098             \textcolor{keywordflow}{case} 0x47:}
\DoxyCodeLine{10099             \textcolor{keywordflow}{case} 0x48:}
\DoxyCodeLine{10100             \textcolor{keywordflow}{case} 0x49:}
\DoxyCodeLine{10101             \textcolor{keywordflow}{case} 0x4A:}
\DoxyCodeLine{10102             \textcolor{keywordflow}{case} 0x4B:}
\DoxyCodeLine{10103             \textcolor{keywordflow}{case} 0x4C:}
\DoxyCodeLine{10104             \textcolor{keywordflow}{case} 0x4D:}
\DoxyCodeLine{10105             \textcolor{keywordflow}{case} 0x4E:}
\DoxyCodeLine{10106             \textcolor{keywordflow}{case} 0x4F:}
\DoxyCodeLine{10107             \textcolor{keywordflow}{case} 0x50:}
\DoxyCodeLine{10108             \textcolor{keywordflow}{case} 0x51:}
\DoxyCodeLine{10109             \textcolor{keywordflow}{case} 0x52:}
\DoxyCodeLine{10110             \textcolor{keywordflow}{case} 0x53:}
\DoxyCodeLine{10111             \textcolor{keywordflow}{case} 0x54:}
\DoxyCodeLine{10112             \textcolor{keywordflow}{case} 0x55:}
\DoxyCodeLine{10113             \textcolor{keywordflow}{case} 0x56:}
\DoxyCodeLine{10114             \textcolor{keywordflow}{case} 0x57:}
\DoxyCodeLine{10115             \{}
\DoxyCodeLine{10116                 \textcolor{keywordflow}{return} get\_binary(input\_format\_t::cbor, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x1Fu, result);}
\DoxyCodeLine{10117             \}}
\DoxyCodeLine{10118 }
\DoxyCodeLine{10119             \textcolor{keywordflow}{case} 0x58: \textcolor{comment}{// Binary data (one-\/byte uint8\_t for n follows)}}
\DoxyCodeLine{10120             \{}
\DoxyCodeLine{10121                 std::uint8\_t len\{\};}
\DoxyCodeLine{10122                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\&}
\DoxyCodeLine{10123                        get\_binary(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{10124             \}}
\DoxyCodeLine{10125 }
\DoxyCodeLine{10126             \textcolor{keywordflow}{case} 0x59: \textcolor{comment}{// Binary data (two-\/byte uint16\_t for n follow)}}
\DoxyCodeLine{10127             \{}
\DoxyCodeLine{10128                 std::uint16\_t len\{\};}
\DoxyCodeLine{10129                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\&}
\DoxyCodeLine{10130                        get\_binary(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{10131             \}}
\DoxyCodeLine{10132 }
\DoxyCodeLine{10133             \textcolor{keywordflow}{case} 0x5A: \textcolor{comment}{// Binary data (four-\/byte uint32\_t for n follow)}}
\DoxyCodeLine{10134             \{}
\DoxyCodeLine{10135                 std::uint32\_t len\{\};}
\DoxyCodeLine{10136                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\&}
\DoxyCodeLine{10137                        get\_binary(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{10138             \}}
\DoxyCodeLine{10139 }
\DoxyCodeLine{10140             \textcolor{keywordflow}{case} 0x5B: \textcolor{comment}{// Binary data (eight-\/byte uint64\_t for n follow)}}
\DoxyCodeLine{10141             \{}
\DoxyCodeLine{10142                 std::uint64\_t len\{\};}
\DoxyCodeLine{10143                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::cbor, len) \&\&}
\DoxyCodeLine{10144                        get\_binary(input\_format\_t::cbor, len, result);}
\DoxyCodeLine{10145             \}}
\DoxyCodeLine{10146 }
\DoxyCodeLine{10147             \textcolor{keywordflow}{case} 0x5F: \textcolor{comment}{// Binary data (indefinite length)}}
\DoxyCodeLine{10148             \{}
\DoxyCodeLine{10149                 \textcolor{keywordflow}{while} (get() != 0xFF)}
\DoxyCodeLine{10150                 \{}
\DoxyCodeLine{10151                     binary\_t chunk;}
\DoxyCodeLine{10152                     \textcolor{keywordflow}{if} (!get\_cbor\_binary(chunk))}
\DoxyCodeLine{10153                     \{}
\DoxyCodeLine{10154                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10155                     \}}
\DoxyCodeLine{10156                     result.insert(result.end(), chunk.begin(), chunk.end());}
\DoxyCodeLine{10157                 \}}
\DoxyCodeLine{10158                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{10159             \}}
\DoxyCodeLine{10160 }
\DoxyCodeLine{10161             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{10162             \{}
\DoxyCodeLine{10163                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{10164                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(113, chars\_read,}
\DoxyCodeLine{10165                                         exception\_message(input\_format\_t::cbor, concat(\textcolor{stringliteral}{"{}expected length specification (0x40-\/0x5B) or indefinite binary array type (0x5F); last byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}binary"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{10166             \}}
\DoxyCodeLine{10167         \}}
\DoxyCodeLine{10168     \}}
\DoxyCodeLine{10169 }
\DoxyCodeLine{10176     \textcolor{keywordtype}{bool} get\_cbor\_array(\textcolor{keyword}{const} std::size\_t len,}
\DoxyCodeLine{10177                         \textcolor{keyword}{const} cbor\_tag\_handler\_t tag\_handler)}
\DoxyCodeLine{10178     \{}
\DoxyCodeLine{10179         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(len)))}
\DoxyCodeLine{10180         \{}
\DoxyCodeLine{10181             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10182         \}}
\DoxyCodeLine{10183 }
\DoxyCodeLine{10184         \textcolor{keywordflow}{if} (len != \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))}
\DoxyCodeLine{10185         \{}
\DoxyCodeLine{10186             \textcolor{keywordflow}{for} (std::size\_t i = 0; i < len; ++i)}
\DoxyCodeLine{10187             \{}
\DoxyCodeLine{10188                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler)))}
\DoxyCodeLine{10189                 \{}
\DoxyCodeLine{10190                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10191                 \}}
\DoxyCodeLine{10192             \}}
\DoxyCodeLine{10193         \}}
\DoxyCodeLine{10194         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10195         \{}
\DoxyCodeLine{10196             \textcolor{keywordflow}{while} (get() != 0xFF)}
\DoxyCodeLine{10197             \{}
\DoxyCodeLine{10198                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_cbor\_internal(\textcolor{keyword}{false}, tag\_handler)))}
\DoxyCodeLine{10199                 \{}
\DoxyCodeLine{10200                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10201                 \}}
\DoxyCodeLine{10202             \}}
\DoxyCodeLine{10203         \}}
\DoxyCodeLine{10204 }
\DoxyCodeLine{10205         \textcolor{keywordflow}{return} sax-\/>end\_array();}
\DoxyCodeLine{10206     \}}
\DoxyCodeLine{10207 }
\DoxyCodeLine{10214     \textcolor{keywordtype}{bool} get\_cbor\_object(\textcolor{keyword}{const} std::size\_t len,}
\DoxyCodeLine{10215                          \textcolor{keyword}{const} cbor\_tag\_handler\_t tag\_handler)}
\DoxyCodeLine{10216     \{}
\DoxyCodeLine{10217         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(len)))}
\DoxyCodeLine{10218         \{}
\DoxyCodeLine{10219             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10220         \}}
\DoxyCodeLine{10221 }
\DoxyCodeLine{10222         \textcolor{keywordflow}{if} (len != 0)}
\DoxyCodeLine{10223         \{}
\DoxyCodeLine{10224             string\_t \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}};}
\DoxyCodeLine{10225             \textcolor{keywordflow}{if} (len != \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))}
\DoxyCodeLine{10226             \{}
\DoxyCodeLine{10227                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < len; ++i)}
\DoxyCodeLine{10228                 \{}
\DoxyCodeLine{10229                     get();}
\DoxyCodeLine{10230                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_cbor\_string(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}) || !sax-\/>key(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})))}
\DoxyCodeLine{10231                     \{}
\DoxyCodeLine{10232                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10233                     \}}
\DoxyCodeLine{10234 }
\DoxyCodeLine{10235                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler)))}
\DoxyCodeLine{10236                     \{}
\DoxyCodeLine{10237                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10238                     \}}
\DoxyCodeLine{10239                     \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}.clear();}
\DoxyCodeLine{10240                 \}}
\DoxyCodeLine{10241             \}}
\DoxyCodeLine{10242             \textcolor{keywordflow}{else}}
\DoxyCodeLine{10243             \{}
\DoxyCodeLine{10244                 \textcolor{keywordflow}{while} (get() != 0xFF)}
\DoxyCodeLine{10245                 \{}
\DoxyCodeLine{10246                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_cbor\_string(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}) || !sax-\/>key(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})))}
\DoxyCodeLine{10247                     \{}
\DoxyCodeLine{10248                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10249                     \}}
\DoxyCodeLine{10250 }
\DoxyCodeLine{10251                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_cbor\_internal(\textcolor{keyword}{true}, tag\_handler)))}
\DoxyCodeLine{10252                     \{}
\DoxyCodeLine{10253                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10254                     \}}
\DoxyCodeLine{10255                     \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}.clear();}
\DoxyCodeLine{10256                 \}}
\DoxyCodeLine{10257             \}}
\DoxyCodeLine{10258         \}}
\DoxyCodeLine{10259 }
\DoxyCodeLine{10260         \textcolor{keywordflow}{return} sax-\/>end\_object();}
\DoxyCodeLine{10261     \}}
\DoxyCodeLine{10262 }
\DoxyCodeLine{10264     \textcolor{comment}{// MsgPack //}}
\DoxyCodeLine{10266 \textcolor{comment}{}}
\DoxyCodeLine{10270     \textcolor{keywordtype}{bool} parse\_msgpack\_internal()}
\DoxyCodeLine{10271     \{}
\DoxyCodeLine{10272         \textcolor{keywordflow}{switch} (get())}
\DoxyCodeLine{10273         \{}
\DoxyCodeLine{10274             \textcolor{comment}{// EOF}}
\DoxyCodeLine{10275             \textcolor{keywordflow}{case} std::char\_traits<char\_type>::eof():}
\DoxyCodeLine{10276                 return unexpect\_eof(\mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}}::msgpack, \textcolor{stringliteral}{"{}value"{}});}
\DoxyCodeLine{10277 }
\DoxyCodeLine{10278             \textcolor{comment}{// positive fixint}}
\DoxyCodeLine{10279             \textcolor{keywordflow}{case} 0x00:}
\DoxyCodeLine{10280             \textcolor{keywordflow}{case} 0x01:}
\DoxyCodeLine{10281             \textcolor{keywordflow}{case} 0x02:}
\DoxyCodeLine{10282             \textcolor{keywordflow}{case} 0x03:}
\DoxyCodeLine{10283             \textcolor{keywordflow}{case} 0x04:}
\DoxyCodeLine{10284             \textcolor{keywordflow}{case} 0x05:}
\DoxyCodeLine{10285             \textcolor{keywordflow}{case} 0x06:}
\DoxyCodeLine{10286             \textcolor{keywordflow}{case} 0x07:}
\DoxyCodeLine{10287             \textcolor{keywordflow}{case} 0x08:}
\DoxyCodeLine{10288             \textcolor{keywordflow}{case} 0x09:}
\DoxyCodeLine{10289             \textcolor{keywordflow}{case} 0x0A:}
\DoxyCodeLine{10290             \textcolor{keywordflow}{case} 0x0B:}
\DoxyCodeLine{10291             \textcolor{keywordflow}{case} 0x0C:}
\DoxyCodeLine{10292             \textcolor{keywordflow}{case} 0x0D:}
\DoxyCodeLine{10293             \textcolor{keywordflow}{case} 0x0E:}
\DoxyCodeLine{10294             \textcolor{keywordflow}{case} 0x0F:}
\DoxyCodeLine{10295             \textcolor{keywordflow}{case} 0x10:}
\DoxyCodeLine{10296             \textcolor{keywordflow}{case} 0x11:}
\DoxyCodeLine{10297             \textcolor{keywordflow}{case} 0x12:}
\DoxyCodeLine{10298             \textcolor{keywordflow}{case} 0x13:}
\DoxyCodeLine{10299             \textcolor{keywordflow}{case} 0x14:}
\DoxyCodeLine{10300             \textcolor{keywordflow}{case} 0x15:}
\DoxyCodeLine{10301             \textcolor{keywordflow}{case} 0x16:}
\DoxyCodeLine{10302             \textcolor{keywordflow}{case} 0x17:}
\DoxyCodeLine{10303             \textcolor{keywordflow}{case} 0x18:}
\DoxyCodeLine{10304             \textcolor{keywordflow}{case} 0x19:}
\DoxyCodeLine{10305             \textcolor{keywordflow}{case} 0x1A:}
\DoxyCodeLine{10306             \textcolor{keywordflow}{case} 0x1B:}
\DoxyCodeLine{10307             \textcolor{keywordflow}{case} 0x1C:}
\DoxyCodeLine{10308             \textcolor{keywordflow}{case} 0x1D:}
\DoxyCodeLine{10309             \textcolor{keywordflow}{case} 0x1E:}
\DoxyCodeLine{10310             \textcolor{keywordflow}{case} 0x1F:}
\DoxyCodeLine{10311             \textcolor{keywordflow}{case} 0x20:}
\DoxyCodeLine{10312             \textcolor{keywordflow}{case} 0x21:}
\DoxyCodeLine{10313             \textcolor{keywordflow}{case} 0x22:}
\DoxyCodeLine{10314             \textcolor{keywordflow}{case} 0x23:}
\DoxyCodeLine{10315             \textcolor{keywordflow}{case} 0x24:}
\DoxyCodeLine{10316             \textcolor{keywordflow}{case} 0x25:}
\DoxyCodeLine{10317             \textcolor{keywordflow}{case} 0x26:}
\DoxyCodeLine{10318             \textcolor{keywordflow}{case} 0x27:}
\DoxyCodeLine{10319             \textcolor{keywordflow}{case} 0x28:}
\DoxyCodeLine{10320             \textcolor{keywordflow}{case} 0x29:}
\DoxyCodeLine{10321             \textcolor{keywordflow}{case} 0x2A:}
\DoxyCodeLine{10322             \textcolor{keywordflow}{case} 0x2B:}
\DoxyCodeLine{10323             \textcolor{keywordflow}{case} 0x2C:}
\DoxyCodeLine{10324             \textcolor{keywordflow}{case} 0x2D:}
\DoxyCodeLine{10325             \textcolor{keywordflow}{case} 0x2E:}
\DoxyCodeLine{10326             \textcolor{keywordflow}{case} 0x2F:}
\DoxyCodeLine{10327             \textcolor{keywordflow}{case} 0x30:}
\DoxyCodeLine{10328             \textcolor{keywordflow}{case} 0x31:}
\DoxyCodeLine{10329             \textcolor{keywordflow}{case} 0x32:}
\DoxyCodeLine{10330             \textcolor{keywordflow}{case} 0x33:}
\DoxyCodeLine{10331             \textcolor{keywordflow}{case} 0x34:}
\DoxyCodeLine{10332             \textcolor{keywordflow}{case} 0x35:}
\DoxyCodeLine{10333             \textcolor{keywordflow}{case} 0x36:}
\DoxyCodeLine{10334             \textcolor{keywordflow}{case} 0x37:}
\DoxyCodeLine{10335             \textcolor{keywordflow}{case} 0x38:}
\DoxyCodeLine{10336             \textcolor{keywordflow}{case} 0x39:}
\DoxyCodeLine{10337             \textcolor{keywordflow}{case} 0x3A:}
\DoxyCodeLine{10338             \textcolor{keywordflow}{case} 0x3B:}
\DoxyCodeLine{10339             \textcolor{keywordflow}{case} 0x3C:}
\DoxyCodeLine{10340             \textcolor{keywordflow}{case} 0x3D:}
\DoxyCodeLine{10341             \textcolor{keywordflow}{case} 0x3E:}
\DoxyCodeLine{10342             \textcolor{keywordflow}{case} 0x3F:}
\DoxyCodeLine{10343             \textcolor{keywordflow}{case} 0x40:}
\DoxyCodeLine{10344             \textcolor{keywordflow}{case} 0x41:}
\DoxyCodeLine{10345             \textcolor{keywordflow}{case} 0x42:}
\DoxyCodeLine{10346             \textcolor{keywordflow}{case} 0x43:}
\DoxyCodeLine{10347             \textcolor{keywordflow}{case} 0x44:}
\DoxyCodeLine{10348             \textcolor{keywordflow}{case} 0x45:}
\DoxyCodeLine{10349             \textcolor{keywordflow}{case} 0x46:}
\DoxyCodeLine{10350             \textcolor{keywordflow}{case} 0x47:}
\DoxyCodeLine{10351             \textcolor{keywordflow}{case} 0x48:}
\DoxyCodeLine{10352             \textcolor{keywordflow}{case} 0x49:}
\DoxyCodeLine{10353             \textcolor{keywordflow}{case} 0x4A:}
\DoxyCodeLine{10354             \textcolor{keywordflow}{case} 0x4B:}
\DoxyCodeLine{10355             \textcolor{keywordflow}{case} 0x4C:}
\DoxyCodeLine{10356             \textcolor{keywordflow}{case} 0x4D:}
\DoxyCodeLine{10357             \textcolor{keywordflow}{case} 0x4E:}
\DoxyCodeLine{10358             \textcolor{keywordflow}{case} 0x4F:}
\DoxyCodeLine{10359             \textcolor{keywordflow}{case} 0x50:}
\DoxyCodeLine{10360             \textcolor{keywordflow}{case} 0x51:}
\DoxyCodeLine{10361             \textcolor{keywordflow}{case} 0x52:}
\DoxyCodeLine{10362             \textcolor{keywordflow}{case} 0x53:}
\DoxyCodeLine{10363             \textcolor{keywordflow}{case} 0x54:}
\DoxyCodeLine{10364             \textcolor{keywordflow}{case} 0x55:}
\DoxyCodeLine{10365             \textcolor{keywordflow}{case} 0x56:}
\DoxyCodeLine{10366             \textcolor{keywordflow}{case} 0x57:}
\DoxyCodeLine{10367             \textcolor{keywordflow}{case} 0x58:}
\DoxyCodeLine{10368             \textcolor{keywordflow}{case} 0x59:}
\DoxyCodeLine{10369             \textcolor{keywordflow}{case} 0x5A:}
\DoxyCodeLine{10370             \textcolor{keywordflow}{case} 0x5B:}
\DoxyCodeLine{10371             \textcolor{keywordflow}{case} 0x5C:}
\DoxyCodeLine{10372             \textcolor{keywordflow}{case} 0x5D:}
\DoxyCodeLine{10373             \textcolor{keywordflow}{case} 0x5E:}
\DoxyCodeLine{10374             \textcolor{keywordflow}{case} 0x5F:}
\DoxyCodeLine{10375             \textcolor{keywordflow}{case} 0x60:}
\DoxyCodeLine{10376             \textcolor{keywordflow}{case} 0x61:}
\DoxyCodeLine{10377             \textcolor{keywordflow}{case} 0x62:}
\DoxyCodeLine{10378             \textcolor{keywordflow}{case} 0x63:}
\DoxyCodeLine{10379             \textcolor{keywordflow}{case} 0x64:}
\DoxyCodeLine{10380             \textcolor{keywordflow}{case} 0x65:}
\DoxyCodeLine{10381             \textcolor{keywordflow}{case} 0x66:}
\DoxyCodeLine{10382             \textcolor{keywordflow}{case} 0x67:}
\DoxyCodeLine{10383             \textcolor{keywordflow}{case} 0x68:}
\DoxyCodeLine{10384             \textcolor{keywordflow}{case} 0x69:}
\DoxyCodeLine{10385             \textcolor{keywordflow}{case} 0x6A:}
\DoxyCodeLine{10386             \textcolor{keywordflow}{case} 0x6B:}
\DoxyCodeLine{10387             \textcolor{keywordflow}{case} 0x6C:}
\DoxyCodeLine{10388             \textcolor{keywordflow}{case} 0x6D:}
\DoxyCodeLine{10389             \textcolor{keywordflow}{case} 0x6E:}
\DoxyCodeLine{10390             \textcolor{keywordflow}{case} 0x6F:}
\DoxyCodeLine{10391             \textcolor{keywordflow}{case} 0x70:}
\DoxyCodeLine{10392             \textcolor{keywordflow}{case} 0x71:}
\DoxyCodeLine{10393             \textcolor{keywordflow}{case} 0x72:}
\DoxyCodeLine{10394             \textcolor{keywordflow}{case} 0x73:}
\DoxyCodeLine{10395             \textcolor{keywordflow}{case} 0x74:}
\DoxyCodeLine{10396             \textcolor{keywordflow}{case} 0x75:}
\DoxyCodeLine{10397             \textcolor{keywordflow}{case} 0x76:}
\DoxyCodeLine{10398             \textcolor{keywordflow}{case} 0x77:}
\DoxyCodeLine{10399             \textcolor{keywordflow}{case} 0x78:}
\DoxyCodeLine{10400             \textcolor{keywordflow}{case} 0x79:}
\DoxyCodeLine{10401             \textcolor{keywordflow}{case} 0x7A:}
\DoxyCodeLine{10402             \textcolor{keywordflow}{case} 0x7B:}
\DoxyCodeLine{10403             \textcolor{keywordflow}{case} 0x7C:}
\DoxyCodeLine{10404             \textcolor{keywordflow}{case} 0x7D:}
\DoxyCodeLine{10405             \textcolor{keywordflow}{case} 0x7E:}
\DoxyCodeLine{10406             \textcolor{keywordflow}{case} 0x7F:}
\DoxyCodeLine{10407                 \textcolor{keywordflow}{return} sax-\/>number\_unsigned(\textcolor{keyword}{static\_cast<}number\_unsigned\_t\textcolor{keyword}{>}(current));}
\DoxyCodeLine{10408 }
\DoxyCodeLine{10409             \textcolor{comment}{// fixmap}}
\DoxyCodeLine{10410             \textcolor{keywordflow}{case} 0x80:}
\DoxyCodeLine{10411             \textcolor{keywordflow}{case} 0x81:}
\DoxyCodeLine{10412             \textcolor{keywordflow}{case} 0x82:}
\DoxyCodeLine{10413             \textcolor{keywordflow}{case} 0x83:}
\DoxyCodeLine{10414             \textcolor{keywordflow}{case} 0x84:}
\DoxyCodeLine{10415             \textcolor{keywordflow}{case} 0x85:}
\DoxyCodeLine{10416             \textcolor{keywordflow}{case} 0x86:}
\DoxyCodeLine{10417             \textcolor{keywordflow}{case} 0x87:}
\DoxyCodeLine{10418             \textcolor{keywordflow}{case} 0x88:}
\DoxyCodeLine{10419             \textcolor{keywordflow}{case} 0x89:}
\DoxyCodeLine{10420             \textcolor{keywordflow}{case} 0x8A:}
\DoxyCodeLine{10421             \textcolor{keywordflow}{case} 0x8B:}
\DoxyCodeLine{10422             \textcolor{keywordflow}{case} 0x8C:}
\DoxyCodeLine{10423             \textcolor{keywordflow}{case} 0x8D:}
\DoxyCodeLine{10424             \textcolor{keywordflow}{case} 0x8E:}
\DoxyCodeLine{10425             \textcolor{keywordflow}{case} 0x8F:}
\DoxyCodeLine{10426                 \textcolor{keywordflow}{return} get\_msgpack\_object(conditional\_static\_cast<std::size\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x0Fu));}
\DoxyCodeLine{10427 }
\DoxyCodeLine{10428             \textcolor{comment}{// fixarray}}
\DoxyCodeLine{10429             \textcolor{keywordflow}{case} 0x90:}
\DoxyCodeLine{10430             \textcolor{keywordflow}{case} 0x91:}
\DoxyCodeLine{10431             \textcolor{keywordflow}{case} 0x92:}
\DoxyCodeLine{10432             \textcolor{keywordflow}{case} 0x93:}
\DoxyCodeLine{10433             \textcolor{keywordflow}{case} 0x94:}
\DoxyCodeLine{10434             \textcolor{keywordflow}{case} 0x95:}
\DoxyCodeLine{10435             \textcolor{keywordflow}{case} 0x96:}
\DoxyCodeLine{10436             \textcolor{keywordflow}{case} 0x97:}
\DoxyCodeLine{10437             \textcolor{keywordflow}{case} 0x98:}
\DoxyCodeLine{10438             \textcolor{keywordflow}{case} 0x99:}
\DoxyCodeLine{10439             \textcolor{keywordflow}{case} 0x9A:}
\DoxyCodeLine{10440             \textcolor{keywordflow}{case} 0x9B:}
\DoxyCodeLine{10441             \textcolor{keywordflow}{case} 0x9C:}
\DoxyCodeLine{10442             \textcolor{keywordflow}{case} 0x9D:}
\DoxyCodeLine{10443             \textcolor{keywordflow}{case} 0x9E:}
\DoxyCodeLine{10444             \textcolor{keywordflow}{case} 0x9F:}
\DoxyCodeLine{10445                 \textcolor{keywordflow}{return} get\_msgpack\_array(conditional\_static\_cast<std::size\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x0Fu));}
\DoxyCodeLine{10446 }
\DoxyCodeLine{10447             \textcolor{comment}{// fixstr}}
\DoxyCodeLine{10448             \textcolor{keywordflow}{case} 0xA0:}
\DoxyCodeLine{10449             \textcolor{keywordflow}{case} 0xA1:}
\DoxyCodeLine{10450             \textcolor{keywordflow}{case} 0xA2:}
\DoxyCodeLine{10451             \textcolor{keywordflow}{case} 0xA3:}
\DoxyCodeLine{10452             \textcolor{keywordflow}{case} 0xA4:}
\DoxyCodeLine{10453             \textcolor{keywordflow}{case} 0xA5:}
\DoxyCodeLine{10454             \textcolor{keywordflow}{case} 0xA6:}
\DoxyCodeLine{10455             \textcolor{keywordflow}{case} 0xA7:}
\DoxyCodeLine{10456             \textcolor{keywordflow}{case} 0xA8:}
\DoxyCodeLine{10457             \textcolor{keywordflow}{case} 0xA9:}
\DoxyCodeLine{10458             \textcolor{keywordflow}{case} 0xAA:}
\DoxyCodeLine{10459             \textcolor{keywordflow}{case} 0xAB:}
\DoxyCodeLine{10460             \textcolor{keywordflow}{case} 0xAC:}
\DoxyCodeLine{10461             \textcolor{keywordflow}{case} 0xAD:}
\DoxyCodeLine{10462             \textcolor{keywordflow}{case} 0xAE:}
\DoxyCodeLine{10463             \textcolor{keywordflow}{case} 0xAF:}
\DoxyCodeLine{10464             \textcolor{keywordflow}{case} 0xB0:}
\DoxyCodeLine{10465             \textcolor{keywordflow}{case} 0xB1:}
\DoxyCodeLine{10466             \textcolor{keywordflow}{case} 0xB2:}
\DoxyCodeLine{10467             \textcolor{keywordflow}{case} 0xB3:}
\DoxyCodeLine{10468             \textcolor{keywordflow}{case} 0xB4:}
\DoxyCodeLine{10469             \textcolor{keywordflow}{case} 0xB5:}
\DoxyCodeLine{10470             \textcolor{keywordflow}{case} 0xB6:}
\DoxyCodeLine{10471             \textcolor{keywordflow}{case} 0xB7:}
\DoxyCodeLine{10472             \textcolor{keywordflow}{case} 0xB8:}
\DoxyCodeLine{10473             \textcolor{keywordflow}{case} 0xB9:}
\DoxyCodeLine{10474             \textcolor{keywordflow}{case} 0xBA:}
\DoxyCodeLine{10475             \textcolor{keywordflow}{case} 0xBB:}
\DoxyCodeLine{10476             \textcolor{keywordflow}{case} 0xBC:}
\DoxyCodeLine{10477             \textcolor{keywordflow}{case} 0xBD:}
\DoxyCodeLine{10478             \textcolor{keywordflow}{case} 0xBE:}
\DoxyCodeLine{10479             \textcolor{keywordflow}{case} 0xBF:}
\DoxyCodeLine{10480             \textcolor{keywordflow}{case} 0xD9: \textcolor{comment}{// str 8}}
\DoxyCodeLine{10481             \textcolor{keywordflow}{case} 0xDA: \textcolor{comment}{// str 16}}
\DoxyCodeLine{10482             \textcolor{keywordflow}{case} 0xDB: \textcolor{comment}{// str 32}}
\DoxyCodeLine{10483             \{}
\DoxyCodeLine{10484                 string\_t s;}
\DoxyCodeLine{10485                 \textcolor{keywordflow}{return} get\_msgpack\_string(s) \&\& sax-\/>string(s);}
\DoxyCodeLine{10486             \}}
\DoxyCodeLine{10487 }
\DoxyCodeLine{10488             \textcolor{keywordflow}{case} 0xC0: \textcolor{comment}{// nil}}
\DoxyCodeLine{10489                 \textcolor{keywordflow}{return} sax-\/>null();}
\DoxyCodeLine{10490 }
\DoxyCodeLine{10491             \textcolor{keywordflow}{case} 0xC2: \textcolor{comment}{// false}}
\DoxyCodeLine{10492                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{false});}
\DoxyCodeLine{10493 }
\DoxyCodeLine{10494             \textcolor{keywordflow}{case} 0xC3: \textcolor{comment}{// true}}
\DoxyCodeLine{10495                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{true});}
\DoxyCodeLine{10496 }
\DoxyCodeLine{10497             \textcolor{keywordflow}{case} 0xC4: \textcolor{comment}{// bin 8}}
\DoxyCodeLine{10498             \textcolor{keywordflow}{case} 0xC5: \textcolor{comment}{// bin 16}}
\DoxyCodeLine{10499             \textcolor{keywordflow}{case} 0xC6: \textcolor{comment}{// bin 32}}
\DoxyCodeLine{10500             \textcolor{keywordflow}{case} 0xC7: \textcolor{comment}{// ext 8}}
\DoxyCodeLine{10501             \textcolor{keywordflow}{case} 0xC8: \textcolor{comment}{// ext 16}}
\DoxyCodeLine{10502             \textcolor{keywordflow}{case} 0xC9: \textcolor{comment}{// ext 32}}
\DoxyCodeLine{10503             \textcolor{keywordflow}{case} 0xD4: \textcolor{comment}{// fixext 1}}
\DoxyCodeLine{10504             \textcolor{keywordflow}{case} 0xD5: \textcolor{comment}{// fixext 2}}
\DoxyCodeLine{10505             \textcolor{keywordflow}{case} 0xD6: \textcolor{comment}{// fixext 4}}
\DoxyCodeLine{10506             \textcolor{keywordflow}{case} 0xD7: \textcolor{comment}{// fixext 8}}
\DoxyCodeLine{10507             \textcolor{keywordflow}{case} 0xD8: \textcolor{comment}{// fixext 16}}
\DoxyCodeLine{10508             \{}
\DoxyCodeLine{10509                 binary\_t b;}
\DoxyCodeLine{10510                 \textcolor{keywordflow}{return} get\_msgpack\_binary(b) \&\& sax-\/>binary(b);}
\DoxyCodeLine{10511             \}}
\DoxyCodeLine{10512 }
\DoxyCodeLine{10513             \textcolor{keywordflow}{case} 0xCA: \textcolor{comment}{// float 32}}
\DoxyCodeLine{10514             \{}
\DoxyCodeLine{10515                 \textcolor{keywordtype}{float} number\{\};}
\DoxyCodeLine{10516                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{10517             \}}
\DoxyCodeLine{10518 }
\DoxyCodeLine{10519             \textcolor{keywordflow}{case} 0xCB: \textcolor{comment}{// float 64}}
\DoxyCodeLine{10520             \{}
\DoxyCodeLine{10521                 \textcolor{keywordtype}{double} number\{\};}
\DoxyCodeLine{10522                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{10523             \}}
\DoxyCodeLine{10524 }
\DoxyCodeLine{10525             \textcolor{keywordflow}{case} 0xCC: \textcolor{comment}{// uint 8}}
\DoxyCodeLine{10526             \{}
\DoxyCodeLine{10527                 std::uint8\_t number\{\};}
\DoxyCodeLine{10528                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{10529             \}}
\DoxyCodeLine{10530 }
\DoxyCodeLine{10531             \textcolor{keywordflow}{case} 0xCD: \textcolor{comment}{// uint 16}}
\DoxyCodeLine{10532             \{}
\DoxyCodeLine{10533                 std::uint16\_t number\{\};}
\DoxyCodeLine{10534                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{10535             \}}
\DoxyCodeLine{10536 }
\DoxyCodeLine{10537             \textcolor{keywordflow}{case} 0xCE: \textcolor{comment}{// uint 32}}
\DoxyCodeLine{10538             \{}
\DoxyCodeLine{10539                 std::uint32\_t number\{\};}
\DoxyCodeLine{10540                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{10541             \}}
\DoxyCodeLine{10542 }
\DoxyCodeLine{10543             \textcolor{keywordflow}{case} 0xCF: \textcolor{comment}{// uint 64}}
\DoxyCodeLine{10544             \{}
\DoxyCodeLine{10545                 std::uint64\_t number\{\};}
\DoxyCodeLine{10546                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{10547             \}}
\DoxyCodeLine{10548 }
\DoxyCodeLine{10549             \textcolor{keywordflow}{case} 0xD0: \textcolor{comment}{// int 8}}
\DoxyCodeLine{10550             \{}
\DoxyCodeLine{10551                 std::int8\_t number\{\};}
\DoxyCodeLine{10552                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{10553             \}}
\DoxyCodeLine{10554 }
\DoxyCodeLine{10555             \textcolor{keywordflow}{case} 0xD1: \textcolor{comment}{// int 16}}
\DoxyCodeLine{10556             \{}
\DoxyCodeLine{10557                 std::int16\_t number\{\};}
\DoxyCodeLine{10558                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{10559             \}}
\DoxyCodeLine{10560 }
\DoxyCodeLine{10561             \textcolor{keywordflow}{case} 0xD2: \textcolor{comment}{// int 32}}
\DoxyCodeLine{10562             \{}
\DoxyCodeLine{10563                 std::int32\_t number\{\};}
\DoxyCodeLine{10564                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{10565             \}}
\DoxyCodeLine{10566 }
\DoxyCodeLine{10567             \textcolor{keywordflow}{case} 0xD3: \textcolor{comment}{// int 64}}
\DoxyCodeLine{10568             \{}
\DoxyCodeLine{10569                 std::int64\_t number\{\};}
\DoxyCodeLine{10570                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{10571             \}}
\DoxyCodeLine{10572 }
\DoxyCodeLine{10573             \textcolor{keywordflow}{case} 0xDC: \textcolor{comment}{// array 16}}
\DoxyCodeLine{10574             \{}
\DoxyCodeLine{10575                 std::uint16\_t len\{\};}
\DoxyCodeLine{10576                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_msgpack\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len));}
\DoxyCodeLine{10577             \}}
\DoxyCodeLine{10578 }
\DoxyCodeLine{10579             \textcolor{keywordflow}{case} 0xDD: \textcolor{comment}{// array 32}}
\DoxyCodeLine{10580             \{}
\DoxyCodeLine{10581                 std::uint32\_t len\{\};}
\DoxyCodeLine{10582                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_msgpack\_array(conditional\_static\_cast<std::size\_t>(len));}
\DoxyCodeLine{10583             \}}
\DoxyCodeLine{10584 }
\DoxyCodeLine{10585             \textcolor{keywordflow}{case} 0xDE: \textcolor{comment}{// map 16}}
\DoxyCodeLine{10586             \{}
\DoxyCodeLine{10587                 std::uint16\_t len\{\};}
\DoxyCodeLine{10588                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_msgpack\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len));}
\DoxyCodeLine{10589             \}}
\DoxyCodeLine{10590 }
\DoxyCodeLine{10591             \textcolor{keywordflow}{case} 0xDF: \textcolor{comment}{// map 32}}
\DoxyCodeLine{10592             \{}
\DoxyCodeLine{10593                 std::uint32\_t len\{\};}
\DoxyCodeLine{10594                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_msgpack\_object(conditional\_static\_cast<std::size\_t>(len));}
\DoxyCodeLine{10595             \}}
\DoxyCodeLine{10596 }
\DoxyCodeLine{10597             \textcolor{comment}{// negative fixint}}
\DoxyCodeLine{10598             \textcolor{keywordflow}{case} 0xE0:}
\DoxyCodeLine{10599             \textcolor{keywordflow}{case} 0xE1:}
\DoxyCodeLine{10600             \textcolor{keywordflow}{case} 0xE2:}
\DoxyCodeLine{10601             \textcolor{keywordflow}{case} 0xE3:}
\DoxyCodeLine{10602             \textcolor{keywordflow}{case} 0xE4:}
\DoxyCodeLine{10603             \textcolor{keywordflow}{case} 0xE5:}
\DoxyCodeLine{10604             \textcolor{keywordflow}{case} 0xE6:}
\DoxyCodeLine{10605             \textcolor{keywordflow}{case} 0xE7:}
\DoxyCodeLine{10606             \textcolor{keywordflow}{case} 0xE8:}
\DoxyCodeLine{10607             \textcolor{keywordflow}{case} 0xE9:}
\DoxyCodeLine{10608             \textcolor{keywordflow}{case} 0xEA:}
\DoxyCodeLine{10609             \textcolor{keywordflow}{case} 0xEB:}
\DoxyCodeLine{10610             \textcolor{keywordflow}{case} 0xEC:}
\DoxyCodeLine{10611             \textcolor{keywordflow}{case} 0xED:}
\DoxyCodeLine{10612             \textcolor{keywordflow}{case} 0xEE:}
\DoxyCodeLine{10613             \textcolor{keywordflow}{case} 0xEF:}
\DoxyCodeLine{10614             \textcolor{keywordflow}{case} 0xF0:}
\DoxyCodeLine{10615             \textcolor{keywordflow}{case} 0xF1:}
\DoxyCodeLine{10616             \textcolor{keywordflow}{case} 0xF2:}
\DoxyCodeLine{10617             \textcolor{keywordflow}{case} 0xF3:}
\DoxyCodeLine{10618             \textcolor{keywordflow}{case} 0xF4:}
\DoxyCodeLine{10619             \textcolor{keywordflow}{case} 0xF5:}
\DoxyCodeLine{10620             \textcolor{keywordflow}{case} 0xF6:}
\DoxyCodeLine{10621             \textcolor{keywordflow}{case} 0xF7:}
\DoxyCodeLine{10622             \textcolor{keywordflow}{case} 0xF8:}
\DoxyCodeLine{10623             \textcolor{keywordflow}{case} 0xF9:}
\DoxyCodeLine{10624             \textcolor{keywordflow}{case} 0xFA:}
\DoxyCodeLine{10625             \textcolor{keywordflow}{case} 0xFB:}
\DoxyCodeLine{10626             \textcolor{keywordflow}{case} 0xFC:}
\DoxyCodeLine{10627             \textcolor{keywordflow}{case} 0xFD:}
\DoxyCodeLine{10628             \textcolor{keywordflow}{case} 0xFE:}
\DoxyCodeLine{10629             \textcolor{keywordflow}{case} 0xFF:}
\DoxyCodeLine{10630                 \textcolor{keywordflow}{return} sax-\/>number\_integer(\textcolor{keyword}{static\_cast<}std::int8\_t\textcolor{keyword}{>}(current));}
\DoxyCodeLine{10631 }
\DoxyCodeLine{10632             \textcolor{keywordflow}{default}: \textcolor{comment}{// anything else}}
\DoxyCodeLine{10633             \{}
\DoxyCodeLine{10634                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{10635                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(112, chars\_read,}
\DoxyCodeLine{10636                                         exception\_message(input\_format\_t::msgpack, concat(\textcolor{stringliteral}{"{}invalid byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{10637             \}}
\DoxyCodeLine{10638         \}}
\DoxyCodeLine{10639     \}}
\DoxyCodeLine{10640 }
\DoxyCodeLine{10651     \textcolor{keywordtype}{bool} get\_msgpack\_string(string\_t\& result)}
\DoxyCodeLine{10652     \{}
\DoxyCodeLine{10653         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format\_t::msgpack, \textcolor{stringliteral}{"{}string"{}})))}
\DoxyCodeLine{10654         \{}
\DoxyCodeLine{10655             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10656         \}}
\DoxyCodeLine{10657 }
\DoxyCodeLine{10658         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{10659         \{}
\DoxyCodeLine{10660             \textcolor{comment}{// fixstr}}
\DoxyCodeLine{10661             \textcolor{keywordflow}{case} 0xA0:}
\DoxyCodeLine{10662             \textcolor{keywordflow}{case} 0xA1:}
\DoxyCodeLine{10663             \textcolor{keywordflow}{case} 0xA2:}
\DoxyCodeLine{10664             \textcolor{keywordflow}{case} 0xA3:}
\DoxyCodeLine{10665             \textcolor{keywordflow}{case} 0xA4:}
\DoxyCodeLine{10666             \textcolor{keywordflow}{case} 0xA5:}
\DoxyCodeLine{10667             \textcolor{keywordflow}{case} 0xA6:}
\DoxyCodeLine{10668             \textcolor{keywordflow}{case} 0xA7:}
\DoxyCodeLine{10669             \textcolor{keywordflow}{case} 0xA8:}
\DoxyCodeLine{10670             \textcolor{keywordflow}{case} 0xA9:}
\DoxyCodeLine{10671             \textcolor{keywordflow}{case} 0xAA:}
\DoxyCodeLine{10672             \textcolor{keywordflow}{case} 0xAB:}
\DoxyCodeLine{10673             \textcolor{keywordflow}{case} 0xAC:}
\DoxyCodeLine{10674             \textcolor{keywordflow}{case} 0xAD:}
\DoxyCodeLine{10675             \textcolor{keywordflow}{case} 0xAE:}
\DoxyCodeLine{10676             \textcolor{keywordflow}{case} 0xAF:}
\DoxyCodeLine{10677             \textcolor{keywordflow}{case} 0xB0:}
\DoxyCodeLine{10678             \textcolor{keywordflow}{case} 0xB1:}
\DoxyCodeLine{10679             \textcolor{keywordflow}{case} 0xB2:}
\DoxyCodeLine{10680             \textcolor{keywordflow}{case} 0xB3:}
\DoxyCodeLine{10681             \textcolor{keywordflow}{case} 0xB4:}
\DoxyCodeLine{10682             \textcolor{keywordflow}{case} 0xB5:}
\DoxyCodeLine{10683             \textcolor{keywordflow}{case} 0xB6:}
\DoxyCodeLine{10684             \textcolor{keywordflow}{case} 0xB7:}
\DoxyCodeLine{10685             \textcolor{keywordflow}{case} 0xB8:}
\DoxyCodeLine{10686             \textcolor{keywordflow}{case} 0xB9:}
\DoxyCodeLine{10687             \textcolor{keywordflow}{case} 0xBA:}
\DoxyCodeLine{10688             \textcolor{keywordflow}{case} 0xBB:}
\DoxyCodeLine{10689             \textcolor{keywordflow}{case} 0xBC:}
\DoxyCodeLine{10690             \textcolor{keywordflow}{case} 0xBD:}
\DoxyCodeLine{10691             \textcolor{keywordflow}{case} 0xBE:}
\DoxyCodeLine{10692             \textcolor{keywordflow}{case} 0xBF:}
\DoxyCodeLine{10693             \{}
\DoxyCodeLine{10694                 \textcolor{keywordflow}{return} get\_string(input\_format\_t::msgpack, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(current) \& 0x1Fu, result);}
\DoxyCodeLine{10695             \}}
\DoxyCodeLine{10696 }
\DoxyCodeLine{10697             \textcolor{keywordflow}{case} 0xD9: \textcolor{comment}{// str 8}}
\DoxyCodeLine{10698             \{}
\DoxyCodeLine{10699                 std::uint8\_t len\{\};}
\DoxyCodeLine{10700                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_string(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{10701             \}}
\DoxyCodeLine{10702 }
\DoxyCodeLine{10703             \textcolor{keywordflow}{case} 0xDA: \textcolor{comment}{// str 16}}
\DoxyCodeLine{10704             \{}
\DoxyCodeLine{10705                 std::uint16\_t len\{\};}
\DoxyCodeLine{10706                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_string(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{10707             \}}
\DoxyCodeLine{10708 }
\DoxyCodeLine{10709             \textcolor{keywordflow}{case} 0xDB: \textcolor{comment}{// str 32}}
\DoxyCodeLine{10710             \{}
\DoxyCodeLine{10711                 std::uint32\_t len\{\};}
\DoxyCodeLine{10712                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\& get\_string(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{10713             \}}
\DoxyCodeLine{10714 }
\DoxyCodeLine{10715             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{10716             \{}
\DoxyCodeLine{10717                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{10718                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(113, chars\_read,}
\DoxyCodeLine{10719                                         exception\_message(input\_format\_t::msgpack, concat(\textcolor{stringliteral}{"{}expected length specification (0xA0-\/0xBF, 0xD9-\/0xDB); last byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}string"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{10720             \}}
\DoxyCodeLine{10721         \}}
\DoxyCodeLine{10722     \}}
\DoxyCodeLine{10723 }
\DoxyCodeLine{10734     \textcolor{keywordtype}{bool} get\_msgpack\_binary(binary\_t\& result)}
\DoxyCodeLine{10735     \{}
\DoxyCodeLine{10736         \textcolor{comment}{// helper function to set the subtype}}
\DoxyCodeLine{10737         \textcolor{keyword}{auto} assign\_and\_return\_true = [\&result](std::int8\_t subtype)}
\DoxyCodeLine{10738         \{}
\DoxyCodeLine{10739             result.set\_subtype(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(subtype));}
\DoxyCodeLine{10740             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{10741         \};}
\DoxyCodeLine{10742 }
\DoxyCodeLine{10743         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{10744         \{}
\DoxyCodeLine{10745             \textcolor{keywordflow}{case} 0xC4: \textcolor{comment}{// bin 8}}
\DoxyCodeLine{10746             \{}
\DoxyCodeLine{10747                 std::uint8\_t len\{\};}
\DoxyCodeLine{10748                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{10749                        get\_binary(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{10750             \}}
\DoxyCodeLine{10751 }
\DoxyCodeLine{10752             \textcolor{keywordflow}{case} 0xC5: \textcolor{comment}{// bin 16}}
\DoxyCodeLine{10753             \{}
\DoxyCodeLine{10754                 std::uint16\_t len\{\};}
\DoxyCodeLine{10755                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{10756                        get\_binary(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{10757             \}}
\DoxyCodeLine{10758 }
\DoxyCodeLine{10759             \textcolor{keywordflow}{case} 0xC6: \textcolor{comment}{// bin 32}}
\DoxyCodeLine{10760             \{}
\DoxyCodeLine{10761                 std::uint32\_t len\{\};}
\DoxyCodeLine{10762                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{10763                        get\_binary(input\_format\_t::msgpack, len, result);}
\DoxyCodeLine{10764             \}}
\DoxyCodeLine{10765 }
\DoxyCodeLine{10766             \textcolor{keywordflow}{case} 0xC7: \textcolor{comment}{// ext 8}}
\DoxyCodeLine{10767             \{}
\DoxyCodeLine{10768                 std::uint8\_t len\{\};}
\DoxyCodeLine{10769                 std::int8\_t subtype\{\};}
\DoxyCodeLine{10770                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{10771                        get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{10772                        get\_binary(input\_format\_t::msgpack, len, result) \&\&}
\DoxyCodeLine{10773                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{10774             \}}
\DoxyCodeLine{10775 }
\DoxyCodeLine{10776             \textcolor{keywordflow}{case} 0xC8: \textcolor{comment}{// ext 16}}
\DoxyCodeLine{10777             \{}
\DoxyCodeLine{10778                 std::uint16\_t len\{\};}
\DoxyCodeLine{10779                 std::int8\_t subtype\{\};}
\DoxyCodeLine{10780                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{10781                        get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{10782                        get\_binary(input\_format\_t::msgpack, len, result) \&\&}
\DoxyCodeLine{10783                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{10784             \}}
\DoxyCodeLine{10785 }
\DoxyCodeLine{10786             \textcolor{keywordflow}{case} 0xC9: \textcolor{comment}{// ext 32}}
\DoxyCodeLine{10787             \{}
\DoxyCodeLine{10788                 std::uint32\_t len\{\};}
\DoxyCodeLine{10789                 std::int8\_t subtype\{\};}
\DoxyCodeLine{10790                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, len) \&\&}
\DoxyCodeLine{10791                        get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{10792                        get\_binary(input\_format\_t::msgpack, len, result) \&\&}
\DoxyCodeLine{10793                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{10794             \}}
\DoxyCodeLine{10795 }
\DoxyCodeLine{10796             \textcolor{keywordflow}{case} 0xD4: \textcolor{comment}{// fixext 1}}
\DoxyCodeLine{10797             \{}
\DoxyCodeLine{10798                 std::int8\_t subtype\{\};}
\DoxyCodeLine{10799                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{10800                        get\_binary(input\_format\_t::msgpack, 1, result) \&\&}
\DoxyCodeLine{10801                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{10802             \}}
\DoxyCodeLine{10803 }
\DoxyCodeLine{10804             \textcolor{keywordflow}{case} 0xD5: \textcolor{comment}{// fixext 2}}
\DoxyCodeLine{10805             \{}
\DoxyCodeLine{10806                 std::int8\_t subtype\{\};}
\DoxyCodeLine{10807                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{10808                        get\_binary(input\_format\_t::msgpack, 2, result) \&\&}
\DoxyCodeLine{10809                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{10810             \}}
\DoxyCodeLine{10811 }
\DoxyCodeLine{10812             \textcolor{keywordflow}{case} 0xD6: \textcolor{comment}{// fixext 4}}
\DoxyCodeLine{10813             \{}
\DoxyCodeLine{10814                 std::int8\_t subtype\{\};}
\DoxyCodeLine{10815                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{10816                        get\_binary(input\_format\_t::msgpack, 4, result) \&\&}
\DoxyCodeLine{10817                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{10818             \}}
\DoxyCodeLine{10819 }
\DoxyCodeLine{10820             \textcolor{keywordflow}{case} 0xD7: \textcolor{comment}{// fixext 8}}
\DoxyCodeLine{10821             \{}
\DoxyCodeLine{10822                 std::int8\_t subtype\{\};}
\DoxyCodeLine{10823                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{10824                        get\_binary(input\_format\_t::msgpack, 8, result) \&\&}
\DoxyCodeLine{10825                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{10826             \}}
\DoxyCodeLine{10827 }
\DoxyCodeLine{10828             \textcolor{keywordflow}{case} 0xD8: \textcolor{comment}{// fixext 16}}
\DoxyCodeLine{10829             \{}
\DoxyCodeLine{10830                 std::int8\_t subtype\{\};}
\DoxyCodeLine{10831                 \textcolor{keywordflow}{return} get\_number(input\_format\_t::msgpack, subtype) \&\&}
\DoxyCodeLine{10832                        get\_binary(input\_format\_t::msgpack, 16, result) \&\&}
\DoxyCodeLine{10833                        assign\_and\_return\_true(subtype);}
\DoxyCodeLine{10834             \}}
\DoxyCodeLine{10835 }
\DoxyCodeLine{10836             \textcolor{keywordflow}{default}:           \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{10837                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};  \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{10838         \}}
\DoxyCodeLine{10839     \}}
\DoxyCodeLine{10840 }
\DoxyCodeLine{10845     \textcolor{keywordtype}{bool} get\_msgpack\_array(\textcolor{keyword}{const} std::size\_t len)}
\DoxyCodeLine{10846     \{}
\DoxyCodeLine{10847         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(len)))}
\DoxyCodeLine{10848         \{}
\DoxyCodeLine{10849             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10850         \}}
\DoxyCodeLine{10851 }
\DoxyCodeLine{10852         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < len; ++i)}
\DoxyCodeLine{10853         \{}
\DoxyCodeLine{10854             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_msgpack\_internal()))}
\DoxyCodeLine{10855             \{}
\DoxyCodeLine{10856                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10857             \}}
\DoxyCodeLine{10858         \}}
\DoxyCodeLine{10859 }
\DoxyCodeLine{10860         \textcolor{keywordflow}{return} sax-\/>end\_array();}
\DoxyCodeLine{10861     \}}
\DoxyCodeLine{10862 }
\DoxyCodeLine{10867     \textcolor{keywordtype}{bool} get\_msgpack\_object(\textcolor{keyword}{const} std::size\_t len)}
\DoxyCodeLine{10868     \{}
\DoxyCodeLine{10869         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(len)))}
\DoxyCodeLine{10870         \{}
\DoxyCodeLine{10871             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10872         \}}
\DoxyCodeLine{10873 }
\DoxyCodeLine{10874         string\_t \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}};}
\DoxyCodeLine{10875         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < len; ++i)}
\DoxyCodeLine{10876         \{}
\DoxyCodeLine{10877             get();}
\DoxyCodeLine{10878             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_msgpack\_string(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}) || !sax-\/>key(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})))}
\DoxyCodeLine{10879             \{}
\DoxyCodeLine{10880                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10881             \}}
\DoxyCodeLine{10882 }
\DoxyCodeLine{10883             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_msgpack\_internal()))}
\DoxyCodeLine{10884             \{}
\DoxyCodeLine{10885                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10886             \}}
\DoxyCodeLine{10887             \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}.clear();}
\DoxyCodeLine{10888         \}}
\DoxyCodeLine{10889 }
\DoxyCodeLine{10890         \textcolor{keywordflow}{return} sax-\/>end\_object();}
\DoxyCodeLine{10891     \}}
\DoxyCodeLine{10892 }
\DoxyCodeLine{10894     \textcolor{comment}{// UBJSON //}}
\DoxyCodeLine{10896 \textcolor{comment}{}}
\DoxyCodeLine{10904     \textcolor{keywordtype}{bool} parse\_ubjson\_internal(\textcolor{keyword}{const} \textcolor{keywordtype}{bool} get\_char = \textcolor{keyword}{true})}
\DoxyCodeLine{10905     \{}
\DoxyCodeLine{10906         \textcolor{keywordflow}{return} get\_ubjson\_value(get\_char ? get\_ignore\_noop() : current);}
\DoxyCodeLine{10907     \}}
\DoxyCodeLine{10908 }
\DoxyCodeLine{10923     \textcolor{keywordtype}{bool} get\_ubjson\_string(string\_t\& result, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} get\_char = \textcolor{keyword}{true})}
\DoxyCodeLine{10924     \{}
\DoxyCodeLine{10925         \textcolor{keywordflow}{if} (get\_char)}
\DoxyCodeLine{10926         \{}
\DoxyCodeLine{10927             get();  \textcolor{comment}{// TODO(niels): may we ignore N here?}}
\DoxyCodeLine{10928         \}}
\DoxyCodeLine{10929 }
\DoxyCodeLine{10930         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}value"{}})))}
\DoxyCodeLine{10931         \{}
\DoxyCodeLine{10932             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10933         \}}
\DoxyCodeLine{10934 }
\DoxyCodeLine{10935         \textcolor{keywordflow}{switch} (current)}
\DoxyCodeLine{10936         \{}
\DoxyCodeLine{10937             \textcolor{keywordflow}{case} \textcolor{charliteral}{'U'}:}
\DoxyCodeLine{10938             \{}
\DoxyCodeLine{10939                 std::uint8\_t len\{\};}
\DoxyCodeLine{10940                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{10941             \}}
\DoxyCodeLine{10942 }
\DoxyCodeLine{10943             \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}:}
\DoxyCodeLine{10944             \{}
\DoxyCodeLine{10945                 std::int8\_t len\{\};}
\DoxyCodeLine{10946                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{10947             \}}
\DoxyCodeLine{10948 }
\DoxyCodeLine{10949             \textcolor{keywordflow}{case} \textcolor{charliteral}{'I'}:}
\DoxyCodeLine{10950             \{}
\DoxyCodeLine{10951                 std::int16\_t len\{\};}
\DoxyCodeLine{10952                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{10953             \}}
\DoxyCodeLine{10954 }
\DoxyCodeLine{10955             \textcolor{keywordflow}{case} \textcolor{charliteral}{'l'}:}
\DoxyCodeLine{10956             \{}
\DoxyCodeLine{10957                 std::int32\_t len\{\};}
\DoxyCodeLine{10958                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{10959             \}}
\DoxyCodeLine{10960 }
\DoxyCodeLine{10961             \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:}
\DoxyCodeLine{10962             \{}
\DoxyCodeLine{10963                 std::int64\_t len\{\};}
\DoxyCodeLine{10964                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{10965             \}}
\DoxyCodeLine{10966 }
\DoxyCodeLine{10967             \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{10968             \{}
\DoxyCodeLine{10969                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{10970                 \{}
\DoxyCodeLine{10971                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{10972                 \}}
\DoxyCodeLine{10973                 std::uint16\_t len\{\};}
\DoxyCodeLine{10974                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{10975             \}}
\DoxyCodeLine{10976 }
\DoxyCodeLine{10977             \textcolor{keywordflow}{case} \textcolor{charliteral}{'m'}:}
\DoxyCodeLine{10978             \{}
\DoxyCodeLine{10979                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{10980                 \{}
\DoxyCodeLine{10981                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{10982                 \}}
\DoxyCodeLine{10983                 std::uint32\_t len\{\};}
\DoxyCodeLine{10984                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{10985             \}}
\DoxyCodeLine{10986 }
\DoxyCodeLine{10987             \textcolor{keywordflow}{case} \textcolor{charliteral}{'M'}:}
\DoxyCodeLine{10988             \{}
\DoxyCodeLine{10989                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{10990                 \{}
\DoxyCodeLine{10991                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{10992                 \}}
\DoxyCodeLine{10993                 std::uint64\_t len\{\};}
\DoxyCodeLine{10994                 \textcolor{keywordflow}{return} get\_number(input\_format, len) \&\& get\_string(input\_format, len, result);}
\DoxyCodeLine{10995             \}}
\DoxyCodeLine{10996 }
\DoxyCodeLine{10997             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{10998                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{10999         \}}
\DoxyCodeLine{11000         \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{11001         std::string message;}
\DoxyCodeLine{11002 }
\DoxyCodeLine{11003         \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{11004         \{}
\DoxyCodeLine{11005             message = \textcolor{stringliteral}{"{}expected length type specification (U, i, I, l, L); last byte: 0x"{}} + last\_token;}
\DoxyCodeLine{11006         \}}
\DoxyCodeLine{11007         \textcolor{keywordflow}{else}}
\DoxyCodeLine{11008         \{}
\DoxyCodeLine{11009             message = \textcolor{stringliteral}{"{}expected length type specification (U, i, u, I, m, l, M, L); last byte: 0x"{}} + last\_token;}
\DoxyCodeLine{11010         \}}
\DoxyCodeLine{11011         \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(113, chars\_read, exception\_message(input\_format, message, \textcolor{stringliteral}{"{}string"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11012     \}}
\DoxyCodeLine{11013 }
\DoxyCodeLine{11018     \textcolor{keywordtype}{bool} get\_ubjson\_ndarray\_size(std::vector<size\_t>\& dim)}
\DoxyCodeLine{11019     \{}
\DoxyCodeLine{11020         std::pair<std::size\_t, char\_int\_type> size\_and\_type;}
\DoxyCodeLine{11021         \textcolor{keywordtype}{size\_t} dimlen = 0;}
\DoxyCodeLine{11022         \textcolor{keywordtype}{bool} no\_ndarray = \textcolor{keyword}{true};}
\DoxyCodeLine{11023 }
\DoxyCodeLine{11024         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_type(size\_and\_type, no\_ndarray)))}
\DoxyCodeLine{11025         \{}
\DoxyCodeLine{11026             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11027         \}}
\DoxyCodeLine{11028 }
\DoxyCodeLine{11029         \textcolor{keywordflow}{if} (size\_and\_type.first != npos)}
\DoxyCodeLine{11030         \{}
\DoxyCodeLine{11031             \textcolor{keywordflow}{if} (size\_and\_type.second != 0)}
\DoxyCodeLine{11032             \{}
\DoxyCodeLine{11033                 \textcolor{keywordflow}{if} (size\_and\_type.second != \textcolor{charliteral}{'N'})}
\DoxyCodeLine{11034                 \{}
\DoxyCodeLine{11035                     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{11036                     \{}
\DoxyCodeLine{11037                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_value(dimlen, no\_ndarray, size\_and\_type.second)))}
\DoxyCodeLine{11038                         \{}
\DoxyCodeLine{11039                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11040                         \}}
\DoxyCodeLine{11041                         dim.push\_back(dimlen);}
\DoxyCodeLine{11042                     \}}
\DoxyCodeLine{11043                 \}}
\DoxyCodeLine{11044             \}}
\DoxyCodeLine{11045             \textcolor{keywordflow}{else}}
\DoxyCodeLine{11046             \{}
\DoxyCodeLine{11047                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{11048                 \{}
\DoxyCodeLine{11049                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_value(dimlen, no\_ndarray)))}
\DoxyCodeLine{11050                     \{}
\DoxyCodeLine{11051                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11052                     \}}
\DoxyCodeLine{11053                     dim.push\_back(dimlen);}
\DoxyCodeLine{11054                 \}}
\DoxyCodeLine{11055             \}}
\DoxyCodeLine{11056         \}}
\DoxyCodeLine{11057         \textcolor{keywordflow}{else}}
\DoxyCodeLine{11058         \{}
\DoxyCodeLine{11059             \textcolor{keywordflow}{while} (current != \textcolor{charliteral}{']'})}
\DoxyCodeLine{11060             \{}
\DoxyCodeLine{11061                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_value(dimlen, no\_ndarray, current)))}
\DoxyCodeLine{11062                 \{}
\DoxyCodeLine{11063                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11064                 \}}
\DoxyCodeLine{11065                 dim.push\_back(dimlen);}
\DoxyCodeLine{11066                 get\_ignore\_noop();}
\DoxyCodeLine{11067             \}}
\DoxyCodeLine{11068         \}}
\DoxyCodeLine{11069         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11070     \}}
\DoxyCodeLine{11071 }
\DoxyCodeLine{11083     \textcolor{keywordtype}{bool} get\_ubjson\_size\_value(std::size\_t\& result, \textcolor{keywordtype}{bool}\& is\_ndarray, char\_int\_type prefix = 0)}
\DoxyCodeLine{11084     \{}
\DoxyCodeLine{11085         \textcolor{keywordflow}{if} (prefix == 0)}
\DoxyCodeLine{11086         \{}
\DoxyCodeLine{11087             prefix = get\_ignore\_noop();}
\DoxyCodeLine{11088         \}}
\DoxyCodeLine{11089 }
\DoxyCodeLine{11090         \textcolor{keywordflow}{switch} (prefix)}
\DoxyCodeLine{11091         \{}
\DoxyCodeLine{11092             \textcolor{keywordflow}{case} \textcolor{charliteral}{'U'}:}
\DoxyCodeLine{11093             \{}
\DoxyCodeLine{11094                 std::uint8\_t number\{\};}
\DoxyCodeLine{11095                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{11096                 \{}
\DoxyCodeLine{11097                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11098                 \}}
\DoxyCodeLine{11099                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number);}
\DoxyCodeLine{11100                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11101             \}}
\DoxyCodeLine{11102 }
\DoxyCodeLine{11103             \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}:}
\DoxyCodeLine{11104             \{}
\DoxyCodeLine{11105                 std::int8\_t number\{\};}
\DoxyCodeLine{11106                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{11107                 \{}
\DoxyCodeLine{11108                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11109                 \}}
\DoxyCodeLine{11110                 \textcolor{keywordflow}{if} (number < 0)}
\DoxyCodeLine{11111                 \{}
\DoxyCodeLine{11112                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), parse\_error::create(113, chars\_read,}
\DoxyCodeLine{11113                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}count in an optimized container must be positive"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11114                 \}}
\DoxyCodeLine{11115                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number); \textcolor{comment}{// NOLINT(bugprone-\/signed-\/char-\/misuse,cert-\/str34-\/c): number is not a char}}
\DoxyCodeLine{11116                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11117             \}}
\DoxyCodeLine{11118 }
\DoxyCodeLine{11119             \textcolor{keywordflow}{case} \textcolor{charliteral}{'I'}:}
\DoxyCodeLine{11120             \{}
\DoxyCodeLine{11121                 std::int16\_t number\{\};}
\DoxyCodeLine{11122                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{11123                 \{}
\DoxyCodeLine{11124                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11125                 \}}
\DoxyCodeLine{11126                 \textcolor{keywordflow}{if} (number < 0)}
\DoxyCodeLine{11127                 \{}
\DoxyCodeLine{11128                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), parse\_error::create(113, chars\_read,}
\DoxyCodeLine{11129                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}count in an optimized container must be positive"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11130                 \}}
\DoxyCodeLine{11131                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number);}
\DoxyCodeLine{11132                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11133             \}}
\DoxyCodeLine{11134 }
\DoxyCodeLine{11135             \textcolor{keywordflow}{case} \textcolor{charliteral}{'l'}:}
\DoxyCodeLine{11136             \{}
\DoxyCodeLine{11137                 std::int32\_t number\{\};}
\DoxyCodeLine{11138                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{11139                 \{}
\DoxyCodeLine{11140                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11141                 \}}
\DoxyCodeLine{11142                 \textcolor{keywordflow}{if} (number < 0)}
\DoxyCodeLine{11143                 \{}
\DoxyCodeLine{11144                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), parse\_error::create(113, chars\_read,}
\DoxyCodeLine{11145                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}count in an optimized container must be positive"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11146                 \}}
\DoxyCodeLine{11147                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number);}
\DoxyCodeLine{11148                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11149             \}}
\DoxyCodeLine{11150 }
\DoxyCodeLine{11151             \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:}
\DoxyCodeLine{11152             \{}
\DoxyCodeLine{11153                 std::int64\_t number\{\};}
\DoxyCodeLine{11154                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{11155                 \{}
\DoxyCodeLine{11156                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11157                 \}}
\DoxyCodeLine{11158                 \textcolor{keywordflow}{if} (number < 0)}
\DoxyCodeLine{11159                 \{}
\DoxyCodeLine{11160                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), parse\_error::create(113, chars\_read,}
\DoxyCodeLine{11161                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}count in an optimized container must be positive"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11162                 \}}
\DoxyCodeLine{11163                 \textcolor{keywordflow}{if} (!value\_in\_range\_of<std::size\_t>(number))}
\DoxyCodeLine{11164                 \{}
\DoxyCodeLine{11165                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), out\_of\_range::create(408,}
\DoxyCodeLine{11166                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}integer value overflow"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11167                 \}}
\DoxyCodeLine{11168                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number);}
\DoxyCodeLine{11169                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11170             \}}
\DoxyCodeLine{11171 }
\DoxyCodeLine{11172             \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{11173             \{}
\DoxyCodeLine{11174                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{11175                 \{}
\DoxyCodeLine{11176                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{11177                 \}}
\DoxyCodeLine{11178                 std::uint16\_t number\{\};}
\DoxyCodeLine{11179                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{11180                 \{}
\DoxyCodeLine{11181                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11182                 \}}
\DoxyCodeLine{11183                 result = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(number);}
\DoxyCodeLine{11184                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11185             \}}
\DoxyCodeLine{11186 }
\DoxyCodeLine{11187             \textcolor{keywordflow}{case} \textcolor{charliteral}{'m'}:}
\DoxyCodeLine{11188             \{}
\DoxyCodeLine{11189                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{11190                 \{}
\DoxyCodeLine{11191                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{11192                 \}}
\DoxyCodeLine{11193                 std::uint32\_t number\{\};}
\DoxyCodeLine{11194                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{11195                 \{}
\DoxyCodeLine{11196                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11197                 \}}
\DoxyCodeLine{11198                 result = conditional\_static\_cast<std::size\_t>(number);}
\DoxyCodeLine{11199                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11200             \}}
\DoxyCodeLine{11201 }
\DoxyCodeLine{11202             \textcolor{keywordflow}{case} \textcolor{charliteral}{'M'}:}
\DoxyCodeLine{11203             \{}
\DoxyCodeLine{11204                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{11205                 \{}
\DoxyCodeLine{11206                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{11207                 \}}
\DoxyCodeLine{11208                 std::uint64\_t number\{\};}
\DoxyCodeLine{11209                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_number(input\_format, number)))}
\DoxyCodeLine{11210                 \{}
\DoxyCodeLine{11211                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11212                 \}}
\DoxyCodeLine{11213                 \textcolor{keywordflow}{if} (!value\_in\_range\_of<std::size\_t>(number))}
\DoxyCodeLine{11214                 \{}
\DoxyCodeLine{11215                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), out\_of\_range::create(408,}
\DoxyCodeLine{11216                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}integer value overflow"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11217                 \}}
\DoxyCodeLine{11218                 result = detail::conditional\_static\_cast<std::size\_t>(number);}
\DoxyCodeLine{11219                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11220             \}}
\DoxyCodeLine{11221 }
\DoxyCodeLine{11222             \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:}
\DoxyCodeLine{11223             \{}
\DoxyCodeLine{11224                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{11225                 \{}
\DoxyCodeLine{11226                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{11227                 \}}
\DoxyCodeLine{11228                 \textcolor{keywordflow}{if} (is\_ndarray) \textcolor{comment}{// ndarray dimensional vector can only contain integers, and can not embed another array}}
\DoxyCodeLine{11229                 \{}
\DoxyCodeLine{11230                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), parse\_error::create(113, chars\_read, exception\_message(input\_format, \textcolor{stringliteral}{"{}ndarray dimentional vector is not allowed"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11231                 \}}
\DoxyCodeLine{11232                 std::vector<size\_t> dim;}
\DoxyCodeLine{11233                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_ndarray\_size(dim)))}
\DoxyCodeLine{11234                 \{}
\DoxyCodeLine{11235                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11236                 \}}
\DoxyCodeLine{11237                 \textcolor{keywordflow}{if} (dim.size() == 1 || (dim.size() == 2 \&\& dim.at(0) == 1)) \textcolor{comment}{// return normal array size if 1D row vector}}
\DoxyCodeLine{11238                 \{}
\DoxyCodeLine{11239                     result = dim.at(dim.size() -\/ 1);}
\DoxyCodeLine{11240                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11241                 \}}
\DoxyCodeLine{11242                 \textcolor{keywordflow}{if} (!dim.empty())  \textcolor{comment}{// if ndarray, convert to an object in JData annotated array format}}
\DoxyCodeLine{11243                 \{}
\DoxyCodeLine{11244                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i : dim) \textcolor{comment}{// test if any dimension in an ndarray is 0, if so, return a 1D empty container}}
\DoxyCodeLine{11245                     \{}
\DoxyCodeLine{11246                         \textcolor{keywordflow}{if} ( i == 0 )}
\DoxyCodeLine{11247                         \{}
\DoxyCodeLine{11248                             result = 0;}
\DoxyCodeLine{11249                             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11250                         \}}
\DoxyCodeLine{11251                     \}}
\DoxyCodeLine{11252 }
\DoxyCodeLine{11253                     string\_t \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}} = \textcolor{stringliteral}{"{}\_ArraySize\_"{}};}
\DoxyCodeLine{11254                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(3) || !sax-\/>key(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}) || !sax-\/>start\_array(dim.size())))}
\DoxyCodeLine{11255                     \{}
\DoxyCodeLine{11256                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11257                     \}}
\DoxyCodeLine{11258                     result = 1;}
\DoxyCodeLine{11259                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i : dim)}
\DoxyCodeLine{11260                     \{}
\DoxyCodeLine{11261                         result *= i;}
\DoxyCodeLine{11262                         \textcolor{keywordflow}{if} (result == 0 || result == npos) \textcolor{comment}{// because dim elements shall not have zeros, result = 0 means overflow happened; it also can't be npos as it is used to initialize size in get\_ubjson\_size\_type()}}
\DoxyCodeLine{11263                         \{}
\DoxyCodeLine{11264                             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), out\_of\_range::create(408, exception\_message(input\_format, \textcolor{stringliteral}{"{}excessive ndarray size caused overflow"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11265                         \}}
\DoxyCodeLine{11266                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>number\_unsigned(\textcolor{keyword}{static\_cast<}number\_unsigned\_t\textcolor{keyword}{>}(i))))}
\DoxyCodeLine{11267                         \{}
\DoxyCodeLine{11268                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11269                         \}}
\DoxyCodeLine{11270                     \}}
\DoxyCodeLine{11271                     is\_ndarray = \textcolor{keyword}{true};}
\DoxyCodeLine{11272                     \textcolor{keywordflow}{return} sax-\/>end\_array();}
\DoxyCodeLine{11273                 \}}
\DoxyCodeLine{11274                 result = 0;}
\DoxyCodeLine{11275                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11276             \}}
\DoxyCodeLine{11277 }
\DoxyCodeLine{11278             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{11279                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11280         \}}
\DoxyCodeLine{11281         \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{11282         std::string message;}
\DoxyCodeLine{11283 }
\DoxyCodeLine{11284         \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{11285         \{}
\DoxyCodeLine{11286             message = \textcolor{stringliteral}{"{}expected length type specification (U, i, I, l, L) after '\#'; last byte: 0x"{}} + last\_token;}
\DoxyCodeLine{11287         \}}
\DoxyCodeLine{11288         \textcolor{keywordflow}{else}}
\DoxyCodeLine{11289         \{}
\DoxyCodeLine{11290             message = \textcolor{stringliteral}{"{}expected length type specification (U, i, u, I, m, l, M, L) after '\#'; last byte: 0x"{}} + last\_token;}
\DoxyCodeLine{11291         \}}
\DoxyCodeLine{11292         \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(113, chars\_read, exception\_message(input\_format, message, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11293     \}}
\DoxyCodeLine{11294 }
\DoxyCodeLine{11306     \textcolor{keywordtype}{bool} get\_ubjson\_size\_type(std::pair<std::size\_t, char\_int\_type>\& result, \textcolor{keywordtype}{bool} inside\_ndarray = \textcolor{keyword}{false})}
\DoxyCodeLine{11307     \{}
\DoxyCodeLine{11308         result.first = npos; \textcolor{comment}{// size}}
\DoxyCodeLine{11309         result.second = 0; \textcolor{comment}{// type}}
\DoxyCodeLine{11310         \textcolor{keywordtype}{bool} is\_ndarray = \textcolor{keyword}{false};}
\DoxyCodeLine{11311 }
\DoxyCodeLine{11312         get\_ignore\_noop();}
\DoxyCodeLine{11313 }
\DoxyCodeLine{11314         \textcolor{keywordflow}{if} (current == \textcolor{charliteral}{'\$'})}
\DoxyCodeLine{11315         \{}
\DoxyCodeLine{11316             result.second = get();  \textcolor{comment}{// must not ignore 'N', because 'N' maybe the type}}
\DoxyCodeLine{11317             \textcolor{keywordflow}{if} (input\_format == input\_format\_t::bjdata}
\DoxyCodeLine{11318                     \&\& JSON\_HEDLEY\_UNLIKELY(std::binary\_search(bjd\_optimized\_type\_markers.begin(), bjd\_optimized\_type\_markers.end(), result.second)))}
\DoxyCodeLine{11319             \{}
\DoxyCodeLine{11320                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{11321                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(112, chars\_read,}
\DoxyCodeLine{11322                                         exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}marker 0x"{}}, last\_token, \textcolor{stringliteral}{"{} is not a permitted optimized array type"{}}), \textcolor{stringliteral}{"{}type"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11323             \}}
\DoxyCodeLine{11324 }
\DoxyCodeLine{11325             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}type"{}})))}
\DoxyCodeLine{11326             \{}
\DoxyCodeLine{11327                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11328             \}}
\DoxyCodeLine{11329 }
\DoxyCodeLine{11330             get\_ignore\_noop();}
\DoxyCodeLine{11331             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(current != \textcolor{charliteral}{'\#'}))}
\DoxyCodeLine{11332             \{}
\DoxyCodeLine{11333                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}value"{}})))}
\DoxyCodeLine{11334                 \{}
\DoxyCodeLine{11335                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11336                 \}}
\DoxyCodeLine{11337                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{11338                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(112, chars\_read,}
\DoxyCodeLine{11339                                         exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}expected '\#' after type information; last byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11340             \}}
\DoxyCodeLine{11341 }
\DoxyCodeLine{11342             \textcolor{keywordtype}{bool} is\_error = get\_ubjson\_size\_value(result.first, is\_ndarray);}
\DoxyCodeLine{11343             \textcolor{keywordflow}{if} (input\_format == input\_format\_t::bjdata \&\& is\_ndarray)}
\DoxyCodeLine{11344             \{}
\DoxyCodeLine{11345                 \textcolor{keywordflow}{if} (inside\_ndarray)}
\DoxyCodeLine{11346                 \{}
\DoxyCodeLine{11347                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), parse\_error::create(112, chars\_read,}
\DoxyCodeLine{11348                                             exception\_message(input\_format, \textcolor{stringliteral}{"{}ndarray can not be recursive"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11349                 \}}
\DoxyCodeLine{11350                 result.second |= (1 << 8); \textcolor{comment}{// use bit 8 to indicate ndarray, all UBJSON and BJData markers should be ASCII letters}}
\DoxyCodeLine{11351             \}}
\DoxyCodeLine{11352             \textcolor{keywordflow}{return} is\_error;}
\DoxyCodeLine{11353         \}}
\DoxyCodeLine{11354 }
\DoxyCodeLine{11355         \textcolor{keywordflow}{if} (current == \textcolor{charliteral}{'\#'})}
\DoxyCodeLine{11356         \{}
\DoxyCodeLine{11357             \textcolor{keywordtype}{bool} is\_error = get\_ubjson\_size\_value(result.first, is\_ndarray);}
\DoxyCodeLine{11358             \textcolor{keywordflow}{if} (input\_format == input\_format\_t::bjdata \&\& is\_ndarray)}
\DoxyCodeLine{11359             \{}
\DoxyCodeLine{11360                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, get\_token\_string(), parse\_error::create(112, chars\_read,}
\DoxyCodeLine{11361                                         exception\_message(input\_format, \textcolor{stringliteral}{"{}ndarray requires both type and size"{}}, \textcolor{stringliteral}{"{}size"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11362             \}}
\DoxyCodeLine{11363             \textcolor{keywordflow}{return} is\_error;}
\DoxyCodeLine{11364         \}}
\DoxyCodeLine{11365 }
\DoxyCodeLine{11366         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11367     \}}
\DoxyCodeLine{11368 }
\DoxyCodeLine{11373     \textcolor{keywordtype}{bool} get\_ubjson\_value(\textcolor{keyword}{const} char\_int\_type prefix)}
\DoxyCodeLine{11374     \{}
\DoxyCodeLine{11375         \textcolor{keywordflow}{switch} (prefix)}
\DoxyCodeLine{11376         \{}
\DoxyCodeLine{11377             \textcolor{keywordflow}{case} std::char\_traits<char\_type>::eof():  \textcolor{comment}{// EOF}}
\DoxyCodeLine{11378                 return unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}value"{}});}
\DoxyCodeLine{11379 }
\DoxyCodeLine{11380             \textcolor{keywordflow}{case} \textcolor{charliteral}{'T'}:  \textcolor{comment}{// true}}
\DoxyCodeLine{11381                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{true});}
\DoxyCodeLine{11382             \textcolor{keywordflow}{case} \textcolor{charliteral}{'F'}:  \textcolor{comment}{// false}}
\DoxyCodeLine{11383                 \textcolor{keywordflow}{return} sax-\/>boolean(\textcolor{keyword}{false});}
\DoxyCodeLine{11384 }
\DoxyCodeLine{11385             \textcolor{keywordflow}{case} \textcolor{charliteral}{'Z'}:  \textcolor{comment}{// null}}
\DoxyCodeLine{11386                 \textcolor{keywordflow}{return} sax-\/>null();}
\DoxyCodeLine{11387 }
\DoxyCodeLine{11388             \textcolor{keywordflow}{case} \textcolor{charliteral}{'U'}:}
\DoxyCodeLine{11389             \{}
\DoxyCodeLine{11390                 std::uint8\_t number\{\};}
\DoxyCodeLine{11391                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{11392             \}}
\DoxyCodeLine{11393 }
\DoxyCodeLine{11394             \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}:}
\DoxyCodeLine{11395             \{}
\DoxyCodeLine{11396                 std::int8\_t number\{\};}
\DoxyCodeLine{11397                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{11398             \}}
\DoxyCodeLine{11399 }
\DoxyCodeLine{11400             \textcolor{keywordflow}{case} \textcolor{charliteral}{'I'}:}
\DoxyCodeLine{11401             \{}
\DoxyCodeLine{11402                 std::int16\_t number\{\};}
\DoxyCodeLine{11403                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{11404             \}}
\DoxyCodeLine{11405 }
\DoxyCodeLine{11406             \textcolor{keywordflow}{case} \textcolor{charliteral}{'l'}:}
\DoxyCodeLine{11407             \{}
\DoxyCodeLine{11408                 std::int32\_t number\{\};}
\DoxyCodeLine{11409                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{11410             \}}
\DoxyCodeLine{11411 }
\DoxyCodeLine{11412             \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:}
\DoxyCodeLine{11413             \{}
\DoxyCodeLine{11414                 std::int64\_t number\{\};}
\DoxyCodeLine{11415                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_integer(number);}
\DoxyCodeLine{11416             \}}
\DoxyCodeLine{11417 }
\DoxyCodeLine{11418             \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}:}
\DoxyCodeLine{11419             \{}
\DoxyCodeLine{11420                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{11421                 \{}
\DoxyCodeLine{11422                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{11423                 \}}
\DoxyCodeLine{11424                 std::uint16\_t number\{\};}
\DoxyCodeLine{11425                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{11426             \}}
\DoxyCodeLine{11427 }
\DoxyCodeLine{11428             \textcolor{keywordflow}{case} \textcolor{charliteral}{'m'}:}
\DoxyCodeLine{11429             \{}
\DoxyCodeLine{11430                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{11431                 \{}
\DoxyCodeLine{11432                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{11433                 \}}
\DoxyCodeLine{11434                 std::uint32\_t number\{\};}
\DoxyCodeLine{11435                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{11436             \}}
\DoxyCodeLine{11437 }
\DoxyCodeLine{11438             \textcolor{keywordflow}{case} \textcolor{charliteral}{'M'}:}
\DoxyCodeLine{11439             \{}
\DoxyCodeLine{11440                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{11441                 \{}
\DoxyCodeLine{11442                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{11443                 \}}
\DoxyCodeLine{11444                 std::uint64\_t number\{\};}
\DoxyCodeLine{11445                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_unsigned(number);}
\DoxyCodeLine{11446             \}}
\DoxyCodeLine{11447 }
\DoxyCodeLine{11448             \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}:}
\DoxyCodeLine{11449             \{}
\DoxyCodeLine{11450                 \textcolor{keywordflow}{if} (input\_format != input\_format\_t::bjdata)}
\DoxyCodeLine{11451                 \{}
\DoxyCodeLine{11452                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{11453                 \}}
\DoxyCodeLine{11454                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte1\_raw = get();}
\DoxyCodeLine{11455                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{11456                 \{}
\DoxyCodeLine{11457                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11458                 \}}
\DoxyCodeLine{11459                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte2\_raw = get();}
\DoxyCodeLine{11460                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{11461                 \{}
\DoxyCodeLine{11462                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11463                 \}}
\DoxyCodeLine{11464 }
\DoxyCodeLine{11465                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte1 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(byte1\_raw);}
\DoxyCodeLine{11466                 \textcolor{keyword}{const} \textcolor{keyword}{auto} byte2 = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(byte2\_raw);}
\DoxyCodeLine{11467 }
\DoxyCodeLine{11468                 \textcolor{comment}{// code from RFC 7049, Appendix D, Figure 3:}}
\DoxyCodeLine{11469                 \textcolor{comment}{// As half-\/precision floating-\/point numbers were only added}}
\DoxyCodeLine{11470                 \textcolor{comment}{// to IEEE 754 in 2008, today's programming platforms often}}
\DoxyCodeLine{11471                 \textcolor{comment}{// still only have limited support for them. It is very}}
\DoxyCodeLine{11472                 \textcolor{comment}{// easy to include at least decoding support for them even}}
\DoxyCodeLine{11473                 \textcolor{comment}{// without such support. An example of a small decoder for}}
\DoxyCodeLine{11474                 \textcolor{comment}{// half-\/precision floating-\/point numbers in the C language}}
\DoxyCodeLine{11475                 \textcolor{comment}{// is shown in Fig. 3.}}
\DoxyCodeLine{11476                 \textcolor{keyword}{const} \textcolor{keyword}{auto} half = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}((byte2 << 8u) + byte1);}
\DoxyCodeLine{11477                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} val = [\&half]}
\DoxyCodeLine{11478                 \{}
\DoxyCodeLine{11479                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} exp = (half >> 10u) \& 0x1Fu;}
\DoxyCodeLine{11480                     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mant = half \& 0x3FFu;}
\DoxyCodeLine{11481                     JSON\_ASSERT(0 <= exp\&\& exp <= 32);}
\DoxyCodeLine{11482                     JSON\_ASSERT(mant <= 1024);}
\DoxyCodeLine{11483                     \textcolor{keywordflow}{switch} (exp)}
\DoxyCodeLine{11484                     \{}
\DoxyCodeLine{11485                         \textcolor{keywordflow}{case} 0:}
\DoxyCodeLine{11486                             \textcolor{keywordflow}{return} std::ldexp(mant, -\/24);}
\DoxyCodeLine{11487                         \textcolor{keywordflow}{case} 31:}
\DoxyCodeLine{11488                             \textcolor{keywordflow}{return} (mant == 0)}
\DoxyCodeLine{11489                             ? std::numeric\_limits<double>::infinity()}
\DoxyCodeLine{11490                             : std::numeric\_limits<double>::quiet\_NaN();}
\DoxyCodeLine{11491                         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{11492                             \textcolor{keywordflow}{return} std::ldexp(mant + 1024, exp -\/ 25);}
\DoxyCodeLine{11493                     \}}
\DoxyCodeLine{11494                 \}();}
\DoxyCodeLine{11495                 \textcolor{keywordflow}{return} sax-\/>number\_float((half \& 0x8000u) != 0}
\DoxyCodeLine{11496                                          ? \textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(-\/val)}
\DoxyCodeLine{11497                                          : \textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(val), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{11498             \}}
\DoxyCodeLine{11499 }
\DoxyCodeLine{11500             \textcolor{keywordflow}{case} \textcolor{charliteral}{'d'}:}
\DoxyCodeLine{11501             \{}
\DoxyCodeLine{11502                 \textcolor{keywordtype}{float} number\{\};}
\DoxyCodeLine{11503                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{11504             \}}
\DoxyCodeLine{11505 }
\DoxyCodeLine{11506             \textcolor{keywordflow}{case} \textcolor{charliteral}{'D'}:}
\DoxyCodeLine{11507             \{}
\DoxyCodeLine{11508                 \textcolor{keywordtype}{double} number\{\};}
\DoxyCodeLine{11509                 \textcolor{keywordflow}{return} get\_number(input\_format, number) \&\& sax-\/>number\_float(\textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(number), \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{11510             \}}
\DoxyCodeLine{11511 }
\DoxyCodeLine{11512             \textcolor{keywordflow}{case} \textcolor{charliteral}{'H'}:}
\DoxyCodeLine{11513             \{}
\DoxyCodeLine{11514                 \textcolor{keywordflow}{return} get\_ubjson\_high\_precision\_number();}
\DoxyCodeLine{11515             \}}
\DoxyCodeLine{11516 }
\DoxyCodeLine{11517             \textcolor{keywordflow}{case} \textcolor{charliteral}{'C'}:  \textcolor{comment}{// char}}
\DoxyCodeLine{11518             \{}
\DoxyCodeLine{11519                 get();}
\DoxyCodeLine{11520                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}char"{}})))}
\DoxyCodeLine{11521                 \{}
\DoxyCodeLine{11522                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11523                 \}}
\DoxyCodeLine{11524                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(current > 127))}
\DoxyCodeLine{11525                 \{}
\DoxyCodeLine{11526                     \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{11527                     \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(113, chars\_read,}
\DoxyCodeLine{11528                                             exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}byte after 'C' must be in range 0x00..0x7F; last byte: 0x"{}}, last\_token), \textcolor{stringliteral}{"{}char"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11529                 \}}
\DoxyCodeLine{11530                 string\_t s(1, \textcolor{keyword}{static\_cast<}typename string\_t::value\_type\textcolor{keyword}{>}(current));}
\DoxyCodeLine{11531                 \textcolor{keywordflow}{return} sax-\/>string(s);}
\DoxyCodeLine{11532             \}}
\DoxyCodeLine{11533 }
\DoxyCodeLine{11534             \textcolor{keywordflow}{case} \textcolor{charliteral}{'S'}:  \textcolor{comment}{// string}}
\DoxyCodeLine{11535             \{}
\DoxyCodeLine{11536                 string\_t s;}
\DoxyCodeLine{11537                 \textcolor{keywordflow}{return} get\_ubjson\_string(s) \&\& sax-\/>string(s);}
\DoxyCodeLine{11538             \}}
\DoxyCodeLine{11539 }
\DoxyCodeLine{11540             \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:  \textcolor{comment}{// array}}
\DoxyCodeLine{11541                 \textcolor{keywordflow}{return} get\_ubjson\_array();}
\DoxyCodeLine{11542 }
\DoxyCodeLine{11543             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\{'}:  \textcolor{comment}{// object}}
\DoxyCodeLine{11544                 \textcolor{keywordflow}{return} get\_ubjson\_object();}
\DoxyCodeLine{11545 }
\DoxyCodeLine{11546             \textcolor{keywordflow}{default}: \textcolor{comment}{// anything else}}
\DoxyCodeLine{11547                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11548         \}}
\DoxyCodeLine{11549         \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{11550         \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(112, chars\_read, exception\_message(input\_format, \textcolor{stringliteral}{"{}invalid byte: 0x"{}} + last\_token, \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11551     \}}
\DoxyCodeLine{11552 }
\DoxyCodeLine{11556     \textcolor{keywordtype}{bool} get\_ubjson\_array()}
\DoxyCodeLine{11557     \{}
\DoxyCodeLine{11558         std::pair<std::size\_t, char\_int\_type> size\_and\_type;}
\DoxyCodeLine{11559         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_type(size\_and\_type)))}
\DoxyCodeLine{11560         \{}
\DoxyCodeLine{11561             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11562         \}}
\DoxyCodeLine{11563 }
\DoxyCodeLine{11564         \textcolor{comment}{// if bit-\/8 of size\_and\_type.second is set to 1, encode bjdata ndarray as an object in JData annotated array format (https://github.com/NeuroJSON/jdata):}}
\DoxyCodeLine{11565         \textcolor{comment}{// \{"{}\_ArrayType\_"{} : "{}typeid"{}, "{}\_ArraySize\_"{} : [n1, n2, ...], "{}\_ArrayData\_"{} : [v1, v2, ...]\}}}
\DoxyCodeLine{11566 }
\DoxyCodeLine{11567         \textcolor{keywordflow}{if} (input\_format == input\_format\_t::bjdata \&\& size\_and\_type.first != npos \&\& (size\_and\_type.second \& (1 << 8)) != 0)}
\DoxyCodeLine{11568         \{}
\DoxyCodeLine{11569             size\_and\_type.second \&= \string~(\textcolor{keyword}{static\_cast<}char\_int\_type\textcolor{keyword}{>}(1) << 8);  \textcolor{comment}{// use bit 8 to indicate ndarray, here we remove the bit to restore the type marker}}
\DoxyCodeLine{11570             \textcolor{keyword}{auto} it = std::lower\_bound(bjd\_types\_map.begin(), bjd\_types\_map.end(), size\_and\_type.second, [](\textcolor{keyword}{const} bjd\_type \& p, char\_int\_type t)}
\DoxyCodeLine{11571             \{}
\DoxyCodeLine{11572                 return p.first < t;}
\DoxyCodeLine{11573             \});}
\DoxyCodeLine{11574             string\_t \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}} = \textcolor{stringliteral}{"{}\_ArrayType\_"{}};}
\DoxyCodeLine{11575             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(it == bjd\_types\_map.end() || it-\/>first != size\_and\_type.second))}
\DoxyCodeLine{11576             \{}
\DoxyCodeLine{11577                 \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{11578                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(112, chars\_read,}
\DoxyCodeLine{11579                                         exception\_message(input\_format, \textcolor{stringliteral}{"{}invalid byte: 0x"{}} + last\_token, \textcolor{stringliteral}{"{}type"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11580             \}}
\DoxyCodeLine{11581 }
\DoxyCodeLine{11582             string\_t type = it-\/>second; \textcolor{comment}{// sax-\/>string() takes a reference}}
\DoxyCodeLine{11583             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>key(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}) || !sax-\/>string(type)))}
\DoxyCodeLine{11584             \{}
\DoxyCodeLine{11585                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11586             \}}
\DoxyCodeLine{11587 }
\DoxyCodeLine{11588             \textcolor{keywordflow}{if} (size\_and\_type.second == \textcolor{charliteral}{'C'})}
\DoxyCodeLine{11589             \{}
\DoxyCodeLine{11590                 size\_and\_type.second = \textcolor{charliteral}{'U'};}
\DoxyCodeLine{11591             \}}
\DoxyCodeLine{11592 }
\DoxyCodeLine{11593             \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}} = \textcolor{stringliteral}{"{}\_ArrayData\_"{}};}
\DoxyCodeLine{11594             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>key(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}) || !sax-\/>start\_array(size\_and\_type.first) ))}
\DoxyCodeLine{11595             \{}
\DoxyCodeLine{11596                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11597             \}}
\DoxyCodeLine{11598 }
\DoxyCodeLine{11599             \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{11600             \{}
\DoxyCodeLine{11601                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_value(size\_and\_type.second)))}
\DoxyCodeLine{11602                 \{}
\DoxyCodeLine{11603                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11604                 \}}
\DoxyCodeLine{11605             \}}
\DoxyCodeLine{11606 }
\DoxyCodeLine{11607             \textcolor{keywordflow}{return} (sax-\/>end\_array() \&\& sax-\/>end\_object());}
\DoxyCodeLine{11608         \}}
\DoxyCodeLine{11609 }
\DoxyCodeLine{11610         \textcolor{keywordflow}{if} (size\_and\_type.first != npos)}
\DoxyCodeLine{11611         \{}
\DoxyCodeLine{11612             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(size\_and\_type.first)))}
\DoxyCodeLine{11613             \{}
\DoxyCodeLine{11614                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11615             \}}
\DoxyCodeLine{11616 }
\DoxyCodeLine{11617             \textcolor{keywordflow}{if} (size\_and\_type.second != 0)}
\DoxyCodeLine{11618             \{}
\DoxyCodeLine{11619                 \textcolor{keywordflow}{if} (size\_and\_type.second != \textcolor{charliteral}{'N'})}
\DoxyCodeLine{11620                 \{}
\DoxyCodeLine{11621                     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{11622                     \{}
\DoxyCodeLine{11623                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_value(size\_and\_type.second)))}
\DoxyCodeLine{11624                         \{}
\DoxyCodeLine{11625                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11626                         \}}
\DoxyCodeLine{11627                     \}}
\DoxyCodeLine{11628                 \}}
\DoxyCodeLine{11629             \}}
\DoxyCodeLine{11630             \textcolor{keywordflow}{else}}
\DoxyCodeLine{11631             \{}
\DoxyCodeLine{11632                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{11633                 \{}
\DoxyCodeLine{11634                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_ubjson\_internal()))}
\DoxyCodeLine{11635                     \{}
\DoxyCodeLine{11636                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11637                     \}}
\DoxyCodeLine{11638                 \}}
\DoxyCodeLine{11639             \}}
\DoxyCodeLine{11640         \}}
\DoxyCodeLine{11641         \textcolor{keywordflow}{else}}
\DoxyCodeLine{11642         \{}
\DoxyCodeLine{11643             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))))}
\DoxyCodeLine{11644             \{}
\DoxyCodeLine{11645                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11646             \}}
\DoxyCodeLine{11647 }
\DoxyCodeLine{11648             \textcolor{keywordflow}{while} (current != \textcolor{charliteral}{']'})}
\DoxyCodeLine{11649             \{}
\DoxyCodeLine{11650                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_ubjson\_internal(\textcolor{keyword}{false})))}
\DoxyCodeLine{11651                 \{}
\DoxyCodeLine{11652                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11653                 \}}
\DoxyCodeLine{11654                 get\_ignore\_noop();}
\DoxyCodeLine{11655             \}}
\DoxyCodeLine{11656         \}}
\DoxyCodeLine{11657 }
\DoxyCodeLine{11658         \textcolor{keywordflow}{return} sax-\/>end\_array();}
\DoxyCodeLine{11659     \}}
\DoxyCodeLine{11660 }
\DoxyCodeLine{11664     \textcolor{keywordtype}{bool} get\_ubjson\_object()}
\DoxyCodeLine{11665     \{}
\DoxyCodeLine{11666         std::pair<std::size\_t, char\_int\_type> size\_and\_type;}
\DoxyCodeLine{11667         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_size\_type(size\_and\_type)))}
\DoxyCodeLine{11668         \{}
\DoxyCodeLine{11669             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11670         \}}
\DoxyCodeLine{11671 }
\DoxyCodeLine{11672         \textcolor{comment}{// do not accept ND-\/array size in objects in BJData}}
\DoxyCodeLine{11673         \textcolor{keywordflow}{if} (input\_format == input\_format\_t::bjdata \&\& size\_and\_type.first != npos \&\& (size\_and\_type.second \& (1 << 8)) != 0)}
\DoxyCodeLine{11674         \{}
\DoxyCodeLine{11675             \textcolor{keyword}{auto} last\_token = get\_token\_string();}
\DoxyCodeLine{11676             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, last\_token, parse\_error::create(112, chars\_read,}
\DoxyCodeLine{11677                                     exception\_message(input\_format, \textcolor{stringliteral}{"{}BJData object does not support ND-\/array size in optimized format"{}}, \textcolor{stringliteral}{"{}object"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11678         \}}
\DoxyCodeLine{11679 }
\DoxyCodeLine{11680         string\_t \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}};}
\DoxyCodeLine{11681         \textcolor{keywordflow}{if} (size\_and\_type.first != npos)}
\DoxyCodeLine{11682         \{}
\DoxyCodeLine{11683             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(size\_and\_type.first)))}
\DoxyCodeLine{11684             \{}
\DoxyCodeLine{11685                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11686             \}}
\DoxyCodeLine{11687 }
\DoxyCodeLine{11688             \textcolor{keywordflow}{if} (size\_and\_type.second != 0)}
\DoxyCodeLine{11689             \{}
\DoxyCodeLine{11690                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{11691                 \{}
\DoxyCodeLine{11692                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_string(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}) || !sax-\/>key(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})))}
\DoxyCodeLine{11693                     \{}
\DoxyCodeLine{11694                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11695                     \}}
\DoxyCodeLine{11696                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_value(size\_and\_type.second)))}
\DoxyCodeLine{11697                     \{}
\DoxyCodeLine{11698                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11699                     \}}
\DoxyCodeLine{11700                     \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}.clear();}
\DoxyCodeLine{11701                 \}}
\DoxyCodeLine{11702             \}}
\DoxyCodeLine{11703             \textcolor{keywordflow}{else}}
\DoxyCodeLine{11704             \{}
\DoxyCodeLine{11705                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size\_and\_type.first; ++i)}
\DoxyCodeLine{11706                 \{}
\DoxyCodeLine{11707                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_string(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}) || !sax-\/>key(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})))}
\DoxyCodeLine{11708                     \{}
\DoxyCodeLine{11709                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11710                     \}}
\DoxyCodeLine{11711                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_ubjson\_internal()))}
\DoxyCodeLine{11712                     \{}
\DoxyCodeLine{11713                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11714                     \}}
\DoxyCodeLine{11715                     \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}.clear();}
\DoxyCodeLine{11716                 \}}
\DoxyCodeLine{11717             \}}
\DoxyCodeLine{11718         \}}
\DoxyCodeLine{11719         \textcolor{keywordflow}{else}}
\DoxyCodeLine{11720         \{}
\DoxyCodeLine{11721             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))))}
\DoxyCodeLine{11722             \{}
\DoxyCodeLine{11723                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11724             \}}
\DoxyCodeLine{11725 }
\DoxyCodeLine{11726             \textcolor{keywordflow}{while} (current != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{11727             \{}
\DoxyCodeLine{11728                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!get\_ubjson\_string(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, \textcolor{keyword}{false}) || !sax-\/>key(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})))}
\DoxyCodeLine{11729                 \{}
\DoxyCodeLine{11730                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11731                 \}}
\DoxyCodeLine{11732                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!parse\_ubjson\_internal()))}
\DoxyCodeLine{11733                 \{}
\DoxyCodeLine{11734                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11735                 \}}
\DoxyCodeLine{11736                 get\_ignore\_noop();}
\DoxyCodeLine{11737                 \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}.clear();}
\DoxyCodeLine{11738             \}}
\DoxyCodeLine{11739         \}}
\DoxyCodeLine{11740 }
\DoxyCodeLine{11741         \textcolor{keywordflow}{return} sax-\/>end\_object();}
\DoxyCodeLine{11742     \}}
\DoxyCodeLine{11743 }
\DoxyCodeLine{11744     \textcolor{comment}{// Note, no reader for UBJSON binary types is implemented because they do}}
\DoxyCodeLine{11745     \textcolor{comment}{// not exist}}
\DoxyCodeLine{11746 }
\DoxyCodeLine{11747     \textcolor{keywordtype}{bool} get\_ubjson\_high\_precision\_number()}
\DoxyCodeLine{11748     \{}
\DoxyCodeLine{11749         \textcolor{comment}{// get size of following number string}}
\DoxyCodeLine{11750         std::size\_t size\{\};}
\DoxyCodeLine{11751         \textcolor{keywordtype}{bool} no\_ndarray = \textcolor{keyword}{true};}
\DoxyCodeLine{11752         \textcolor{keyword}{auto} res = get\_ubjson\_size\_value(size, no\_ndarray);}
\DoxyCodeLine{11753         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!res))}
\DoxyCodeLine{11754         \{}
\DoxyCodeLine{11755             \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{11756         \}}
\DoxyCodeLine{11757 }
\DoxyCodeLine{11758         \textcolor{comment}{// get number string}}
\DoxyCodeLine{11759         std::vector<char> number\_vector;}
\DoxyCodeLine{11760         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < size; ++i)}
\DoxyCodeLine{11761         \{}
\DoxyCodeLine{11762             get();}
\DoxyCodeLine{11763             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(input\_format, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{11764             \{}
\DoxyCodeLine{11765                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11766             \}}
\DoxyCodeLine{11767             number\_vector.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(current));}
\DoxyCodeLine{11768         \}}
\DoxyCodeLine{11769 }
\DoxyCodeLine{11770         \textcolor{comment}{// parse number string}}
\DoxyCodeLine{11771         \textcolor{keyword}{using }ia\_type = \textcolor{keyword}{decltype}(detail::input\_adapter(number\_vector));}
\DoxyCodeLine{11772         \textcolor{keyword}{auto} number\_lexer = \mbox{\hyperlink{classdetail_1_1lexer}{detail::lexer<BasicJsonType, ia\_type>}}(detail::input\_adapter(number\_vector), \textcolor{keyword}{false});}
\DoxyCodeLine{11773         \textcolor{keyword}{const} \textcolor{keyword}{auto} result\_number = number\_lexer.scan();}
\DoxyCodeLine{11774         \textcolor{keyword}{const} \textcolor{keyword}{auto} number\_string = number\_lexer.get\_token\_string();}
\DoxyCodeLine{11775         \textcolor{keyword}{const} \textcolor{keyword}{auto} result\_remainder = number\_lexer.scan();}
\DoxyCodeLine{11776 }
\DoxyCodeLine{11777         \textcolor{keyword}{using }token\_type = \textcolor{keyword}{typename} \mbox{\hyperlink{classdetail_1_1lexer__base_add65fa7a85aa15052963809fbcc04540}{detail::lexer\_base<BasicJsonType>::token\_type}};}
\DoxyCodeLine{11778 }
\DoxyCodeLine{11779         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(result\_remainder != token\_type::end\_of\_input))}
\DoxyCodeLine{11780         \{}
\DoxyCodeLine{11781             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, number\_string, parse\_error::create(115, chars\_read,}
\DoxyCodeLine{11782                                     exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}invalid number text: "{}}, number\_lexer.get\_token\_string()), \textcolor{stringliteral}{"{}high-\/precision number"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11783         \}}
\DoxyCodeLine{11784 }
\DoxyCodeLine{11785         \textcolor{keywordflow}{switch} (result\_number)}
\DoxyCodeLine{11786         \{}
\DoxyCodeLine{11787             \textcolor{keywordflow}{case} token\_type::value\_integer:}
\DoxyCodeLine{11788                 \textcolor{keywordflow}{return} sax-\/>number\_integer(number\_lexer.get\_number\_integer());}
\DoxyCodeLine{11789             \textcolor{keywordflow}{case} token\_type::value\_unsigned:}
\DoxyCodeLine{11790                 \textcolor{keywordflow}{return} sax-\/>number\_unsigned(number\_lexer.get\_number\_unsigned());}
\DoxyCodeLine{11791             \textcolor{keywordflow}{case} token\_type::value\_float:}
\DoxyCodeLine{11792                 \textcolor{keywordflow}{return} sax-\/>number\_float(number\_lexer.get\_number\_float(), std::move(number\_string));}
\DoxyCodeLine{11793             \textcolor{keywordflow}{case} token\_type::uninitialized:}
\DoxyCodeLine{11794             \textcolor{keywordflow}{case} token\_type::literal\_true:}
\DoxyCodeLine{11795             \textcolor{keywordflow}{case} token\_type::literal\_false:}
\DoxyCodeLine{11796             \textcolor{keywordflow}{case} token\_type::literal\_null:}
\DoxyCodeLine{11797             \textcolor{keywordflow}{case} token\_type::value\_string:}
\DoxyCodeLine{11798             \textcolor{keywordflow}{case} token\_type::begin\_array:}
\DoxyCodeLine{11799             \textcolor{keywordflow}{case} token\_type::begin\_object:}
\DoxyCodeLine{11800             \textcolor{keywordflow}{case} token\_type::end\_array:}
\DoxyCodeLine{11801             \textcolor{keywordflow}{case} token\_type::end\_object:}
\DoxyCodeLine{11802             \textcolor{keywordflow}{case} token\_type::name\_separator:}
\DoxyCodeLine{11803             \textcolor{keywordflow}{case} token\_type::value\_separator:}
\DoxyCodeLine{11804             \textcolor{keywordflow}{case} token\_type::parse\_error:}
\DoxyCodeLine{11805             \textcolor{keywordflow}{case} token\_type::end\_of\_input:}
\DoxyCodeLine{11806             \textcolor{keywordflow}{case} token\_type::literal\_or\_value:}
\DoxyCodeLine{11807             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{11808                 \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, number\_string, parse\_error::create(115, chars\_read,}
\DoxyCodeLine{11809                                         exception\_message(input\_format, concat(\textcolor{stringliteral}{"{}invalid number text: "{}}, number\_lexer.get\_token\_string()), \textcolor{stringliteral}{"{}high-\/precision number"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11810         \}}
\DoxyCodeLine{11811     \}}
\DoxyCodeLine{11812 }
\DoxyCodeLine{11814     \textcolor{comment}{// Utility functions //}}
\DoxyCodeLine{11816 \textcolor{comment}{}}
\DoxyCodeLine{11826     char\_int\_type get()}
\DoxyCodeLine{11827     \{}
\DoxyCodeLine{11828         ++chars\_read;}
\DoxyCodeLine{11829         \textcolor{keywordflow}{return} current = ia.get\_character();}
\DoxyCodeLine{11830     \}}
\DoxyCodeLine{11831 }
\DoxyCodeLine{11835     char\_int\_type get\_ignore\_noop()}
\DoxyCodeLine{11836     \{}
\DoxyCodeLine{11837         \textcolor{keywordflow}{do}}
\DoxyCodeLine{11838         \{}
\DoxyCodeLine{11839             get();}
\DoxyCodeLine{11840         \}}
\DoxyCodeLine{11841         \textcolor{keywordflow}{while} (current == \textcolor{charliteral}{'N'});}
\DoxyCodeLine{11842 }
\DoxyCodeLine{11843         \textcolor{keywordflow}{return} current;}
\DoxyCodeLine{11844     \}}
\DoxyCodeLine{11845 }
\DoxyCodeLine{11846     \textcolor{comment}{/*}}
\DoxyCodeLine{11847 \textcolor{comment}{    @brief read a number from the input}}
\DoxyCodeLine{11848 \textcolor{comment}{}}
\DoxyCodeLine{11849 \textcolor{comment}{    @tparam NumberType the type of the number}}
\DoxyCodeLine{11850 \textcolor{comment}{    @param[in] format   the current format (for diagnostics)}}
\DoxyCodeLine{11851 \textcolor{comment}{    @param[out] result  number of type @a NumberType}}
\DoxyCodeLine{11852 \textcolor{comment}{}}
\DoxyCodeLine{11853 \textcolor{comment}{    @return whether conversion completed}}
\DoxyCodeLine{11854 \textcolor{comment}{}}
\DoxyCodeLine{11855 \textcolor{comment}{    @note This function needs to respect the system's endianness, because}}
\DoxyCodeLine{11856 \textcolor{comment}{          bytes in CBOR, MessagePack, and UBJSON are stored in network order}}
\DoxyCodeLine{11857 \textcolor{comment}{          (big endian) and therefore need reordering on little endian systems.}}
\DoxyCodeLine{11858 \textcolor{comment}{          On the other hand, BSON and BJData use little endian and should reorder}}
\DoxyCodeLine{11859 \textcolor{comment}{          on big endian systems.}}
\DoxyCodeLine{11860 \textcolor{comment}{    */}}
\DoxyCodeLine{11861     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType, \textcolor{keywordtype}{bool} InputIsLittleEndian = false>}
\DoxyCodeLine{11862     \textcolor{keywordtype}{bool} get\_number(\textcolor{keyword}{const} input\_format\_t format, NumberType\& result)}
\DoxyCodeLine{11863     \{}
\DoxyCodeLine{11864         \textcolor{comment}{// step 1: read input into array with system's byte order}}
\DoxyCodeLine{11865         std::array<std::uint8\_t, \textcolor{keyword}{sizeof}(NumberType)> vec\{\};}
\DoxyCodeLine{11866         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(NumberType); ++i)}
\DoxyCodeLine{11867         \{}
\DoxyCodeLine{11868             get();}
\DoxyCodeLine{11869             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(format, \textcolor{stringliteral}{"{}number"{}})))}
\DoxyCodeLine{11870             \{}
\DoxyCodeLine{11871                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11872             \}}
\DoxyCodeLine{11873 }
\DoxyCodeLine{11874             \textcolor{comment}{// reverse byte order prior to conversion if necessary}}
\DoxyCodeLine{11875             \textcolor{keywordflow}{if} (is\_little\_endian != (InputIsLittleEndian || format == input\_format\_t::bjdata))}
\DoxyCodeLine{11876             \{}
\DoxyCodeLine{11877                 vec[\textcolor{keyword}{sizeof}(NumberType) -\/ i -\/ 1] = \textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(current);}
\DoxyCodeLine{11878             \}}
\DoxyCodeLine{11879             \textcolor{keywordflow}{else}}
\DoxyCodeLine{11880             \{}
\DoxyCodeLine{11881                 vec[i] = \textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(current); \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{11882             \}}
\DoxyCodeLine{11883         \}}
\DoxyCodeLine{11884 }
\DoxyCodeLine{11885         \textcolor{comment}{// step 2: convert array into number of type T and return}}
\DoxyCodeLine{11886         std::memcpy(\&result, vec.data(), \textcolor{keyword}{sizeof}(NumberType));}
\DoxyCodeLine{11887         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11888     \}}
\DoxyCodeLine{11889 }
\DoxyCodeLine{11904     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType>}
\DoxyCodeLine{11905     \textcolor{keywordtype}{bool} get\_string(\textcolor{keyword}{const} input\_format\_t format,}
\DoxyCodeLine{11906                     \textcolor{keyword}{const} NumberType len,}
\DoxyCodeLine{11907                     string\_t\& result)}
\DoxyCodeLine{11908     \{}
\DoxyCodeLine{11909         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{true};}
\DoxyCodeLine{11910         \textcolor{keywordflow}{for} (NumberType i = 0; i < len; i++)}
\DoxyCodeLine{11911         \{}
\DoxyCodeLine{11912             get();}
\DoxyCodeLine{11913             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(format, \textcolor{stringliteral}{"{}string"{}})))}
\DoxyCodeLine{11914             \{}
\DoxyCodeLine{11915                 success = \textcolor{keyword}{false};}
\DoxyCodeLine{11916                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11917             \}}
\DoxyCodeLine{11918             result.push\_back(\textcolor{keyword}{static\_cast<}typename string\_t::value\_type\textcolor{keyword}{>}(current));}
\DoxyCodeLine{11919         \}}
\DoxyCodeLine{11920         \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{11921     \}}
\DoxyCodeLine{11922 }
\DoxyCodeLine{11937     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType>}
\DoxyCodeLine{11938     \textcolor{keywordtype}{bool} get\_binary(\textcolor{keyword}{const} input\_format\_t format,}
\DoxyCodeLine{11939                     \textcolor{keyword}{const} NumberType len,}
\DoxyCodeLine{11940                     binary\_t\& result)}
\DoxyCodeLine{11941     \{}
\DoxyCodeLine{11942         \textcolor{keywordtype}{bool} success = \textcolor{keyword}{true};}
\DoxyCodeLine{11943         \textcolor{keywordflow}{for} (NumberType i = 0; i < len; i++)}
\DoxyCodeLine{11944         \{}
\DoxyCodeLine{11945             get();}
\DoxyCodeLine{11946             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!unexpect\_eof(format, \textcolor{stringliteral}{"{}binary"{}})))}
\DoxyCodeLine{11947             \{}
\DoxyCodeLine{11948                 success = \textcolor{keyword}{false};}
\DoxyCodeLine{11949                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11950             \}}
\DoxyCodeLine{11951             result.push\_back(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(current));}
\DoxyCodeLine{11952         \}}
\DoxyCodeLine{11953         \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{11954     \}}
\DoxyCodeLine{11955 }
\DoxyCodeLine{11961     JSON\_HEDLEY\_NON\_NULL(3)}
\DoxyCodeLine{11962     bool unexpect\_eof(const input\_format\_t format, const \textcolor{keywordtype}{char}* context)\textcolor{keyword}{ const}}
\DoxyCodeLine{11963 \textcolor{keyword}{    }\{}
\DoxyCodeLine{11964         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(current == std::char\_traits<char\_type>::eof()))}
\DoxyCodeLine{11965         \{}
\DoxyCodeLine{11966             \textcolor{keywordflow}{return} sax-\/>parse\_error(chars\_read, \textcolor{stringliteral}{"{}<end of file>"{}},}
\DoxyCodeLine{11967                                     parse\_error::create(110, chars\_read, exception\_message(format, \textcolor{stringliteral}{"{}unexpected end of input"{}}, context), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{11968         \}}
\DoxyCodeLine{11969         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{11970     \}}
\DoxyCodeLine{11971 }
\DoxyCodeLine{11975     std::string get\_token\_string()\textcolor{keyword}{ const}}
\DoxyCodeLine{11976 \textcolor{keyword}{    }\{}
\DoxyCodeLine{11977         std::array<char, 3> cr\{\{\}\};}
\DoxyCodeLine{11978         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}((std::snprintf)(cr.data(), cr.size(), \textcolor{stringliteral}{"{}\%.2hhX"{}}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(current))); \textcolor{comment}{// NOLINT(cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{11979         \textcolor{keywordflow}{return} std::string\{cr.data()\};}
\DoxyCodeLine{11980     \}}
\DoxyCodeLine{11981 }
\DoxyCodeLine{11988     std::string exception\_message(\textcolor{keyword}{const} input\_format\_t format,}
\DoxyCodeLine{11989                                   \textcolor{keyword}{const} std::string\& \mbox{\hyperlink{namespacedetail}{detail}},}
\DoxyCodeLine{11990                                   \textcolor{keyword}{const} std::string\& context)\textcolor{keyword}{ const}}
\DoxyCodeLine{11991 \textcolor{keyword}{    }\{}
\DoxyCodeLine{11992         std::string error\_msg = \textcolor{stringliteral}{"{}syntax error while parsing "{}};}
\DoxyCodeLine{11993 }
\DoxyCodeLine{11994         \textcolor{keywordflow}{switch} (format)}
\DoxyCodeLine{11995         \{}
\DoxyCodeLine{11996             \textcolor{keywordflow}{case} input\_format\_t::cbor:}
\DoxyCodeLine{11997                 error\_msg += \textcolor{stringliteral}{"{}CBOR"{}};}
\DoxyCodeLine{11998                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11999 }
\DoxyCodeLine{12000             \textcolor{keywordflow}{case} input\_format\_t::msgpack:}
\DoxyCodeLine{12001                 error\_msg += \textcolor{stringliteral}{"{}MessagePack"{}};}
\DoxyCodeLine{12002                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12003 }
\DoxyCodeLine{12004             \textcolor{keywordflow}{case} input\_format\_t::ubjson:}
\DoxyCodeLine{12005                 error\_msg += \textcolor{stringliteral}{"{}UBJSON"{}};}
\DoxyCodeLine{12006                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12007 }
\DoxyCodeLine{12008             \textcolor{keywordflow}{case} input\_format\_t::bson:}
\DoxyCodeLine{12009                 error\_msg += \textcolor{stringliteral}{"{}BSON"{}};}
\DoxyCodeLine{12010                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12011 }
\DoxyCodeLine{12012             \textcolor{keywordflow}{case} input\_format\_t::bjdata:}
\DoxyCodeLine{12013                 error\_msg += \textcolor{stringliteral}{"{}BJData"{}};}
\DoxyCodeLine{12014                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12015 }
\DoxyCodeLine{12016             \textcolor{keywordflow}{case} input\_format\_t::json: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{12017             \textcolor{keywordflow}{default}:            \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{12018                 JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{12019         \}}
\DoxyCodeLine{12020 }
\DoxyCodeLine{12021         \textcolor{keywordflow}{return} concat(error\_msg, \textcolor{charliteral}{' '}, context, \textcolor{stringliteral}{"{}: "{}}, \mbox{\hyperlink{namespacedetail}{detail}});}
\DoxyCodeLine{12022     \}}
\DoxyCodeLine{12023 }
\DoxyCodeLine{12024   \textcolor{keyword}{private}:}
\DoxyCodeLine{12025     \textcolor{keyword}{static} JSON\_INLINE\_VARIABLE \textcolor{keyword}{constexpr} std::size\_t npos = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{12026 }
\DoxyCodeLine{12028     InputAdapterType ia;}
\DoxyCodeLine{12029 }
\DoxyCodeLine{12031     char\_int\_type current = std::char\_traits<char\_type>::eof();}
\DoxyCodeLine{12032 }
\DoxyCodeLine{12034     std::size\_t chars\_read = 0;}
\DoxyCodeLine{12035 }
\DoxyCodeLine{12037     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_little\_endian = little\_endianness();}
\DoxyCodeLine{12038 }
\DoxyCodeLine{12040     \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} input\_format = input\_format\_t::json;}
\DoxyCodeLine{12041 }
\DoxyCodeLine{12043     json\_sax\_t* sax = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12044 }
\DoxyCodeLine{12045     \textcolor{comment}{// excluded markers in bjdata optimized type}}
\DoxyCodeLine{12046 \textcolor{preprocessor}{\#define JSON\_BINARY\_READER\_MAKE\_BJD\_OPTIMIZED\_TYPE\_MARKERS\_ \(\backslash\)}}
\DoxyCodeLine{12047 \textcolor{preprocessor}{    make\_array<char\_int\_type>('F', 'H', 'N', 'S', 'T', 'Z', '[', '\{')}}
\DoxyCodeLine{12048 }
\DoxyCodeLine{12049 \textcolor{preprocessor}{\#define JSON\_BINARY\_READER\_MAKE\_BJD\_TYPES\_MAP\_ \(\backslash\)}}
\DoxyCodeLine{12050 \textcolor{preprocessor}{    make\_array<bjd\_type>(                      \(\backslash\)}}
\DoxyCodeLine{12051 \textcolor{preprocessor}{    bjd\_type\{'C', "{}char"{}}\},                     \(\backslash\)}
\DoxyCodeLine{12052     bjd\_type\{'D', "{}double"{}\},                   \(\backslash\)}
\DoxyCodeLine{12053     bjd\_type\{'I', "{}int16"{}\},                    \(\backslash\)}
\DoxyCodeLine{12054     bjd\_type\{'L', "{}int64"{}\},                    \(\backslash\)}
\DoxyCodeLine{12055     bjd\_type\{'M', "{}uint64"{}\},                   \(\backslash\)}
\DoxyCodeLine{12056     bjd\_type\{'U', "{}uint8"{}\},                    \(\backslash\)}
\DoxyCodeLine{12057     bjd\_type\{'d', "{}single"{}\},                   \(\backslash\)}
\DoxyCodeLine{12058     bjd\_type\{'i', "{}int8"{}\},                     \(\backslash\)}
\DoxyCodeLine{12059     bjd\_type\{'l', "{}int32"{}\},                    \(\backslash\)}
\DoxyCodeLine{12060     bjd\_type\{'m', "{}uint32"{}\},                   \(\backslash\)}
\DoxyCodeLine{12061     bjd\_type\{'u', "{}uint16"{}\})}
\DoxyCodeLine{12062 }
\DoxyCodeLine{12063   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{12064     \textcolor{comment}{// lookup tables}}
\DoxyCodeLine{12065     \textcolor{comment}{// NOLINTNEXTLINE(cppcoreguidelines-\/non-\/private-\/member-\/variables-\/in-\/classes)}}
\DoxyCodeLine{12066     \textcolor{keyword}{const} \textcolor{keyword}{decltype}(JSON\_BINARY\_READER\_MAKE\_BJD\_OPTIMIZED\_TYPE\_MARKERS\_) bjd\_optimized\_type\_markers =}
\DoxyCodeLine{12067         JSON\_BINARY\_READER\_MAKE\_BJD\_OPTIMIZED\_TYPE\_MARKERS\_;}
\DoxyCodeLine{12068 }
\DoxyCodeLine{12069     \textcolor{keyword}{using }bjd\_type = std::pair<char\_int\_type, string\_t>;}
\DoxyCodeLine{12070     \textcolor{comment}{// NOLINTNEXTLINE(cppcoreguidelines-\/non-\/private-\/member-\/variables-\/in-\/classes)}}
\DoxyCodeLine{12071     \textcolor{keyword}{const} \textcolor{keyword}{decltype}(JSON\_BINARY\_READER\_MAKE\_BJD\_TYPES\_MAP\_) bjd\_types\_map =}
\DoxyCodeLine{12072         JSON\_BINARY\_READER\_MAKE\_BJD\_TYPES\_MAP\_;}
\DoxyCodeLine{12073 }
\DoxyCodeLine{12074 \textcolor{preprocessor}{\#undef JSON\_BINARY\_READER\_MAKE\_BJD\_OPTIMIZED\_TYPE\_MARKERS\_}}
\DoxyCodeLine{12075 \textcolor{preprocessor}{\#undef JSON\_BINARY\_READER\_MAKE\_BJD\_TYPES\_MAP\_}}
\DoxyCodeLine{12076 \};}
\DoxyCodeLine{12077 }
\DoxyCodeLine{12078 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{12079     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} InputAdapterType, \textcolor{keyword}{typename} SAX>}
\DoxyCodeLine{12080     \textcolor{keyword}{constexpr} std::size\_t binary\_reader<BasicJsonType, InputAdapterType, SAX>::npos;}
\DoxyCodeLine{12081 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12082 }
\DoxyCodeLine{12083 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{12084 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{12085 }
\DoxyCodeLine{12086 \textcolor{comment}{// \#include <nlohmann/detail/input/input\_adapters.hpp>}}
\DoxyCodeLine{12087 }
\DoxyCodeLine{12088 \textcolor{comment}{// \#include <nlohmann/detail/input/lexer.hpp>}}
\DoxyCodeLine{12089 }
\DoxyCodeLine{12090 \textcolor{comment}{// \#include <nlohmann/detail/input/parser.hpp>}}
\DoxyCodeLine{12091 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{12092 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{12093 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{12094 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{12095 \textcolor{comment}{//}}
\DoxyCodeLine{12096 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{12097 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{12098 }
\DoxyCodeLine{12099 }
\DoxyCodeLine{12100 }
\DoxyCodeLine{12101 \textcolor{preprocessor}{\#include <cmath>} \textcolor{comment}{// isfinite}}
\DoxyCodeLine{12102 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// uint8\_t}}
\DoxyCodeLine{12103 \textcolor{preprocessor}{\#include <functional>} \textcolor{comment}{// function}}
\DoxyCodeLine{12104 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{12105 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// move}}
\DoxyCodeLine{12106 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{12107 }
\DoxyCodeLine{12108 \textcolor{comment}{// \#include <nlohmann/detail/exceptions.hpp>}}
\DoxyCodeLine{12109 }
\DoxyCodeLine{12110 \textcolor{comment}{// \#include <nlohmann/detail/input/input\_adapters.hpp>}}
\DoxyCodeLine{12111 }
\DoxyCodeLine{12112 \textcolor{comment}{// \#include <nlohmann/detail/input/json\_sax.hpp>}}
\DoxyCodeLine{12113 }
\DoxyCodeLine{12114 \textcolor{comment}{// \#include <nlohmann/detail/input/lexer.hpp>}}
\DoxyCodeLine{12115 }
\DoxyCodeLine{12116 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{12117 }
\DoxyCodeLine{12118 \textcolor{comment}{// \#include <nlohmann/detail/meta/is\_sax.hpp>}}
\DoxyCodeLine{12119 }
\DoxyCodeLine{12120 \textcolor{comment}{// \#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{12121 }
\DoxyCodeLine{12122 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{12123 }
\DoxyCodeLine{12124 }
\DoxyCodeLine{12125 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{12126 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{12127 \{}
\DoxyCodeLine{12129 \textcolor{comment}{// parser //}}
\DoxyCodeLine{12131 \textcolor{comment}{}}
\DoxyCodeLine{12132 \textcolor{keyword}{enum class} \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312ef}{parse\_event\_t}} : std::uint8\_t}
\DoxyCodeLine{12133 \{}
\DoxyCodeLine{12135     \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efae73f17027cb0acbb537f29d0a6944b26}{object\_start}},}
\DoxyCodeLine{12137     \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efaf63e2a2468a37aa4f394fcc3bcb8249c}{object\_end}},}
\DoxyCodeLine{12139     \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efaa4388a3d92419edbb1c6efd4d52461f3}{array\_start}},}
\DoxyCodeLine{12141     \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa49642fb732aa2e112188fba1f9d3ef7f}{array\_end}},}
\DoxyCodeLine{12143     \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}},}
\DoxyCodeLine{12145     \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}}
\DoxyCodeLine{12146 \};}
\DoxyCodeLine{12147 }
\DoxyCodeLine{12148 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{12149 \textcolor{keyword}{using }parser\_callback\_t =}
\DoxyCodeLine{12150     std::function<bool(\textcolor{keywordtype}{int} \textcolor{comment}{/*depth*/}, parse\_event\_t \textcolor{comment}{/*event*/}, BasicJsonType\& \textcolor{comment}{/*parsed*/})>;}
\DoxyCodeLine{12151 }
\DoxyCodeLine{12157 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} InputAdapterType>}
\DoxyCodeLine{12158 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1parser}{parser}}}
\DoxyCodeLine{12159 \{}
\DoxyCodeLine{12160     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{12161     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{12162     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{12163     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{12164     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1lexer}{lexer\_t}} = \mbox{\hyperlink{classdetail_1_1lexer}{lexer<BasicJsonType, InputAdapterType>}};}
\DoxyCodeLine{12165     \textcolor{keyword}{using }token\_type = \textcolor{keyword}{typename} lexer\_t::token\_type;}
\DoxyCodeLine{12166 }
\DoxyCodeLine{12167   \textcolor{keyword}{public}:}
\DoxyCodeLine{12169     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1parser_a4bb9ea1b0fddb8f46ff987bbf9e54045}{parser}}(InputAdapterType\&\& adapter,}
\DoxyCodeLine{12170                     \textcolor{keyword}{const} parser\_callback\_t<BasicJsonType> cb = \textcolor{keyword}{nullptr},}
\DoxyCodeLine{12171                     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions\_ = \textcolor{keyword}{true},}
\DoxyCodeLine{12172                     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} skip\_comments = \textcolor{keyword}{false})}
\DoxyCodeLine{12173         : callback(cb)}
\DoxyCodeLine{12174         , m\_lexer(std::move(adapter), skip\_comments)}
\DoxyCodeLine{12175         , allow\_exceptions(allow\_exceptions\_)}
\DoxyCodeLine{12176     \{}
\DoxyCodeLine{12177         \textcolor{comment}{// read first token}}
\DoxyCodeLine{12178         get\_token();}
\DoxyCodeLine{12179     \}}
\DoxyCodeLine{12180 }
\DoxyCodeLine{12191     \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1parser_a59f4b745d4aa146bf7a60a30060f592f}{parse}}(\textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict, BasicJsonType\& result)}
\DoxyCodeLine{12192     \{}
\DoxyCodeLine{12193         \textcolor{keywordflow}{if} (callback)}
\DoxyCodeLine{12194         \{}
\DoxyCodeLine{12195             \mbox{\hyperlink{classdetail_1_1json__sax__dom__callback__parser}{json\_sax\_dom\_callback\_parser<BasicJsonType>}} sdp(result, callback, allow\_exceptions);}
\DoxyCodeLine{12196             sax\_parse\_internal(\&sdp);}
\DoxyCodeLine{12197 }
\DoxyCodeLine{12198             \textcolor{comment}{// in strict mode, input must be completely read}}
\DoxyCodeLine{12199             \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298a2133fd717402a7966ee88d06f9e0b792}{strict}} \&\& (get\_token() != token\_type::end\_of\_input))}
\DoxyCodeLine{12200             \{}
\DoxyCodeLine{12201                 sdp.parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12202                                 m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12203                                 parse\_error::create(101, m\_lexer.get\_position(),}
\DoxyCodeLine{12204                                                     exception\_message(token\_type::end\_of\_input, \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12205             \}}
\DoxyCodeLine{12206 }
\DoxyCodeLine{12207             \textcolor{comment}{// in case of an error, return discarded value}}
\DoxyCodeLine{12208             \textcolor{keywordflow}{if} (sdp.is\_errored())}
\DoxyCodeLine{12209             \{}
\DoxyCodeLine{12210                 result = value\_t::discarded;}
\DoxyCodeLine{12211                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{12212             \}}
\DoxyCodeLine{12213 }
\DoxyCodeLine{12214             \textcolor{comment}{// set top-\/level value to null if it was discarded by the callback}}
\DoxyCodeLine{12215             \textcolor{comment}{// function}}
\DoxyCodeLine{12216             \textcolor{keywordflow}{if} (result.is\_discarded())}
\DoxyCodeLine{12217             \{}
\DoxyCodeLine{12218                 result = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12219             \}}
\DoxyCodeLine{12220         \}}
\DoxyCodeLine{12221         \textcolor{keywordflow}{else}}
\DoxyCodeLine{12222         \{}
\DoxyCodeLine{12223             \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{json\_sax\_dom\_parser<BasicJsonType>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{12224             sax\_parse\_internal(\&sdp);}
\DoxyCodeLine{12225 }
\DoxyCodeLine{12226             \textcolor{comment}{// in strict mode, input must be completely read}}
\DoxyCodeLine{12227             \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298a2133fd717402a7966ee88d06f9e0b792}{strict}} \&\& (get\_token() != token\_type::end\_of\_input))}
\DoxyCodeLine{12228             \{}
\DoxyCodeLine{12229                 sdp.parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12230                                 m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12231                                 parse\_error::create(101, m\_lexer.get\_position(), exception\_message(token\_type::end\_of\_input, \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12232             \}}
\DoxyCodeLine{12233 }
\DoxyCodeLine{12234             \textcolor{comment}{// in case of an error, return discarded value}}
\DoxyCodeLine{12235             \textcolor{keywordflow}{if} (sdp.is\_errored())}
\DoxyCodeLine{12236             \{}
\DoxyCodeLine{12237                 result = value\_t::discarded;}
\DoxyCodeLine{12238                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{12239             \}}
\DoxyCodeLine{12240         \}}
\DoxyCodeLine{12241 }
\DoxyCodeLine{12242         result.assert\_invariant();}
\DoxyCodeLine{12243     \}}
\DoxyCodeLine{12244 }
\DoxyCodeLine{12251     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1parser_ac46da3262cbe66ade670c5b4782451e6}{accept}}(\textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true})}
\DoxyCodeLine{12252     \{}
\DoxyCodeLine{12253         \mbox{\hyperlink{classdetail_1_1json__sax__acceptor}{json\_sax\_acceptor<BasicJsonType>}} sax\_acceptor;}
\DoxyCodeLine{12254         \textcolor{keywordflow}{return} sax\_parse(\&sax\_acceptor, \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298a2133fd717402a7966ee88d06f9e0b792}{strict}});}
\DoxyCodeLine{12255     \}}
\DoxyCodeLine{12256 }
\DoxyCodeLine{12257     \textcolor{keyword}{template}<\textcolor{keyword}{typename} SAX>}
\DoxyCodeLine{12258     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{12259     bool sax\_parse(SAX* sax, const \textcolor{keywordtype}{bool} strict = true)}
\DoxyCodeLine{12260     \{}
\DoxyCodeLine{12261         (void)\mbox{\hyperlink{structdetail_1_1is__sax__static__asserts}{detail::is\_sax\_static\_asserts<SAX, BasicJsonType>}} \{\};}
\DoxyCodeLine{12262         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} result = sax\_parse\_internal(sax);}
\DoxyCodeLine{12263 }
\DoxyCodeLine{12264         \textcolor{comment}{// strict mode: next byte must be EOF}}
\DoxyCodeLine{12265         \textcolor{keywordflow}{if} (result \&\& strict \&\& (get\_token() != token\_type::end\_of\_input))}
\DoxyCodeLine{12266         \{}
\DoxyCodeLine{12267             \textcolor{keywordflow}{return} sax-\/>parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12268                                     m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12269                                     parse\_error::create(101, m\_lexer.get\_position(), exception\_message(token\_type::end\_of\_input, \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12270         \}}
\DoxyCodeLine{12271 }
\DoxyCodeLine{12272         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{12273     \}}
\DoxyCodeLine{12274 }
\DoxyCodeLine{12275   \textcolor{keyword}{private}:}
\DoxyCodeLine{12276     \textcolor{keyword}{template}<\textcolor{keyword}{typename} SAX>}
\DoxyCodeLine{12277     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{12278     bool sax\_parse\_internal(SAX* sax)}
\DoxyCodeLine{12279     \{}
\DoxyCodeLine{12280         \textcolor{comment}{// stack to remember the hierarchy of structured values we are parsing}}
\DoxyCodeLine{12281         \textcolor{comment}{// true = array; false = object}}
\DoxyCodeLine{12282         std::vector<bool> states;}
\DoxyCodeLine{12283         \textcolor{comment}{// value to avoid a goto (see comment where set to true)}}
\DoxyCodeLine{12284         \textcolor{keywordtype}{bool} skip\_to\_state\_evaluation = \textcolor{keyword}{false};}
\DoxyCodeLine{12285 }
\DoxyCodeLine{12286         \textcolor{keywordflow}{while} (\textcolor{keyword}{true})}
\DoxyCodeLine{12287         \{}
\DoxyCodeLine{12288             \textcolor{keywordflow}{if} (!skip\_to\_state\_evaluation)}
\DoxyCodeLine{12289             \{}
\DoxyCodeLine{12290                 \textcolor{comment}{// invariant: get\_token() was called before each iteration}}
\DoxyCodeLine{12291                 \textcolor{keywordflow}{switch} (last\_token)}
\DoxyCodeLine{12292                 \{}
\DoxyCodeLine{12293                     \textcolor{keywordflow}{case} token\_type::begin\_object:}
\DoxyCodeLine{12294                     \{}
\DoxyCodeLine{12295                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_object(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))))}
\DoxyCodeLine{12296                         \{}
\DoxyCodeLine{12297                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12298                         \}}
\DoxyCodeLine{12299 }
\DoxyCodeLine{12300                         \textcolor{comment}{// closing \} -\/> we are done}}
\DoxyCodeLine{12301                         \textcolor{keywordflow}{if} (get\_token() == token\_type::end\_object)}
\DoxyCodeLine{12302                         \{}
\DoxyCodeLine{12303                             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>end\_object()))}
\DoxyCodeLine{12304                             \{}
\DoxyCodeLine{12305                                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12306                             \}}
\DoxyCodeLine{12307                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12308                         \}}
\DoxyCodeLine{12309 }
\DoxyCodeLine{12310                         \textcolor{comment}{// parse key}}
\DoxyCodeLine{12311                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(last\_token != token\_type::value\_string))}
\DoxyCodeLine{12312                         \{}
\DoxyCodeLine{12313                             \textcolor{keywordflow}{return} sax-\/>parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12314                                                     m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12315                                                     parse\_error::create(101, m\_lexer.get\_position(), exception\_message(token\_type::value\_string, \textcolor{stringliteral}{"{}object key"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12316                         \}}
\DoxyCodeLine{12317                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>key(m\_lexer.get\_string())))}
\DoxyCodeLine{12318                         \{}
\DoxyCodeLine{12319                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12320                         \}}
\DoxyCodeLine{12321 }
\DoxyCodeLine{12322                         \textcolor{comment}{// parse separator (:)}}
\DoxyCodeLine{12323                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(get\_token() != token\_type::name\_separator))}
\DoxyCodeLine{12324                         \{}
\DoxyCodeLine{12325                             \textcolor{keywordflow}{return} sax-\/>parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12326                                                     m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12327                                                     parse\_error::create(101, m\_lexer.get\_position(), exception\_message(token\_type::name\_separator, \textcolor{stringliteral}{"{}object separator"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12328                         \}}
\DoxyCodeLine{12329 }
\DoxyCodeLine{12330                         \textcolor{comment}{// remember we are now inside an object}}
\DoxyCodeLine{12331                         states.push\_back(\textcolor{keyword}{false});}
\DoxyCodeLine{12332 }
\DoxyCodeLine{12333                         \textcolor{comment}{// parse values}}
\DoxyCodeLine{12334                         get\_token();}
\DoxyCodeLine{12335                         \textcolor{keywordflow}{continue};}
\DoxyCodeLine{12336                     \}}
\DoxyCodeLine{12337 }
\DoxyCodeLine{12338                     \textcolor{keywordflow}{case} token\_type::begin\_array:}
\DoxyCodeLine{12339                     \{}
\DoxyCodeLine{12340                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>start\_array(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))))}
\DoxyCodeLine{12341                         \{}
\DoxyCodeLine{12342                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12343                         \}}
\DoxyCodeLine{12344 }
\DoxyCodeLine{12345                         \textcolor{comment}{// closing ] -\/> we are done}}
\DoxyCodeLine{12346                         \textcolor{keywordflow}{if} (get\_token() == token\_type::end\_array)}
\DoxyCodeLine{12347                         \{}
\DoxyCodeLine{12348                             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>end\_array()))}
\DoxyCodeLine{12349                             \{}
\DoxyCodeLine{12350                                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12351                             \}}
\DoxyCodeLine{12352                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{12353                         \}}
\DoxyCodeLine{12354 }
\DoxyCodeLine{12355                         \textcolor{comment}{// remember we are now inside an array}}
\DoxyCodeLine{12356                         states.push\_back(\textcolor{keyword}{true});}
\DoxyCodeLine{12357 }
\DoxyCodeLine{12358                         \textcolor{comment}{// parse values (no need to call get\_token)}}
\DoxyCodeLine{12359                         \textcolor{keywordflow}{continue};}
\DoxyCodeLine{12360                     \}}
\DoxyCodeLine{12361 }
\DoxyCodeLine{12362                     \textcolor{keywordflow}{case} token\_type::value\_float:}
\DoxyCodeLine{12363                     \{}
\DoxyCodeLine{12364                         \textcolor{keyword}{const} \textcolor{keyword}{auto} res = m\_lexer.get\_number\_float();}
\DoxyCodeLine{12365 }
\DoxyCodeLine{12366                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!std::isfinite(res)))}
\DoxyCodeLine{12367                         \{}
\DoxyCodeLine{12368                             \textcolor{keywordflow}{return} sax-\/>parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12369                                                     m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12370                                                     out\_of\_range::create(406, concat(\textcolor{stringliteral}{"{}number overflow parsing '"{}}, m\_lexer.get\_token\_string(), \textcolor{charliteral}{'\(\backslash\)''}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12371                         \}}
\DoxyCodeLine{12372 }
\DoxyCodeLine{12373                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>number\_float(res, m\_lexer.get\_string())))}
\DoxyCodeLine{12374                         \{}
\DoxyCodeLine{12375                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12376                         \}}
\DoxyCodeLine{12377 }
\DoxyCodeLine{12378                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{12379                     \}}
\DoxyCodeLine{12380 }
\DoxyCodeLine{12381                     \textcolor{keywordflow}{case} token\_type::literal\_false:}
\DoxyCodeLine{12382                     \{}
\DoxyCodeLine{12383                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>boolean(\textcolor{keyword}{false})))}
\DoxyCodeLine{12384                         \{}
\DoxyCodeLine{12385                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12386                         \}}
\DoxyCodeLine{12387                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{12388                     \}}
\DoxyCodeLine{12389 }
\DoxyCodeLine{12390                     \textcolor{keywordflow}{case} token\_type::literal\_null:}
\DoxyCodeLine{12391                     \{}
\DoxyCodeLine{12392                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>null()))}
\DoxyCodeLine{12393                         \{}
\DoxyCodeLine{12394                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12395                         \}}
\DoxyCodeLine{12396                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{12397                     \}}
\DoxyCodeLine{12398 }
\DoxyCodeLine{12399                     \textcolor{keywordflow}{case} token\_type::literal\_true:}
\DoxyCodeLine{12400                     \{}
\DoxyCodeLine{12401                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>boolean(\textcolor{keyword}{true})))}
\DoxyCodeLine{12402                         \{}
\DoxyCodeLine{12403                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12404                         \}}
\DoxyCodeLine{12405                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{12406                     \}}
\DoxyCodeLine{12407 }
\DoxyCodeLine{12408                     \textcolor{keywordflow}{case} token\_type::value\_integer:}
\DoxyCodeLine{12409                     \{}
\DoxyCodeLine{12410                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>number\_integer(m\_lexer.get\_number\_integer())))}
\DoxyCodeLine{12411                         \{}
\DoxyCodeLine{12412                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12413                         \}}
\DoxyCodeLine{12414                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{12415                     \}}
\DoxyCodeLine{12416 }
\DoxyCodeLine{12417                     \textcolor{keywordflow}{case} token\_type::value\_string:}
\DoxyCodeLine{12418                     \{}
\DoxyCodeLine{12419                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>string(m\_lexer.get\_string())))}
\DoxyCodeLine{12420                         \{}
\DoxyCodeLine{12421                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12422                         \}}
\DoxyCodeLine{12423                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{12424                     \}}
\DoxyCodeLine{12425 }
\DoxyCodeLine{12426                     \textcolor{keywordflow}{case} token\_type::value\_unsigned:}
\DoxyCodeLine{12427                     \{}
\DoxyCodeLine{12428                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>number\_unsigned(m\_lexer.get\_number\_unsigned())))}
\DoxyCodeLine{12429                         \{}
\DoxyCodeLine{12430                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12431                         \}}
\DoxyCodeLine{12432                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{12433                     \}}
\DoxyCodeLine{12434 }
\DoxyCodeLine{12435                     \textcolor{keywordflow}{case} token\_type::parse\_error:}
\DoxyCodeLine{12436                     \{}
\DoxyCodeLine{12437                         \textcolor{comment}{// using "{}uninitialized"{} to avoid "{}expected"{} message}}
\DoxyCodeLine{12438                         \textcolor{keywordflow}{return} sax-\/>parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12439                                                 m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12440                                                 parse\_error::create(101, m\_lexer.get\_position(), exception\_message(token\_type::uninitialized, \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12441                     \}}
\DoxyCodeLine{12442 }
\DoxyCodeLine{12443                     \textcolor{keywordflow}{case} token\_type::uninitialized:}
\DoxyCodeLine{12444                     \textcolor{keywordflow}{case} token\_type::end\_array:}
\DoxyCodeLine{12445                     \textcolor{keywordflow}{case} token\_type::end\_object:}
\DoxyCodeLine{12446                     \textcolor{keywordflow}{case} token\_type::name\_separator:}
\DoxyCodeLine{12447                     \textcolor{keywordflow}{case} token\_type::value\_separator:}
\DoxyCodeLine{12448                     \textcolor{keywordflow}{case} token\_type::end\_of\_input:}
\DoxyCodeLine{12449                     \textcolor{keywordflow}{case} token\_type::literal\_or\_value:}
\DoxyCodeLine{12450                     \textcolor{keywordflow}{default}: \textcolor{comment}{// the last token was unexpected}}
\DoxyCodeLine{12451                     \{}
\DoxyCodeLine{12452                         \textcolor{keywordflow}{return} sax-\/>parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12453                                                 m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12454                                                 parse\_error::create(101, m\_lexer.get\_position(), exception\_message(token\_type::literal\_or\_value, \textcolor{stringliteral}{"{}value"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12455                     \}}
\DoxyCodeLine{12456                 \}}
\DoxyCodeLine{12457             \}}
\DoxyCodeLine{12458             \textcolor{keywordflow}{else}}
\DoxyCodeLine{12459             \{}
\DoxyCodeLine{12460                 skip\_to\_state\_evaluation = \textcolor{keyword}{false};}
\DoxyCodeLine{12461             \}}
\DoxyCodeLine{12462 }
\DoxyCodeLine{12463             \textcolor{comment}{// we reached this line after we successfully parsed a value}}
\DoxyCodeLine{12464             \textcolor{keywordflow}{if} (states.empty())}
\DoxyCodeLine{12465             \{}
\DoxyCodeLine{12466                 \textcolor{comment}{// empty stack: we reached the end of the hierarchy: done}}
\DoxyCodeLine{12467                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12468             \}}
\DoxyCodeLine{12469 }
\DoxyCodeLine{12470             \textcolor{keywordflow}{if} (states.back())  \textcolor{comment}{// array}}
\DoxyCodeLine{12471             \{}
\DoxyCodeLine{12472                 \textcolor{comment}{// comma -\/> next value}}
\DoxyCodeLine{12473                 \textcolor{keywordflow}{if} (get\_token() == token\_type::value\_separator)}
\DoxyCodeLine{12474                 \{}
\DoxyCodeLine{12475                     \textcolor{comment}{// parse a new value}}
\DoxyCodeLine{12476                     get\_token();}
\DoxyCodeLine{12477                     \textcolor{keywordflow}{continue};}
\DoxyCodeLine{12478                 \}}
\DoxyCodeLine{12479 }
\DoxyCodeLine{12480                 \textcolor{comment}{// closing ]}}
\DoxyCodeLine{12481                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(last\_token == token\_type::end\_array))}
\DoxyCodeLine{12482                 \{}
\DoxyCodeLine{12483                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>end\_array()))}
\DoxyCodeLine{12484                     \{}
\DoxyCodeLine{12485                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12486                     \}}
\DoxyCodeLine{12487 }
\DoxyCodeLine{12488                     \textcolor{comment}{// We are done with this array. Before we can parse a}}
\DoxyCodeLine{12489                     \textcolor{comment}{// new value, we need to evaluate the new state first.}}
\DoxyCodeLine{12490                     \textcolor{comment}{// By setting skip\_to\_state\_evaluation to false, we}}
\DoxyCodeLine{12491                     \textcolor{comment}{// are effectively jumping to the beginning of this if.}}
\DoxyCodeLine{12492                     JSON\_ASSERT(!states.empty());}
\DoxyCodeLine{12493                     states.pop\_back();}
\DoxyCodeLine{12494                     skip\_to\_state\_evaluation = \textcolor{keyword}{true};}
\DoxyCodeLine{12495                     \textcolor{keywordflow}{continue};}
\DoxyCodeLine{12496                 \}}
\DoxyCodeLine{12497 }
\DoxyCodeLine{12498                 \textcolor{keywordflow}{return} sax-\/>parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12499                                         m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12500                                         parse\_error::create(101, m\_lexer.get\_position(), exception\_message(token\_type::end\_array, \textcolor{stringliteral}{"{}array"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12501             \}}
\DoxyCodeLine{12502 }
\DoxyCodeLine{12503             \textcolor{comment}{// states.back() is false -\/> object}}
\DoxyCodeLine{12504 }
\DoxyCodeLine{12505             \textcolor{comment}{// comma -\/> next value}}
\DoxyCodeLine{12506             \textcolor{keywordflow}{if} (get\_token() == token\_type::value\_separator)}
\DoxyCodeLine{12507             \{}
\DoxyCodeLine{12508                 \textcolor{comment}{// parse key}}
\DoxyCodeLine{12509                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(get\_token() != token\_type::value\_string))}
\DoxyCodeLine{12510                 \{}
\DoxyCodeLine{12511                     \textcolor{keywordflow}{return} sax-\/>parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12512                                             m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12513                                             parse\_error::create(101, m\_lexer.get\_position(), exception\_message(token\_type::value\_string, \textcolor{stringliteral}{"{}object key"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12514                 \}}
\DoxyCodeLine{12515 }
\DoxyCodeLine{12516                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>key(m\_lexer.get\_string())))}
\DoxyCodeLine{12517                 \{}
\DoxyCodeLine{12518                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12519                 \}}
\DoxyCodeLine{12520 }
\DoxyCodeLine{12521                 \textcolor{comment}{// parse separator (:)}}
\DoxyCodeLine{12522                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(get\_token() != token\_type::name\_separator))}
\DoxyCodeLine{12523                 \{}
\DoxyCodeLine{12524                     \textcolor{keywordflow}{return} sax-\/>parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12525                                             m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12526                                             parse\_error::create(101, m\_lexer.get\_position(), exception\_message(token\_type::name\_separator, \textcolor{stringliteral}{"{}object separator"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12527                 \}}
\DoxyCodeLine{12528 }
\DoxyCodeLine{12529                 \textcolor{comment}{// parse values}}
\DoxyCodeLine{12530                 get\_token();}
\DoxyCodeLine{12531                 \textcolor{keywordflow}{continue};}
\DoxyCodeLine{12532             \}}
\DoxyCodeLine{12533 }
\DoxyCodeLine{12534             \textcolor{comment}{// closing \}}}
\DoxyCodeLine{12535             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(last\_token == token\_type::end\_object))}
\DoxyCodeLine{12536             \{}
\DoxyCodeLine{12537                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!sax-\/>end\_object()))}
\DoxyCodeLine{12538                 \{}
\DoxyCodeLine{12539                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12540                 \}}
\DoxyCodeLine{12541 }
\DoxyCodeLine{12542                 \textcolor{comment}{// We are done with this object. Before we can parse a}}
\DoxyCodeLine{12543                 \textcolor{comment}{// new value, we need to evaluate the new state first.}}
\DoxyCodeLine{12544                 \textcolor{comment}{// By setting skip\_to\_state\_evaluation to false, we}}
\DoxyCodeLine{12545                 \textcolor{comment}{// are effectively jumping to the beginning of this if.}}
\DoxyCodeLine{12546                 JSON\_ASSERT(!states.empty());}
\DoxyCodeLine{12547                 states.pop\_back();}
\DoxyCodeLine{12548                 skip\_to\_state\_evaluation = \textcolor{keyword}{true};}
\DoxyCodeLine{12549                 \textcolor{keywordflow}{continue};}
\DoxyCodeLine{12550             \}}
\DoxyCodeLine{12551 }
\DoxyCodeLine{12552             \textcolor{keywordflow}{return} sax-\/>parse\_error(m\_lexer.get\_position(),}
\DoxyCodeLine{12553                                     m\_lexer.get\_token\_string(),}
\DoxyCodeLine{12554                                     parse\_error::create(101, m\_lexer.get\_position(), exception\_message(token\_type::end\_object, \textcolor{stringliteral}{"{}object"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{12555         \}}
\DoxyCodeLine{12556     \}}
\DoxyCodeLine{12557 }
\DoxyCodeLine{12559     token\_type get\_token()}
\DoxyCodeLine{12560     \{}
\DoxyCodeLine{12561         \textcolor{keywordflow}{return} last\_token = m\_lexer.scan();}
\DoxyCodeLine{12562     \}}
\DoxyCodeLine{12563 }
\DoxyCodeLine{12564     std::string exception\_message(\textcolor{keyword}{const} token\_type expected, \textcolor{keyword}{const} std::string\& context)}
\DoxyCodeLine{12565     \{}
\DoxyCodeLine{12566         std::string error\_msg = \textcolor{stringliteral}{"{}syntax error "{}};}
\DoxyCodeLine{12567 }
\DoxyCodeLine{12568         \textcolor{keywordflow}{if} (!context.empty())}
\DoxyCodeLine{12569         \{}
\DoxyCodeLine{12570             error\_msg += concat(\textcolor{stringliteral}{"{}while parsing "{}}, context, \textcolor{charliteral}{' '});}
\DoxyCodeLine{12571         \}}
\DoxyCodeLine{12572 }
\DoxyCodeLine{12573         error\_msg += \textcolor{stringliteral}{"{}-\/ "{}};}
\DoxyCodeLine{12574 }
\DoxyCodeLine{12575         \textcolor{keywordflow}{if} (last\_token == token\_type::parse\_error)}
\DoxyCodeLine{12576         \{}
\DoxyCodeLine{12577             error\_msg += concat(m\_lexer.get\_error\_message(), \textcolor{stringliteral}{"{}; last read: '"{}},}
\DoxyCodeLine{12578                                 m\_lexer.get\_token\_string(), \textcolor{charliteral}{'\(\backslash\)''});}
\DoxyCodeLine{12579         \}}
\DoxyCodeLine{12580         \textcolor{keywordflow}{else}}
\DoxyCodeLine{12581         \{}
\DoxyCodeLine{12582             error\_msg += concat(\textcolor{stringliteral}{"{}unexpected "{}}, lexer\_t::token\_type\_name(last\_token));}
\DoxyCodeLine{12583         \}}
\DoxyCodeLine{12584 }
\DoxyCodeLine{12585         \textcolor{keywordflow}{if} (expected != token\_type::uninitialized)}
\DoxyCodeLine{12586         \{}
\DoxyCodeLine{12587             error\_msg += concat(\textcolor{stringliteral}{"{}; expected "{}}, lexer\_t::token\_type\_name(expected));}
\DoxyCodeLine{12588         \}}
\DoxyCodeLine{12589 }
\DoxyCodeLine{12590         \textcolor{keywordflow}{return} error\_msg;}
\DoxyCodeLine{12591     \}}
\DoxyCodeLine{12592 }
\DoxyCodeLine{12593   \textcolor{keyword}{private}:}
\DoxyCodeLine{12595     \textcolor{keyword}{const} parser\_callback\_t<BasicJsonType> callback = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12597     token\_type last\_token = token\_type::uninitialized;}
\DoxyCodeLine{12599     lexer\_t m\_lexer;}
\DoxyCodeLine{12601     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true};}
\DoxyCodeLine{12602 \};}
\DoxyCodeLine{12603 }
\DoxyCodeLine{12604 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{12605 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{12606 }
\DoxyCodeLine{12607 \textcolor{comment}{// \#include <nlohmann/detail/iterators/internal\_iterator.hpp>}}
\DoxyCodeLine{12608 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{12609 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{12610 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{12611 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{12612 \textcolor{comment}{//}}
\DoxyCodeLine{12613 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{12614 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{12615 }
\DoxyCodeLine{12616 }
\DoxyCodeLine{12617 }
\DoxyCodeLine{12618 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{12619 }
\DoxyCodeLine{12620 \textcolor{comment}{// \#include <nlohmann/detail/iterators/primitive\_iterator.hpp>}}
\DoxyCodeLine{12621 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{12622 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{12623 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{12624 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{12625 \textcolor{comment}{//}}
\DoxyCodeLine{12626 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{12627 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{12628 }
\DoxyCodeLine{12629 }
\DoxyCodeLine{12630 }
\DoxyCodeLine{12631 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// ptrdiff\_t}}
\DoxyCodeLine{12632 \textcolor{preprocessor}{\#include <limits>}  \textcolor{comment}{// numeric\_limits}}
\DoxyCodeLine{12633 }
\DoxyCodeLine{12634 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{12635 }
\DoxyCodeLine{12636 }
\DoxyCodeLine{12637 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{12638 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{12639 \{}
\DoxyCodeLine{12640 }
\DoxyCodeLine{12641 \textcolor{comment}{/*}}
\DoxyCodeLine{12642 \textcolor{comment}{@brief an iterator for primitive JSON types}}
\DoxyCodeLine{12643 \textcolor{comment}{}}
\DoxyCodeLine{12644 \textcolor{comment}{This class models an iterator for primitive JSON types (boolean, number,}}
\DoxyCodeLine{12645 \textcolor{comment}{string). It's only purpose is to allow the iterator/const\_iterator classes}}
\DoxyCodeLine{12646 \textcolor{comment}{to "{}iterate"{} over primitive values. Internally, the iterator is modeled by}}
\DoxyCodeLine{12647 \textcolor{comment}{a `difference\_type` variable. Value begin\_value (`0`) models the begin,}}
\DoxyCodeLine{12648 \textcolor{comment}{end\_value (`1`) models past the end.}}
\DoxyCodeLine{12649 \textcolor{comment}{*/}}
\DoxyCodeLine{12650 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1primitive__iterator__t}{primitive\_iterator\_t}}}
\DoxyCodeLine{12651 \{}
\DoxyCodeLine{12652   \textcolor{keyword}{private}:}
\DoxyCodeLine{12653     \textcolor{keyword}{using }difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{12654     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} difference\_type begin\_value = 0;}
\DoxyCodeLine{12655     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} difference\_type end\_value = begin\_value + 1;}
\DoxyCodeLine{12656 }
\DoxyCodeLine{12657   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{12659     difference\_type m\_it = (std::numeric\_limits<std::ptrdiff\_t>::min)();}
\DoxyCodeLine{12660 }
\DoxyCodeLine{12661   \textcolor{keyword}{public}:}
\DoxyCodeLine{12662     \textcolor{keyword}{constexpr} difference\_type get\_value() \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{12663     \{}
\DoxyCodeLine{12664         \textcolor{keywordflow}{return} m\_it;}
\DoxyCodeLine{12665     \}}
\DoxyCodeLine{12666 }
\DoxyCodeLine{12668     \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1primitive__iterator__t_ae05402e355829cd46a9b31365a7b1a49}{set\_begin}}() noexcept}
\DoxyCodeLine{12669     \{}
\DoxyCodeLine{12670         m\_it = begin\_value;}
\DoxyCodeLine{12671     \}}
\DoxyCodeLine{12672 }
\DoxyCodeLine{12674     \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1primitive__iterator__t_a761383c368d1c32f11bbeb31a04e6488}{set\_end}}() noexcept}
\DoxyCodeLine{12675     \{}
\DoxyCodeLine{12676         m\_it = end\_value;}
\DoxyCodeLine{12677     \}}
\DoxyCodeLine{12678 }
\DoxyCodeLine{12680     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1primitive__iterator__t_a46f7197f0ba0ef7c1f24caf3f7f52d6b}{is\_begin}}() const noexcept}
\DoxyCodeLine{12681     \{}
\DoxyCodeLine{12682         \textcolor{keywordflow}{return} m\_it == begin\_value;}
\DoxyCodeLine{12683     \}}
\DoxyCodeLine{12684 }
\DoxyCodeLine{12686     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1primitive__iterator__t_a9b8509ec7a7cbd4b1da3726be658f5a0}{is\_end}}() const noexcept}
\DoxyCodeLine{12687     \{}
\DoxyCodeLine{12688         \textcolor{keywordflow}{return} m\_it == end\_value;}
\DoxyCodeLine{12689     \}}
\DoxyCodeLine{12690 }
\DoxyCodeLine{12691     \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} operator==(\mbox{\hyperlink{classdetail_1_1primitive__iterator__t}{primitive\_iterator\_t}} lhs, \mbox{\hyperlink{classdetail_1_1primitive__iterator__t}{primitive\_iterator\_t}} rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{12692     \{}
\DoxyCodeLine{12693         \textcolor{keywordflow}{return} lhs.m\_it == rhs.m\_it;}
\DoxyCodeLine{12694     \}}
\DoxyCodeLine{12695 }
\DoxyCodeLine{12696     \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} operator<(primitive\_iterator\_t lhs, primitive\_iterator\_t rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{12697     \{}
\DoxyCodeLine{12698         \textcolor{keywordflow}{return} lhs.m\_it < rhs.m\_it;}
\DoxyCodeLine{12699     \}}
\DoxyCodeLine{12700 }
\DoxyCodeLine{12701     primitive\_iterator\_t operator+(difference\_type n) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{12702     \{}
\DoxyCodeLine{12703         \textcolor{keyword}{auto} result = *\textcolor{keyword}{this};}
\DoxyCodeLine{12704         result += n;}
\DoxyCodeLine{12705         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{12706     \}}
\DoxyCodeLine{12707 }
\DoxyCodeLine{12708     \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} difference\_type operator-\/(primitive\_iterator\_t lhs, primitive\_iterator\_t rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{12709     \{}
\DoxyCodeLine{12710         \textcolor{keywordflow}{return} lhs.m\_it -\/ rhs.m\_it;}
\DoxyCodeLine{12711     \}}
\DoxyCodeLine{12712 }
\DoxyCodeLine{12713     primitive\_iterator\_t\& operator++() noexcept}
\DoxyCodeLine{12714     \{}
\DoxyCodeLine{12715         ++m\_it;}
\DoxyCodeLine{12716         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12717     \}}
\DoxyCodeLine{12718 }
\DoxyCodeLine{12719     primitive\_iterator\_t operator++(\textcolor{keywordtype}{int})\& \textcolor{keyword}{noexcept} \textcolor{comment}{// NOLINT(cert-\/dcl21-\/cpp)}}
\DoxyCodeLine{12720     \{}
\DoxyCodeLine{12721         \textcolor{keyword}{auto} result = *\textcolor{keyword}{this};}
\DoxyCodeLine{12722         ++m\_it;}
\DoxyCodeLine{12723         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{12724     \}}
\DoxyCodeLine{12725 }
\DoxyCodeLine{12726     primitive\_iterator\_t\& operator-\/-\/() noexcept}
\DoxyCodeLine{12727     \{}
\DoxyCodeLine{12728         -\/-\/m\_it;}
\DoxyCodeLine{12729         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12730     \}}
\DoxyCodeLine{12731 }
\DoxyCodeLine{12732     primitive\_iterator\_t operator-\/-\/(\textcolor{keywordtype}{int})\& \textcolor{keyword}{noexcept} \textcolor{comment}{// NOLINT(cert-\/dcl21-\/cpp)}}
\DoxyCodeLine{12733     \{}
\DoxyCodeLine{12734         \textcolor{keyword}{auto} result = *\textcolor{keyword}{this};}
\DoxyCodeLine{12735         -\/-\/m\_it;}
\DoxyCodeLine{12736         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{12737     \}}
\DoxyCodeLine{12738 }
\DoxyCodeLine{12739     primitive\_iterator\_t\& operator+=(difference\_type n) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{12740     \{}
\DoxyCodeLine{12741         m\_it += n;}
\DoxyCodeLine{12742         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12743     \}}
\DoxyCodeLine{12744 }
\DoxyCodeLine{12745     primitive\_iterator\_t\& operator-\/=(difference\_type n) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{12746     \{}
\DoxyCodeLine{12747         m\_it -\/= n;}
\DoxyCodeLine{12748         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12749     \}}
\DoxyCodeLine{12750 \};}
\DoxyCodeLine{12751 }
\DoxyCodeLine{12752 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{12753 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{12754 }
\DoxyCodeLine{12755 }
\DoxyCodeLine{12756 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{12757 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{12758 \{}
\DoxyCodeLine{12759 }
\DoxyCodeLine{12766 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1internal__iterator}{internal\_iterator}}}
\DoxyCodeLine{12767 \{}
\DoxyCodeLine{12769     \textcolor{keyword}{typename} BasicJsonType::object\_t::iterator object\_iterator \{\};}
\DoxyCodeLine{12771     \textcolor{keyword}{typename} BasicJsonType::array\_t::iterator array\_iterator \{\};}
\DoxyCodeLine{12773     \mbox{\hyperlink{classdetail_1_1primitive__iterator__t}{primitive\_iterator\_t}} primitive\_iterator \{\};}
\DoxyCodeLine{12774 \};}
\DoxyCodeLine{12775 }
\DoxyCodeLine{12776 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{12777 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{12778 }
\DoxyCodeLine{12779 \textcolor{comment}{// \#include <nlohmann/detail/iterators/iter\_impl.hpp>}}
\DoxyCodeLine{12780 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{12781 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{12782 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{12783 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{12784 \textcolor{comment}{//}}
\DoxyCodeLine{12785 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{12786 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{12787 }
\DoxyCodeLine{12788 }
\DoxyCodeLine{12789 }
\DoxyCodeLine{12790 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// iterator, random\_access\_iterator\_tag, bidirectional\_iterator\_tag, advance, next}}
\DoxyCodeLine{12791 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// conditional, is\_const, remove\_const}}
\DoxyCodeLine{12792 }
\DoxyCodeLine{12793 \textcolor{comment}{// \#include <nlohmann/detail/exceptions.hpp>}}
\DoxyCodeLine{12794 }
\DoxyCodeLine{12795 \textcolor{comment}{// \#include <nlohmann/detail/iterators/internal\_iterator.hpp>}}
\DoxyCodeLine{12796 }
\DoxyCodeLine{12797 \textcolor{comment}{// \#include <nlohmann/detail/iterators/primitive\_iterator.hpp>}}
\DoxyCodeLine{12798 }
\DoxyCodeLine{12799 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{12800 }
\DoxyCodeLine{12801 \textcolor{comment}{// \#include <nlohmann/detail/meta/cpp\_future.hpp>}}
\DoxyCodeLine{12802 }
\DoxyCodeLine{12803 \textcolor{comment}{// \#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{12804 }
\DoxyCodeLine{12805 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{12806 }
\DoxyCodeLine{12807 }
\DoxyCodeLine{12808 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{12809 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{12810 \{}
\DoxyCodeLine{12811 }
\DoxyCodeLine{12812 \textcolor{comment}{// forward declare, to be able to friend it later on}}
\DoxyCodeLine{12813 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType> \textcolor{keyword}{class }iteration\_proxy;}
\DoxyCodeLine{12814 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType> \textcolor{keyword}{class }iteration\_proxy\_value;}
\DoxyCodeLine{12815 }
\DoxyCodeLine{12832 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{12833 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}} \textcolor{comment}{// NOLINT(cppcoreguidelines-\/special-\/member-\/functions,hicpp-\/special-\/member-\/functions)}}
\DoxyCodeLine{12834 \{}
\DoxyCodeLine{12836     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iter__impl}{other\_iter\_impl}} = \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl<typename std::conditional<std::is\_const<BasicJsonType>::value}}, \textcolor{keyword}{typename} std::remove\_const<BasicJsonType>::type, \textcolor{keyword}{const} BasicJsonType>::type>;}
\DoxyCodeLine{12838     \textcolor{keyword}{friend} \mbox{\hyperlink{classdetail_1_1iter__impl}{other\_iter\_impl}};}
\DoxyCodeLine{12839     \textcolor{keyword}{friend} BasicJsonType;}
\DoxyCodeLine{12840     \textcolor{keyword}{friend} \mbox{\hyperlink{classdetail_1_1iteration__proxy}{iteration\_proxy<iter\_impl>}};}
\DoxyCodeLine{12841     \textcolor{keyword}{friend} \mbox{\hyperlink{classdetail_1_1iteration__proxy__value}{iteration\_proxy\_value<iter\_impl>}};}
\DoxyCodeLine{12842 }
\DoxyCodeLine{12843     \textcolor{keyword}{using }object\_t = \textcolor{keyword}{typename} BasicJsonType::object\_t;}
\DoxyCodeLine{12844     \textcolor{keyword}{using }array\_t = \textcolor{keyword}{typename} BasicJsonType::array\_t;}
\DoxyCodeLine{12845     \textcolor{comment}{// make sure BasicJsonType is basic\_json or const basic\_json}}
\DoxyCodeLine{12846     \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structdetail_1_1is__basic__json}{is\_basic\_json<typename std::remove\_const<BasicJsonType>::type}}>::value,}
\DoxyCodeLine{12847                   \textcolor{stringliteral}{"{}iter\_impl only accepts (const) basic\_json"{}});}
\DoxyCodeLine{12848     \textcolor{comment}{// superficial check for the LegacyBidirectionalIterator named requirement}}
\DoxyCodeLine{12849     \textcolor{keyword}{static\_assert}(std::is\_base\_of<std::bidirectional\_iterator\_tag, std::bidirectional\_iterator\_tag>::value}
\DoxyCodeLine{12850                   \&\&  std::is\_base\_of<std::bidirectional\_iterator\_tag, typename std::iterator\_traits<typename array\_t::iterator>::iterator\_category>::value,}
\DoxyCodeLine{12851                   \textcolor{stringliteral}{"{}basic\_json iterator assumes array and object type iterators satisfy the LegacyBidirectionalIterator named requirement."{}});}
\DoxyCodeLine{12852 }
\DoxyCodeLine{12853   \textcolor{keyword}{public}:}
\DoxyCodeLine{12859     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iter__impl_a8fa317aaddc3dc7c58264e52e295c43e}{iterator\_category}} = std::bidirectional\_iterator\_tag;}
\DoxyCodeLine{12860 }
\DoxyCodeLine{12862     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iter__impl_ab6c453d3fea1df38fa45fd4f97ea42df}{value\_type}} = \textcolor{keyword}{typename} BasicJsonType::value\_type;}
\DoxyCodeLine{12864     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iter__impl_a6d51e1372282929d1c240223aa973c6e}{difference\_type}} = \textcolor{keyword}{typename} BasicJsonType::difference\_type;}
\DoxyCodeLine{12866     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iter__impl_aa8dd63c75410c2526f14481b2647e829}{pointer}} = \textcolor{keyword}{typename} std::conditional<std::is\_const<BasicJsonType>::value,}
\DoxyCodeLine{12867           \textcolor{keyword}{typename} BasicJsonType::const\_pointer,}
\DoxyCodeLine{12868           \textcolor{keyword}{typename} BasicJsonType::pointer>::type;}
\DoxyCodeLine{12870     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1iter__impl_aef4718cdd15a8743df34c4861c375144}{reference}} =}
\DoxyCodeLine{12871         \textcolor{keyword}{typename} std::conditional<std::is\_const<BasicJsonType>::value,}
\DoxyCodeLine{12872         \textcolor{keyword}{typename} BasicJsonType::const\_reference,}
\DoxyCodeLine{12873         \textcolor{keyword}{typename} BasicJsonType::reference>::type;}
\DoxyCodeLine{12874 }
\DoxyCodeLine{12875     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12876     \mbox{\hyperlink{classdetail_1_1iter__impl}{\string~iter\_impl}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12877     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}(\mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\&\&) noexcept = default;}
\DoxyCodeLine{12878     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& operator=(\mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\&\&) noexcept = default;}
\DoxyCodeLine{12879 }
\DoxyCodeLine{12886     explicit \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}(\mbox{\hyperlink{classdetail_1_1iter__impl_aa8dd63c75410c2526f14481b2647e829}{pointer}} \textcolor{keywordtype}{object}) noexcept : m\_object(\textcolor{keywordtype}{object})}
\DoxyCodeLine{12887     \{}
\DoxyCodeLine{12888         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{12889 }
\DoxyCodeLine{12890         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{12891         \{}
\DoxyCodeLine{12892             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{12893             \{}
\DoxyCodeLine{12894                 m\_it.object\_iterator = \textcolor{keyword}{typename} object\_t::iterator();}
\DoxyCodeLine{12895                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12896             \}}
\DoxyCodeLine{12897 }
\DoxyCodeLine{12898             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{12899             \{}
\DoxyCodeLine{12900                 m\_it.array\_iterator = \textcolor{keyword}{typename} array\_t::iterator();}
\DoxyCodeLine{12901                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12902             \}}
\DoxyCodeLine{12903 }
\DoxyCodeLine{12904             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{12905             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{12906             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{12907             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{12908             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{12909             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{12910             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{12911             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{12912             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{12913             \{}
\DoxyCodeLine{12914                 m\_it.primitive\_iterator = \mbox{\hyperlink{classdetail_1_1primitive__iterator__t}{primitive\_iterator\_t}}();}
\DoxyCodeLine{12915                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12916             \}}
\DoxyCodeLine{12917         \}}
\DoxyCodeLine{12918     \}}
\DoxyCodeLine{12919 }
\DoxyCodeLine{12936     \mbox{\hyperlink{classdetail_1_1iter__impl_af8d8847a82d9dab28bd4650ed13a7c90}{iter\_impl}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl<const BasicJsonType>}}\& other) noexcept}
\DoxyCodeLine{12937         : m\_object(other.m\_object), m\_it(other.m\_it)}
\DoxyCodeLine{12938     \{\}}
\DoxyCodeLine{12939 }
\DoxyCodeLine{12946     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& \mbox{\hyperlink{classdetail_1_1iter__impl_ae347fdf39e75d13ce488335ef1529b27}{operator=}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl<const BasicJsonType>}}\& other) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{12947     \{}
\DoxyCodeLine{12948         \textcolor{keywordflow}{if} (\&other != \textcolor{keyword}{this})}
\DoxyCodeLine{12949         \{}
\DoxyCodeLine{12950             m\_object = other.m\_object;}
\DoxyCodeLine{12951             m\_it = other.\mbox{\hyperlink{classdetail_1_1iter__impl_a79b7b8c6b778d9f7e76b086b45d9ea2e}{m\_it}};}
\DoxyCodeLine{12952         \}}
\DoxyCodeLine{12953         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12954     \}}
\DoxyCodeLine{12955 }
\DoxyCodeLine{12961     \mbox{\hyperlink{classdetail_1_1iter__impl_a26079f33eb8a16683577cf3782558f26}{iter\_impl}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}<\textcolor{keyword}{typename} std::remove\_const<BasicJsonType>::type>\& other) noexcept}
\DoxyCodeLine{12962         : m\_object(other.m\_object), m\_it(other.m\_it)}
\DoxyCodeLine{12963     \{\}}
\DoxyCodeLine{12964 }
\DoxyCodeLine{12971     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& \mbox{\hyperlink{classdetail_1_1iter__impl_a228140be2554afd5dfe54d4194780b7c}{operator=}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}<\textcolor{keyword}{typename} std::remove\_const<BasicJsonType>::type>\& other) \textcolor{keyword}{noexcept} \textcolor{comment}{// NOLINT(cert-\/oop54-\/cpp)}}
\DoxyCodeLine{12972     \{}
\DoxyCodeLine{12973         m\_object = other.m\_object;}
\DoxyCodeLine{12974         m\_it = other.\mbox{\hyperlink{classdetail_1_1iter__impl_a79b7b8c6b778d9f7e76b086b45d9ea2e}{m\_it}};}
\DoxyCodeLine{12975         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{12976     \}}
\DoxyCodeLine{12977 }
\DoxyCodeLine{12978   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{12983     \textcolor{keywordtype}{void} set\_begin() noexcept}
\DoxyCodeLine{12984     \{}
\DoxyCodeLine{12985         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{12986 }
\DoxyCodeLine{12987         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{12988         \{}
\DoxyCodeLine{12989             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{12990             \{}
\DoxyCodeLine{12991                 m\_it.object\_iterator = m\_object-\/>m\_value.object-\/>begin();}
\DoxyCodeLine{12992                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12993             \}}
\DoxyCodeLine{12994 }
\DoxyCodeLine{12995             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{12996             \{}
\DoxyCodeLine{12997                 m\_it.array\_iterator = m\_object-\/>m\_value.array-\/>begin();}
\DoxyCodeLine{12998                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{12999             \}}
\DoxyCodeLine{13000 }
\DoxyCodeLine{13001             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13002             \{}
\DoxyCodeLine{13003                 \textcolor{comment}{// set to end so begin()==end() is true: null is empty}}
\DoxyCodeLine{13004                 m\_it.primitive\_iterator.set\_end();}
\DoxyCodeLine{13005                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13006             \}}
\DoxyCodeLine{13007 }
\DoxyCodeLine{13008             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13009             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13010             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13011             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13012             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13013             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13014             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13015             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13016             \{}
\DoxyCodeLine{13017                 m\_it.primitive\_iterator.set\_begin();}
\DoxyCodeLine{13018                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13019             \}}
\DoxyCodeLine{13020         \}}
\DoxyCodeLine{13021     \}}
\DoxyCodeLine{13022 }
\DoxyCodeLine{13027     \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1iter__impl_afc94db3b8f35616347c25fae68e09509}{set\_end}}() noexcept}
\DoxyCodeLine{13028     \{}
\DoxyCodeLine{13029         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13030 }
\DoxyCodeLine{13031         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{13032         \{}
\DoxyCodeLine{13033             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{13034             \{}
\DoxyCodeLine{13035                 m\_it.object\_iterator = m\_object-\/>m\_value.object-\/>end();}
\DoxyCodeLine{13036                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13037             \}}
\DoxyCodeLine{13038 }
\DoxyCodeLine{13039             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{13040             \{}
\DoxyCodeLine{13041                 m\_it.array\_iterator = m\_object-\/>m\_value.array-\/>end();}
\DoxyCodeLine{13042                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13043             \}}
\DoxyCodeLine{13044 }
\DoxyCodeLine{13045             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13046             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13047             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13048             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13049             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13050             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13051             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13052             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13053             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13054             \{}
\DoxyCodeLine{13055                 m\_it.primitive\_iterator.set\_end();}
\DoxyCodeLine{13056                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13057             \}}
\DoxyCodeLine{13058         \}}
\DoxyCodeLine{13059     \}}
\DoxyCodeLine{13060 }
\DoxyCodeLine{13061   \textcolor{keyword}{public}:}
\DoxyCodeLine{13066     \mbox{\hyperlink{classdetail_1_1iter__impl_aef4718cdd15a8743df34c4861c375144}{reference}} \mbox{\hyperlink{classdetail_1_1iter__impl_abbef7d5bdb2c45980a34e907610c32b2}{operator*}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{13067 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13068         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13069 }
\DoxyCodeLine{13070         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{13071         \{}
\DoxyCodeLine{13072             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{13073             \{}
\DoxyCodeLine{13074                 JSON\_ASSERT(m\_it.object\_iterator != m\_object-\/>m\_value.object-\/>end());}
\DoxyCodeLine{13075                 \textcolor{keywordflow}{return} m\_it.object\_iterator-\/>second;}
\DoxyCodeLine{13076             \}}
\DoxyCodeLine{13077 }
\DoxyCodeLine{13078             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{13079             \{}
\DoxyCodeLine{13080                 JSON\_ASSERT(m\_it.array\_iterator != m\_object-\/>m\_value.array-\/>end());}
\DoxyCodeLine{13081                 \textcolor{keywordflow}{return} *m\_it.array\_iterator;}
\DoxyCodeLine{13082             \}}
\DoxyCodeLine{13083 }
\DoxyCodeLine{13084             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13085                 JSON\_THROW(invalid\_iterator::create(214, \textcolor{stringliteral}{"{}cannot get value"{}}, m\_object));}
\DoxyCodeLine{13086 }
\DoxyCodeLine{13087             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13088             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13089             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13090             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13091             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13092             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13093             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13094             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13095             \{}
\DoxyCodeLine{13096                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(m\_it.primitive\_iterator.is\_begin()))}
\DoxyCodeLine{13097                 \{}
\DoxyCodeLine{13098                     \textcolor{keywordflow}{return} *m\_object;}
\DoxyCodeLine{13099                 \}}
\DoxyCodeLine{13100 }
\DoxyCodeLine{13101                 JSON\_THROW(invalid\_iterator::create(214, \textcolor{stringliteral}{"{}cannot get value"{}}, m\_object));}
\DoxyCodeLine{13102             \}}
\DoxyCodeLine{13103         \}}
\DoxyCodeLine{13104     \}}
\DoxyCodeLine{13105 }
\DoxyCodeLine{13110     \mbox{\hyperlink{classdetail_1_1iter__impl_aa8dd63c75410c2526f14481b2647e829}{pointer}} \mbox{\hyperlink{classdetail_1_1iter__impl_a72314a87e67ba523f1be2f014f4eab56}{operator-\/>}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{13111 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13112         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13113 }
\DoxyCodeLine{13114         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{13115         \{}
\DoxyCodeLine{13116             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{13117             \{}
\DoxyCodeLine{13118                 JSON\_ASSERT(m\_it.object\_iterator != m\_object-\/>m\_value.object-\/>end());}
\DoxyCodeLine{13119                 \textcolor{keywordflow}{return} \&(m\_it.object\_iterator-\/>second);}
\DoxyCodeLine{13120             \}}
\DoxyCodeLine{13121 }
\DoxyCodeLine{13122             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{13123             \{}
\DoxyCodeLine{13124                 JSON\_ASSERT(m\_it.array\_iterator != m\_object-\/>m\_value.array-\/>end());}
\DoxyCodeLine{13125                 \textcolor{keywordflow}{return} \&*m\_it.array\_iterator;}
\DoxyCodeLine{13126             \}}
\DoxyCodeLine{13127 }
\DoxyCodeLine{13128             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13129             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13130             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13131             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13132             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13133             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13134             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13135             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13136             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13137             \{}
\DoxyCodeLine{13138                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(m\_it.primitive\_iterator.is\_begin()))}
\DoxyCodeLine{13139                 \{}
\DoxyCodeLine{13140                     \textcolor{keywordflow}{return} m\_object;}
\DoxyCodeLine{13141                 \}}
\DoxyCodeLine{13142 }
\DoxyCodeLine{13143                 JSON\_THROW(invalid\_iterator::create(214, \textcolor{stringliteral}{"{}cannot get value"{}}, m\_object));}
\DoxyCodeLine{13144             \}}
\DoxyCodeLine{13145         \}}
\DoxyCodeLine{13146     \}}
\DoxyCodeLine{13147 }
\DoxyCodeLine{13152     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}} \mbox{\hyperlink{classdetail_1_1iter__impl_a5a1af6b2cd3611778b697bb7d7107f0d}{operator++}}(\textcolor{keywordtype}{int})\& \textcolor{comment}{// NOLINT(cert-\/dcl21-\/cpp)}}
\DoxyCodeLine{13153     \{}
\DoxyCodeLine{13154         \textcolor{keyword}{auto} result = *\textcolor{keyword}{this};}
\DoxyCodeLine{13155         ++(*this);}
\DoxyCodeLine{13156         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{13157     \}}
\DoxyCodeLine{13158 }
\DoxyCodeLine{13163     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& \mbox{\hyperlink{classdetail_1_1iter__impl_ab0288ec335f563769a09fba1123c076c}{operator++}}()}
\DoxyCodeLine{13164     \{}
\DoxyCodeLine{13165         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13166 }
\DoxyCodeLine{13167         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{13168         \{}
\DoxyCodeLine{13169             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{13170             \{}
\DoxyCodeLine{13171                 std::advance(m\_it.object\_iterator, 1);}
\DoxyCodeLine{13172                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13173             \}}
\DoxyCodeLine{13174 }
\DoxyCodeLine{13175             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{13176             \{}
\DoxyCodeLine{13177                 std::advance(m\_it.array\_iterator, 1);}
\DoxyCodeLine{13178                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13179             \}}
\DoxyCodeLine{13180 }
\DoxyCodeLine{13181             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13182             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13183             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13184             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13185             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13186             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13187             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13188             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13189             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13190             \{}
\DoxyCodeLine{13191                 ++m\_it.primitive\_iterator;}
\DoxyCodeLine{13192                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13193             \}}
\DoxyCodeLine{13194         \}}
\DoxyCodeLine{13195 }
\DoxyCodeLine{13196         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{13197     \}}
\DoxyCodeLine{13198 }
\DoxyCodeLine{13203     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}} \mbox{\hyperlink{classdetail_1_1iter__impl_ae8c229d46359424bf850f1ecb5587a70}{operator-\/-\/}}(\textcolor{keywordtype}{int})\& \textcolor{comment}{// NOLINT(cert-\/dcl21-\/cpp)}}
\DoxyCodeLine{13204     \{}
\DoxyCodeLine{13205         \textcolor{keyword}{auto} result = *\textcolor{keyword}{this};}
\DoxyCodeLine{13206         -\/-\/(*this);}
\DoxyCodeLine{13207         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{13208     \}}
\DoxyCodeLine{13209 }
\DoxyCodeLine{13214     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& \mbox{\hyperlink{classdetail_1_1iter__impl_a3b7d07348aaaaf3eda9bd98b7d80415f}{operator-\/-\/}}()}
\DoxyCodeLine{13215     \{}
\DoxyCodeLine{13216         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13217 }
\DoxyCodeLine{13218         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{13219         \{}
\DoxyCodeLine{13220             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{13221             \{}
\DoxyCodeLine{13222                 std::advance(m\_it.object\_iterator, -\/1);}
\DoxyCodeLine{13223                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13224             \}}
\DoxyCodeLine{13225 }
\DoxyCodeLine{13226             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{13227             \{}
\DoxyCodeLine{13228                 std::advance(m\_it.array\_iterator, -\/1);}
\DoxyCodeLine{13229                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13230             \}}
\DoxyCodeLine{13231 }
\DoxyCodeLine{13232             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13233             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13234             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13235             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13236             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13237             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13238             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13239             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13240             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13241             \{}
\DoxyCodeLine{13242                 -\/-\/m\_it.primitive\_iterator;}
\DoxyCodeLine{13243                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13244             \}}
\DoxyCodeLine{13245         \}}
\DoxyCodeLine{13246 }
\DoxyCodeLine{13247         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{13248     \}}
\DoxyCodeLine{13249 }
\DoxyCodeLine{13254     \textcolor{keyword}{template} < \textcolor{keyword}{typename} IterImpl, detail::enable\_if\_t < (std::is\_same<IterImpl, iter\_impl>::value || std::is\_same<IterImpl, other\_iter\_impl>::value), std::\textcolor{keywordtype}{nullptr}\_t > = \textcolor{keywordtype}{nullptr} >}
\DoxyCodeLine{13255     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1iter__impl_a57b4e1eee4a3cdb3c0683cf64979da8d}{operator==}}(\textcolor{keyword}{const} IterImpl\& other)\textcolor{keyword}{ const}}
\DoxyCodeLine{13256 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13257         \textcolor{comment}{// if objects are not the same, the comparison is undefined}}
\DoxyCodeLine{13258         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(m\_object != other.m\_object))}
\DoxyCodeLine{13259         \{}
\DoxyCodeLine{13260             JSON\_THROW(invalid\_iterator::create(212, \textcolor{stringliteral}{"{}cannot compare iterators of different containers"{}}, m\_object));}
\DoxyCodeLine{13261         \}}
\DoxyCodeLine{13262 }
\DoxyCodeLine{13263         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13264 }
\DoxyCodeLine{13265         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{13266         \{}
\DoxyCodeLine{13267             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{13268                 \textcolor{keywordflow}{return} (m\_it.object\_iterator == other.m\_it.object\_iterator);}
\DoxyCodeLine{13269 }
\DoxyCodeLine{13270             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{13271                 \textcolor{keywordflow}{return} (m\_it.array\_iterator == other.m\_it.array\_iterator);}
\DoxyCodeLine{13272 }
\DoxyCodeLine{13273             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13274             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13275             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13276             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13277             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13278             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13279             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13280             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13281             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13282                 \textcolor{keywordflow}{return} (m\_it.primitive\_iterator == other.m\_it.primitive\_iterator);}
\DoxyCodeLine{13283         \}}
\DoxyCodeLine{13284     \}}
\DoxyCodeLine{13285 }
\DoxyCodeLine{13290     \textcolor{keyword}{template} < \textcolor{keyword}{typename} IterImpl, detail::enable\_if\_t < (std::is\_same<IterImpl, iter\_impl>::value || std::is\_same<IterImpl, other\_iter\_impl>::value), std::\textcolor{keywordtype}{nullptr}\_t > = \textcolor{keywordtype}{nullptr} >}
\DoxyCodeLine{13291     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1iter__impl_ae52db5f16f00edc13c848fe99e4c521b}{operator!=}}(\textcolor{keyword}{const} IterImpl\& other)\textcolor{keyword}{ const}}
\DoxyCodeLine{13292 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13293         \textcolor{keywordflow}{return} !operator==(other);}
\DoxyCodeLine{13294     \}}
\DoxyCodeLine{13295 }
\DoxyCodeLine{13300     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1iter__impl_a339df296df7f5d014d5c7cedf40497da}{operator<}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& other)\textcolor{keyword}{ const}}
\DoxyCodeLine{13301 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13302         \textcolor{comment}{// if objects are not the same, the comparison is undefined}}
\DoxyCodeLine{13303         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(m\_object != other.m\_object))}
\DoxyCodeLine{13304         \{}
\DoxyCodeLine{13305             JSON\_THROW(invalid\_iterator::create(212, \textcolor{stringliteral}{"{}cannot compare iterators of different containers"{}}, m\_object));}
\DoxyCodeLine{13306         \}}
\DoxyCodeLine{13307 }
\DoxyCodeLine{13308         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13309 }
\DoxyCodeLine{13310         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{13311         \{}
\DoxyCodeLine{13312             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{13313                 JSON\_THROW(invalid\_iterator::create(213, \textcolor{stringliteral}{"{}cannot compare order of object iterators"{}}, m\_object));}
\DoxyCodeLine{13314 }
\DoxyCodeLine{13315             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{13316                 \textcolor{keywordflow}{return} (m\_it.array\_iterator < other.\mbox{\hyperlink{classdetail_1_1iter__impl_a79b7b8c6b778d9f7e76b086b45d9ea2e}{m\_it}}.\mbox{\hyperlink{structdetail_1_1internal__iterator_a2ad2dc9ea8bba2b50811e34f905350bd}{array\_iterator}});}
\DoxyCodeLine{13317 }
\DoxyCodeLine{13318             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13319             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13320             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13321             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13322             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13323             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13324             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13325             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13326             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13327                 \textcolor{keywordflow}{return} (m\_it.primitive\_iterator < other.\mbox{\hyperlink{classdetail_1_1iter__impl_a79b7b8c6b778d9f7e76b086b45d9ea2e}{m\_it}}.\mbox{\hyperlink{structdetail_1_1internal__iterator_a8bb8034d2d35fb129e0dd742ce024e44}{primitive\_iterator}});}
\DoxyCodeLine{13328         \}}
\DoxyCodeLine{13329     \}}
\DoxyCodeLine{13330 }
\DoxyCodeLine{13335     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1iter__impl_a343806ffb02d7ce5266492128dfd5f9b}{operator<=}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& other)\textcolor{keyword}{ const}}
\DoxyCodeLine{13336 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13337         \textcolor{keywordflow}{return} !other.operator < (*this);}
\DoxyCodeLine{13338     \}}
\DoxyCodeLine{13339 }
\DoxyCodeLine{13344     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1iter__impl_a9b066d888f2f0ad0cd601594661a8e8b}{operator>}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& other)\textcolor{keyword}{ const}}
\DoxyCodeLine{13345 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13346         \textcolor{keywordflow}{return} !operator<=(other);}
\DoxyCodeLine{13347     \}}
\DoxyCodeLine{13348 }
\DoxyCodeLine{13353     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classdetail_1_1iter__impl_a25a3a8e85eb37727487f210f5304a48e}{operator>=}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& other)\textcolor{keyword}{ const}}
\DoxyCodeLine{13354 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13355         \textcolor{keywordflow}{return} !\mbox{\hyperlink{namespacedetail_aac7ca91589afb0bad68baec5949daaa2}{operator<}}(other);}
\DoxyCodeLine{13356     \}}
\DoxyCodeLine{13357 }
\DoxyCodeLine{13362     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& \mbox{\hyperlink{classdetail_1_1iter__impl_a5e2dd333526ae85044fe78f65aac9b52}{operator+=}}(\mbox{\hyperlink{classdetail_1_1iter__impl_a6d51e1372282929d1c240223aa973c6e}{difference\_type}} i)}
\DoxyCodeLine{13363     \{}
\DoxyCodeLine{13364         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13365 }
\DoxyCodeLine{13366         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{13367         \{}
\DoxyCodeLine{13368             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{13369                 JSON\_THROW(invalid\_iterator::create(209, \textcolor{stringliteral}{"{}cannot use offsets with object iterators"{}}, m\_object));}
\DoxyCodeLine{13370 }
\DoxyCodeLine{13371             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{13372             \{}
\DoxyCodeLine{13373                 std::advance(m\_it.array\_iterator, i);}
\DoxyCodeLine{13374                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13375             \}}
\DoxyCodeLine{13376 }
\DoxyCodeLine{13377             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13378             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13379             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13380             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13381             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13382             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13383             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13384             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13385             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13386             \{}
\DoxyCodeLine{13387                 m\_it.primitive\_iterator += i;}
\DoxyCodeLine{13388                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{13389             \}}
\DoxyCodeLine{13390         \}}
\DoxyCodeLine{13391 }
\DoxyCodeLine{13392         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{13393     \}}
\DoxyCodeLine{13394 }
\DoxyCodeLine{13399     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& \mbox{\hyperlink{classdetail_1_1iter__impl_a3b48ed5856ca2011e8463d868fda3d0b}{operator-\/=}}(\mbox{\hyperlink{classdetail_1_1iter__impl_a6d51e1372282929d1c240223aa973c6e}{difference\_type}} i)}
\DoxyCodeLine{13400     \{}
\DoxyCodeLine{13401         \textcolor{keywordflow}{return} operator+=(-\/i);}
\DoxyCodeLine{13402     \}}
\DoxyCodeLine{13403 }
\DoxyCodeLine{13408     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}} \mbox{\hyperlink{classdetail_1_1iter__impl_a03abdffc86382e7c2a7c462c217d120e}{operator+}}(\mbox{\hyperlink{classdetail_1_1iter__impl_a6d51e1372282929d1c240223aa973c6e}{difference\_type}} i)\textcolor{keyword}{ const}}
\DoxyCodeLine{13409 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13410         \textcolor{keyword}{auto} result = *\textcolor{keyword}{this};}
\DoxyCodeLine{13411         result += i;}
\DoxyCodeLine{13412         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{13413     \}}
\DoxyCodeLine{13414 }
\DoxyCodeLine{13419     \textcolor{keyword}{friend} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}} \mbox{\hyperlink{classdetail_1_1iter__impl_a94108d1a7563e103534f23eb5c1ee175}{operator+}}(\mbox{\hyperlink{classdetail_1_1iter__impl_a6d51e1372282929d1c240223aa973c6e}{difference\_type}} i, \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& it)}
\DoxyCodeLine{13420     \{}
\DoxyCodeLine{13421         \textcolor{keyword}{auto} result = it;}
\DoxyCodeLine{13422         result += i;}
\DoxyCodeLine{13423         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{13424     \}}
\DoxyCodeLine{13425 }
\DoxyCodeLine{13430     \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}} \mbox{\hyperlink{classdetail_1_1iter__impl_abfcadba7a9796c3f5a5e123efef349ec}{operator-\/}}(\mbox{\hyperlink{classdetail_1_1iter__impl_a6d51e1372282929d1c240223aa973c6e}{difference\_type}} i)\textcolor{keyword}{ const}}
\DoxyCodeLine{13431 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13432         \textcolor{keyword}{auto} result = *\textcolor{keyword}{this};}
\DoxyCodeLine{13433         result -\/= i;}
\DoxyCodeLine{13434         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{13435     \}}
\DoxyCodeLine{13436 }
\DoxyCodeLine{13441     \mbox{\hyperlink{classdetail_1_1iter__impl_a6d51e1372282929d1c240223aa973c6e}{difference\_type}} \mbox{\hyperlink{classdetail_1_1iter__impl_a848837b8db99998c90d7bd71492d0dee}{operator-\/}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1iter__impl}{iter\_impl}}\& other)\textcolor{keyword}{ const}}
\DoxyCodeLine{13442 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13443         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13444 }
\DoxyCodeLine{13445         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{13446         \{}
\DoxyCodeLine{13447             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{13448                 JSON\_THROW(invalid\_iterator::create(209, \textcolor{stringliteral}{"{}cannot use offsets with object iterators"{}}, m\_object));}
\DoxyCodeLine{13449 }
\DoxyCodeLine{13450             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{13451                 \textcolor{keywordflow}{return} m\_it.array\_iterator -\/ other.\mbox{\hyperlink{classdetail_1_1iter__impl_a79b7b8c6b778d9f7e76b086b45d9ea2e}{m\_it}}.\mbox{\hyperlink{structdetail_1_1internal__iterator_a2ad2dc9ea8bba2b50811e34f905350bd}{array\_iterator}};}
\DoxyCodeLine{13452 }
\DoxyCodeLine{13453             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13454             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13455             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13456             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13457             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13458             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13459             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13460             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13461             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13462                 \textcolor{keywordflow}{return} m\_it.primitive\_iterator -\/ other.\mbox{\hyperlink{classdetail_1_1iter__impl_a79b7b8c6b778d9f7e76b086b45d9ea2e}{m\_it}}.\mbox{\hyperlink{structdetail_1_1internal__iterator_a8bb8034d2d35fb129e0dd742ce024e44}{primitive\_iterator}};}
\DoxyCodeLine{13463         \}}
\DoxyCodeLine{13464     \}}
\DoxyCodeLine{13465 }
\DoxyCodeLine{13470     \mbox{\hyperlink{classdetail_1_1iter__impl_aef4718cdd15a8743df34c4861c375144}{reference}} \mbox{\hyperlink{classdetail_1_1iter__impl_a5e557e30103e2af36cd8173c88eb586c}{operator[]}}(\mbox{\hyperlink{classdetail_1_1iter__impl_a6d51e1372282929d1c240223aa973c6e}{difference\_type}} n)\textcolor{keyword}{ const}}
\DoxyCodeLine{13471 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13472         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13473 }
\DoxyCodeLine{13474         \textcolor{keywordflow}{switch} (m\_object-\/>m\_type)}
\DoxyCodeLine{13475         \{}
\DoxyCodeLine{13476             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{13477                 JSON\_THROW(invalid\_iterator::create(208, \textcolor{stringliteral}{"{}cannot use operator[] for object iterators"{}}, m\_object));}
\DoxyCodeLine{13478 }
\DoxyCodeLine{13479             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{13480                 \textcolor{keywordflow}{return} *std::next(m\_it.array\_iterator, n);}
\DoxyCodeLine{13481 }
\DoxyCodeLine{13482             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{13483                 JSON\_THROW(invalid\_iterator::create(214, \textcolor{stringliteral}{"{}cannot get value"{}}, m\_object));}
\DoxyCodeLine{13484 }
\DoxyCodeLine{13485             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{13486             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{13487             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{13488             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{13489             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{13490             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{13491             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{13492             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{13493             \{}
\DoxyCodeLine{13494                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(m\_it.primitive\_iterator.get\_value() == -\/n))}
\DoxyCodeLine{13495                 \{}
\DoxyCodeLine{13496                     \textcolor{keywordflow}{return} *m\_object;}
\DoxyCodeLine{13497                 \}}
\DoxyCodeLine{13498 }
\DoxyCodeLine{13499                 JSON\_THROW(invalid\_iterator::create(214, \textcolor{stringliteral}{"{}cannot get value"{}}, m\_object));}
\DoxyCodeLine{13500             \}}
\DoxyCodeLine{13501         \}}
\DoxyCodeLine{13502     \}}
\DoxyCodeLine{13503 }
\DoxyCodeLine{13508     \textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{classdetail_1_1iter__impl_a4064b295014b32f3cabd86f94264fc74}{key}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{13509 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13510         JSON\_ASSERT(m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{13511 }
\DoxyCodeLine{13512         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(m\_object-\/>is\_object()))}
\DoxyCodeLine{13513         \{}
\DoxyCodeLine{13514             \textcolor{keywordflow}{return} m\_it.object\_iterator-\/>first;}
\DoxyCodeLine{13515         \}}
\DoxyCodeLine{13516 }
\DoxyCodeLine{13517         JSON\_THROW(invalid\_iterator::create(207, \textcolor{stringliteral}{"{}cannot use key() for non-\/object iterators"{}}, m\_object));}
\DoxyCodeLine{13518     \}}
\DoxyCodeLine{13519 }
\DoxyCodeLine{13524     \mbox{\hyperlink{classdetail_1_1iter__impl_aef4718cdd15a8743df34c4861c375144}{reference}} \mbox{\hyperlink{classdetail_1_1iter__impl_a96557c87bc9b3adf6aa0b1a6b6209525}{value}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{13525 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13526         \textcolor{keywordflow}{return} operator*();}
\DoxyCodeLine{13527     \}}
\DoxyCodeLine{13528 }
\DoxyCodeLine{13529   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{13531     pointer m\_object = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13533     \mbox{\hyperlink{structdetail_1_1internal__iterator}{internal\_iterator<typename std::remove\_const<BasicJsonType>::type}}> m\_it \{\};}
\DoxyCodeLine{13534 \};}
\DoxyCodeLine{13535 }
\DoxyCodeLine{13536 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{13537 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{13538 }
\DoxyCodeLine{13539 \textcolor{comment}{// \#include <nlohmann/detail/iterators/iteration\_proxy.hpp>}}
\DoxyCodeLine{13540 }
\DoxyCodeLine{13541 \textcolor{comment}{// \#include <nlohmann/detail/iterators/json\_reverse\_iterator.hpp>}}
\DoxyCodeLine{13542 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{13543 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{13544 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{13545 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{13546 \textcolor{comment}{//}}
\DoxyCodeLine{13547 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{13548 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{13549 }
\DoxyCodeLine{13550 }
\DoxyCodeLine{13551 }
\DoxyCodeLine{13552 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// ptrdiff\_t}}
\DoxyCodeLine{13553 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// reverse\_iterator}}
\DoxyCodeLine{13554 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// declval}}
\DoxyCodeLine{13555 }
\DoxyCodeLine{13556 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{13557 }
\DoxyCodeLine{13558 }
\DoxyCodeLine{13559 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{13560 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{13561 \{}
\DoxyCodeLine{13562 }
\DoxyCodeLine{13564 \textcolor{comment}{// reverse\_iterator //}}
\DoxyCodeLine{13566 \textcolor{comment}{}}
\DoxyCodeLine{13585 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Base>}
\DoxyCodeLine{13586 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}} : \textcolor{keyword}{public} std::reverse\_iterator<Base>}
\DoxyCodeLine{13587 \{}
\DoxyCodeLine{13588   \textcolor{keyword}{public}:}
\DoxyCodeLine{13589     \textcolor{keyword}{using }difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{13591     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1json__reverse__iterator_ab306723c375c396a5ccd90e2d31ad651}{base\_iterator}} = std::reverse\_iterator<Base>;}
\DoxyCodeLine{13593     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a81a4d0a61246d4ece37fd14eacfadda0}{reference}} = \textcolor{keyword}{typename} Base::reference;}
\DoxyCodeLine{13594 }
\DoxyCodeLine{13596     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_ad0012dca9469c2d5669ca2e446c8957d}{json\_reverse\_iterator}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} base\_iterator::iterator\_type\& it) noexcept}
\DoxyCodeLine{13597         : \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_ab306723c375c396a5ccd90e2d31ad651}{base\_iterator}}(it) \{\}}
\DoxyCodeLine{13598 }
\DoxyCodeLine{13600     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a95ef832171f9aba019f284125bed75ca}{json\_reverse\_iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_ab306723c375c396a5ccd90e2d31ad651}{base\_iterator}}\& it) noexcept : \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_ab306723c375c396a5ccd90e2d31ad651}{base\_iterator}}(it) \{\}}
\DoxyCodeLine{13601 }
\DoxyCodeLine{13603     \mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a000addec834a8db323312794737623da}{operator++}}(\textcolor{keywordtype}{int})\& \textcolor{comment}{// NOLINT(cert-\/dcl21-\/cpp)}}
\DoxyCodeLine{13604     \{}
\DoxyCodeLine{13605         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\textcolor{keyword}{>}(base\_iterator::operator++(1));}
\DoxyCodeLine{13606     \}}
\DoxyCodeLine{13607 }
\DoxyCodeLine{13609     \mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\& \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a3e611d63a209fdfd1278c2a9d86c40e3}{operator++}}()}
\DoxyCodeLine{13610     \{}
\DoxyCodeLine{13611         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\&\textcolor{keyword}{>}(base\_iterator::operator++());}
\DoxyCodeLine{13612     \}}
\DoxyCodeLine{13613 }
\DoxyCodeLine{13615     \mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a1abdaf558ee194cdd44e9cee82fce77d}{operator-\/-\/}}(\textcolor{keywordtype}{int})\& \textcolor{comment}{// NOLINT(cert-\/dcl21-\/cpp)}}
\DoxyCodeLine{13616     \{}
\DoxyCodeLine{13617         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\textcolor{keyword}{>}(base\_iterator::operator-\/-\/(1));}
\DoxyCodeLine{13618     \}}
\DoxyCodeLine{13619 }
\DoxyCodeLine{13621     \mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\& \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a9736216bab45871b1c62eb68df0613c3}{operator-\/-\/}}()}
\DoxyCodeLine{13622     \{}
\DoxyCodeLine{13623         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\&\textcolor{keyword}{>}(base\_iterator::operator-\/-\/());}
\DoxyCodeLine{13624     \}}
\DoxyCodeLine{13625 }
\DoxyCodeLine{13627     \mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\& \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a4e433b66cce1a79c88bfe645de9794dc}{operator+=}}(difference\_type i)}
\DoxyCodeLine{13628     \{}
\DoxyCodeLine{13629         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\&\textcolor{keyword}{>}(base\_iterator::operator+=(i));}
\DoxyCodeLine{13630     \}}
\DoxyCodeLine{13631 }
\DoxyCodeLine{13633     \mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_adff7b1171a9a154b5a339b0a0e85404d}{operator+}}(difference\_type i)\textcolor{keyword}{ const}}
\DoxyCodeLine{13634 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13635         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\textcolor{keyword}{>}(base\_iterator::operator+(i));}
\DoxyCodeLine{13636     \}}
\DoxyCodeLine{13637 }
\DoxyCodeLine{13639     \mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_abb64fbf5298d1bdc987496f57a288877}{operator-\/}}(difference\_type i)\textcolor{keyword}{ const}}
\DoxyCodeLine{13640 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13641         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\textcolor{keyword}{>}(base\_iterator::operator-\/(i));}
\DoxyCodeLine{13642     \}}
\DoxyCodeLine{13643 }
\DoxyCodeLine{13645     difference\_type \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a6eba395b9f3f0b2c470c5a240a041128}{operator-\/}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator}{json\_reverse\_iterator}}\& other)\textcolor{keyword}{ const}}
\DoxyCodeLine{13646 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13647         \textcolor{keywordflow}{return} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_ab306723c375c396a5ccd90e2d31ad651}{base\_iterator}}(*\textcolor{keyword}{this}) -\/ \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_ab306723c375c396a5ccd90e2d31ad651}{base\_iterator}}(other);}
\DoxyCodeLine{13648     \}}
\DoxyCodeLine{13649 }
\DoxyCodeLine{13651     \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a81a4d0a61246d4ece37fd14eacfadda0}{reference}} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a50a57718a9d49039b7592bf34f5819a2}{operator[]}}(difference\_type n)\textcolor{keyword}{ const}}
\DoxyCodeLine{13652 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13653         \textcolor{keywordflow}{return} *(this-\/>operator+(n));}
\DoxyCodeLine{13654     \}}
\DoxyCodeLine{13655 }
\DoxyCodeLine{13657     \textcolor{keyword}{auto} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a68d4f0c3e978afdc7509ee88e2f7b996}{key}}() const -\/> decltype(std::declval<Base>().\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}())}
\DoxyCodeLine{13658     \{}
\DoxyCodeLine{13659         \textcolor{keyword}{auto} it = -\/-\/this-\/>base();}
\DoxyCodeLine{13660         \textcolor{keywordflow}{return} it.key();}
\DoxyCodeLine{13661     \}}
\DoxyCodeLine{13662 }
\DoxyCodeLine{13664     \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a81a4d0a61246d4ece37fd14eacfadda0}{reference}} \mbox{\hyperlink{classdetail_1_1json__reverse__iterator_a90132b4589e7b8c6cfdf4e25e1c311fe}{value}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{13665 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13666         \textcolor{keyword}{auto} it = -\/-\/this-\/>base();}
\DoxyCodeLine{13667         \textcolor{keywordflow}{return} it.operator * ();}
\DoxyCodeLine{13668     \}}
\DoxyCodeLine{13669 \};}
\DoxyCodeLine{13670 }
\DoxyCodeLine{13671 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{13672 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{13673 }
\DoxyCodeLine{13674 \textcolor{comment}{// \#include <nlohmann/detail/iterators/primitive\_iterator.hpp>}}
\DoxyCodeLine{13675 }
\DoxyCodeLine{13676 \textcolor{comment}{// \#include <nlohmann/detail/json\_pointer.hpp>}}
\DoxyCodeLine{13677 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{13678 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{13679 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{13680 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{13681 \textcolor{comment}{//}}
\DoxyCodeLine{13682 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{13683 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{13684 }
\DoxyCodeLine{13685 }
\DoxyCodeLine{13686 }
\DoxyCodeLine{13687 \textcolor{preprocessor}{\#include <algorithm>} \textcolor{comment}{// all\_of}}
\DoxyCodeLine{13688 \textcolor{preprocessor}{\#include <cctype>} \textcolor{comment}{// isdigit}}
\DoxyCodeLine{13689 \textcolor{preprocessor}{\#include <cerrno>} \textcolor{comment}{// errno, ERANGE}}
\DoxyCodeLine{13690 \textcolor{preprocessor}{\#include <cstdlib>} \textcolor{comment}{// strtoull}}
\DoxyCodeLine{13691 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{13692 \textcolor{preprocessor}{    \#include <iosfwd>} \textcolor{comment}{// ostream}}
\DoxyCodeLine{13693 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{13694 \textcolor{preprocessor}{\#include <limits>} \textcolor{comment}{// max}}
\DoxyCodeLine{13695 \textcolor{preprocessor}{\#include <numeric>} \textcolor{comment}{// accumulate}}
\DoxyCodeLine{13696 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{13697 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// move}}
\DoxyCodeLine{13698 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{13699 }
\DoxyCodeLine{13700 \textcolor{comment}{// \#include <nlohmann/detail/exceptions.hpp>}}
\DoxyCodeLine{13701 }
\DoxyCodeLine{13702 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{13703 }
\DoxyCodeLine{13704 \textcolor{comment}{// \#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{13705 }
\DoxyCodeLine{13706 \textcolor{comment}{// \#include <nlohmann/detail/string\_escape.hpp>}}
\DoxyCodeLine{13707 }
\DoxyCodeLine{13708 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{13709 }
\DoxyCodeLine{13710 }
\DoxyCodeLine{13711 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{13712 }
\DoxyCodeLine{13715 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringType>}
\DoxyCodeLine{13716 \textcolor{keyword}{class }\mbox{\hyperlink{classjson__pointer}{json\_pointer}}}
\DoxyCodeLine{13717 \{}
\DoxyCodeLine{13718     \textcolor{comment}{// allow basic\_json to access private members}}
\DoxyCodeLine{13719     NLOHMANN\_BASIC\_JSON\_TPL\_DECLARATION}
\DoxyCodeLine{13720     \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__json}{basic\_json}};}
\DoxyCodeLine{13721 }
\DoxyCodeLine{13722     \textcolor{keyword}{template}<\textcolor{keyword}{typename}>}
\DoxyCodeLine{13723     \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classjson__pointer}{json\_pointer}};}
\DoxyCodeLine{13724 }
\DoxyCodeLine{13725     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{13726     \textcolor{keyword}{struct }string\_t\_helper}
\DoxyCodeLine{13727     \{}
\DoxyCodeLine{13728         \textcolor{keyword}{using }type = T;}
\DoxyCodeLine{13729     \};}
\DoxyCodeLine{13730 }
\DoxyCodeLine{13731     NLOHMANN\_BASIC\_JSON\_TPL\_DECLARATION}
\DoxyCodeLine{13732     \textcolor{keyword}{struct }string\_t\_helper<NLOHMANN\_BASIC\_JSON\_TPL>}
\DoxyCodeLine{13733     \{}
\DoxyCodeLine{13734         \textcolor{keyword}{using }type = StringType;}
\DoxyCodeLine{13735     \};}
\DoxyCodeLine{13736 }
\DoxyCodeLine{13737   \textcolor{keyword}{public}:}
\DoxyCodeLine{13738     \textcolor{comment}{// for backwards compatibility accept BasicJsonType}}
\DoxyCodeLine{13739     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} string\_t\_helper<RefStringType>::type;}
\DoxyCodeLine{13740 }
\DoxyCodeLine{13743     \textcolor{keyword}{explicit} \mbox{\hyperlink{classjson__pointer_a5288b8f5d6ff6faca37f664b98a16ecd}{json\_pointer}}(\textcolor{keyword}{const} string\_t\& s = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{13744         : reference\_tokens(split(s))}
\DoxyCodeLine{13745     \{\}}
\DoxyCodeLine{13746 }
\DoxyCodeLine{13749     string\_t \mbox{\hyperlink{classjson__pointer_a6b94e2003be4cd72c4f145bcea2578ec}{to\_string}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{13750 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13751         \textcolor{keywordflow}{return} std::accumulate(reference\_tokens.begin(), reference\_tokens.end(),}
\DoxyCodeLine{13752                                string\_t\{\},}
\DoxyCodeLine{13753                                [](\textcolor{keyword}{const} string\_t\& a, \textcolor{keyword}{const} string\_t\& b)}
\DoxyCodeLine{13754         \{}
\DoxyCodeLine{13755             return detail::concat(a, \textcolor{stringliteral}{'/'}, detail::escape(b));}
\DoxyCodeLine{13756         \});}
\DoxyCodeLine{13757     \}}
\DoxyCodeLine{13758 }
\DoxyCodeLine{13761     JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.0, to\_string())}
\DoxyCodeLine{13762     operator string\_t()\textcolor{keyword}{ const}}
\DoxyCodeLine{13763 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13764         \textcolor{keywordflow}{return} to\_string();}
\DoxyCodeLine{13765     \}}
\DoxyCodeLine{13766 }
\DoxyCodeLine{13767 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{13770     \textcolor{keyword}{friend} std::ostream\& \mbox{\hyperlink{classjson__pointer_ad4140db2dd2f347f46f3abae0fc2156f}{operator<<}}(std::ostream\& o, \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& ptr)}
\DoxyCodeLine{13771     \{}
\DoxyCodeLine{13772         o << ptr.\mbox{\hyperlink{classjson__pointer_a6b94e2003be4cd72c4f145bcea2578ec}{to\_string}}();}
\DoxyCodeLine{13773         \textcolor{keywordflow}{return} o;}
\DoxyCodeLine{13774     \}}
\DoxyCodeLine{13775 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13776 }
\DoxyCodeLine{13779     \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& \mbox{\hyperlink{classjson__pointer_a8bb8e43c6e01a6370cd49ba130171219}{operator/=}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& ptr)}
\DoxyCodeLine{13780     \{}
\DoxyCodeLine{13781         reference\_tokens.insert(reference\_tokens.end(),}
\DoxyCodeLine{13782                                 ptr.reference\_tokens.begin(),}
\DoxyCodeLine{13783                                 ptr.reference\_tokens.end());}
\DoxyCodeLine{13784         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{13785     \}}
\DoxyCodeLine{13786 }
\DoxyCodeLine{13789     \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& \mbox{\hyperlink{classjson__pointer_aa810a9db8c1d6e67c4a3703dc66a18d4}{operator/=}}(string\_t token)}
\DoxyCodeLine{13790     \{}
\DoxyCodeLine{13791         push\_back(std::move(token));}
\DoxyCodeLine{13792         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{13793     \}}
\DoxyCodeLine{13794 }
\DoxyCodeLine{13797     \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& \mbox{\hyperlink{classjson__pointer_a6c2bffffbf08b77259e0b658c841703c}{operator/=}}(std::size\_t array\_idx)}
\DoxyCodeLine{13798     \{}
\DoxyCodeLine{13799         \textcolor{keywordflow}{return} *\textcolor{keyword}{this} /= std::to\_string(array\_idx);}
\DoxyCodeLine{13800     \}}
\DoxyCodeLine{13801 }
\DoxyCodeLine{13804     \textcolor{keyword}{friend} \mbox{\hyperlink{classjson__pointer}{json\_pointer}} \mbox{\hyperlink{classjson__pointer_a90a11fe6c7f37b1746a3ff9cb24b0d53}{operator/}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& lhs,}
\DoxyCodeLine{13805                                   \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& rhs)}
\DoxyCodeLine{13806     \{}
\DoxyCodeLine{13807         \textcolor{keywordflow}{return} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}(lhs) /= rhs;}
\DoxyCodeLine{13808     \}}
\DoxyCodeLine{13809 }
\DoxyCodeLine{13812     \textcolor{keyword}{friend} \mbox{\hyperlink{classjson__pointer}{json\_pointer}} \mbox{\hyperlink{classjson__pointer_a116956f4487af44732dd685e970679b0}{operator/}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& lhs, string\_t token) \textcolor{comment}{// NOLINT(performance-\/unnecessary-\/value-\/param)}}
\DoxyCodeLine{13813     \{}
\DoxyCodeLine{13814         \textcolor{keywordflow}{return} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}(lhs) /= std::move(token);}
\DoxyCodeLine{13815     \}}
\DoxyCodeLine{13816 }
\DoxyCodeLine{13819     \textcolor{keyword}{friend} \mbox{\hyperlink{classjson__pointer}{json\_pointer}} \mbox{\hyperlink{classjson__pointer_a29f6d4b492e784b9d196b05a4048c289}{operator/}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& lhs, std::size\_t array\_idx)}
\DoxyCodeLine{13820     \{}
\DoxyCodeLine{13821         \textcolor{keywordflow}{return} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}(lhs) /= array\_idx;}
\DoxyCodeLine{13822     \}}
\DoxyCodeLine{13823 }
\DoxyCodeLine{13826     \mbox{\hyperlink{classjson__pointer}{json\_pointer}} \mbox{\hyperlink{classjson__pointer_aa03c0c1206e171342d27a4583258858b}{parent\_pointer}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{13827 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13828         \textcolor{keywordflow}{if} (empty())}
\DoxyCodeLine{13829         \{}
\DoxyCodeLine{13830             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{13831         \}}
\DoxyCodeLine{13832 }
\DoxyCodeLine{13833         \mbox{\hyperlink{classjson__pointer}{json\_pointer}} res = *\textcolor{keyword}{this};}
\DoxyCodeLine{13834         res.\mbox{\hyperlink{classjson__pointer_a662118b470c87a1b564946c2602c49ce}{pop\_back}}();}
\DoxyCodeLine{13835         \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{13836     \}}
\DoxyCodeLine{13837 }
\DoxyCodeLine{13840     \textcolor{keywordtype}{void} \mbox{\hyperlink{classjson__pointer_a662118b470c87a1b564946c2602c49ce}{pop\_back}}()}
\DoxyCodeLine{13841     \{}
\DoxyCodeLine{13842         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(empty()))}
\DoxyCodeLine{13843         \{}
\DoxyCodeLine{13844             JSON\_THROW(detail::out\_of\_range::create(405, \textcolor{stringliteral}{"{}JSON pointer has no parent"{}}, \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{13845         \}}
\DoxyCodeLine{13846 }
\DoxyCodeLine{13847         reference\_tokens.pop\_back();}
\DoxyCodeLine{13848     \}}
\DoxyCodeLine{13849 }
\DoxyCodeLine{13852     \textcolor{keyword}{const} string\_t\& \mbox{\hyperlink{classjson__pointer_aba71e63e4032cfc46dd90aeb09e5cb0f}{back}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{13853 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13854         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(empty()))}
\DoxyCodeLine{13855         \{}
\DoxyCodeLine{13856             JSON\_THROW(detail::out\_of\_range::create(405, \textcolor{stringliteral}{"{}JSON pointer has no parent"{}}, \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{13857         \}}
\DoxyCodeLine{13858 }
\DoxyCodeLine{13859         \textcolor{keywordflow}{return} reference\_tokens.back();}
\DoxyCodeLine{13860     \}}
\DoxyCodeLine{13861 }
\DoxyCodeLine{13864     \textcolor{keywordtype}{void} \mbox{\hyperlink{classjson__pointer_adbe97f9c00a221fb7be88d940b39a24f}{push\_back}}(\textcolor{keyword}{const} string\_t\& token)}
\DoxyCodeLine{13865     \{}
\DoxyCodeLine{13866         reference\_tokens.push\_back(token);}
\DoxyCodeLine{13867     \}}
\DoxyCodeLine{13868 }
\DoxyCodeLine{13871     \textcolor{keywordtype}{void} \mbox{\hyperlink{classjson__pointer_a6fa4848eafc232ae1af91c3d2696897e}{push\_back}}(string\_t\&\& token)}
\DoxyCodeLine{13872     \{}
\DoxyCodeLine{13873         reference\_tokens.push\_back(std::move(token));}
\DoxyCodeLine{13874     \}}
\DoxyCodeLine{13875 }
\DoxyCodeLine{13878     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classjson__pointer_a5c3d08bd0a0e99c3377db33600c68a64}{empty}}() const noexcept}
\DoxyCodeLine{13879     \{}
\DoxyCodeLine{13880         \textcolor{keywordflow}{return} reference\_tokens.empty();}
\DoxyCodeLine{13881     \}}
\DoxyCodeLine{13882 }
\DoxyCodeLine{13883   \textcolor{keyword}{private}:}
\DoxyCodeLine{13894     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{13895     \textcolor{keyword}{static} \textcolor{keyword}{typename} BasicJsonType::size\_type array\_index(\textcolor{keyword}{const} string\_t\& s)}
\DoxyCodeLine{13896     \{}
\DoxyCodeLine{13897         \textcolor{keyword}{using }size\_type = \textcolor{keyword}{typename} BasicJsonType::size\_type;}
\DoxyCodeLine{13898 }
\DoxyCodeLine{13899         \textcolor{comment}{// error condition (cf. RFC 6901, Sect. 4)}}
\DoxyCodeLine{13900         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(s.size() > 1 \&\& s[0] == \textcolor{charliteral}{'0'}))}
\DoxyCodeLine{13901         \{}
\DoxyCodeLine{13902             JSON\_THROW(\mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{detail::parse\_error::create}}(106, 0, detail::concat(\textcolor{stringliteral}{"{}array index '"{}}, s, \textcolor{stringliteral}{"{}' must not begin with '0'"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{13903         \}}
\DoxyCodeLine{13904 }
\DoxyCodeLine{13905         \textcolor{comment}{// error condition (cf. RFC 6901, Sect. 4)}}
\DoxyCodeLine{13906         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(s.size() > 1 \&\& !(s[0] >= \textcolor{charliteral}{'1'} \&\& s[0] <= \textcolor{charliteral}{'9'})))}
\DoxyCodeLine{13907         \{}
\DoxyCodeLine{13908             JSON\_THROW(\mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{detail::parse\_error::create}}(109, 0, detail::concat(\textcolor{stringliteral}{"{}array index '"{}}, s, \textcolor{stringliteral}{"{}' is not a number"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{13909         \}}
\DoxyCodeLine{13910 }
\DoxyCodeLine{13911         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* p = s.c\_str();}
\DoxyCodeLine{13912         \textcolor{keywordtype}{char}* p\_end = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13913         errno = 0; \textcolor{comment}{// strtoull doesn't reset errno}}
\DoxyCodeLine{13914         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} res = std::strtoull(p, \&p\_end, 10); \textcolor{comment}{// NOLINT(runtime/int)}}
\DoxyCodeLine{13915         \textcolor{keywordflow}{if} (p == p\_end \textcolor{comment}{// invalid input or empty string}}
\DoxyCodeLine{13916                 || errno == ERANGE \textcolor{comment}{// out of range}}
\DoxyCodeLine{13917                 || JSON\_HEDLEY\_UNLIKELY(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(p\_end -\/ p) != s.size())) \textcolor{comment}{// incomplete read}}
\DoxyCodeLine{13918         \{}
\DoxyCodeLine{13919             JSON\_THROW(detail::out\_of\_range::create(404, detail::concat(\textcolor{stringliteral}{"{}unresolved reference token '"{}}, s, \textcolor{stringliteral}{"{}'"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{13920         \}}
\DoxyCodeLine{13921 }
\DoxyCodeLine{13922         \textcolor{comment}{// only triggered on special platforms (like 32bit), see also}}
\DoxyCodeLine{13923         \textcolor{comment}{// https://github.com/nlohmann/json/pull/2203}}
\DoxyCodeLine{13924         \textcolor{keywordflow}{if} (res >= \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}((std::numeric\_limits<size\_type>::max)()))  \textcolor{comment}{// NOLINT(runtime/int)}}
\DoxyCodeLine{13925         \{}
\DoxyCodeLine{13926             JSON\_THROW(detail::out\_of\_range::create(410, detail::concat(\textcolor{stringliteral}{"{}array index "{}}, s, \textcolor{stringliteral}{"{} exceeds size\_type"{}}), \textcolor{keyword}{nullptr}));   \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{13927         \}}
\DoxyCodeLine{13928 }
\DoxyCodeLine{13929         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}size\_type\textcolor{keyword}{>}(res);}
\DoxyCodeLine{13930     \}}
\DoxyCodeLine{13931 }
\DoxyCodeLine{13932   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{13933     \mbox{\hyperlink{classjson__pointer}{json\_pointer}} top()\textcolor{keyword}{ const}}
\DoxyCodeLine{13934 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13935         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(empty()))}
\DoxyCodeLine{13936         \{}
\DoxyCodeLine{13937             JSON\_THROW(detail::out\_of\_range::create(405, \textcolor{stringliteral}{"{}JSON pointer has no parent"{}}, \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{13938         \}}
\DoxyCodeLine{13939 }
\DoxyCodeLine{13940         \mbox{\hyperlink{classjson__pointer}{json\_pointer}} result = *\textcolor{keyword}{this};}
\DoxyCodeLine{13941         result.reference\_tokens = \{reference\_tokens[0]\};}
\DoxyCodeLine{13942         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{13943     \}}
\DoxyCodeLine{13944 }
\DoxyCodeLine{13945   \textcolor{keyword}{private}:}
\DoxyCodeLine{13954     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{13955     BasicJsonType\& get\_and\_create(BasicJsonType\& j)\textcolor{keyword}{ const}}
\DoxyCodeLine{13956 \textcolor{keyword}{    }\{}
\DoxyCodeLine{13957         \textcolor{keyword}{auto}* result = \&j;}
\DoxyCodeLine{13958 }
\DoxyCodeLine{13959         \textcolor{comment}{// in case no reference tokens exist, return a reference to the JSON value}}
\DoxyCodeLine{13960         \textcolor{comment}{// j which will be overwritten by a primitive value}}
\DoxyCodeLine{13961         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& reference\_token : reference\_tokens)}
\DoxyCodeLine{13962         \{}
\DoxyCodeLine{13963             \textcolor{keywordflow}{switch} (result-\/>type())}
\DoxyCodeLine{13964             \{}
\DoxyCodeLine{13965                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{detail::value\_t::null}}:}
\DoxyCodeLine{13966                 \{}
\DoxyCodeLine{13967                     \textcolor{keywordflow}{if} (reference\_token == \textcolor{stringliteral}{"{}0"{}})}
\DoxyCodeLine{13968                     \{}
\DoxyCodeLine{13969                         \textcolor{comment}{// start a new array if reference token is 0}}
\DoxyCodeLine{13970                         result = \&result-\/>operator[](0);}
\DoxyCodeLine{13971                     \}}
\DoxyCodeLine{13972                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13973                     \{}
\DoxyCodeLine{13974                         \textcolor{comment}{// start a new object otherwise}}
\DoxyCodeLine{13975                         result = \&result-\/>operator[](reference\_token);}
\DoxyCodeLine{13976                     \}}
\DoxyCodeLine{13977                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{13978                 \}}
\DoxyCodeLine{13979 }
\DoxyCodeLine{13980                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{detail::value\_t::object}}:}
\DoxyCodeLine{13981                 \{}
\DoxyCodeLine{13982                     \textcolor{comment}{// create an entry in the object}}
\DoxyCodeLine{13983                     result = \&result-\/>operator[](reference\_token);}
\DoxyCodeLine{13984                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{13985                 \}}
\DoxyCodeLine{13986 }
\DoxyCodeLine{13987                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{detail::value\_t::array}}:}
\DoxyCodeLine{13988                 \{}
\DoxyCodeLine{13989                     \textcolor{comment}{// create an entry in the array}}
\DoxyCodeLine{13990                     result = \&result-\/>operator[](array\_index<BasicJsonType>(reference\_token));}
\DoxyCodeLine{13991                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{13992                 \}}
\DoxyCodeLine{13993 }
\DoxyCodeLine{13994                 \textcolor{comment}{/*}}
\DoxyCodeLine{13995 \textcolor{comment}{                The following code is only reached if there exists a reference}}
\DoxyCodeLine{13996 \textcolor{comment}{                token \_and\_ the current value is primitive. In this case, we have}}
\DoxyCodeLine{13997 \textcolor{comment}{                an error situation, because primitive values may only occur as}}
\DoxyCodeLine{13998 \textcolor{comment}{                single value; that is, with an empty list of reference tokens.}}
\DoxyCodeLine{13999 \textcolor{comment}{                */}}
\DoxyCodeLine{14000                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{detail::value\_t::string}}:}
\DoxyCodeLine{14001                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{detail::value\_t::boolean}}:}
\DoxyCodeLine{14002                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{detail::value\_t::number\_integer}}:}
\DoxyCodeLine{14003                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{detail::value\_t::number\_unsigned}}:}
\DoxyCodeLine{14004                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{detail::value\_t::number\_float}}:}
\DoxyCodeLine{14005                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{detail::value\_t::binary}}:}
\DoxyCodeLine{14006                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{detail::value\_t::discarded}}:}
\DoxyCodeLine{14007                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14008                     JSON\_THROW(detail::type\_error::create(313, \textcolor{stringliteral}{"{}invalid value to unflatten"{}}, \&j));}
\DoxyCodeLine{14009             \}}
\DoxyCodeLine{14010         \}}
\DoxyCodeLine{14011 }
\DoxyCodeLine{14012         \textcolor{keywordflow}{return} *result;}
\DoxyCodeLine{14013     \}}
\DoxyCodeLine{14014 }
\DoxyCodeLine{14034     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{14035     BasicJsonType\& get\_unchecked(BasicJsonType* ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{14036 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14037         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& reference\_token : reference\_tokens)}
\DoxyCodeLine{14038         \{}
\DoxyCodeLine{14039             \textcolor{comment}{// convert null values to arrays or objects before continuing}}
\DoxyCodeLine{14040             \textcolor{keywordflow}{if} (ptr-\/>is\_null())}
\DoxyCodeLine{14041             \{}
\DoxyCodeLine{14042                 \textcolor{comment}{// check if reference token is a number}}
\DoxyCodeLine{14043                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} nums =}
\DoxyCodeLine{14044                     std::all\_of(reference\_token.begin(), reference\_token.end(),}
\DoxyCodeLine{14045                                 [](\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} x)}
\DoxyCodeLine{14046                 \{}
\DoxyCodeLine{14047                     return std::isdigit(x);}
\DoxyCodeLine{14048                 \});}
\DoxyCodeLine{14049 }
\DoxyCodeLine{14050                 \textcolor{comment}{// change value to array for numbers or "{}-\/"{} or to object otherwise}}
\DoxyCodeLine{14051                 *ptr = (nums || reference\_token == \textcolor{stringliteral}{"{}-\/"{}})}
\DoxyCodeLine{14052                        ? \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{detail::value\_t::array}}}
\DoxyCodeLine{14053                        : \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{detail::value\_t::object}};}
\DoxyCodeLine{14054             \}}
\DoxyCodeLine{14055 }
\DoxyCodeLine{14056             \textcolor{keywordflow}{switch} (ptr-\/>type())}
\DoxyCodeLine{14057             \{}
\DoxyCodeLine{14058                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{detail::value\_t::object}}:}
\DoxyCodeLine{14059                 \{}
\DoxyCodeLine{14060                     \textcolor{comment}{// use unchecked object access}}
\DoxyCodeLine{14061                     ptr = \&ptr-\/>operator[](reference\_token);}
\DoxyCodeLine{14062                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{14063                 \}}
\DoxyCodeLine{14064 }
\DoxyCodeLine{14065                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{detail::value\_t::array}}:}
\DoxyCodeLine{14066                 \{}
\DoxyCodeLine{14067                     \textcolor{keywordflow}{if} (reference\_token == \textcolor{stringliteral}{"{}-\/"{}})}
\DoxyCodeLine{14068                     \{}
\DoxyCodeLine{14069                         \textcolor{comment}{// explicitly treat "{}-\/"{} as index beyond the end}}
\DoxyCodeLine{14070                         ptr = \&ptr-\/>operator[](ptr-\/>m\_value.array-\/>size());}
\DoxyCodeLine{14071                     \}}
\DoxyCodeLine{14072                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{14073                     \{}
\DoxyCodeLine{14074                         \textcolor{comment}{// convert array index to number; unchecked access}}
\DoxyCodeLine{14075                         ptr = \&ptr-\/>operator[](array\_index<BasicJsonType>(reference\_token));}
\DoxyCodeLine{14076                     \}}
\DoxyCodeLine{14077                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{14078                 \}}
\DoxyCodeLine{14079 }
\DoxyCodeLine{14080                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{detail::value\_t::null}}:}
\DoxyCodeLine{14081                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{detail::value\_t::string}}:}
\DoxyCodeLine{14082                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{detail::value\_t::boolean}}:}
\DoxyCodeLine{14083                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{detail::value\_t::number\_integer}}:}
\DoxyCodeLine{14084                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{detail::value\_t::number\_unsigned}}:}
\DoxyCodeLine{14085                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{detail::value\_t::number\_float}}:}
\DoxyCodeLine{14086                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{detail::value\_t::binary}}:}
\DoxyCodeLine{14087                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{detail::value\_t::discarded}}:}
\DoxyCodeLine{14088                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14089                     JSON\_THROW(detail::out\_of\_range::create(404, detail::concat(\textcolor{stringliteral}{"{}unresolved reference token '"{}}, reference\_token, \textcolor{stringliteral}{"{}'"{}}), ptr));}
\DoxyCodeLine{14090             \}}
\DoxyCodeLine{14091         \}}
\DoxyCodeLine{14092 }
\DoxyCodeLine{14093         \textcolor{keywordflow}{return} *ptr;}
\DoxyCodeLine{14094     \}}
\DoxyCodeLine{14095 }
\DoxyCodeLine{14102     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{14103     BasicJsonType\& get\_checked(BasicJsonType* ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{14104 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14105         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& reference\_token : reference\_tokens)}
\DoxyCodeLine{14106         \{}
\DoxyCodeLine{14107             \textcolor{keywordflow}{switch} (ptr-\/>type())}
\DoxyCodeLine{14108             \{}
\DoxyCodeLine{14109                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{detail::value\_t::object}}:}
\DoxyCodeLine{14110                 \{}
\DoxyCodeLine{14111                     \textcolor{comment}{// note: at performs range check}}
\DoxyCodeLine{14112                     ptr = \&ptr-\/>at(reference\_token);}
\DoxyCodeLine{14113                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{14114                 \}}
\DoxyCodeLine{14115 }
\DoxyCodeLine{14116                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{detail::value\_t::array}}:}
\DoxyCodeLine{14117                 \{}
\DoxyCodeLine{14118                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(reference\_token == \textcolor{stringliteral}{"{}-\/"{}}))}
\DoxyCodeLine{14119                     \{}
\DoxyCodeLine{14120                         \textcolor{comment}{// "{}-\/"{} always fails the range check}}
\DoxyCodeLine{14121                         JSON\_THROW(detail::out\_of\_range::create(402, detail::concat(}
\DoxyCodeLine{14122                                 \textcolor{stringliteral}{"{}array index '-\/' ("{}}, std::to\_string(ptr-\/>m\_value.array-\/>size()),}
\DoxyCodeLine{14123                                 \textcolor{stringliteral}{"{}) is out of range"{}}), ptr));}
\DoxyCodeLine{14124                     \}}
\DoxyCodeLine{14125 }
\DoxyCodeLine{14126                     \textcolor{comment}{// note: at performs range check}}
\DoxyCodeLine{14127                     ptr = \&ptr-\/>at(array\_index<BasicJsonType>(reference\_token));}
\DoxyCodeLine{14128                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{14129                 \}}
\DoxyCodeLine{14130 }
\DoxyCodeLine{14131                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{detail::value\_t::null}}:}
\DoxyCodeLine{14132                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{detail::value\_t::string}}:}
\DoxyCodeLine{14133                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{detail::value\_t::boolean}}:}
\DoxyCodeLine{14134                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{detail::value\_t::number\_integer}}:}
\DoxyCodeLine{14135                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{detail::value\_t::number\_unsigned}}:}
\DoxyCodeLine{14136                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{detail::value\_t::number\_float}}:}
\DoxyCodeLine{14137                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{detail::value\_t::binary}}:}
\DoxyCodeLine{14138                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{detail::value\_t::discarded}}:}
\DoxyCodeLine{14139                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14140                     JSON\_THROW(detail::out\_of\_range::create(404, detail::concat(\textcolor{stringliteral}{"{}unresolved reference token '"{}}, reference\_token, \textcolor{stringliteral}{"{}'"{}}), ptr));}
\DoxyCodeLine{14141             \}}
\DoxyCodeLine{14142         \}}
\DoxyCodeLine{14143 }
\DoxyCodeLine{14144         \textcolor{keywordflow}{return} *ptr;}
\DoxyCodeLine{14145     \}}
\DoxyCodeLine{14146 }
\DoxyCodeLine{14160     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{14161     \textcolor{keyword}{const} BasicJsonType\& get\_unchecked(\textcolor{keyword}{const} BasicJsonType* ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{14162 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14163         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& reference\_token : reference\_tokens)}
\DoxyCodeLine{14164         \{}
\DoxyCodeLine{14165             \textcolor{keywordflow}{switch} (ptr-\/>type())}
\DoxyCodeLine{14166             \{}
\DoxyCodeLine{14167                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{detail::value\_t::object}}:}
\DoxyCodeLine{14168                 \{}
\DoxyCodeLine{14169                     \textcolor{comment}{// use unchecked object access}}
\DoxyCodeLine{14170                     ptr = \&ptr-\/>operator[](reference\_token);}
\DoxyCodeLine{14171                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{14172                 \}}
\DoxyCodeLine{14173 }
\DoxyCodeLine{14174                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{detail::value\_t::array}}:}
\DoxyCodeLine{14175                 \{}
\DoxyCodeLine{14176                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(reference\_token == \textcolor{stringliteral}{"{}-\/"{}}))}
\DoxyCodeLine{14177                     \{}
\DoxyCodeLine{14178                         \textcolor{comment}{// "{}-\/"{} cannot be used for const access}}
\DoxyCodeLine{14179                         JSON\_THROW(detail::out\_of\_range::create(402, detail::concat(\textcolor{stringliteral}{"{}array index '-\/' ("{}}, std::to\_string(ptr-\/>m\_value.array-\/>size()), \textcolor{stringliteral}{"{}) is out of range"{}}), ptr));}
\DoxyCodeLine{14180                     \}}
\DoxyCodeLine{14181 }
\DoxyCodeLine{14182                     \textcolor{comment}{// use unchecked array access}}
\DoxyCodeLine{14183                     ptr = \&ptr-\/>operator[](array\_index<BasicJsonType>(reference\_token));}
\DoxyCodeLine{14184                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{14185                 \}}
\DoxyCodeLine{14186 }
\DoxyCodeLine{14187                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{detail::value\_t::null}}:}
\DoxyCodeLine{14188                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{detail::value\_t::string}}:}
\DoxyCodeLine{14189                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{detail::value\_t::boolean}}:}
\DoxyCodeLine{14190                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{detail::value\_t::number\_integer}}:}
\DoxyCodeLine{14191                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{detail::value\_t::number\_unsigned}}:}
\DoxyCodeLine{14192                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{detail::value\_t::number\_float}}:}
\DoxyCodeLine{14193                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{detail::value\_t::binary}}:}
\DoxyCodeLine{14194                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{detail::value\_t::discarded}}:}
\DoxyCodeLine{14195                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14196                     JSON\_THROW(detail::out\_of\_range::create(404, detail::concat(\textcolor{stringliteral}{"{}unresolved reference token '"{}}, reference\_token, \textcolor{stringliteral}{"{}'"{}}), ptr));}
\DoxyCodeLine{14197             \}}
\DoxyCodeLine{14198         \}}
\DoxyCodeLine{14199 }
\DoxyCodeLine{14200         \textcolor{keywordflow}{return} *ptr;}
\DoxyCodeLine{14201     \}}
\DoxyCodeLine{14202 }
\DoxyCodeLine{14209     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{14210     \textcolor{keyword}{const} BasicJsonType\& get\_checked(\textcolor{keyword}{const} BasicJsonType* ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{14211 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14212         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& reference\_token : reference\_tokens)}
\DoxyCodeLine{14213         \{}
\DoxyCodeLine{14214             \textcolor{keywordflow}{switch} (ptr-\/>type())}
\DoxyCodeLine{14215             \{}
\DoxyCodeLine{14216                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{detail::value\_t::object}}:}
\DoxyCodeLine{14217                 \{}
\DoxyCodeLine{14218                     \textcolor{comment}{// note: at performs range check}}
\DoxyCodeLine{14219                     ptr = \&ptr-\/>at(reference\_token);}
\DoxyCodeLine{14220                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{14221                 \}}
\DoxyCodeLine{14222 }
\DoxyCodeLine{14223                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{detail::value\_t::array}}:}
\DoxyCodeLine{14224                 \{}
\DoxyCodeLine{14225                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(reference\_token == \textcolor{stringliteral}{"{}-\/"{}}))}
\DoxyCodeLine{14226                     \{}
\DoxyCodeLine{14227                         \textcolor{comment}{// "{}-\/"{} always fails the range check}}
\DoxyCodeLine{14228                         JSON\_THROW(detail::out\_of\_range::create(402, detail::concat(}
\DoxyCodeLine{14229                                 \textcolor{stringliteral}{"{}array index '-\/' ("{}}, std::to\_string(ptr-\/>m\_value.array-\/>size()),}
\DoxyCodeLine{14230                                 \textcolor{stringliteral}{"{}) is out of range"{}}), ptr));}
\DoxyCodeLine{14231                     \}}
\DoxyCodeLine{14232 }
\DoxyCodeLine{14233                     \textcolor{comment}{// note: at performs range check}}
\DoxyCodeLine{14234                     ptr = \&ptr-\/>at(array\_index<BasicJsonType>(reference\_token));}
\DoxyCodeLine{14235                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{14236                 \}}
\DoxyCodeLine{14237 }
\DoxyCodeLine{14238                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{detail::value\_t::null}}:}
\DoxyCodeLine{14239                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{detail::value\_t::string}}:}
\DoxyCodeLine{14240                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{detail::value\_t::boolean}}:}
\DoxyCodeLine{14241                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{detail::value\_t::number\_integer}}:}
\DoxyCodeLine{14242                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{detail::value\_t::number\_unsigned}}:}
\DoxyCodeLine{14243                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{detail::value\_t::number\_float}}:}
\DoxyCodeLine{14244                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{detail::value\_t::binary}}:}
\DoxyCodeLine{14245                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{detail::value\_t::discarded}}:}
\DoxyCodeLine{14246                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14247                     JSON\_THROW(detail::out\_of\_range::create(404, detail::concat(\textcolor{stringliteral}{"{}unresolved reference token '"{}}, reference\_token, \textcolor{stringliteral}{"{}'"{}}), ptr));}
\DoxyCodeLine{14248             \}}
\DoxyCodeLine{14249         \}}
\DoxyCodeLine{14250 }
\DoxyCodeLine{14251         \textcolor{keywordflow}{return} *ptr;}
\DoxyCodeLine{14252     \}}
\DoxyCodeLine{14253 }
\DoxyCodeLine{14258     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{14259     \textcolor{keywordtype}{bool} contains(\textcolor{keyword}{const} BasicJsonType* ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{14260 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14261         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& reference\_token : reference\_tokens)}
\DoxyCodeLine{14262         \{}
\DoxyCodeLine{14263             \textcolor{keywordflow}{switch} (ptr-\/>type())}
\DoxyCodeLine{14264             \{}
\DoxyCodeLine{14265                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{detail::value\_t::object}}:}
\DoxyCodeLine{14266                 \{}
\DoxyCodeLine{14267                     \textcolor{keywordflow}{if} (!ptr-\/>contains(reference\_token))}
\DoxyCodeLine{14268                     \{}
\DoxyCodeLine{14269                         \textcolor{comment}{// we did not find the key in the object}}
\DoxyCodeLine{14270                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14271                     \}}
\DoxyCodeLine{14272 }
\DoxyCodeLine{14273                     ptr = \&ptr-\/>operator[](reference\_token);}
\DoxyCodeLine{14274                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{14275                 \}}
\DoxyCodeLine{14276 }
\DoxyCodeLine{14277                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{detail::value\_t::array}}:}
\DoxyCodeLine{14278                 \{}
\DoxyCodeLine{14279                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(reference\_token == \textcolor{stringliteral}{"{}-\/"{}}))}
\DoxyCodeLine{14280                     \{}
\DoxyCodeLine{14281                         \textcolor{comment}{// "{}-\/"{} always fails the range check}}
\DoxyCodeLine{14282                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14283                     \}}
\DoxyCodeLine{14284                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(reference\_token.size() == 1 \&\& !(\textcolor{stringliteral}{"{}0"{}} <= reference\_token \&\& reference\_token <= \textcolor{stringliteral}{"{}9"{}})))}
\DoxyCodeLine{14285                     \{}
\DoxyCodeLine{14286                         \textcolor{comment}{// invalid char}}
\DoxyCodeLine{14287                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14288                     \}}
\DoxyCodeLine{14289                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(reference\_token.size() > 1))}
\DoxyCodeLine{14290                     \{}
\DoxyCodeLine{14291                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(\textcolor{charliteral}{'1'} <= reference\_token[0] \&\& reference\_token[0] <= \textcolor{charliteral}{'9'})))}
\DoxyCodeLine{14292                         \{}
\DoxyCodeLine{14293                             \textcolor{comment}{// first char should be between '1' and '9'}}
\DoxyCodeLine{14294                             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14295                         \}}
\DoxyCodeLine{14296                         \textcolor{keywordflow}{for} (std::size\_t i = 1; i < reference\_token.size(); i++)}
\DoxyCodeLine{14297                         \{}
\DoxyCodeLine{14298                             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(\textcolor{charliteral}{'0'} <= reference\_token[i] \&\& reference\_token[i] <= \textcolor{charliteral}{'9'})))}
\DoxyCodeLine{14299                             \{}
\DoxyCodeLine{14300                                 \textcolor{comment}{// other char should be between '0' and '9'}}
\DoxyCodeLine{14301                                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14302                             \}}
\DoxyCodeLine{14303                         \}}
\DoxyCodeLine{14304                     \}}
\DoxyCodeLine{14305 }
\DoxyCodeLine{14306                     \textcolor{keyword}{const} \textcolor{keyword}{auto} idx = array\_index<BasicJsonType>(reference\_token);}
\DoxyCodeLine{14307                     \textcolor{keywordflow}{if} (idx >= ptr-\/>size())}
\DoxyCodeLine{14308                     \{}
\DoxyCodeLine{14309                         \textcolor{comment}{// index out of range}}
\DoxyCodeLine{14310                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14311                     \}}
\DoxyCodeLine{14312 }
\DoxyCodeLine{14313                     ptr = \&ptr-\/>operator[](idx);}
\DoxyCodeLine{14314                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{14315                 \}}
\DoxyCodeLine{14316 }
\DoxyCodeLine{14317                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{detail::value\_t::null}}:}
\DoxyCodeLine{14318                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{detail::value\_t::string}}:}
\DoxyCodeLine{14319                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{detail::value\_t::boolean}}:}
\DoxyCodeLine{14320                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{detail::value\_t::number\_integer}}:}
\DoxyCodeLine{14321                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{detail::value\_t::number\_unsigned}}:}
\DoxyCodeLine{14322                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{detail::value\_t::number\_float}}:}
\DoxyCodeLine{14323                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{detail::value\_t::binary}}:}
\DoxyCodeLine{14324                 \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{detail::value\_t::discarded}}:}
\DoxyCodeLine{14325                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14326                 \{}
\DoxyCodeLine{14327                     \textcolor{comment}{// we do not expect primitive values if there is still a}}
\DoxyCodeLine{14328                     \textcolor{comment}{// reference token to process}}
\DoxyCodeLine{14329                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14330                 \}}
\DoxyCodeLine{14331             \}}
\DoxyCodeLine{14332         \}}
\DoxyCodeLine{14333 }
\DoxyCodeLine{14334         \textcolor{comment}{// no reference token left means we found a primitive value}}
\DoxyCodeLine{14335         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14336     \}}
\DoxyCodeLine{14337 }
\DoxyCodeLine{14347     \textcolor{keyword}{static} std::vector<string\_t> split(\textcolor{keyword}{const} string\_t\& reference\_string)}
\DoxyCodeLine{14348     \{}
\DoxyCodeLine{14349         std::vector<string\_t> result;}
\DoxyCodeLine{14350 }
\DoxyCodeLine{14351         \textcolor{comment}{// special case: empty reference string -\/> no reference tokens}}
\DoxyCodeLine{14352         \textcolor{keywordflow}{if} (reference\_string.empty())}
\DoxyCodeLine{14353         \{}
\DoxyCodeLine{14354             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{14355         \}}
\DoxyCodeLine{14356 }
\DoxyCodeLine{14357         \textcolor{comment}{// check if nonempty reference string begins with slash}}
\DoxyCodeLine{14358         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(reference\_string[0] != \textcolor{charliteral}{'/'}))}
\DoxyCodeLine{14359         \{}
\DoxyCodeLine{14360             JSON\_THROW(\mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{detail::parse\_error::create}}(107, 1, detail::concat(\textcolor{stringliteral}{"{}JSON pointer must be empty or begin with '/' -\/ was: '"{}}, reference\_string, \textcolor{stringliteral}{"{}'"{}}), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{14361         \}}
\DoxyCodeLine{14362 }
\DoxyCodeLine{14363         \textcolor{comment}{// extract the reference tokens:}}
\DoxyCodeLine{14364         \textcolor{comment}{// -\/ slash: position of the last read slash (or end of string)}}
\DoxyCodeLine{14365         \textcolor{comment}{// -\/ start: position after the previous slash}}
\DoxyCodeLine{14366         \textcolor{keywordflow}{for} (}
\DoxyCodeLine{14367             \textcolor{comment}{// search for the first slash after the first character}}
\DoxyCodeLine{14368             std::size\_t slash = reference\_string.find\_first\_of(\textcolor{charliteral}{'/'}, 1),}
\DoxyCodeLine{14369             \textcolor{comment}{// set the beginning of the first reference token}}
\DoxyCodeLine{14370             start = 1;}
\DoxyCodeLine{14371             \textcolor{comment}{// we can stop if start == 0 (if slash == string\_t::npos)}}
\DoxyCodeLine{14372             start != 0;}
\DoxyCodeLine{14373             \textcolor{comment}{// set the beginning of the next reference token}}
\DoxyCodeLine{14374             \textcolor{comment}{// (will eventually be 0 if slash == string\_t::npos)}}
\DoxyCodeLine{14375             start = (slash == string\_t::npos) ? 0 : slash + 1,}
\DoxyCodeLine{14376             \textcolor{comment}{// find next slash}}
\DoxyCodeLine{14377             slash = reference\_string.find\_first\_of(\textcolor{charliteral}{'/'}, start))}
\DoxyCodeLine{14378         \{}
\DoxyCodeLine{14379             \textcolor{comment}{// use the text between the beginning of the reference token}}
\DoxyCodeLine{14380             \textcolor{comment}{// (start) and the last slash (slash).}}
\DoxyCodeLine{14381             \textcolor{keyword}{auto} reference\_token = reference\_string.substr(start, slash -\/ start);}
\DoxyCodeLine{14382 }
\DoxyCodeLine{14383             \textcolor{comment}{// check reference tokens are properly escaped}}
\DoxyCodeLine{14384             \textcolor{keywordflow}{for} (std::size\_t pos = reference\_token.find\_first\_of(\textcolor{charliteral}{'\string~'});}
\DoxyCodeLine{14385                     pos != string\_t::npos;}
\DoxyCodeLine{14386                     pos = reference\_token.find\_first\_of(\textcolor{charliteral}{'\string~'}, pos + 1))}
\DoxyCodeLine{14387             \{}
\DoxyCodeLine{14388                 JSON\_ASSERT(reference\_token[pos] == \textcolor{charliteral}{'\string~'});}
\DoxyCodeLine{14389 }
\DoxyCodeLine{14390                 \textcolor{comment}{// \string~ must be followed by 0 or 1}}
\DoxyCodeLine{14391                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(pos == reference\_token.size() -\/ 1 ||}
\DoxyCodeLine{14392                                          (reference\_token[pos + 1] != \textcolor{charliteral}{'0'} \&\&}
\DoxyCodeLine{14393                                           reference\_token[pos + 1] != \textcolor{charliteral}{'1'})))}
\DoxyCodeLine{14394                 \{}
\DoxyCodeLine{14395                     JSON\_THROW(\mbox{\hyperlink{classdetail_1_1parse__error_a07046ea9f33d28f120af188ed674d6df}{detail::parse\_error::create}}(108, 0, \textcolor{stringliteral}{"{}escape character '\string~' must be followed with '0' or '1'"{}}, \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{14396                 \}}
\DoxyCodeLine{14397             \}}
\DoxyCodeLine{14398 }
\DoxyCodeLine{14399             \textcolor{comment}{// finally, store the reference token}}
\DoxyCodeLine{14400             detail::unescape(reference\_token);}
\DoxyCodeLine{14401             result.push\_back(reference\_token);}
\DoxyCodeLine{14402         \}}
\DoxyCodeLine{14403 }
\DoxyCodeLine{14404         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{14405     \}}
\DoxyCodeLine{14406 }
\DoxyCodeLine{14407   \textcolor{keyword}{private}:}
\DoxyCodeLine{14415     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{14416     \textcolor{keyword}{static} \textcolor{keywordtype}{void} flatten(\textcolor{keyword}{const} string\_t\& reference\_string,}
\DoxyCodeLine{14417                         \textcolor{keyword}{const} BasicJsonType\& value,}
\DoxyCodeLine{14418                         BasicJsonType\& result)}
\DoxyCodeLine{14419     \{}
\DoxyCodeLine{14420         \textcolor{keywordflow}{switch} (\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.type())}
\DoxyCodeLine{14421         \{}
\DoxyCodeLine{14422             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{detail::value\_t::array}}:}
\DoxyCodeLine{14423             \{}
\DoxyCodeLine{14424                 \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.m\_value.array-\/>empty())}
\DoxyCodeLine{14425                 \{}
\DoxyCodeLine{14426                     \textcolor{comment}{// flatten empty array as null}}
\DoxyCodeLine{14427                     result[reference\_string] = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14428                 \}}
\DoxyCodeLine{14429                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{14430                 \{}
\DoxyCodeLine{14431                     \textcolor{comment}{// iterate array and use index as reference string}}
\DoxyCodeLine{14432                     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.m\_value.array-\/>size(); ++i)}
\DoxyCodeLine{14433                     \{}
\DoxyCodeLine{14434                         flatten(detail::concat(reference\_string, \textcolor{charliteral}{'/'}, std::to\_string(i)),}
\DoxyCodeLine{14435                                 \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.m\_value.array-\/>operator[](i), result);}
\DoxyCodeLine{14436                     \}}
\DoxyCodeLine{14437                 \}}
\DoxyCodeLine{14438                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14439             \}}
\DoxyCodeLine{14440 }
\DoxyCodeLine{14441             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{detail::value\_t::object}}:}
\DoxyCodeLine{14442             \{}
\DoxyCodeLine{14443                 \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.m\_value.object-\/>empty())}
\DoxyCodeLine{14444                 \{}
\DoxyCodeLine{14445                     \textcolor{comment}{// flatten empty object as null}}
\DoxyCodeLine{14446                     result[reference\_string] = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14447                 \}}
\DoxyCodeLine{14448                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{14449                 \{}
\DoxyCodeLine{14450                     \textcolor{comment}{// iterate object and use keys as reference string}}
\DoxyCodeLine{14451                     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& element : *\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.m\_value.object)}
\DoxyCodeLine{14452                     \{}
\DoxyCodeLine{14453                         flatten(detail::concat(reference\_string, \textcolor{charliteral}{'/'}, \mbox{\hyperlink{namespacedetail_af2a9ce4740e0b45d33129e2c8e53a0a8}{detail::escape}}(element.first)), element.second, result);}
\DoxyCodeLine{14454                     \}}
\DoxyCodeLine{14455                 \}}
\DoxyCodeLine{14456                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14457             \}}
\DoxyCodeLine{14458 }
\DoxyCodeLine{14459             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd}{detail::value\_t::null}}:}
\DoxyCodeLine{14460             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ab45cffe084dd3d20d928bee85e7b0f21}{detail::value\_t::string}}:}
\DoxyCodeLine{14461             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a84e2c64f38f78ba3ea5c905ab5a2da27}{detail::value\_t::boolean}}:}
\DoxyCodeLine{14462             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a5763da164f8659d94a56e29df64b4bcc}{detail::value\_t::number\_integer}}:}
\DoxyCodeLine{14463             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632adce7cc8ec29055c4158828921f2f265e}{detail::value\_t::number\_unsigned}}:}
\DoxyCodeLine{14464             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632ad9966ecb59667235a57b4b999a649eef}{detail::value\_t::number\_float}}:}
\DoxyCodeLine{14465             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a9d7183f16acce70658f686ae7f1a4d20}{detail::value\_t::binary}}:}
\DoxyCodeLine{14466             \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632a94708897ec9db8647dfe695714c98e46}{detail::value\_t::discarded}}:}
\DoxyCodeLine{14467             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14468             \{}
\DoxyCodeLine{14469                 \textcolor{comment}{// add primitive value with its reference string}}
\DoxyCodeLine{14470                 result[reference\_string] = \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}};}
\DoxyCodeLine{14471                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14472             \}}
\DoxyCodeLine{14473         \}}
\DoxyCodeLine{14474     \}}
\DoxyCodeLine{14475 }
\DoxyCodeLine{14486     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{14487     \textcolor{keyword}{static} BasicJsonType}
\DoxyCodeLine{14488     unflatten(\textcolor{keyword}{const} BasicJsonType\& value)}
\DoxyCodeLine{14489     \{}
\DoxyCodeLine{14490         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.is\_object()))}
\DoxyCodeLine{14491         \{}
\DoxyCodeLine{14492             JSON\_THROW(detail::type\_error::create(314, \textcolor{stringliteral}{"{}only objects can be unflattened"{}}, \&value));}
\DoxyCodeLine{14493         \}}
\DoxyCodeLine{14494 }
\DoxyCodeLine{14495         BasicJsonType result;}
\DoxyCodeLine{14496 }
\DoxyCodeLine{14497         \textcolor{comment}{// iterate the JSON object values}}
\DoxyCodeLine{14498         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& element : *\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.m\_value.object)}
\DoxyCodeLine{14499         \{}
\DoxyCodeLine{14500             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!element.second.is\_primitive()))}
\DoxyCodeLine{14501             \{}
\DoxyCodeLine{14502                 JSON\_THROW(detail::type\_error::create(315, \textcolor{stringliteral}{"{}values in object must be primitive"{}}, \&element.second));}
\DoxyCodeLine{14503             \}}
\DoxyCodeLine{14504 }
\DoxyCodeLine{14505             \textcolor{comment}{// assign value to reference pointed to by JSON pointer; Note that if}}
\DoxyCodeLine{14506             \textcolor{comment}{// the JSON pointer is "{}"{} (i.e., points to the whole value), function}}
\DoxyCodeLine{14507             \textcolor{comment}{// get\_and\_create returns a reference to result itself. An assignment}}
\DoxyCodeLine{14508             \textcolor{comment}{// will then create a primitive value.}}
\DoxyCodeLine{14509             \mbox{\hyperlink{classjson__pointer}{json\_pointer}}(element.first).get\_and\_create(result) = element.second;}
\DoxyCodeLine{14510         \}}
\DoxyCodeLine{14511 }
\DoxyCodeLine{14512         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{14513     \}}
\DoxyCodeLine{14514 }
\DoxyCodeLine{14515     \textcolor{comment}{// can't use conversion operator because of ambiguity}}
\DoxyCodeLine{14516     \mbox{\hyperlink{classjson__pointer}{json\_pointer<string\_t>}} convert() const\&}
\DoxyCodeLine{14517     \{}
\DoxyCodeLine{14518         \mbox{\hyperlink{classjson__pointer}{json\_pointer<string\_t>}} result;}
\DoxyCodeLine{14519         result.reference\_tokens = reference\_tokens;}
\DoxyCodeLine{14520         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{14521     \}}
\DoxyCodeLine{14522 }
\DoxyCodeLine{14523     \mbox{\hyperlink{classjson__pointer}{json\_pointer<string\_t>}} convert()\&\&}
\DoxyCodeLine{14524     \{}
\DoxyCodeLine{14525         \mbox{\hyperlink{classjson__pointer}{json\_pointer<string\_t>}} result;}
\DoxyCodeLine{14526         result.reference\_tokens = std::move(reference\_tokens);}
\DoxyCodeLine{14527         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{14528     \}}
\DoxyCodeLine{14529 }
\DoxyCodeLine{14530   \textcolor{keyword}{public}:}
\DoxyCodeLine{14531 \textcolor{preprocessor}{\#if JSON\_HAS\_THREE\_WAY\_COMPARISON}}
\DoxyCodeLine{14534     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeRhs>}
\DoxyCodeLine{14535     \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}\& rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{14536     \{}
\DoxyCodeLine{14537         \textcolor{keywordflow}{return} reference\_tokens == rhs.reference\_tokens;}
\DoxyCodeLine{14538     \}}
\DoxyCodeLine{14539 }
\DoxyCodeLine{14542     JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.2, \textcolor{keyword}{operator}==(\mbox{\hyperlink{classjson__pointer}{json\_pointer}}))}
\DoxyCodeLine{14543     \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} string\_t\& rhs)\textcolor{keyword}{ const}}
\DoxyCodeLine{14544 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14545         \textcolor{keywordflow}{return} *\textcolor{keyword}{this} == \mbox{\hyperlink{classjson__pointer}{json\_pointer}}(rhs);}
\DoxyCodeLine{14546     \}}
\DoxyCodeLine{14547 }
\DoxyCodeLine{14549     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeRhs>}
\DoxyCodeLine{14550     std::strong\_ordering operator<=>(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}\& rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{14551     \{}
\DoxyCodeLine{14552         \textcolor{keywordflow}{return}  reference\_tokens <=> rhs.reference\_tokens; \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{14553     \}}
\DoxyCodeLine{14554 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{14557     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeLhs, \textcolor{keyword}{typename} RefStringTypeRhs>}
\DoxyCodeLine{14558     \textcolor{comment}{// NOLINTNEXTLINE(readability-\/redundant-\/declaration)}}
\DoxyCodeLine{14559     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeLhs>}}\& lhs,}
\DoxyCodeLine{14560                            \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}\& rhs) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{14561 }
\DoxyCodeLine{14564     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeLhs, \textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{14565     \textcolor{comment}{// NOLINTNEXTLINE(readability-\/redundant-\/declaration)}}
\DoxyCodeLine{14566     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeLhs>}}\& lhs,}
\DoxyCodeLine{14567                            \textcolor{keyword}{const} StringType\& rhs);}
\DoxyCodeLine{14568 }
\DoxyCodeLine{14571     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeRhs, \textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{14572     \textcolor{comment}{// NOLINTNEXTLINE(readability-\/redundant-\/declaration)}}
\DoxyCodeLine{14573     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} StringType\& lhs,}
\DoxyCodeLine{14574                            \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}\& rhs);}
\DoxyCodeLine{14575 }
\DoxyCodeLine{14578     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeLhs, \textcolor{keyword}{typename} RefStringTypeRhs>}
\DoxyCodeLine{14579     \textcolor{comment}{// NOLINTNEXTLINE(readability-\/redundant-\/declaration)}}
\DoxyCodeLine{14580     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeLhs>}}\& lhs,}
\DoxyCodeLine{14581                            \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}\& rhs) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{14582 }
\DoxyCodeLine{14585     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeLhs, \textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{14586     \textcolor{comment}{// NOLINTNEXTLINE(readability-\/redundant-\/declaration)}}
\DoxyCodeLine{14587     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeLhs>}}\& lhs,}
\DoxyCodeLine{14588                            \textcolor{keyword}{const} StringType\& rhs);}
\DoxyCodeLine{14589 }
\DoxyCodeLine{14592     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeRhs, \textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{14593     \textcolor{comment}{// NOLINTNEXTLINE(readability-\/redundant-\/declaration)}}
\DoxyCodeLine{14594     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} StringType\& lhs,}
\DoxyCodeLine{14595                            \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}\& rhs);}
\DoxyCodeLine{14596 }
\DoxyCodeLine{14598     \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeLhs, \textcolor{keyword}{typename} RefStringTypeRhs>}
\DoxyCodeLine{14599     \textcolor{comment}{// NOLINTNEXTLINE(readability-\/redundant-\/declaration)}}
\DoxyCodeLine{14600     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_aac7ca91589afb0bad68baec5949daaa2}{operator<}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeLhs>}}\& lhs,}
\DoxyCodeLine{14601                           \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}\& rhs) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{14602 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14603 }
\DoxyCodeLine{14604   \textcolor{keyword}{private}:}
\DoxyCodeLine{14606     std::vector<string\_t> reference\_tokens;}
\DoxyCodeLine{14607 \};}
\DoxyCodeLine{14608 }
\DoxyCodeLine{14609 \textcolor{preprocessor}{\#if !JSON\_HAS\_THREE\_WAY\_COMPARISON}}
\DoxyCodeLine{14610 \textcolor{comment}{// functions cannot be defined inside class due to ODR violations}}
\DoxyCodeLine{14611 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeLhs, \textcolor{keyword}{typename} RefStringTypeRhs>}
\DoxyCodeLine{14612 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeLhs>}}\& lhs,}
\DoxyCodeLine{14613                        \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}\& rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{14614 \{}
\DoxyCodeLine{14615     \textcolor{keywordflow}{return} lhs.reference\_tokens == rhs.reference\_tokens;}
\DoxyCodeLine{14616 \}}
\DoxyCodeLine{14617 }
\DoxyCodeLine{14618 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeLhs,}
\DoxyCodeLine{14619          \textcolor{keyword}{typename} StringType = \textcolor{keyword}{typename} json\_pointer<RefStringTypeLhs>::string\_t>}
\DoxyCodeLine{14620 JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.2, \textcolor{keyword}{operator}==(\mbox{\hyperlink{classjson__pointer}{json\_pointer}}, \mbox{\hyperlink{classjson__pointer}{json\_pointer}}))}
\DoxyCodeLine{14621 inline \textcolor{keywordtype}{bool} operator==(const \mbox{\hyperlink{classjson__pointer}{json\_pointer}}<RefStringTypeLhs>\& lhs,}
\DoxyCodeLine{14622                        const StringType\& rhs)}
\DoxyCodeLine{14623 \{}
\DoxyCodeLine{14624     \textcolor{keywordflow}{return} lhs == \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeLhs>}}(rhs);}
\DoxyCodeLine{14625 \}}
\DoxyCodeLine{14626 }
\DoxyCodeLine{14627 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeRhs,}
\DoxyCodeLine{14628          \textcolor{keyword}{typename} StringType = \textcolor{keyword}{typename} json\_pointer<RefStringTypeRhs>::string\_t>}
\DoxyCodeLine{14629 JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.2, \textcolor{keyword}{operator}==(\mbox{\hyperlink{classjson__pointer}{json\_pointer}}, \mbox{\hyperlink{classjson__pointer}{json\_pointer}}))}
\DoxyCodeLine{14630 inline \textcolor{keywordtype}{bool} operator==(const StringType\& lhs,}
\DoxyCodeLine{14631                        const \mbox{\hyperlink{classjson__pointer}{json\_pointer}}<RefStringTypeRhs>\& rhs)}
\DoxyCodeLine{14632 \{}
\DoxyCodeLine{14633     \textcolor{keywordflow}{return} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}(lhs) == rhs;}
\DoxyCodeLine{14634 \}}
\DoxyCodeLine{14635 }
\DoxyCodeLine{14636 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeLhs, \textcolor{keyword}{typename} RefStringTypeRhs>}
\DoxyCodeLine{14637 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} operator!=(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeLhs>}}\& lhs,}
\DoxyCodeLine{14638                        \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}\& rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{14639 \{}
\DoxyCodeLine{14640     \textcolor{keywordflow}{return} !(lhs == rhs);}
\DoxyCodeLine{14641 \}}
\DoxyCodeLine{14642 }
\DoxyCodeLine{14643 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeLhs,}
\DoxyCodeLine{14644          \textcolor{keyword}{typename} StringType = \textcolor{keyword}{typename} json\_pointer<RefStringTypeLhs>::string\_t>}
\DoxyCodeLine{14645 JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.2, \textcolor{keyword}{operator}!=(\mbox{\hyperlink{classjson__pointer}{json\_pointer}}, \mbox{\hyperlink{classjson__pointer}{json\_pointer}}))}
\DoxyCodeLine{14646 inline \textcolor{keywordtype}{bool} operator!=(const \mbox{\hyperlink{classjson__pointer}{json\_pointer}}<RefStringTypeLhs>\& lhs,}
\DoxyCodeLine{14647                        const StringType\& rhs)}
\DoxyCodeLine{14648 \{}
\DoxyCodeLine{14649     \textcolor{keywordflow}{return} !(lhs == rhs);}
\DoxyCodeLine{14650 \}}
\DoxyCodeLine{14651 }
\DoxyCodeLine{14652 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeRhs,}
\DoxyCodeLine{14653          \textcolor{keyword}{typename} StringType = \textcolor{keyword}{typename} json\_pointer<RefStringTypeRhs>::string\_t>}
\DoxyCodeLine{14654 JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.2, \textcolor{keyword}{operator}!=(\mbox{\hyperlink{classjson__pointer}{json\_pointer}}, \mbox{\hyperlink{classjson__pointer}{json\_pointer}}))}
\DoxyCodeLine{14655 inline \textcolor{keywordtype}{bool} operator!=(const StringType\& lhs,}
\DoxyCodeLine{14656                        const \mbox{\hyperlink{classjson__pointer}{json\_pointer}}<RefStringTypeRhs>\& rhs)}
\DoxyCodeLine{14657 \{}
\DoxyCodeLine{14658     \textcolor{keywordflow}{return} !(lhs == rhs);}
\DoxyCodeLine{14659 \}}
\DoxyCodeLine{14660 }
\DoxyCodeLine{14661 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RefStringTypeLhs, \textcolor{keyword}{typename} RefStringTypeRhs>}
\DoxyCodeLine{14662 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} operator<(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeLhs>}}\& lhs,}
\DoxyCodeLine{14663                       \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer<RefStringTypeRhs>}}\& rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{14664 \{}
\DoxyCodeLine{14665     \textcolor{keywordflow}{return} lhs.reference\_tokens < rhs.reference\_tokens;}
\DoxyCodeLine{14666 \}}
\DoxyCodeLine{14667 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14668 }
\DoxyCodeLine{14669 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{14670 }
\DoxyCodeLine{14671 \textcolor{comment}{// \#include <nlohmann/detail/json\_ref.hpp>}}
\DoxyCodeLine{14672 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{14673 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{14674 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{14675 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{14676 \textcolor{comment}{//}}
\DoxyCodeLine{14677 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{14678 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{14679 }
\DoxyCodeLine{14680 }
\DoxyCodeLine{14681 }
\DoxyCodeLine{14682 \textcolor{preprocessor}{\#include <initializer\_list>}}
\DoxyCodeLine{14683 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{14684 }
\DoxyCodeLine{14685 \textcolor{comment}{// \#include <nlohmann/detail/abi\_macros.hpp>}}
\DoxyCodeLine{14686 }
\DoxyCodeLine{14687 \textcolor{comment}{// \#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{14688 }
\DoxyCodeLine{14689 }
\DoxyCodeLine{14690 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{14691 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{14692 \{}
\DoxyCodeLine{14693 }
\DoxyCodeLine{14694 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{14695 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}}
\DoxyCodeLine{14696 \{}
\DoxyCodeLine{14697   \textcolor{keyword}{public}:}
\DoxyCodeLine{14698     \textcolor{keyword}{using }value\_type = BasicJsonType;}
\DoxyCodeLine{14699 }
\DoxyCodeLine{14700     \mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}(value\_type\&\& \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}})}
\DoxyCodeLine{14701         : owned\_value(std::move(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}))}
\DoxyCodeLine{14702     \{\}}
\DoxyCodeLine{14703 }
\DoxyCodeLine{14704     \mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}(\textcolor{keyword}{const} value\_type\& \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}})}
\DoxyCodeLine{14705         : value\_ref(\&\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}})}
\DoxyCodeLine{14706     \{\}}
\DoxyCodeLine{14707 }
\DoxyCodeLine{14708     \mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}(std::initializer\_list<json\_ref> init)}
\DoxyCodeLine{14709         : owned\_value(init)}
\DoxyCodeLine{14710     \{\}}
\DoxyCodeLine{14711 }
\DoxyCodeLine{14712     \textcolor{keyword}{template} <}
\DoxyCodeLine{14713         \textcolor{keyword}{class}... Args,}
\DoxyCodeLine{14714         enable\_if\_t<std::is\_constructible<value\_type, Args...>::value, \textcolor{keywordtype}{int}> = 0 >}
\DoxyCodeLine{14715     \mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}(Args \&\& ... args)}
\DoxyCodeLine{14716         : owned\_value(std::forward<Args>(args)...)}
\DoxyCodeLine{14717     \{\}}
\DoxyCodeLine{14718 }
\DoxyCodeLine{14719     \textcolor{comment}{// class should be movable only}}
\DoxyCodeLine{14720     \mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}(\mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}\&\&) \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14721     \mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{14722     \mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{14723     \mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}\& operator=(\mbox{\hyperlink{classdetail_1_1json__ref}{json\_ref}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{14724     \mbox{\hyperlink{classdetail_1_1json__ref}{\string~json\_ref}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14725 }
\DoxyCodeLine{14726     value\_type moved\_or\_copied()\textcolor{keyword}{ const}}
\DoxyCodeLine{14727 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14728         \textcolor{keywordflow}{if} (value\_ref == \textcolor{keyword}{nullptr})}
\DoxyCodeLine{14729         \{}
\DoxyCodeLine{14730             \textcolor{keywordflow}{return} std::move(owned\_value);}
\DoxyCodeLine{14731         \}}
\DoxyCodeLine{14732         \textcolor{keywordflow}{return} *value\_ref;}
\DoxyCodeLine{14733     \}}
\DoxyCodeLine{14734 }
\DoxyCodeLine{14735     value\_type \textcolor{keyword}{const}\& operator*()\textcolor{keyword}{ const}}
\DoxyCodeLine{14736 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14737         \textcolor{keywordflow}{return} value\_ref ? *value\_ref : owned\_value;}
\DoxyCodeLine{14738     \}}
\DoxyCodeLine{14739 }
\DoxyCodeLine{14740     value\_type \textcolor{keyword}{const}* operator-\/>()\textcolor{keyword}{ const}}
\DoxyCodeLine{14741 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14742         \textcolor{keywordflow}{return} \&** \textcolor{keyword}{this};}
\DoxyCodeLine{14743     \}}
\DoxyCodeLine{14744 }
\DoxyCodeLine{14745   \textcolor{keyword}{private}:}
\DoxyCodeLine{14746     \textcolor{keyword}{mutable} value\_type owned\_value = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14747     value\_type \textcolor{keyword}{const}* value\_ref = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14748 \};}
\DoxyCodeLine{14749 }
\DoxyCodeLine{14750 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{14751 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{14752 }
\DoxyCodeLine{14753 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{14754 }
\DoxyCodeLine{14755 \textcolor{comment}{// \#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{14756 }
\DoxyCodeLine{14757 \textcolor{comment}{// \#include <nlohmann/detail/string\_escape.hpp>}}
\DoxyCodeLine{14758 }
\DoxyCodeLine{14759 \textcolor{comment}{// \#include <nlohmann/detail/meta/cpp\_future.hpp>}}
\DoxyCodeLine{14760 }
\DoxyCodeLine{14761 \textcolor{comment}{// \#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{14762 }
\DoxyCodeLine{14763 \textcolor{comment}{// \#include <nlohmann/detail/output/binary\_writer.hpp>}}
\DoxyCodeLine{14764 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{14765 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{14766 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{14767 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{14768 \textcolor{comment}{//}}
\DoxyCodeLine{14769 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{14770 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{14771 }
\DoxyCodeLine{14772 }
\DoxyCodeLine{14773 }
\DoxyCodeLine{14774 \textcolor{preprocessor}{\#include <algorithm>} \textcolor{comment}{// reverse}}
\DoxyCodeLine{14775 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{14776 \textcolor{preprocessor}{\#include <map>} \textcolor{comment}{// map}}
\DoxyCodeLine{14777 \textcolor{preprocessor}{\#include <cmath>} \textcolor{comment}{// isnan, isinf}}
\DoxyCodeLine{14778 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// uint8\_t, uint16\_t, uint32\_t, uint64\_t}}
\DoxyCodeLine{14779 \textcolor{preprocessor}{\#include <cstring>} \textcolor{comment}{// memcpy}}
\DoxyCodeLine{14780 \textcolor{preprocessor}{\#include <limits>} \textcolor{comment}{// numeric\_limits}}
\DoxyCodeLine{14781 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string}}
\DoxyCodeLine{14782 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// move}}
\DoxyCodeLine{14783 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{14784 }
\DoxyCodeLine{14785 \textcolor{comment}{// \#include <nlohmann/detail/input/binary\_reader.hpp>}}
\DoxyCodeLine{14786 }
\DoxyCodeLine{14787 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{14788 }
\DoxyCodeLine{14789 \textcolor{comment}{// \#include <nlohmann/detail/output/output\_adapters.hpp>}}
\DoxyCodeLine{14790 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{14791 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{14792 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{14793 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{14794 \textcolor{comment}{//}}
\DoxyCodeLine{14795 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{14796 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{14797 }
\DoxyCodeLine{14798 }
\DoxyCodeLine{14799 }
\DoxyCodeLine{14800 \textcolor{preprocessor}{\#include <algorithm>} \textcolor{comment}{// copy}}
\DoxyCodeLine{14801 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t}}
\DoxyCodeLine{14802 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// back\_inserter}}
\DoxyCodeLine{14803 \textcolor{preprocessor}{\#include <memory>} \textcolor{comment}{// shared\_ptr, make\_shared}}
\DoxyCodeLine{14804 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// basic\_string}}
\DoxyCodeLine{14805 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{14806 }
\DoxyCodeLine{14807 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{14808 \textcolor{preprocessor}{    \#include <ios>}      \textcolor{comment}{// streamsize}}
\DoxyCodeLine{14809 \textcolor{preprocessor}{    \#include <ostream>}  \textcolor{comment}{// basic\_ostream}}
\DoxyCodeLine{14810 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{14811 }
\DoxyCodeLine{14812 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{14813 }
\DoxyCodeLine{14814 }
\DoxyCodeLine{14815 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{14816 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{14817 \{}
\DoxyCodeLine{14818 }
\DoxyCodeLine{14820 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharType> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}}
\DoxyCodeLine{14821 \{}
\DoxyCodeLine{14822     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} write\_character(CharType c) = 0;}
\DoxyCodeLine{14823     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} write\_characters(\textcolor{keyword}{const} CharType* s, std::size\_t length) = 0;}
\DoxyCodeLine{14824     \textcolor{keyword}{virtual} \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{\string~output\_adapter\_protocol}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14825 }
\DoxyCodeLine{14826     \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14827     \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14828     \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}(\mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}\&\&) \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14829     \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14830     \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}\& operator=(\mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}\&\&) \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14831 \};}
\DoxyCodeLine{14832 }
\DoxyCodeLine{14834 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{14835 \textcolor{keyword}{using }\mbox{\hyperlink{namespacedetail_a160eb5d333fe01b259af32d3d4798a7b}{output\_adapter\_t}} = std::shared\_ptr<output\_adapter\_protocol<CharType>>;}
\DoxyCodeLine{14836 }
\DoxyCodeLine{14838 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharType, \textcolor{keyword}{typename} AllocatorType = std::allocator<CharType>>}
\DoxyCodeLine{14839 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1output__vector__adapter}{output\_vector\_adapter}} : \textcolor{keyword}{public} \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}<CharType>}
\DoxyCodeLine{14840 \{}
\DoxyCodeLine{14841   \textcolor{keyword}{public}:}
\DoxyCodeLine{14842     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1output__vector__adapter}{output\_vector\_adapter}}(std::vector<CharType, AllocatorType>\& vec) noexcept}
\DoxyCodeLine{14843         : v(vec)}
\DoxyCodeLine{14844     \{\}}
\DoxyCodeLine{14845 }
\DoxyCodeLine{14846     \textcolor{keywordtype}{void} write\_character(CharType c)\textcolor{keyword}{ override}}
\DoxyCodeLine{14847 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14848         v.push\_back(c);}
\DoxyCodeLine{14849     \}}
\DoxyCodeLine{14850 }
\DoxyCodeLine{14851     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{14852     \textcolor{keywordtype}{void} write\_characters(\textcolor{keyword}{const} CharType* s, std::size\_t length)\textcolor{keyword}{ override}}
\DoxyCodeLine{14853 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14854         v.insert(v.end(), s, s + length);}
\DoxyCodeLine{14855     \}}
\DoxyCodeLine{14856 }
\DoxyCodeLine{14857   \textcolor{keyword}{private}:}
\DoxyCodeLine{14858     std::vector<CharType, AllocatorType>\& v;}
\DoxyCodeLine{14859 \};}
\DoxyCodeLine{14860 }
\DoxyCodeLine{14861 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{14863 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{14864 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1output__stream__adapter}{output\_stream\_adapter}} : \textcolor{keyword}{public} \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}<CharType>}
\DoxyCodeLine{14865 \{}
\DoxyCodeLine{14866   \textcolor{keyword}{public}:}
\DoxyCodeLine{14867     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1output__stream__adapter}{output\_stream\_adapter}}(std::basic\_ostream<CharType>\& s) noexcept}
\DoxyCodeLine{14868         : stream(s)}
\DoxyCodeLine{14869     \{\}}
\DoxyCodeLine{14870 }
\DoxyCodeLine{14871     \textcolor{keywordtype}{void} write\_character(CharType c)\textcolor{keyword}{ override}}
\DoxyCodeLine{14872 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14873         stream.put(c);}
\DoxyCodeLine{14874     \}}
\DoxyCodeLine{14875 }
\DoxyCodeLine{14876     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{14877     \textcolor{keywordtype}{void} write\_characters(\textcolor{keyword}{const} CharType* s, std::size\_t length)\textcolor{keyword}{ override}}
\DoxyCodeLine{14878 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14879         stream.write(s, \textcolor{keyword}{static\_cast<}std::streamsize\textcolor{keyword}{>}(length));}
\DoxyCodeLine{14880     \}}
\DoxyCodeLine{14881 }
\DoxyCodeLine{14882   \textcolor{keyword}{private}:}
\DoxyCodeLine{14883     std::basic\_ostream<CharType>\& stream;}
\DoxyCodeLine{14884 \};}
\DoxyCodeLine{14885 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{14886 }
\DoxyCodeLine{14888 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharType, \textcolor{keyword}{typename} StringType = std::basic\_\textcolor{keywordtype}{string}<CharType>>}
\DoxyCodeLine{14889 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1output__string__adapter}{output\_string\_adapter}} : \textcolor{keyword}{public} \mbox{\hyperlink{structdetail_1_1output__adapter__protocol}{output\_adapter\_protocol}}<CharType>}
\DoxyCodeLine{14890 \{}
\DoxyCodeLine{14891   \textcolor{keyword}{public}:}
\DoxyCodeLine{14892     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1output__string__adapter}{output\_string\_adapter}}(StringType\& s) noexcept}
\DoxyCodeLine{14893         : str(s)}
\DoxyCodeLine{14894     \{\}}
\DoxyCodeLine{14895 }
\DoxyCodeLine{14896     \textcolor{keywordtype}{void} write\_character(CharType c)\textcolor{keyword}{ override}}
\DoxyCodeLine{14897 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14898         str.push\_back(c);}
\DoxyCodeLine{14899     \}}
\DoxyCodeLine{14900 }
\DoxyCodeLine{14901     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{14902     \textcolor{keywordtype}{void} write\_characters(\textcolor{keyword}{const} CharType* s, std::size\_t length)\textcolor{keyword}{ override}}
\DoxyCodeLine{14903 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14904         str.append(s, length);}
\DoxyCodeLine{14905     \}}
\DoxyCodeLine{14906 }
\DoxyCodeLine{14907   \textcolor{keyword}{private}:}
\DoxyCodeLine{14908     StringType\& str;}
\DoxyCodeLine{14909 \};}
\DoxyCodeLine{14910 }
\DoxyCodeLine{14911 \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharType, \textcolor{keyword}{typename} StringType = std::basic\_\textcolor{keywordtype}{string}<CharType>>}
\DoxyCodeLine{14912 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1output__adapter}{output\_adapter}}}
\DoxyCodeLine{14913 \{}
\DoxyCodeLine{14914   \textcolor{keyword}{public}:}
\DoxyCodeLine{14915     \textcolor{keyword}{template}<\textcolor{keyword}{typename} AllocatorType = std::allocator<CharType>>}
\DoxyCodeLine{14916     \mbox{\hyperlink{classdetail_1_1output__adapter}{output\_adapter}}(std::vector<CharType, AllocatorType>\& vec)}
\DoxyCodeLine{14917         : oa(std::make\_shared<\mbox{\hyperlink{classdetail_1_1output__vector__adapter}{output\_vector\_adapter<CharType, AllocatorType>}}>(vec)) \{\}}
\DoxyCodeLine{14918 }
\DoxyCodeLine{14919 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{14920     \mbox{\hyperlink{classdetail_1_1output__adapter}{output\_adapter}}(std::basic\_ostream<CharType>\& s)}
\DoxyCodeLine{14921         : oa(std::make\_shared<\mbox{\hyperlink{classdetail_1_1output__stream__adapter}{output\_stream\_adapter<CharType>}}>(s)) \{\}}
\DoxyCodeLine{14922 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{14923 }
\DoxyCodeLine{14924     \mbox{\hyperlink{classdetail_1_1output__adapter}{output\_adapter}}(StringType\& s)}
\DoxyCodeLine{14925         : oa(std::make\_shared<\mbox{\hyperlink{classdetail_1_1output__string__adapter}{output\_string\_adapter<CharType, StringType>}}>(s)) \{\}}
\DoxyCodeLine{14926 }
\DoxyCodeLine{14927     \textcolor{keyword}{operator} \mbox{\hyperlink{namespacedetail_a160eb5d333fe01b259af32d3d4798a7b}{output\_adapter\_t<CharType>}}()}
\DoxyCodeLine{14928     \{}
\DoxyCodeLine{14929         \textcolor{keywordflow}{return} oa;}
\DoxyCodeLine{14930     \}}
\DoxyCodeLine{14931 }
\DoxyCodeLine{14932   \textcolor{keyword}{private}:}
\DoxyCodeLine{14933     \mbox{\hyperlink{namespacedetail_a160eb5d333fe01b259af32d3d4798a7b}{output\_adapter\_t<CharType>}} oa = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14934 \};}
\DoxyCodeLine{14935 }
\DoxyCodeLine{14936 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{14937 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{14938 }
\DoxyCodeLine{14939 \textcolor{comment}{// \#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{14940 }
\DoxyCodeLine{14941 }
\DoxyCodeLine{14942 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{14943 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{14944 \{}
\DoxyCodeLine{14945 }
\DoxyCodeLine{14947 \textcolor{comment}{// binary writer //}}
\DoxyCodeLine{14949 \textcolor{comment}{}}
\DoxyCodeLine{14953 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{14954 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1binary__writer}{binary\_writer}}}
\DoxyCodeLine{14955 \{}
\DoxyCodeLine{14956     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{14957     \textcolor{keyword}{using }binary\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t;}
\DoxyCodeLine{14958     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{14959 }
\DoxyCodeLine{14960   \textcolor{keyword}{public}:}
\DoxyCodeLine{14966     \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1binary__writer_a5b4f1bfcd0f3f7b57060c059e008c45b}{binary\_writer}}(\mbox{\hyperlink{namespacedetail_a160eb5d333fe01b259af32d3d4798a7b}{output\_adapter\_t<CharType>}} adapter) : oa(std::move(adapter))}
\DoxyCodeLine{14967     \{}
\DoxyCodeLine{14968         JSON\_ASSERT(oa);}
\DoxyCodeLine{14969     \}}
\DoxyCodeLine{14970 }
\DoxyCodeLine{14975     \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1binary__writer_a1aae361b7492825979cbb80245b9c0d6}{write\_bson}}(\textcolor{keyword}{const} BasicJsonType\& j)}
\DoxyCodeLine{14976     \{}
\DoxyCodeLine{14977         \textcolor{keywordflow}{switch} (j.type())}
\DoxyCodeLine{14978         \{}
\DoxyCodeLine{14979             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{14980             \{}
\DoxyCodeLine{14981                 write\_bson\_object(*j.m\_value.object);}
\DoxyCodeLine{14982                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14983             \}}
\DoxyCodeLine{14984 }
\DoxyCodeLine{14985             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{14986             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{14987             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{14988             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{14989             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{14990             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{14991             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{14992             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{14993             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{14994             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14995             \{}
\DoxyCodeLine{14996                 JSON\_THROW(type\_error::create(317, concat(\textcolor{stringliteral}{"{}to serialize to BSON, top-\/level type must be object, but is "{}}, j.type\_name()), \&j));}
\DoxyCodeLine{14997             \}}
\DoxyCodeLine{14998         \}}
\DoxyCodeLine{14999     \}}
\DoxyCodeLine{15000 }
\DoxyCodeLine{15004     \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1binary__writer_ae6ab36b61e8ad346e75d9f9abc983d4c}{write\_cbor}}(\textcolor{keyword}{const} BasicJsonType\& j)}
\DoxyCodeLine{15005     \{}
\DoxyCodeLine{15006         \textcolor{keywordflow}{switch} (j.type())}
\DoxyCodeLine{15007         \{}
\DoxyCodeLine{15008             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{15009             \{}
\DoxyCodeLine{15010                 oa-\/>write\_character(to\_char\_type(0xF6));}
\DoxyCodeLine{15011                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15012             \}}
\DoxyCodeLine{15013 }
\DoxyCodeLine{15014             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{15015             \{}
\DoxyCodeLine{15016                 oa-\/>write\_character(j.m\_value.boolean}
\DoxyCodeLine{15017                                     ? to\_char\_type(0xF5)}
\DoxyCodeLine{15018                                     : to\_char\_type(0xF4));}
\DoxyCodeLine{15019                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15020             \}}
\DoxyCodeLine{15021 }
\DoxyCodeLine{15022             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{15023             \{}
\DoxyCodeLine{15024                 \textcolor{keywordflow}{if} (j.m\_value.number\_integer >= 0)}
\DoxyCodeLine{15025                 \{}
\DoxyCodeLine{15026                     \textcolor{comment}{// CBOR does not differentiate between positive signed}}
\DoxyCodeLine{15027                     \textcolor{comment}{// integers and unsigned integers. Therefore, we used the}}
\DoxyCodeLine{15028                     \textcolor{comment}{// code from the value\_t::number\_unsigned case here.}}
\DoxyCodeLine{15029                     \textcolor{keywordflow}{if} (j.m\_value.number\_integer <= 0x17)}
\DoxyCodeLine{15030                     \{}
\DoxyCodeLine{15031                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15032                     \}}
\DoxyCodeLine{15033                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_integer <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15034                     \{}
\DoxyCodeLine{15035                         oa-\/>write\_character(to\_char\_type(0x18));}
\DoxyCodeLine{15036                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15037                     \}}
\DoxyCodeLine{15038                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_integer <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15039                     \{}
\DoxyCodeLine{15040                         oa-\/>write\_character(to\_char\_type(0x19));}
\DoxyCodeLine{15041                         write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15042                     \}}
\DoxyCodeLine{15043                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_integer <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15044                     \{}
\DoxyCodeLine{15045                         oa-\/>write\_character(to\_char\_type(0x1A));}
\DoxyCodeLine{15046                         write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15047                     \}}
\DoxyCodeLine{15048                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{15049                     \{}
\DoxyCodeLine{15050                         oa-\/>write\_character(to\_char\_type(0x1B));}
\DoxyCodeLine{15051                         write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15052                     \}}
\DoxyCodeLine{15053                 \}}
\DoxyCodeLine{15054                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15055                 \{}
\DoxyCodeLine{15056                     \textcolor{comment}{// The conversions below encode the sign in the first}}
\DoxyCodeLine{15057                     \textcolor{comment}{// byte, and the value is converted to a positive number.}}
\DoxyCodeLine{15058                     \textcolor{keyword}{const} \textcolor{keyword}{auto} positive\_number = -\/1 -\/ j.m\_value.number\_integer;}
\DoxyCodeLine{15059                     \textcolor{keywordflow}{if} (j.m\_value.number\_integer >= -\/24)}
\DoxyCodeLine{15060                     \{}
\DoxyCodeLine{15061                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0x20 + positive\_number));}
\DoxyCodeLine{15062                     \}}
\DoxyCodeLine{15063                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (positive\_number <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15064                     \{}
\DoxyCodeLine{15065                         oa-\/>write\_character(to\_char\_type(0x38));}
\DoxyCodeLine{15066                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(positive\_number));}
\DoxyCodeLine{15067                     \}}
\DoxyCodeLine{15068                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (positive\_number <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15069                     \{}
\DoxyCodeLine{15070                         oa-\/>write\_character(to\_char\_type(0x39));}
\DoxyCodeLine{15071                         write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(positive\_number));}
\DoxyCodeLine{15072                     \}}
\DoxyCodeLine{15073                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (positive\_number <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15074                     \{}
\DoxyCodeLine{15075                         oa-\/>write\_character(to\_char\_type(0x3A));}
\DoxyCodeLine{15076                         write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(positive\_number));}
\DoxyCodeLine{15077                     \}}
\DoxyCodeLine{15078                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{15079                     \{}
\DoxyCodeLine{15080                         oa-\/>write\_character(to\_char\_type(0x3B));}
\DoxyCodeLine{15081                         write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(positive\_number));}
\DoxyCodeLine{15082                     \}}
\DoxyCodeLine{15083                 \}}
\DoxyCodeLine{15084                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15085             \}}
\DoxyCodeLine{15086 }
\DoxyCodeLine{15087             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{15088             \{}
\DoxyCodeLine{15089                 \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= 0x17)}
\DoxyCodeLine{15090                 \{}
\DoxyCodeLine{15091                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(j.m\_value.number\_unsigned));}
\DoxyCodeLine{15092                 \}}
\DoxyCodeLine{15093                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15094                 \{}
\DoxyCodeLine{15095                     oa-\/>write\_character(to\_char\_type(0x18));}
\DoxyCodeLine{15096                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(j.m\_value.number\_unsigned));}
\DoxyCodeLine{15097                 \}}
\DoxyCodeLine{15098                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15099                 \{}
\DoxyCodeLine{15100                     oa-\/>write\_character(to\_char\_type(0x19));}
\DoxyCodeLine{15101                     write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(j.m\_value.number\_unsigned));}
\DoxyCodeLine{15102                 \}}
\DoxyCodeLine{15103                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15104                 \{}
\DoxyCodeLine{15105                     oa-\/>write\_character(to\_char\_type(0x1A));}
\DoxyCodeLine{15106                     write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(j.m\_value.number\_unsigned));}
\DoxyCodeLine{15107                 \}}
\DoxyCodeLine{15108                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15109                 \{}
\DoxyCodeLine{15110                     oa-\/>write\_character(to\_char\_type(0x1B));}
\DoxyCodeLine{15111                     write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(j.m\_value.number\_unsigned));}
\DoxyCodeLine{15112                 \}}
\DoxyCodeLine{15113                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15114             \}}
\DoxyCodeLine{15115 }
\DoxyCodeLine{15116             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{15117             \{}
\DoxyCodeLine{15118                 \textcolor{keywordflow}{if} (std::isnan(j.m\_value.number\_float))}
\DoxyCodeLine{15119                 \{}
\DoxyCodeLine{15120                     \textcolor{comment}{// NaN is 0xf97e00 in CBOR}}
\DoxyCodeLine{15121                     oa-\/>write\_character(to\_char\_type(0xF9));}
\DoxyCodeLine{15122                     oa-\/>write\_character(to\_char\_type(0x7E));}
\DoxyCodeLine{15123                     oa-\/>write\_character(to\_char\_type(0x00));}
\DoxyCodeLine{15124                 \}}
\DoxyCodeLine{15125                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (std::isinf(j.m\_value.number\_float))}
\DoxyCodeLine{15126                 \{}
\DoxyCodeLine{15127                     \textcolor{comment}{// Infinity is 0xf97c00, -\/Infinity is 0xf9fc00}}
\DoxyCodeLine{15128                     oa-\/>write\_character(to\_char\_type(0xf9));}
\DoxyCodeLine{15129                     oa-\/>write\_character(j.m\_value.number\_float > 0 ? to\_char\_type(0x7C) : to\_char\_type(0xFC));}
\DoxyCodeLine{15130                     oa-\/>write\_character(to\_char\_type(0x00));}
\DoxyCodeLine{15131                 \}}
\DoxyCodeLine{15132                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15133                 \{}
\DoxyCodeLine{15134                     write\_compact\_float(j.m\_value.number\_float, detail::input\_format\_t::cbor);}
\DoxyCodeLine{15135                 \}}
\DoxyCodeLine{15136                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15137             \}}
\DoxyCodeLine{15138 }
\DoxyCodeLine{15139             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{15140             \{}
\DoxyCodeLine{15141                 \textcolor{comment}{// step 1: write control byte and the string length}}
\DoxyCodeLine{15142                 \textcolor{keyword}{const} \textcolor{keyword}{auto} N = j.m\_value.string-\/>size();}
\DoxyCodeLine{15143                 \textcolor{keywordflow}{if} (N <= 0x17)}
\DoxyCodeLine{15144                 \{}
\DoxyCodeLine{15145                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0x60 + N));}
\DoxyCodeLine{15146                 \}}
\DoxyCodeLine{15147                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15148                 \{}
\DoxyCodeLine{15149                     oa-\/>write\_character(to\_char\_type(0x78));}
\DoxyCodeLine{15150                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15151                 \}}
\DoxyCodeLine{15152                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15153                 \{}
\DoxyCodeLine{15154                     oa-\/>write\_character(to\_char\_type(0x79));}
\DoxyCodeLine{15155                     write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15156                 \}}
\DoxyCodeLine{15157                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15158                 \{}
\DoxyCodeLine{15159                     oa-\/>write\_character(to\_char\_type(0x7A));}
\DoxyCodeLine{15160                     write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15161                 \}}
\DoxyCodeLine{15162                 \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{15163                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint64\_t>::max)())}
\DoxyCodeLine{15164                 \{}
\DoxyCodeLine{15165                     oa-\/>write\_character(to\_char\_type(0x7B));}
\DoxyCodeLine{15166                     write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15167                 \}}
\DoxyCodeLine{15168                 \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{15169 }
\DoxyCodeLine{15170                 \textcolor{comment}{// step 2: write the string}}
\DoxyCodeLine{15171                 oa-\/>write\_characters(}
\DoxyCodeLine{15172                     \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }CharType*\textcolor{keyword}{>}(j.m\_value.string-\/>c\_str()),}
\DoxyCodeLine{15173                     j.m\_value.string-\/>size());}
\DoxyCodeLine{15174                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15175             \}}
\DoxyCodeLine{15176 }
\DoxyCodeLine{15177             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{15178             \{}
\DoxyCodeLine{15179                 \textcolor{comment}{// step 1: write control byte and the array size}}
\DoxyCodeLine{15180                 \textcolor{keyword}{const} \textcolor{keyword}{auto} N = j.m\_value.array-\/>size();}
\DoxyCodeLine{15181                 \textcolor{keywordflow}{if} (N <= 0x17)}
\DoxyCodeLine{15182                 \{}
\DoxyCodeLine{15183                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0x80 + N));}
\DoxyCodeLine{15184                 \}}
\DoxyCodeLine{15185                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15186                 \{}
\DoxyCodeLine{15187                     oa-\/>write\_character(to\_char\_type(0x98));}
\DoxyCodeLine{15188                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15189                 \}}
\DoxyCodeLine{15190                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15191                 \{}
\DoxyCodeLine{15192                     oa-\/>write\_character(to\_char\_type(0x99));}
\DoxyCodeLine{15193                     write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15194                 \}}
\DoxyCodeLine{15195                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15196                 \{}
\DoxyCodeLine{15197                     oa-\/>write\_character(to\_char\_type(0x9A));}
\DoxyCodeLine{15198                     write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15199                 \}}
\DoxyCodeLine{15200                 \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{15201                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint64\_t>::max)())}
\DoxyCodeLine{15202                 \{}
\DoxyCodeLine{15203                     oa-\/>write\_character(to\_char\_type(0x9B));}
\DoxyCodeLine{15204                     write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15205                 \}}
\DoxyCodeLine{15206                 \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{15207 }
\DoxyCodeLine{15208                 \textcolor{comment}{// step 2: write each element}}
\DoxyCodeLine{15209                 \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : *j.m\_value.array)}
\DoxyCodeLine{15210                 \{}
\DoxyCodeLine{15211                     write\_cbor(el);}
\DoxyCodeLine{15212                 \}}
\DoxyCodeLine{15213                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15214             \}}
\DoxyCodeLine{15215 }
\DoxyCodeLine{15216             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{15217             \{}
\DoxyCodeLine{15218                 \textcolor{keywordflow}{if} (j.m\_value.binary-\/>has\_subtype())}
\DoxyCodeLine{15219                 \{}
\DoxyCodeLine{15220                     \textcolor{keywordflow}{if} (j.m\_value.binary-\/>subtype() <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15221                     \{}
\DoxyCodeLine{15222                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0xd8));}
\DoxyCodeLine{15223                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(j.m\_value.binary-\/>subtype()));}
\DoxyCodeLine{15224                     \}}
\DoxyCodeLine{15225                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.binary-\/>subtype() <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15226                     \{}
\DoxyCodeLine{15227                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0xd9));}
\DoxyCodeLine{15228                         write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(j.m\_value.binary-\/>subtype()));}
\DoxyCodeLine{15229                     \}}
\DoxyCodeLine{15230                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.binary-\/>subtype() <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15231                     \{}
\DoxyCodeLine{15232                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0xda));}
\DoxyCodeLine{15233                         write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(j.m\_value.binary-\/>subtype()));}
\DoxyCodeLine{15234                     \}}
\DoxyCodeLine{15235                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.binary-\/>subtype() <= (std::numeric\_limits<std::uint64\_t>::max)())}
\DoxyCodeLine{15236                     \{}
\DoxyCodeLine{15237                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0xdb));}
\DoxyCodeLine{15238                         write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(j.m\_value.binary-\/>subtype()));}
\DoxyCodeLine{15239                     \}}
\DoxyCodeLine{15240                 \}}
\DoxyCodeLine{15241 }
\DoxyCodeLine{15242                 \textcolor{comment}{// step 1: write control byte and the binary array size}}
\DoxyCodeLine{15243                 \textcolor{keyword}{const} \textcolor{keyword}{auto} N = j.m\_value.binary-\/>size();}
\DoxyCodeLine{15244                 \textcolor{keywordflow}{if} (N <= 0x17)}
\DoxyCodeLine{15245                 \{}
\DoxyCodeLine{15246                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0x40 + N));}
\DoxyCodeLine{15247                 \}}
\DoxyCodeLine{15248                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15249                 \{}
\DoxyCodeLine{15250                     oa-\/>write\_character(to\_char\_type(0x58));}
\DoxyCodeLine{15251                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15252                 \}}
\DoxyCodeLine{15253                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15254                 \{}
\DoxyCodeLine{15255                     oa-\/>write\_character(to\_char\_type(0x59));}
\DoxyCodeLine{15256                     write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15257                 \}}
\DoxyCodeLine{15258                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15259                 \{}
\DoxyCodeLine{15260                     oa-\/>write\_character(to\_char\_type(0x5A));}
\DoxyCodeLine{15261                     write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15262                 \}}
\DoxyCodeLine{15263                 \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{15264                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint64\_t>::max)())}
\DoxyCodeLine{15265                 \{}
\DoxyCodeLine{15266                     oa-\/>write\_character(to\_char\_type(0x5B));}
\DoxyCodeLine{15267                     write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15268                 \}}
\DoxyCodeLine{15269                 \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{15270 }
\DoxyCodeLine{15271                 \textcolor{comment}{// step 2: write each element}}
\DoxyCodeLine{15272                 oa-\/>write\_characters(}
\DoxyCodeLine{15273                     \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }CharType*\textcolor{keyword}{>}(j.m\_value.binary-\/>data()),}
\DoxyCodeLine{15274                     N);}
\DoxyCodeLine{15275 }
\DoxyCodeLine{15276                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15277             \}}
\DoxyCodeLine{15278 }
\DoxyCodeLine{15279             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{15280             \{}
\DoxyCodeLine{15281                 \textcolor{comment}{// step 1: write control byte and the object size}}
\DoxyCodeLine{15282                 \textcolor{keyword}{const} \textcolor{keyword}{auto} N = j.m\_value.object-\/>size();}
\DoxyCodeLine{15283                 \textcolor{keywordflow}{if} (N <= 0x17)}
\DoxyCodeLine{15284                 \{}
\DoxyCodeLine{15285                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0xA0 + N));}
\DoxyCodeLine{15286                 \}}
\DoxyCodeLine{15287                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15288                 \{}
\DoxyCodeLine{15289                     oa-\/>write\_character(to\_char\_type(0xB8));}
\DoxyCodeLine{15290                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15291                 \}}
\DoxyCodeLine{15292                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15293                 \{}
\DoxyCodeLine{15294                     oa-\/>write\_character(to\_char\_type(0xB9));}
\DoxyCodeLine{15295                     write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15296                 \}}
\DoxyCodeLine{15297                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15298                 \{}
\DoxyCodeLine{15299                     oa-\/>write\_character(to\_char\_type(0xBA));}
\DoxyCodeLine{15300                     write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15301                 \}}
\DoxyCodeLine{15302                 \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{15303                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint64\_t>::max)())}
\DoxyCodeLine{15304                 \{}
\DoxyCodeLine{15305                     oa-\/>write\_character(to\_char\_type(0xBB));}
\DoxyCodeLine{15306                     write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15307                 \}}
\DoxyCodeLine{15308                 \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{15309 }
\DoxyCodeLine{15310                 \textcolor{comment}{// step 2: write each element}}
\DoxyCodeLine{15311                 \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : *j.m\_value.object)}
\DoxyCodeLine{15312                 \{}
\DoxyCodeLine{15313                     write\_cbor(el.first);}
\DoxyCodeLine{15314                     write\_cbor(el.second);}
\DoxyCodeLine{15315                 \}}
\DoxyCodeLine{15316                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15317             \}}
\DoxyCodeLine{15318 }
\DoxyCodeLine{15319             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{15320             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15321                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15322         \}}
\DoxyCodeLine{15323     \}}
\DoxyCodeLine{15324 }
\DoxyCodeLine{15328     \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1binary__writer_adc3dbefa80134d3530a1b3f1c9629586}{write\_msgpack}}(\textcolor{keyword}{const} BasicJsonType\& j)}
\DoxyCodeLine{15329     \{}
\DoxyCodeLine{15330         \textcolor{keywordflow}{switch} (j.type())}
\DoxyCodeLine{15331         \{}
\DoxyCodeLine{15332             \textcolor{keywordflow}{case} value\_t::null: \textcolor{comment}{// nil}}
\DoxyCodeLine{15333             \{}
\DoxyCodeLine{15334                 oa-\/>write\_character(to\_char\_type(0xC0));}
\DoxyCodeLine{15335                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15336             \}}
\DoxyCodeLine{15337 }
\DoxyCodeLine{15338             \textcolor{keywordflow}{case} value\_t::boolean: \textcolor{comment}{// true and false}}
\DoxyCodeLine{15339             \{}
\DoxyCodeLine{15340                 oa-\/>write\_character(j.m\_value.boolean}
\DoxyCodeLine{15341                                     ? to\_char\_type(0xC3)}
\DoxyCodeLine{15342                                     : to\_char\_type(0xC2));}
\DoxyCodeLine{15343                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15344             \}}
\DoxyCodeLine{15345 }
\DoxyCodeLine{15346             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{15347             \{}
\DoxyCodeLine{15348                 \textcolor{keywordflow}{if} (j.m\_value.number\_integer >= 0)}
\DoxyCodeLine{15349                 \{}
\DoxyCodeLine{15350                     \textcolor{comment}{// MessagePack does not differentiate between positive}}
\DoxyCodeLine{15351                     \textcolor{comment}{// signed integers and unsigned integers. Therefore, we used}}
\DoxyCodeLine{15352                     \textcolor{comment}{// the code from the value\_t::number\_unsigned case here.}}
\DoxyCodeLine{15353                     \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned < 128)}
\DoxyCodeLine{15354                     \{}
\DoxyCodeLine{15355                         \textcolor{comment}{// positive fixnum}}
\DoxyCodeLine{15356                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15357                     \}}
\DoxyCodeLine{15358                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15359                     \{}
\DoxyCodeLine{15360                         \textcolor{comment}{// uint 8}}
\DoxyCodeLine{15361                         oa-\/>write\_character(to\_char\_type(0xCC));}
\DoxyCodeLine{15362                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15363                     \}}
\DoxyCodeLine{15364                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15365                     \{}
\DoxyCodeLine{15366                         \textcolor{comment}{// uint 16}}
\DoxyCodeLine{15367                         oa-\/>write\_character(to\_char\_type(0xCD));}
\DoxyCodeLine{15368                         write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15369                     \}}
\DoxyCodeLine{15370                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15371                     \{}
\DoxyCodeLine{15372                         \textcolor{comment}{// uint 32}}
\DoxyCodeLine{15373                         oa-\/>write\_character(to\_char\_type(0xCE));}
\DoxyCodeLine{15374                         write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15375                     \}}
\DoxyCodeLine{15376                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint64\_t>::max)())}
\DoxyCodeLine{15377                     \{}
\DoxyCodeLine{15378                         \textcolor{comment}{// uint 64}}
\DoxyCodeLine{15379                         oa-\/>write\_character(to\_char\_type(0xCF));}
\DoxyCodeLine{15380                         write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15381                     \}}
\DoxyCodeLine{15382                 \}}
\DoxyCodeLine{15383                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15384                 \{}
\DoxyCodeLine{15385                     \textcolor{keywordflow}{if} (j.m\_value.number\_integer >= -\/32)}
\DoxyCodeLine{15386                     \{}
\DoxyCodeLine{15387                         \textcolor{comment}{// negative fixnum}}
\DoxyCodeLine{15388                         write\_number(\textcolor{keyword}{static\_cast<}std::int8\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15389                     \}}
\DoxyCodeLine{15390                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_integer >= (std::numeric\_limits<std::int8\_t>::min)() \&\&}
\DoxyCodeLine{15391                              j.m\_value.number\_integer <= (std::numeric\_limits<std::int8\_t>::max)())}
\DoxyCodeLine{15392                     \{}
\DoxyCodeLine{15393                         \textcolor{comment}{// int 8}}
\DoxyCodeLine{15394                         oa-\/>write\_character(to\_char\_type(0xD0));}
\DoxyCodeLine{15395                         write\_number(\textcolor{keyword}{static\_cast<}std::int8\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15396                     \}}
\DoxyCodeLine{15397                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_integer >= (std::numeric\_limits<std::int16\_t>::min)() \&\&}
\DoxyCodeLine{15398                              j.m\_value.number\_integer <= (std::numeric\_limits<std::int16\_t>::max)())}
\DoxyCodeLine{15399                     \{}
\DoxyCodeLine{15400                         \textcolor{comment}{// int 16}}
\DoxyCodeLine{15401                         oa-\/>write\_character(to\_char\_type(0xD1));}
\DoxyCodeLine{15402                         write\_number(\textcolor{keyword}{static\_cast<}std::int16\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15403                     \}}
\DoxyCodeLine{15404                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_integer >= (std::numeric\_limits<std::int32\_t>::min)() \&\&}
\DoxyCodeLine{15405                              j.m\_value.number\_integer <= (std::numeric\_limits<std::int32\_t>::max)())}
\DoxyCodeLine{15406                     \{}
\DoxyCodeLine{15407                         \textcolor{comment}{// int 32}}
\DoxyCodeLine{15408                         oa-\/>write\_character(to\_char\_type(0xD2));}
\DoxyCodeLine{15409                         write\_number(\textcolor{keyword}{static\_cast<}std::int32\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15410                     \}}
\DoxyCodeLine{15411                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_integer >= (std::numeric\_limits<std::int64\_t>::min)() \&\&}
\DoxyCodeLine{15412                              j.m\_value.number\_integer <= (std::numeric\_limits<std::int64\_t>::max)())}
\DoxyCodeLine{15413                     \{}
\DoxyCodeLine{15414                         \textcolor{comment}{// int 64}}
\DoxyCodeLine{15415                         oa-\/>write\_character(to\_char\_type(0xD3));}
\DoxyCodeLine{15416                         write\_number(\textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15417                     \}}
\DoxyCodeLine{15418                 \}}
\DoxyCodeLine{15419                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15420             \}}
\DoxyCodeLine{15421 }
\DoxyCodeLine{15422             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{15423             \{}
\DoxyCodeLine{15424                 \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned < 128)}
\DoxyCodeLine{15425                 \{}
\DoxyCodeLine{15426                     \textcolor{comment}{// positive fixnum}}
\DoxyCodeLine{15427                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15428                 \}}
\DoxyCodeLine{15429                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15430                 \{}
\DoxyCodeLine{15431                     \textcolor{comment}{// uint 8}}
\DoxyCodeLine{15432                     oa-\/>write\_character(to\_char\_type(0xCC));}
\DoxyCodeLine{15433                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15434                 \}}
\DoxyCodeLine{15435                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15436                 \{}
\DoxyCodeLine{15437                     \textcolor{comment}{// uint 16}}
\DoxyCodeLine{15438                     oa-\/>write\_character(to\_char\_type(0xCD));}
\DoxyCodeLine{15439                     write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15440                 \}}
\DoxyCodeLine{15441                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15442                 \{}
\DoxyCodeLine{15443                     \textcolor{comment}{// uint 32}}
\DoxyCodeLine{15444                     oa-\/>write\_character(to\_char\_type(0xCE));}
\DoxyCodeLine{15445                     write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15446                 \}}
\DoxyCodeLine{15447                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint64\_t>::max)())}
\DoxyCodeLine{15448                 \{}
\DoxyCodeLine{15449                     \textcolor{comment}{// uint 64}}
\DoxyCodeLine{15450                     oa-\/>write\_character(to\_char\_type(0xCF));}
\DoxyCodeLine{15451                     write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(j.m\_value.number\_integer));}
\DoxyCodeLine{15452                 \}}
\DoxyCodeLine{15453                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15454             \}}
\DoxyCodeLine{15455 }
\DoxyCodeLine{15456             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{15457             \{}
\DoxyCodeLine{15458                 write\_compact\_float(j.m\_value.number\_float, detail::input\_format\_t::msgpack);}
\DoxyCodeLine{15459                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15460             \}}
\DoxyCodeLine{15461 }
\DoxyCodeLine{15462             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{15463             \{}
\DoxyCodeLine{15464                 \textcolor{comment}{// step 1: write control byte and the string length}}
\DoxyCodeLine{15465                 \textcolor{keyword}{const} \textcolor{keyword}{auto} N = j.m\_value.string-\/>size();}
\DoxyCodeLine{15466                 \textcolor{keywordflow}{if} (N <= 31)}
\DoxyCodeLine{15467                 \{}
\DoxyCodeLine{15468                     \textcolor{comment}{// fixstr}}
\DoxyCodeLine{15469                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0xA0 | N));}
\DoxyCodeLine{15470                 \}}
\DoxyCodeLine{15471                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15472                 \{}
\DoxyCodeLine{15473                     \textcolor{comment}{// str 8}}
\DoxyCodeLine{15474                     oa-\/>write\_character(to\_char\_type(0xD9));}
\DoxyCodeLine{15475                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15476                 \}}
\DoxyCodeLine{15477                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15478                 \{}
\DoxyCodeLine{15479                     \textcolor{comment}{// str 16}}
\DoxyCodeLine{15480                     oa-\/>write\_character(to\_char\_type(0xDA));}
\DoxyCodeLine{15481                     write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15482                 \}}
\DoxyCodeLine{15483                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15484                 \{}
\DoxyCodeLine{15485                     \textcolor{comment}{// str 32}}
\DoxyCodeLine{15486                     oa-\/>write\_character(to\_char\_type(0xDB));}
\DoxyCodeLine{15487                     write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15488                 \}}
\DoxyCodeLine{15489 }
\DoxyCodeLine{15490                 \textcolor{comment}{// step 2: write the string}}
\DoxyCodeLine{15491                 oa-\/>write\_characters(}
\DoxyCodeLine{15492                     \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }CharType*\textcolor{keyword}{>}(j.m\_value.string-\/>c\_str()),}
\DoxyCodeLine{15493                     j.m\_value.string-\/>size());}
\DoxyCodeLine{15494                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15495             \}}
\DoxyCodeLine{15496 }
\DoxyCodeLine{15497             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{15498             \{}
\DoxyCodeLine{15499                 \textcolor{comment}{// step 1: write control byte and the array size}}
\DoxyCodeLine{15500                 \textcolor{keyword}{const} \textcolor{keyword}{auto} N = j.m\_value.array-\/>size();}
\DoxyCodeLine{15501                 \textcolor{keywordflow}{if} (N <= 15)}
\DoxyCodeLine{15502                 \{}
\DoxyCodeLine{15503                     \textcolor{comment}{// fixarray}}
\DoxyCodeLine{15504                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0x90 | N));}
\DoxyCodeLine{15505                 \}}
\DoxyCodeLine{15506                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15507                 \{}
\DoxyCodeLine{15508                     \textcolor{comment}{// array 16}}
\DoxyCodeLine{15509                     oa-\/>write\_character(to\_char\_type(0xDC));}
\DoxyCodeLine{15510                     write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15511                 \}}
\DoxyCodeLine{15512                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15513                 \{}
\DoxyCodeLine{15514                     \textcolor{comment}{// array 32}}
\DoxyCodeLine{15515                     oa-\/>write\_character(to\_char\_type(0xDD));}
\DoxyCodeLine{15516                     write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15517                 \}}
\DoxyCodeLine{15518 }
\DoxyCodeLine{15519                 \textcolor{comment}{// step 2: write each element}}
\DoxyCodeLine{15520                 \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : *j.m\_value.array)}
\DoxyCodeLine{15521                 \{}
\DoxyCodeLine{15522                     write\_msgpack(el);}
\DoxyCodeLine{15523                 \}}
\DoxyCodeLine{15524                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15525             \}}
\DoxyCodeLine{15526 }
\DoxyCodeLine{15527             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{15528             \{}
\DoxyCodeLine{15529                 \textcolor{comment}{// step 0: determine if the binary type has a set subtype to}}
\DoxyCodeLine{15530                 \textcolor{comment}{// determine whether or not to use the ext or fixext types}}
\DoxyCodeLine{15531                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_ext = j.m\_value.binary-\/>has\_subtype();}
\DoxyCodeLine{15532 }
\DoxyCodeLine{15533                 \textcolor{comment}{// step 1: write control byte and the byte string length}}
\DoxyCodeLine{15534                 \textcolor{keyword}{const} \textcolor{keyword}{auto} N = j.m\_value.binary-\/>size();}
\DoxyCodeLine{15535                 \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{15536                 \{}
\DoxyCodeLine{15537                     std::uint8\_t output\_type\{\};}
\DoxyCodeLine{15538                     \textcolor{keywordtype}{bool} fixed = \textcolor{keyword}{true};}
\DoxyCodeLine{15539                     \textcolor{keywordflow}{if} (use\_ext)}
\DoxyCodeLine{15540                     \{}
\DoxyCodeLine{15541                         \textcolor{keywordflow}{switch} (N)}
\DoxyCodeLine{15542                         \{}
\DoxyCodeLine{15543                             \textcolor{keywordflow}{case} 1:}
\DoxyCodeLine{15544                                 output\_type = 0xD4; \textcolor{comment}{// fixext 1}}
\DoxyCodeLine{15545                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15546                             \textcolor{keywordflow}{case} 2:}
\DoxyCodeLine{15547                                 output\_type = 0xD5; \textcolor{comment}{// fixext 2}}
\DoxyCodeLine{15548                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15549                             \textcolor{keywordflow}{case} 4:}
\DoxyCodeLine{15550                                 output\_type = 0xD6; \textcolor{comment}{// fixext 4}}
\DoxyCodeLine{15551                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15552                             \textcolor{keywordflow}{case} 8:}
\DoxyCodeLine{15553                                 output\_type = 0xD7; \textcolor{comment}{// fixext 8}}
\DoxyCodeLine{15554                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15555                             \textcolor{keywordflow}{case} 16:}
\DoxyCodeLine{15556                                 output\_type = 0xD8; \textcolor{comment}{// fixext 16}}
\DoxyCodeLine{15557                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15558                             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15559                                 output\_type = 0xC7; \textcolor{comment}{// ext 8}}
\DoxyCodeLine{15560                                 fixed = \textcolor{keyword}{false};}
\DoxyCodeLine{15561                                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15562                         \}}
\DoxyCodeLine{15563 }
\DoxyCodeLine{15564                     \}}
\DoxyCodeLine{15565                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{15566                     \{}
\DoxyCodeLine{15567                         output\_type = 0xC4; \textcolor{comment}{// bin 8}}
\DoxyCodeLine{15568                         fixed = \textcolor{keyword}{false};}
\DoxyCodeLine{15569                     \}}
\DoxyCodeLine{15570 }
\DoxyCodeLine{15571                     oa-\/>write\_character(to\_char\_type(output\_type));}
\DoxyCodeLine{15572                     \textcolor{keywordflow}{if} (!fixed)}
\DoxyCodeLine{15573                     \{}
\DoxyCodeLine{15574                         write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15575                     \}}
\DoxyCodeLine{15576                 \}}
\DoxyCodeLine{15577                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15578                 \{}
\DoxyCodeLine{15579                     std::uint8\_t output\_type = use\_ext}
\DoxyCodeLine{15580                                                ? 0xC8 \textcolor{comment}{// ext 16}}
\DoxyCodeLine{15581                                                : 0xC5; \textcolor{comment}{// bin 16}}
\DoxyCodeLine{15582 }
\DoxyCodeLine{15583                     oa-\/>write\_character(to\_char\_type(output\_type));}
\DoxyCodeLine{15584                     write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15585                 \}}
\DoxyCodeLine{15586                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15587                 \{}
\DoxyCodeLine{15588                     std::uint8\_t output\_type = use\_ext}
\DoxyCodeLine{15589                                                ? 0xC9 \textcolor{comment}{// ext 32}}
\DoxyCodeLine{15590                                                : 0xC6; \textcolor{comment}{// bin 32}}
\DoxyCodeLine{15591 }
\DoxyCodeLine{15592                     oa-\/>write\_character(to\_char\_type(output\_type));}
\DoxyCodeLine{15593                     write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15594                 \}}
\DoxyCodeLine{15595 }
\DoxyCodeLine{15596                 \textcolor{comment}{// step 1.5: if this is an ext type, write the subtype}}
\DoxyCodeLine{15597                 \textcolor{keywordflow}{if} (use\_ext)}
\DoxyCodeLine{15598                 \{}
\DoxyCodeLine{15599                     write\_number(\textcolor{keyword}{static\_cast<}std::int8\_t\textcolor{keyword}{>}(j.m\_value.binary-\/>subtype()));}
\DoxyCodeLine{15600                 \}}
\DoxyCodeLine{15601 }
\DoxyCodeLine{15602                 \textcolor{comment}{// step 2: write the byte string}}
\DoxyCodeLine{15603                 oa-\/>write\_characters(}
\DoxyCodeLine{15604                     \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }CharType*\textcolor{keyword}{>}(j.m\_value.binary-\/>data()),}
\DoxyCodeLine{15605                     N);}
\DoxyCodeLine{15606 }
\DoxyCodeLine{15607                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15608             \}}
\DoxyCodeLine{15609 }
\DoxyCodeLine{15610             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{15611             \{}
\DoxyCodeLine{15612                 \textcolor{comment}{// step 1: write control byte and the object size}}
\DoxyCodeLine{15613                 \textcolor{keyword}{const} \textcolor{keyword}{auto} N = j.m\_value.object-\/>size();}
\DoxyCodeLine{15614                 \textcolor{keywordflow}{if} (N <= 15)}
\DoxyCodeLine{15615                 \{}
\DoxyCodeLine{15616                     \textcolor{comment}{// fixmap}}
\DoxyCodeLine{15617                     write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0x80 | (N \& 0xF)));}
\DoxyCodeLine{15618                 \}}
\DoxyCodeLine{15619                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint16\_t>::max)())}
\DoxyCodeLine{15620                 \{}
\DoxyCodeLine{15621                     \textcolor{comment}{// map 16}}
\DoxyCodeLine{15622                     oa-\/>write\_character(to\_char\_type(0xDE));}
\DoxyCodeLine{15623                     write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15624                 \}}
\DoxyCodeLine{15625                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (N <= (std::numeric\_limits<std::uint32\_t>::max)())}
\DoxyCodeLine{15626                 \{}
\DoxyCodeLine{15627                     \textcolor{comment}{// map 32}}
\DoxyCodeLine{15628                     oa-\/>write\_character(to\_char\_type(0xDF));}
\DoxyCodeLine{15629                     write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(N));}
\DoxyCodeLine{15630                 \}}
\DoxyCodeLine{15631 }
\DoxyCodeLine{15632                 \textcolor{comment}{// step 2: write each element}}
\DoxyCodeLine{15633                 \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : *j.m\_value.object)}
\DoxyCodeLine{15634                 \{}
\DoxyCodeLine{15635                     write\_msgpack(el.first);}
\DoxyCodeLine{15636                     write\_msgpack(el.second);}
\DoxyCodeLine{15637                 \}}
\DoxyCodeLine{15638                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15639             \}}
\DoxyCodeLine{15640 }
\DoxyCodeLine{15641             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{15642             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15643                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15644         \}}
\DoxyCodeLine{15645     \}}
\DoxyCodeLine{15646 }
\DoxyCodeLine{15654     \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1binary__writer_a972bec9688cbc5673bb482bbe9543e2a}{write\_ubjson}}(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_count,}
\DoxyCodeLine{15655                       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_type, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} add\_prefix = \textcolor{keyword}{true},}
\DoxyCodeLine{15656                       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_bjdata = \textcolor{keyword}{false})}
\DoxyCodeLine{15657     \{}
\DoxyCodeLine{15658         \textcolor{keywordflow}{switch} (j.type())}
\DoxyCodeLine{15659         \{}
\DoxyCodeLine{15660             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{15661             \{}
\DoxyCodeLine{15662                 \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{15663                 \{}
\DoxyCodeLine{15664                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'Z'}));}
\DoxyCodeLine{15665                 \}}
\DoxyCodeLine{15666                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15667             \}}
\DoxyCodeLine{15668 }
\DoxyCodeLine{15669             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{15670             \{}
\DoxyCodeLine{15671                 \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{15672                 \{}
\DoxyCodeLine{15673                     oa-\/>write\_character(j.m\_value.boolean}
\DoxyCodeLine{15674                                         ? to\_char\_type(\textcolor{charliteral}{'T'})}
\DoxyCodeLine{15675                                         : to\_char\_type(\textcolor{charliteral}{'F'}));}
\DoxyCodeLine{15676                 \}}
\DoxyCodeLine{15677                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15678             \}}
\DoxyCodeLine{15679 }
\DoxyCodeLine{15680             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{15681             \{}
\DoxyCodeLine{15682                 write\_number\_with\_ubjson\_prefix(j.m\_value.number\_integer, add\_prefix, use\_bjdata);}
\DoxyCodeLine{15683                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15684             \}}
\DoxyCodeLine{15685 }
\DoxyCodeLine{15686             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{15687             \{}
\DoxyCodeLine{15688                 write\_number\_with\_ubjson\_prefix(j.m\_value.number\_unsigned, add\_prefix, use\_bjdata);}
\DoxyCodeLine{15689                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15690             \}}
\DoxyCodeLine{15691 }
\DoxyCodeLine{15692             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{15693             \{}
\DoxyCodeLine{15694                 write\_number\_with\_ubjson\_prefix(j.m\_value.number\_float, add\_prefix, use\_bjdata);}
\DoxyCodeLine{15695                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15696             \}}
\DoxyCodeLine{15697 }
\DoxyCodeLine{15698             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{15699             \{}
\DoxyCodeLine{15700                 \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{15701                 \{}
\DoxyCodeLine{15702                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'S'}));}
\DoxyCodeLine{15703                 \}}
\DoxyCodeLine{15704                 write\_number\_with\_ubjson\_prefix(j.m\_value.string-\/>size(), \textcolor{keyword}{true}, use\_bjdata);}
\DoxyCodeLine{15705                 oa-\/>write\_characters(}
\DoxyCodeLine{15706                     \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }CharType*\textcolor{keyword}{>}(j.m\_value.string-\/>c\_str()),}
\DoxyCodeLine{15707                     j.m\_value.string-\/>size());}
\DoxyCodeLine{15708                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15709             \}}
\DoxyCodeLine{15710 }
\DoxyCodeLine{15711             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{15712             \{}
\DoxyCodeLine{15713                 \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{15714                 \{}
\DoxyCodeLine{15715                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'['}));}
\DoxyCodeLine{15716                 \}}
\DoxyCodeLine{15717 }
\DoxyCodeLine{15718                 \textcolor{keywordtype}{bool} prefix\_required = \textcolor{keyword}{true};}
\DoxyCodeLine{15719                 \textcolor{keywordflow}{if} (use\_type \&\& !j.m\_value.array-\/>empty())}
\DoxyCodeLine{15720                 \{}
\DoxyCodeLine{15721                     JSON\_ASSERT(use\_count);}
\DoxyCodeLine{15722                     \textcolor{keyword}{const} CharType first\_prefix = ubjson\_prefix(j.front(), use\_bjdata);}
\DoxyCodeLine{15723                     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} same\_prefix = std::all\_of(j.begin() + 1, j.end(),}
\DoxyCodeLine{15724                                                          [\textcolor{keyword}{this}, first\_prefix, use\_bjdata](\textcolor{keyword}{const} BasicJsonType \& v)}
\DoxyCodeLine{15725                     \{}
\DoxyCodeLine{15726                         return ubjson\_prefix(v, use\_bjdata) == first\_prefix;}
\DoxyCodeLine{15727                     \});}
\DoxyCodeLine{15728 }
\DoxyCodeLine{15729                     std::vector<CharType> bjdx = \{\textcolor{charliteral}{'['}, \textcolor{charliteral}{'\{'}, \textcolor{charliteral}{'S'}, \textcolor{charliteral}{'H'}, \textcolor{charliteral}{'T'}, \textcolor{charliteral}{'F'}, \textcolor{charliteral}{'N'}, \textcolor{charliteral}{'Z'}\}; \textcolor{comment}{// excluded markers in bjdata optimized type}}
\DoxyCodeLine{15730 }
\DoxyCodeLine{15731                     \textcolor{keywordflow}{if} (same\_prefix \&\& !(use\_bjdata \&\& std::find(bjdx.begin(), bjdx.end(), first\_prefix) != bjdx.end()))}
\DoxyCodeLine{15732                     \{}
\DoxyCodeLine{15733                         prefix\_required = \textcolor{keyword}{false};}
\DoxyCodeLine{15734                         oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'\$'}));}
\DoxyCodeLine{15735                         oa-\/>write\_character(first\_prefix);}
\DoxyCodeLine{15736                     \}}
\DoxyCodeLine{15737                 \}}
\DoxyCodeLine{15738 }
\DoxyCodeLine{15739                 \textcolor{keywordflow}{if} (use\_count)}
\DoxyCodeLine{15740                 \{}
\DoxyCodeLine{15741                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'\#'}));}
\DoxyCodeLine{15742                     write\_number\_with\_ubjson\_prefix(j.m\_value.array-\/>size(), \textcolor{keyword}{true}, use\_bjdata);}
\DoxyCodeLine{15743                 \}}
\DoxyCodeLine{15744 }
\DoxyCodeLine{15745                 \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : *j.m\_value.array)}
\DoxyCodeLine{15746                 \{}
\DoxyCodeLine{15747                     write\_ubjson(el, use\_count, use\_type, prefix\_required, use\_bjdata);}
\DoxyCodeLine{15748                 \}}
\DoxyCodeLine{15749 }
\DoxyCodeLine{15750                 \textcolor{keywordflow}{if} (!use\_count)}
\DoxyCodeLine{15751                 \{}
\DoxyCodeLine{15752                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{']'}));}
\DoxyCodeLine{15753                 \}}
\DoxyCodeLine{15754 }
\DoxyCodeLine{15755                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15756             \}}
\DoxyCodeLine{15757 }
\DoxyCodeLine{15758             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{15759             \{}
\DoxyCodeLine{15760                 \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{15761                 \{}
\DoxyCodeLine{15762                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'['}));}
\DoxyCodeLine{15763                 \}}
\DoxyCodeLine{15764 }
\DoxyCodeLine{15765                 \textcolor{keywordflow}{if} (use\_type \&\& !j.m\_value.binary-\/>empty())}
\DoxyCodeLine{15766                 \{}
\DoxyCodeLine{15767                     JSON\_ASSERT(use\_count);}
\DoxyCodeLine{15768                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'\$'}));}
\DoxyCodeLine{15769                     oa-\/>write\_character(\textcolor{charliteral}{'U'});}
\DoxyCodeLine{15770                 \}}
\DoxyCodeLine{15771 }
\DoxyCodeLine{15772                 \textcolor{keywordflow}{if} (use\_count)}
\DoxyCodeLine{15773                 \{}
\DoxyCodeLine{15774                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'\#'}));}
\DoxyCodeLine{15775                     write\_number\_with\_ubjson\_prefix(j.m\_value.binary-\/>size(), \textcolor{keyword}{true}, use\_bjdata);}
\DoxyCodeLine{15776                 \}}
\DoxyCodeLine{15777 }
\DoxyCodeLine{15778                 \textcolor{keywordflow}{if} (use\_type)}
\DoxyCodeLine{15779                 \{}
\DoxyCodeLine{15780                     oa-\/>write\_characters(}
\DoxyCodeLine{15781                         \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }CharType*\textcolor{keyword}{>}(j.m\_value.binary-\/>data()),}
\DoxyCodeLine{15782                         j.m\_value.binary-\/>size());}
\DoxyCodeLine{15783                 \}}
\DoxyCodeLine{15784                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15785                 \{}
\DoxyCodeLine{15786                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < j.m\_value.binary-\/>size(); ++i)}
\DoxyCodeLine{15787                     \{}
\DoxyCodeLine{15788                         oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'U'}));}
\DoxyCodeLine{15789                         oa-\/>write\_character(j.m\_value.binary-\/>data()[i]);}
\DoxyCodeLine{15790                     \}}
\DoxyCodeLine{15791                 \}}
\DoxyCodeLine{15792 }
\DoxyCodeLine{15793                 \textcolor{keywordflow}{if} (!use\_count)}
\DoxyCodeLine{15794                 \{}
\DoxyCodeLine{15795                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{']'}));}
\DoxyCodeLine{15796                 \}}
\DoxyCodeLine{15797 }
\DoxyCodeLine{15798                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15799             \}}
\DoxyCodeLine{15800 }
\DoxyCodeLine{15801             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{15802             \{}
\DoxyCodeLine{15803                 \textcolor{keywordflow}{if} (use\_bjdata \&\& j.m\_value.object-\/>size() == 3 \&\& j.m\_value.object-\/>find(\textcolor{stringliteral}{"{}\_ArrayType\_"{}}) != j.m\_value.object-\/>end() \&\& j.m\_value.object-\/>find(\textcolor{stringliteral}{"{}\_ArraySize\_"{}}) != j.m\_value.object-\/>end() \&\& j.m\_value.object-\/>find(\textcolor{stringliteral}{"{}\_ArrayData\_"{}}) != j.m\_value.object-\/>end())}
\DoxyCodeLine{15804                 \{}
\DoxyCodeLine{15805                     \textcolor{keywordflow}{if} (!write\_bjdata\_ndarray(*j.m\_value.object, use\_count, use\_type))  \textcolor{comment}{// decode bjdata ndarray in the JData format (https://github.com/NeuroJSON/jdata)}}
\DoxyCodeLine{15806                     \{}
\DoxyCodeLine{15807                         \textcolor{keywordflow}{break};}
\DoxyCodeLine{15808                     \}}
\DoxyCodeLine{15809                 \}}
\DoxyCodeLine{15810 }
\DoxyCodeLine{15811                 \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{15812                 \{}
\DoxyCodeLine{15813                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'\{'}));}
\DoxyCodeLine{15814                 \}}
\DoxyCodeLine{15815 }
\DoxyCodeLine{15816                 \textcolor{keywordtype}{bool} prefix\_required = \textcolor{keyword}{true};}
\DoxyCodeLine{15817                 \textcolor{keywordflow}{if} (use\_type \&\& !j.m\_value.object-\/>empty())}
\DoxyCodeLine{15818                 \{}
\DoxyCodeLine{15819                     JSON\_ASSERT(use\_count);}
\DoxyCodeLine{15820                     \textcolor{keyword}{const} CharType first\_prefix = ubjson\_prefix(j.front(), use\_bjdata);}
\DoxyCodeLine{15821                     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} same\_prefix = std::all\_of(j.begin(), j.end(),}
\DoxyCodeLine{15822                                                          [\textcolor{keyword}{this}, first\_prefix, use\_bjdata](\textcolor{keyword}{const} BasicJsonType \& v)}
\DoxyCodeLine{15823                     \{}
\DoxyCodeLine{15824                         return ubjson\_prefix(v, use\_bjdata) == first\_prefix;}
\DoxyCodeLine{15825                     \});}
\DoxyCodeLine{15826 }
\DoxyCodeLine{15827                     std::vector<CharType> bjdx = \{\textcolor{charliteral}{'['}, \textcolor{charliteral}{'\{'}, \textcolor{charliteral}{'S'}, \textcolor{charliteral}{'H'}, \textcolor{charliteral}{'T'}, \textcolor{charliteral}{'F'}, \textcolor{charliteral}{'N'}, \textcolor{charliteral}{'Z'}\}; \textcolor{comment}{// excluded markers in bjdata optimized type}}
\DoxyCodeLine{15828 }
\DoxyCodeLine{15829                     \textcolor{keywordflow}{if} (same\_prefix \&\& !(use\_bjdata \&\& std::find(bjdx.begin(), bjdx.end(), first\_prefix) != bjdx.end()))}
\DoxyCodeLine{15830                     \{}
\DoxyCodeLine{15831                         prefix\_required = \textcolor{keyword}{false};}
\DoxyCodeLine{15832                         oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'\$'}));}
\DoxyCodeLine{15833                         oa-\/>write\_character(first\_prefix);}
\DoxyCodeLine{15834                     \}}
\DoxyCodeLine{15835                 \}}
\DoxyCodeLine{15836 }
\DoxyCodeLine{15837                 \textcolor{keywordflow}{if} (use\_count)}
\DoxyCodeLine{15838                 \{}
\DoxyCodeLine{15839                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'\#'}));}
\DoxyCodeLine{15840                     write\_number\_with\_ubjson\_prefix(j.m\_value.object-\/>size(), \textcolor{keyword}{true}, use\_bjdata);}
\DoxyCodeLine{15841                 \}}
\DoxyCodeLine{15842 }
\DoxyCodeLine{15843                 \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : *j.m\_value.object)}
\DoxyCodeLine{15844                 \{}
\DoxyCodeLine{15845                     write\_number\_with\_ubjson\_prefix(el.first.size(), \textcolor{keyword}{true}, use\_bjdata);}
\DoxyCodeLine{15846                     oa-\/>write\_characters(}
\DoxyCodeLine{15847                         \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }CharType*\textcolor{keyword}{>}(el.first.c\_str()),}
\DoxyCodeLine{15848                         el.first.size());}
\DoxyCodeLine{15849                     write\_ubjson(el.second, use\_count, use\_type, prefix\_required, use\_bjdata);}
\DoxyCodeLine{15850                 \}}
\DoxyCodeLine{15851 }
\DoxyCodeLine{15852                 \textcolor{keywordflow}{if} (!use\_count)}
\DoxyCodeLine{15853                 \{}
\DoxyCodeLine{15854                     oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'\}'}));}
\DoxyCodeLine{15855                 \}}
\DoxyCodeLine{15856 }
\DoxyCodeLine{15857                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15858             \}}
\DoxyCodeLine{15859 }
\DoxyCodeLine{15860             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{15861             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15862                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15863         \}}
\DoxyCodeLine{15864     \}}
\DoxyCodeLine{15865 }
\DoxyCodeLine{15866   \textcolor{keyword}{private}:}
\DoxyCodeLine{15868     \textcolor{comment}{// BSON //}}
\DoxyCodeLine{15870 \textcolor{comment}{}}
\DoxyCodeLine{15875     \textcolor{keyword}{static} std::size\_t calc\_bson\_entry\_header\_size(\textcolor{keyword}{const} string\_t\& name, \textcolor{keyword}{const} BasicJsonType\& j)}
\DoxyCodeLine{15876     \{}
\DoxyCodeLine{15877         \textcolor{keyword}{const} \textcolor{keyword}{auto} it = name.find(\textcolor{keyword}{static\_cast<}typename string\_t::value\_type\textcolor{keyword}{>}(0));}
\DoxyCodeLine{15878         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(it != BasicJsonType::string\_t::npos))}
\DoxyCodeLine{15879         \{}
\DoxyCodeLine{15880             JSON\_THROW(out\_of\_range::create(409, concat(\textcolor{stringliteral}{"{}BSON key cannot contain code point U+0000 (at byte "{}}, std::to\_string(it), \textcolor{stringliteral}{"{})"{}}), \&j));}
\DoxyCodeLine{15881             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(j);}
\DoxyCodeLine{15882         \}}
\DoxyCodeLine{15883 }
\DoxyCodeLine{15884         \textcolor{keywordflow}{return} \textcolor{comment}{/*id*/} 1ul + name.size() + \textcolor{comment}{/*zero-\/terminator*/}1u;}
\DoxyCodeLine{15885     \}}
\DoxyCodeLine{15886 }
\DoxyCodeLine{15890     \textcolor{keywordtype}{void} write\_bson\_entry\_header(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{15891                                  \textcolor{keyword}{const} std::uint8\_t element\_type)}
\DoxyCodeLine{15892     \{}
\DoxyCodeLine{15893         oa-\/>write\_character(to\_char\_type(element\_type)); \textcolor{comment}{// boolean}}
\DoxyCodeLine{15894         oa-\/>write\_characters(}
\DoxyCodeLine{15895             \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }CharType*\textcolor{keyword}{>}(name.c\_str()),}
\DoxyCodeLine{15896             name.size() + 1u);}
\DoxyCodeLine{15897     \}}
\DoxyCodeLine{15898 }
\DoxyCodeLine{15902     \textcolor{keywordtype}{void} write\_bson\_boolean(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{15903                             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value)}
\DoxyCodeLine{15904     \{}
\DoxyCodeLine{15905         write\_bson\_entry\_header(name, 0x08);}
\DoxyCodeLine{15906         oa-\/>write\_character(value ? to\_char\_type(0x01) : to\_char\_type(0x00));}
\DoxyCodeLine{15907     \}}
\DoxyCodeLine{15908 }
\DoxyCodeLine{15912     \textcolor{keywordtype}{void} write\_bson\_double(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{15913                            \textcolor{keyword}{const} \textcolor{keywordtype}{double} value)}
\DoxyCodeLine{15914     \{}
\DoxyCodeLine{15915         write\_bson\_entry\_header(name, 0x01);}
\DoxyCodeLine{15916         write\_number<double>(value, \textcolor{keyword}{true});}
\DoxyCodeLine{15917     \}}
\DoxyCodeLine{15918 }
\DoxyCodeLine{15922     \textcolor{keyword}{static} std::size\_t calc\_bson\_string\_size(\textcolor{keyword}{const} string\_t\& value)}
\DoxyCodeLine{15923     \{}
\DoxyCodeLine{15924         \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(std::int32\_t) + \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.size() + 1ul;}
\DoxyCodeLine{15925     \}}
\DoxyCodeLine{15926 }
\DoxyCodeLine{15930     \textcolor{keywordtype}{void} write\_bson\_string(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{15931                            \textcolor{keyword}{const} string\_t\& value)}
\DoxyCodeLine{15932     \{}
\DoxyCodeLine{15933         write\_bson\_entry\_header(name, 0x02);}
\DoxyCodeLine{15934 }
\DoxyCodeLine{15935         write\_number<std::int32\_t>(\textcolor{keyword}{static\_cast<}std::int32\_t\textcolor{keyword}{>}(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.size() + 1ul), \textcolor{keyword}{true});}
\DoxyCodeLine{15936         oa-\/>write\_characters(}
\DoxyCodeLine{15937             \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }CharType*\textcolor{keyword}{>}(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.c\_str()),}
\DoxyCodeLine{15938             \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.size() + 1);}
\DoxyCodeLine{15939     \}}
\DoxyCodeLine{15940 }
\DoxyCodeLine{15944     \textcolor{keywordtype}{void} write\_bson\_null(\textcolor{keyword}{const} string\_t\& name)}
\DoxyCodeLine{15945     \{}
\DoxyCodeLine{15946         write\_bson\_entry\_header(name, 0x0A);}
\DoxyCodeLine{15947     \}}
\DoxyCodeLine{15948 }
\DoxyCodeLine{15952     \textcolor{keyword}{static} std::size\_t calc\_bson\_integer\_size(\textcolor{keyword}{const} std::int64\_t value)}
\DoxyCodeLine{15953     \{}
\DoxyCodeLine{15954         \textcolor{keywordflow}{return} (std::numeric\_limits<std::int32\_t>::min)() <= value \&\& value <= (std::numeric\_limits<std::int32\_t>::max)()}
\DoxyCodeLine{15955                ? \textcolor{keyword}{sizeof}(std::int32\_t)}
\DoxyCodeLine{15956                : \textcolor{keyword}{sizeof}(std::int64\_t);}
\DoxyCodeLine{15957     \}}
\DoxyCodeLine{15958 }
\DoxyCodeLine{15962     \textcolor{keywordtype}{void} write\_bson\_integer(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{15963                             \textcolor{keyword}{const} std::int64\_t value)}
\DoxyCodeLine{15964     \{}
\DoxyCodeLine{15965         \textcolor{keywordflow}{if} ((std::numeric\_limits<std::int32\_t>::min)() <= value \&\& value <= (std::numeric\_limits<std::int32\_t>::max)())}
\DoxyCodeLine{15966         \{}
\DoxyCodeLine{15967             write\_bson\_entry\_header(name, 0x10); \textcolor{comment}{// int32}}
\DoxyCodeLine{15968             write\_number<std::int32\_t>(\textcolor{keyword}{static\_cast<}std::int32\_t\textcolor{keyword}{>}(value), \textcolor{keyword}{true});}
\DoxyCodeLine{15969         \}}
\DoxyCodeLine{15970         \textcolor{keywordflow}{else}}
\DoxyCodeLine{15971         \{}
\DoxyCodeLine{15972             write\_bson\_entry\_header(name, 0x12); \textcolor{comment}{// int64}}
\DoxyCodeLine{15973             write\_number<std::int64\_t>(\textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}(value), \textcolor{keyword}{true});}
\DoxyCodeLine{15974         \}}
\DoxyCodeLine{15975     \}}
\DoxyCodeLine{15976 }
\DoxyCodeLine{15980     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::size\_t calc\_bson\_unsigned\_size(\textcolor{keyword}{const} std::uint64\_t value) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{15981     \{}
\DoxyCodeLine{15982         \textcolor{keywordflow}{return} (value <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int32\_t>::max)()))}
\DoxyCodeLine{15983                ? \textcolor{keyword}{sizeof}(std::int32\_t)}
\DoxyCodeLine{15984                : \textcolor{keyword}{sizeof}(std::int64\_t);}
\DoxyCodeLine{15985     \}}
\DoxyCodeLine{15986 }
\DoxyCodeLine{15990     \textcolor{keywordtype}{void} write\_bson\_unsigned(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{15991                              \textcolor{keyword}{const} BasicJsonType\& j)}
\DoxyCodeLine{15992     \{}
\DoxyCodeLine{15993         \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int32\_t>::max)()))}
\DoxyCodeLine{15994         \{}
\DoxyCodeLine{15995             write\_bson\_entry\_header(name, 0x10 \textcolor{comment}{/* int32 */});}
\DoxyCodeLine{15996             write\_number<std::int32\_t>(\textcolor{keyword}{static\_cast<}std::int32\_t\textcolor{keyword}{>}(j.m\_value.number\_unsigned), \textcolor{keyword}{true});}
\DoxyCodeLine{15997         \}}
\DoxyCodeLine{15998         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int64\_t>::max)()))}
\DoxyCodeLine{15999         \{}
\DoxyCodeLine{16000             write\_bson\_entry\_header(name, 0x12 \textcolor{comment}{/* int64 */});}
\DoxyCodeLine{16001             write\_number<std::int64\_t>(\textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}(j.m\_value.number\_unsigned), \textcolor{keyword}{true});}
\DoxyCodeLine{16002         \}}
\DoxyCodeLine{16003         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16004         \{}
\DoxyCodeLine{16005             JSON\_THROW(out\_of\_range::create(407, concat(\textcolor{stringliteral}{"{}integer number "{}}, std::to\_string(j.m\_value.number\_unsigned), \textcolor{stringliteral}{"{} cannot be represented by BSON as it does not fit int64"{}}), \&j));}
\DoxyCodeLine{16006         \}}
\DoxyCodeLine{16007     \}}
\DoxyCodeLine{16008 }
\DoxyCodeLine{16012     \textcolor{keywordtype}{void} write\_bson\_object\_entry(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{16013                                  \textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::object\_t\& value)}
\DoxyCodeLine{16014     \{}
\DoxyCodeLine{16015         write\_bson\_entry\_header(name, 0x03); \textcolor{comment}{// object}}
\DoxyCodeLine{16016         write\_bson\_object(value);}
\DoxyCodeLine{16017     \}}
\DoxyCodeLine{16018 }
\DoxyCodeLine{16022     \textcolor{keyword}{static} std::size\_t calc\_bson\_array\_size(\textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::array\_t\& value)}
\DoxyCodeLine{16023     \{}
\DoxyCodeLine{16024         std::size\_t array\_index = 0ul;}
\DoxyCodeLine{16025 }
\DoxyCodeLine{16026         \textcolor{keyword}{const} std::size\_t embedded\_document\_size = std::accumulate(std::begin(value), std::end(value), \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(0), [\&array\_index](std::size\_t result, \textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::array\_t::value\_type \& el)}
\DoxyCodeLine{16027         \{}
\DoxyCodeLine{16028             \textcolor{keywordflow}{return} result + calc\_bson\_element\_size(std::to\_string(array\_index++), el);}
\DoxyCodeLine{16029         \});}
\DoxyCodeLine{16030 }
\DoxyCodeLine{16031         \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(std::int32\_t) + embedded\_document\_size + 1ul;}
\DoxyCodeLine{16032     \}}
\DoxyCodeLine{16033 }
\DoxyCodeLine{16037     \textcolor{keyword}{static} std::size\_t calc\_bson\_binary\_size(\textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::binary\_t\& value)}
\DoxyCodeLine{16038     \{}
\DoxyCodeLine{16039         \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(std::int32\_t) + \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.size() + 1ul;}
\DoxyCodeLine{16040     \}}
\DoxyCodeLine{16041 }
\DoxyCodeLine{16045     \textcolor{keywordtype}{void} write\_bson\_array(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{16046                           \textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::array\_t\& value)}
\DoxyCodeLine{16047     \{}
\DoxyCodeLine{16048         write\_bson\_entry\_header(name, 0x04); \textcolor{comment}{// array}}
\DoxyCodeLine{16049         write\_number<std::int32\_t>(\textcolor{keyword}{static\_cast<}std::int32\_t\textcolor{keyword}{>}(calc\_bson\_array\_size(value)), \textcolor{keyword}{true});}
\DoxyCodeLine{16050 }
\DoxyCodeLine{16051         std::size\_t array\_index = 0ul;}
\DoxyCodeLine{16052 }
\DoxyCodeLine{16053         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : value)}
\DoxyCodeLine{16054         \{}
\DoxyCodeLine{16055             write\_bson\_element(std::to\_string(array\_index++), el);}
\DoxyCodeLine{16056         \}}
\DoxyCodeLine{16057 }
\DoxyCodeLine{16058         oa-\/>write\_character(to\_char\_type(0x00));}
\DoxyCodeLine{16059     \}}
\DoxyCodeLine{16060 }
\DoxyCodeLine{16064     \textcolor{keywordtype}{void} write\_bson\_binary(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{16065                            \textcolor{keyword}{const} binary\_t\& value)}
\DoxyCodeLine{16066     \{}
\DoxyCodeLine{16067         write\_bson\_entry\_header(name, 0x05);}
\DoxyCodeLine{16068 }
\DoxyCodeLine{16069         write\_number<std::int32\_t>(\textcolor{keyword}{static\_cast<}std::int32\_t\textcolor{keyword}{>}(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.size()), \textcolor{keyword}{true});}
\DoxyCodeLine{16070         write\_number(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.has\_subtype() ? \textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.subtype()) : \textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(0x00));}
\DoxyCodeLine{16071 }
\DoxyCodeLine{16072         oa-\/>write\_characters(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }CharType*\textcolor{keyword}{>}(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.data()), \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.size());}
\DoxyCodeLine{16073     \}}
\DoxyCodeLine{16074 }
\DoxyCodeLine{16079     \textcolor{keyword}{static} std::size\_t calc\_bson\_element\_size(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{16080             \textcolor{keyword}{const} BasicJsonType\& j)}
\DoxyCodeLine{16081     \{}
\DoxyCodeLine{16082         \textcolor{keyword}{const} \textcolor{keyword}{auto} header\_size = calc\_bson\_entry\_header\_size(name, j);}
\DoxyCodeLine{16083         \textcolor{keywordflow}{switch} (j.type())}
\DoxyCodeLine{16084         \{}
\DoxyCodeLine{16085             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{16086                 \textcolor{keywordflow}{return} header\_size + calc\_bson\_object\_size(*j.m\_value.object);}
\DoxyCodeLine{16087 }
\DoxyCodeLine{16088             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{16089                 \textcolor{keywordflow}{return} header\_size + calc\_bson\_array\_size(*j.m\_value.array);}
\DoxyCodeLine{16090 }
\DoxyCodeLine{16091             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{16092                 \textcolor{keywordflow}{return} header\_size + calc\_bson\_binary\_size(*j.m\_value.binary);}
\DoxyCodeLine{16093 }
\DoxyCodeLine{16094             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{16095                 \textcolor{keywordflow}{return} header\_size + 1ul;}
\DoxyCodeLine{16096 }
\DoxyCodeLine{16097             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{16098                 \textcolor{keywordflow}{return} header\_size + 8ul;}
\DoxyCodeLine{16099 }
\DoxyCodeLine{16100             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{16101                 \textcolor{keywordflow}{return} header\_size + calc\_bson\_integer\_size(j.m\_value.number\_integer);}
\DoxyCodeLine{16102 }
\DoxyCodeLine{16103             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{16104                 \textcolor{keywordflow}{return} header\_size + calc\_bson\_unsigned\_size(j.m\_value.number\_unsigned);}
\DoxyCodeLine{16105 }
\DoxyCodeLine{16106             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{16107                 \textcolor{keywordflow}{return} header\_size + calc\_bson\_string\_size(*j.m\_value.string);}
\DoxyCodeLine{16108 }
\DoxyCodeLine{16109             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{16110                 \textcolor{keywordflow}{return} header\_size + 0ul;}
\DoxyCodeLine{16111 }
\DoxyCodeLine{16112             \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{16113             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{16114             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{16115                 JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert)}}
\DoxyCodeLine{16116                 \textcolor{keywordflow}{return} 0ul;}
\DoxyCodeLine{16117                 \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{16118         \}}
\DoxyCodeLine{16119     \}}
\DoxyCodeLine{16120 }
\DoxyCodeLine{16127     \textcolor{keywordtype}{void} write\_bson\_element(\textcolor{keyword}{const} string\_t\& name,}
\DoxyCodeLine{16128                             \textcolor{keyword}{const} BasicJsonType\& j)}
\DoxyCodeLine{16129     \{}
\DoxyCodeLine{16130         \textcolor{keywordflow}{switch} (j.type())}
\DoxyCodeLine{16131         \{}
\DoxyCodeLine{16132             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{16133                 \textcolor{keywordflow}{return} write\_bson\_object\_entry(name, *j.m\_value.object);}
\DoxyCodeLine{16134 }
\DoxyCodeLine{16135             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{16136                 \textcolor{keywordflow}{return} write\_bson\_array(name, *j.m\_value.array);}
\DoxyCodeLine{16137 }
\DoxyCodeLine{16138             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{16139                 \textcolor{keywordflow}{return} write\_bson\_binary(name, *j.m\_value.binary);}
\DoxyCodeLine{16140 }
\DoxyCodeLine{16141             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{16142                 \textcolor{keywordflow}{return} write\_bson\_boolean(name, j.m\_value.boolean);}
\DoxyCodeLine{16143 }
\DoxyCodeLine{16144             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{16145                 \textcolor{keywordflow}{return} write\_bson\_double(name, j.m\_value.number\_float);}
\DoxyCodeLine{16146 }
\DoxyCodeLine{16147             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{16148                 \textcolor{keywordflow}{return} write\_bson\_integer(name, j.m\_value.number\_integer);}
\DoxyCodeLine{16149 }
\DoxyCodeLine{16150             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{16151                 \textcolor{keywordflow}{return} write\_bson\_unsigned(name, j);}
\DoxyCodeLine{16152 }
\DoxyCodeLine{16153             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{16154                 \textcolor{keywordflow}{return} write\_bson\_string(name, *j.m\_value.string);}
\DoxyCodeLine{16155 }
\DoxyCodeLine{16156             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{16157                 \textcolor{keywordflow}{return} write\_bson\_null(name);}
\DoxyCodeLine{16158 }
\DoxyCodeLine{16159             \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{16160             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{16161             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{16162                 JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert)}}
\DoxyCodeLine{16163                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{16164                 \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{16165         \}}
\DoxyCodeLine{16166     \}}
\DoxyCodeLine{16167 }
\DoxyCodeLine{16174     \textcolor{keyword}{static} std::size\_t calc\_bson\_object\_size(\textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::object\_t\& value)}
\DoxyCodeLine{16175     \{}
\DoxyCodeLine{16176         std::size\_t document\_size = std::accumulate(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.begin(), \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.end(), \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(0),}
\DoxyCodeLine{16177                                     [](\textcolor{keywordtype}{size\_t} result, \textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::object\_t::value\_type \& el)}
\DoxyCodeLine{16178         \{}
\DoxyCodeLine{16179             return result += calc\_bson\_element\_size(el.first, el.second);}
\DoxyCodeLine{16180         \});}
\DoxyCodeLine{16181 }
\DoxyCodeLine{16182         \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(std::int32\_t) + document\_size + 1ul;}
\DoxyCodeLine{16183     \}}
\DoxyCodeLine{16184 }
\DoxyCodeLine{16189     \textcolor{keywordtype}{void} write\_bson\_object(\textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::object\_t\& value)}
\DoxyCodeLine{16190     \{}
\DoxyCodeLine{16191         write\_number<std::int32\_t>(\textcolor{keyword}{static\_cast<}std::int32\_t\textcolor{keyword}{>}(calc\_bson\_object\_size(value)), \textcolor{keyword}{true});}
\DoxyCodeLine{16192 }
\DoxyCodeLine{16193         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : value)}
\DoxyCodeLine{16194         \{}
\DoxyCodeLine{16195             write\_bson\_element(el.first, el.second);}
\DoxyCodeLine{16196         \}}
\DoxyCodeLine{16197 }
\DoxyCodeLine{16198         oa-\/>write\_character(to\_char\_type(0x00));}
\DoxyCodeLine{16199     \}}
\DoxyCodeLine{16200 }
\DoxyCodeLine{16202     \textcolor{comment}{// CBOR //}}
\DoxyCodeLine{16204 \textcolor{comment}{}}
\DoxyCodeLine{16205     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} CharType get\_cbor\_float\_prefix(\textcolor{keywordtype}{float} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{16206     \{}
\DoxyCodeLine{16207         \textcolor{keywordflow}{return} to\_char\_type(0xFA);  \textcolor{comment}{// Single-\/Precision Float}}
\DoxyCodeLine{16208     \}}
\DoxyCodeLine{16209 }
\DoxyCodeLine{16210     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} CharType get\_cbor\_float\_prefix(\textcolor{keywordtype}{double} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{16211     \{}
\DoxyCodeLine{16212         \textcolor{keywordflow}{return} to\_char\_type(0xFB);  \textcolor{comment}{// Double-\/Precision Float}}
\DoxyCodeLine{16213     \}}
\DoxyCodeLine{16214 }
\DoxyCodeLine{16216     \textcolor{comment}{// MsgPack //}}
\DoxyCodeLine{16218 \textcolor{comment}{}}
\DoxyCodeLine{16219     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} CharType get\_msgpack\_float\_prefix(\textcolor{keywordtype}{float} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{16220     \{}
\DoxyCodeLine{16221         \textcolor{keywordflow}{return} to\_char\_type(0xCA);  \textcolor{comment}{// float 32}}
\DoxyCodeLine{16222     \}}
\DoxyCodeLine{16223 }
\DoxyCodeLine{16224     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} CharType get\_msgpack\_float\_prefix(\textcolor{keywordtype}{double} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{16225     \{}
\DoxyCodeLine{16226         \textcolor{keywordflow}{return} to\_char\_type(0xCB);  \textcolor{comment}{// float 64}}
\DoxyCodeLine{16227     \}}
\DoxyCodeLine{16228 }
\DoxyCodeLine{16230     \textcolor{comment}{// UBJSON //}}
\DoxyCodeLine{16232 \textcolor{comment}{}}
\DoxyCodeLine{16233     \textcolor{comment}{// UBJSON: write number (floating point)}}
\DoxyCodeLine{16234     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{16235                  std::is\_floating\_point<NumberType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{16236     \textcolor{keywordtype}{void} write\_number\_with\_ubjson\_prefix(\textcolor{keyword}{const} NumberType n,}
\DoxyCodeLine{16237                                          \textcolor{keyword}{const} \textcolor{keywordtype}{bool} add\_prefix,}
\DoxyCodeLine{16238                                          \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_bjdata)}
\DoxyCodeLine{16239     \{}
\DoxyCodeLine{16240         \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16241         \{}
\DoxyCodeLine{16242             oa-\/>write\_character(get\_ubjson\_float\_prefix(n));}
\DoxyCodeLine{16243         \}}
\DoxyCodeLine{16244         write\_number(n, use\_bjdata);}
\DoxyCodeLine{16245     \}}
\DoxyCodeLine{16246 }
\DoxyCodeLine{16247     \textcolor{comment}{// UBJSON: write number (unsigned integer)}}
\DoxyCodeLine{16248     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{16249                  std::is\_unsigned<NumberType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{16250     \textcolor{keywordtype}{void} write\_number\_with\_ubjson\_prefix(\textcolor{keyword}{const} NumberType n,}
\DoxyCodeLine{16251                                          \textcolor{keyword}{const} \textcolor{keywordtype}{bool} add\_prefix,}
\DoxyCodeLine{16252                                          \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_bjdata)}
\DoxyCodeLine{16253     \{}
\DoxyCodeLine{16254         \textcolor{keywordflow}{if} (n <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int8\_t>::max)()))}
\DoxyCodeLine{16255         \{}
\DoxyCodeLine{16256             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16257             \{}
\DoxyCodeLine{16258                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'i'}));  \textcolor{comment}{// int8}}
\DoxyCodeLine{16259             \}}
\DoxyCodeLine{16260             write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16261         \}}
\DoxyCodeLine{16262         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{16263         \{}
\DoxyCodeLine{16264             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16265             \{}
\DoxyCodeLine{16266                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'U'}));  \textcolor{comment}{// uint8}}
\DoxyCodeLine{16267             \}}
\DoxyCodeLine{16268             write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16269         \}}
\DoxyCodeLine{16270         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int16\_t>::max)()))}
\DoxyCodeLine{16271         \{}
\DoxyCodeLine{16272             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16273             \{}
\DoxyCodeLine{16274                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'I'}));  \textcolor{comment}{// int16}}
\DoxyCodeLine{16275             \}}
\DoxyCodeLine{16276             write\_number(\textcolor{keyword}{static\_cast<}std::int16\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16277         \}}
\DoxyCodeLine{16278         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (use\_bjdata \&\& n <= \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<uint16\_t>::max)()))}
\DoxyCodeLine{16279         \{}
\DoxyCodeLine{16280             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16281             \{}
\DoxyCodeLine{16282                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'u'}));  \textcolor{comment}{// uint16 -\/ bjdata only}}
\DoxyCodeLine{16283             \}}
\DoxyCodeLine{16284             write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16285         \}}
\DoxyCodeLine{16286         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int32\_t>::max)()))}
\DoxyCodeLine{16287         \{}
\DoxyCodeLine{16288             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16289             \{}
\DoxyCodeLine{16290                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'l'}));  \textcolor{comment}{// int32}}
\DoxyCodeLine{16291             \}}
\DoxyCodeLine{16292             write\_number(\textcolor{keyword}{static\_cast<}std::int32\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16293         \}}
\DoxyCodeLine{16294         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (use\_bjdata \&\& n <= \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<uint32\_t>::max)()))}
\DoxyCodeLine{16295         \{}
\DoxyCodeLine{16296             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16297             \{}
\DoxyCodeLine{16298                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'m'}));  \textcolor{comment}{// uint32 -\/ bjdata only}}
\DoxyCodeLine{16299             \}}
\DoxyCodeLine{16300             write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16301         \}}
\DoxyCodeLine{16302         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int64\_t>::max)()))}
\DoxyCodeLine{16303         \{}
\DoxyCodeLine{16304             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16305             \{}
\DoxyCodeLine{16306                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'L'}));  \textcolor{comment}{// int64}}
\DoxyCodeLine{16307             \}}
\DoxyCodeLine{16308             write\_number(\textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16309         \}}
\DoxyCodeLine{16310         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (use\_bjdata \&\& n <= (std::numeric\_limits<uint64\_t>::max)())}
\DoxyCodeLine{16311         \{}
\DoxyCodeLine{16312             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16313             \{}
\DoxyCodeLine{16314                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'M'}));  \textcolor{comment}{// uint64 -\/ bjdata only}}
\DoxyCodeLine{16315             \}}
\DoxyCodeLine{16316             write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16317         \}}
\DoxyCodeLine{16318         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16319         \{}
\DoxyCodeLine{16320             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16321             \{}
\DoxyCodeLine{16322                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'H'}));  \textcolor{comment}{// high-\/precision number}}
\DoxyCodeLine{16323             \}}
\DoxyCodeLine{16324 }
\DoxyCodeLine{16325             \textcolor{keyword}{const} \textcolor{keyword}{auto} number = BasicJsonType(n).dump();}
\DoxyCodeLine{16326             write\_number\_with\_ubjson\_prefix(number.size(), \textcolor{keyword}{true}, use\_bjdata);}
\DoxyCodeLine{16327             \textcolor{keywordflow}{for} (std::size\_t i = 0; i < number.size(); ++i)}
\DoxyCodeLine{16328             \{}
\DoxyCodeLine{16329                 oa-\/>write\_character(to\_char\_type(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(number[i])));}
\DoxyCodeLine{16330             \}}
\DoxyCodeLine{16331         \}}
\DoxyCodeLine{16332     \}}
\DoxyCodeLine{16333 }
\DoxyCodeLine{16334     \textcolor{comment}{// UBJSON: write number (signed integer)}}
\DoxyCodeLine{16335     \textcolor{keyword}{template} < \textcolor{keyword}{typename} NumberType, \textcolor{keyword}{typename} std::enable\_if <}
\DoxyCodeLine{16336                    std::is\_signed<NumberType>::value\&\&}
\DoxyCodeLine{16337                    !std::is\_floating\_point<NumberType>::value, \textcolor{keywordtype}{int} >::type = 0 >}
\DoxyCodeLine{16338     \textcolor{keywordtype}{void} write\_number\_with\_ubjson\_prefix(\textcolor{keyword}{const} NumberType n,}
\DoxyCodeLine{16339                                          \textcolor{keyword}{const} \textcolor{keywordtype}{bool} add\_prefix,}
\DoxyCodeLine{16340                                          \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_bjdata)}
\DoxyCodeLine{16341     \{}
\DoxyCodeLine{16342         \textcolor{keywordflow}{if} ((std::numeric\_limits<std::int8\_t>::min)() <= n \&\& n <= (std::numeric\_limits<std::int8\_t>::max)())}
\DoxyCodeLine{16343         \{}
\DoxyCodeLine{16344             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16345             \{}
\DoxyCodeLine{16346                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'i'}));  \textcolor{comment}{// int8}}
\DoxyCodeLine{16347             \}}
\DoxyCodeLine{16348             write\_number(\textcolor{keyword}{static\_cast<}std::int8\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16349         \}}
\DoxyCodeLine{16350         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::uint8\_t>::min)()) <= n \&\& n <= \textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::uint8\_t>::max)()))}
\DoxyCodeLine{16351         \{}
\DoxyCodeLine{16352             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16353             \{}
\DoxyCodeLine{16354                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'U'}));  \textcolor{comment}{// uint8}}
\DoxyCodeLine{16355             \}}
\DoxyCodeLine{16356             write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16357         \}}
\DoxyCodeLine{16358         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((std::numeric\_limits<std::int16\_t>::min)() <= n \&\& n <= (std::numeric\_limits<std::int16\_t>::max)())}
\DoxyCodeLine{16359         \{}
\DoxyCodeLine{16360             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16361             \{}
\DoxyCodeLine{16362                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'I'}));  \textcolor{comment}{// int16}}
\DoxyCodeLine{16363             \}}
\DoxyCodeLine{16364             write\_number(\textcolor{keyword}{static\_cast<}std::int16\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16365         \}}
\DoxyCodeLine{16366         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (use\_bjdata \&\& (\textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::uint16\_t>::min)()) <= n \&\& n <= \textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::uint16\_t>::max)())))}
\DoxyCodeLine{16367         \{}
\DoxyCodeLine{16368             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16369             \{}
\DoxyCodeLine{16370                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'u'}));  \textcolor{comment}{// uint16 -\/ bjdata only}}
\DoxyCodeLine{16371             \}}
\DoxyCodeLine{16372             write\_number(\textcolor{keyword}{static\_cast<}uint16\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16373         \}}
\DoxyCodeLine{16374         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((std::numeric\_limits<std::int32\_t>::min)() <= n \&\& n <= (std::numeric\_limits<std::int32\_t>::max)())}
\DoxyCodeLine{16375         \{}
\DoxyCodeLine{16376             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16377             \{}
\DoxyCodeLine{16378                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'l'}));  \textcolor{comment}{// int32}}
\DoxyCodeLine{16379             \}}
\DoxyCodeLine{16380             write\_number(\textcolor{keyword}{static\_cast<}std::int32\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16381         \}}
\DoxyCodeLine{16382         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (use\_bjdata \&\& (\textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::uint32\_t>::min)()) <= n \&\& n <= \textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::uint32\_t>::max)())))}
\DoxyCodeLine{16383         \{}
\DoxyCodeLine{16384             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16385             \{}
\DoxyCodeLine{16386                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'m'}));  \textcolor{comment}{// uint32 -\/ bjdata only}}
\DoxyCodeLine{16387             \}}
\DoxyCodeLine{16388             write\_number(\textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16389         \}}
\DoxyCodeLine{16390         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((std::numeric\_limits<std::int64\_t>::min)() <= n \&\& n <= (std::numeric\_limits<std::int64\_t>::max)())}
\DoxyCodeLine{16391         \{}
\DoxyCodeLine{16392             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16393             \{}
\DoxyCodeLine{16394                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'L'}));  \textcolor{comment}{// int64}}
\DoxyCodeLine{16395             \}}
\DoxyCodeLine{16396             write\_number(\textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}(n), use\_bjdata);}
\DoxyCodeLine{16397         \}}
\DoxyCodeLine{16398         \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{16399         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16400         \{}
\DoxyCodeLine{16401             \textcolor{keywordflow}{if} (add\_prefix)}
\DoxyCodeLine{16402             \{}
\DoxyCodeLine{16403                 oa-\/>write\_character(to\_char\_type(\textcolor{charliteral}{'H'}));  \textcolor{comment}{// high-\/precision number}}
\DoxyCodeLine{16404             \}}
\DoxyCodeLine{16405 }
\DoxyCodeLine{16406             \textcolor{keyword}{const} \textcolor{keyword}{auto} number = BasicJsonType(n).dump();}
\DoxyCodeLine{16407             write\_number\_with\_ubjson\_prefix(number.size(), \textcolor{keyword}{true}, use\_bjdata);}
\DoxyCodeLine{16408             \textcolor{keywordflow}{for} (std::size\_t i = 0; i < number.size(); ++i)}
\DoxyCodeLine{16409             \{}
\DoxyCodeLine{16410                 oa-\/>write\_character(to\_char\_type(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(number[i])));}
\DoxyCodeLine{16411             \}}
\DoxyCodeLine{16412         \}}
\DoxyCodeLine{16413         \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{16414     \}}
\DoxyCodeLine{16415 }
\DoxyCodeLine{16419     CharType ubjson\_prefix(\textcolor{keyword}{const} BasicJsonType\& j, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_bjdata) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{16420     \{}
\DoxyCodeLine{16421         \textcolor{keywordflow}{switch} (j.type())}
\DoxyCodeLine{16422         \{}
\DoxyCodeLine{16423             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{16424                 \textcolor{keywordflow}{return} \textcolor{charliteral}{'Z'};}
\DoxyCodeLine{16425 }
\DoxyCodeLine{16426             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{16427                 \textcolor{keywordflow}{return} j.m\_value.boolean ? \textcolor{charliteral}{'T'} : \textcolor{charliteral}{'F'};}
\DoxyCodeLine{16428 }
\DoxyCodeLine{16429             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{16430             \{}
\DoxyCodeLine{16431                 \textcolor{keywordflow}{if} ((std::numeric\_limits<std::int8\_t>::min)() <= j.m\_value.number\_integer \&\& j.m\_value.number\_integer <= (std::numeric\_limits<std::int8\_t>::max)())}
\DoxyCodeLine{16432                 \{}
\DoxyCodeLine{16433                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'i'};}
\DoxyCodeLine{16434                 \}}
\DoxyCodeLine{16435                 \textcolor{keywordflow}{if} ((std::numeric\_limits<std::uint8\_t>::min)() <= j.m\_value.number\_integer \&\& j.m\_value.number\_integer <= (std::numeric\_limits<std::uint8\_t>::max)())}
\DoxyCodeLine{16436                 \{}
\DoxyCodeLine{16437                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'U'};}
\DoxyCodeLine{16438                 \}}
\DoxyCodeLine{16439                 \textcolor{keywordflow}{if} ((std::numeric\_limits<std::int16\_t>::min)() <= j.m\_value.number\_integer \&\& j.m\_value.number\_integer <= (std::numeric\_limits<std::int16\_t>::max)())}
\DoxyCodeLine{16440                 \{}
\DoxyCodeLine{16441                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'I'};}
\DoxyCodeLine{16442                 \}}
\DoxyCodeLine{16443                 \textcolor{keywordflow}{if} (use\_bjdata \&\& ((std::numeric\_limits<std::uint16\_t>::min)() <= j.m\_value.number\_integer \&\& j.m\_value.number\_integer <= (std::numeric\_limits<std::uint16\_t>::max)()))}
\DoxyCodeLine{16444                 \{}
\DoxyCodeLine{16445                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'u'};}
\DoxyCodeLine{16446                 \}}
\DoxyCodeLine{16447                 \textcolor{keywordflow}{if} ((std::numeric\_limits<std::int32\_t>::min)() <= j.m\_value.number\_integer \&\& j.m\_value.number\_integer <= (std::numeric\_limits<std::int32\_t>::max)())}
\DoxyCodeLine{16448                 \{}
\DoxyCodeLine{16449                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'l'};}
\DoxyCodeLine{16450                 \}}
\DoxyCodeLine{16451                 \textcolor{keywordflow}{if} (use\_bjdata \&\& ((std::numeric\_limits<std::uint32\_t>::min)() <= j.m\_value.number\_integer \&\& j.m\_value.number\_integer <= (std::numeric\_limits<std::uint32\_t>::max)()))}
\DoxyCodeLine{16452                 \{}
\DoxyCodeLine{16453                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'m'};}
\DoxyCodeLine{16454                 \}}
\DoxyCodeLine{16455                 \textcolor{keywordflow}{if} ((std::numeric\_limits<std::int64\_t>::min)() <= j.m\_value.number\_integer \&\& j.m\_value.number\_integer <= (std::numeric\_limits<std::int64\_t>::max)())}
\DoxyCodeLine{16456                 \{}
\DoxyCodeLine{16457                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'L'};}
\DoxyCodeLine{16458                 \}}
\DoxyCodeLine{16459                 \textcolor{comment}{// anything else is treated as high-\/precision number}}
\DoxyCodeLine{16460                 \textcolor{keywordflow}{return} \textcolor{charliteral}{'H'}; \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{16461             \}}
\DoxyCodeLine{16462 }
\DoxyCodeLine{16463             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{16464             \{}
\DoxyCodeLine{16465                 \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int8\_t>::max)()))}
\DoxyCodeLine{16466                 \{}
\DoxyCodeLine{16467                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'i'};}
\DoxyCodeLine{16468                 \}}
\DoxyCodeLine{16469                 \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::uint8\_t>::max)()))}
\DoxyCodeLine{16470                 \{}
\DoxyCodeLine{16471                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'U'};}
\DoxyCodeLine{16472                 \}}
\DoxyCodeLine{16473                 \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int16\_t>::max)()))}
\DoxyCodeLine{16474                 \{}
\DoxyCodeLine{16475                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'I'};}
\DoxyCodeLine{16476                 \}}
\DoxyCodeLine{16477                 \textcolor{keywordflow}{if} (use\_bjdata \&\& j.m\_value.number\_unsigned <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::uint16\_t>::max)()))}
\DoxyCodeLine{16478                 \{}
\DoxyCodeLine{16479                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'u'};}
\DoxyCodeLine{16480                 \}}
\DoxyCodeLine{16481                 \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int32\_t>::max)()))}
\DoxyCodeLine{16482                 \{}
\DoxyCodeLine{16483                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'l'};}
\DoxyCodeLine{16484                 \}}
\DoxyCodeLine{16485                 \textcolor{keywordflow}{if} (use\_bjdata \&\& j.m\_value.number\_unsigned <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::uint32\_t>::max)()))}
\DoxyCodeLine{16486                 \{}
\DoxyCodeLine{16487                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'m'};}
\DoxyCodeLine{16488                 \}}
\DoxyCodeLine{16489                 \textcolor{keywordflow}{if} (j.m\_value.number\_unsigned <= \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}((std::numeric\_limits<std::int64\_t>::max)()))}
\DoxyCodeLine{16490                 \{}
\DoxyCodeLine{16491                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'L'};}
\DoxyCodeLine{16492                 \}}
\DoxyCodeLine{16493                 \textcolor{keywordflow}{if} (use\_bjdata \&\& j.m\_value.number\_unsigned <= (std::numeric\_limits<std::uint64\_t>::max)())}
\DoxyCodeLine{16494                 \{}
\DoxyCodeLine{16495                     \textcolor{keywordflow}{return} \textcolor{charliteral}{'M'};}
\DoxyCodeLine{16496                 \}}
\DoxyCodeLine{16497                 \textcolor{comment}{// anything else is treated as high-\/precision number}}
\DoxyCodeLine{16498                 \textcolor{keywordflow}{return} \textcolor{charliteral}{'H'}; \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{16499             \}}
\DoxyCodeLine{16500 }
\DoxyCodeLine{16501             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{16502                 \textcolor{keywordflow}{return} get\_ubjson\_float\_prefix(j.m\_value.number\_float);}
\DoxyCodeLine{16503 }
\DoxyCodeLine{16504             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{16505                 \textcolor{keywordflow}{return} \textcolor{charliteral}{'S'};}
\DoxyCodeLine{16506 }
\DoxyCodeLine{16507             \textcolor{keywordflow}{case} value\_t::array: \textcolor{comment}{// fallthrough}}
\DoxyCodeLine{16508             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{16509                 \textcolor{keywordflow}{return} \textcolor{charliteral}{'['};}
\DoxyCodeLine{16510 }
\DoxyCodeLine{16511             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{16512                 \textcolor{keywordflow}{return} \textcolor{charliteral}{'\{'};}
\DoxyCodeLine{16513 }
\DoxyCodeLine{16514             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{16515             \textcolor{keywordflow}{default}:  \textcolor{comment}{// discarded values}}
\DoxyCodeLine{16516                 \textcolor{keywordflow}{return} \textcolor{charliteral}{'N'};}
\DoxyCodeLine{16517         \}}
\DoxyCodeLine{16518     \}}
\DoxyCodeLine{16519 }
\DoxyCodeLine{16520     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} CharType get\_ubjson\_float\_prefix(\textcolor{keywordtype}{float} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{16521     \{}
\DoxyCodeLine{16522         \textcolor{keywordflow}{return} \textcolor{charliteral}{'d'};  \textcolor{comment}{// float 32}}
\DoxyCodeLine{16523     \}}
\DoxyCodeLine{16524 }
\DoxyCodeLine{16525     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} CharType get\_ubjson\_float\_prefix(\textcolor{keywordtype}{double} \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{16526     \{}
\DoxyCodeLine{16527         \textcolor{keywordflow}{return} \textcolor{charliteral}{'D'};  \textcolor{comment}{// float 64}}
\DoxyCodeLine{16528     \}}
\DoxyCodeLine{16529 }
\DoxyCodeLine{16533     \textcolor{keywordtype}{bool} write\_bjdata\_ndarray(\textcolor{keyword}{const} \textcolor{keyword}{typename} BasicJsonType::object\_t\& value, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_count, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_type)}
\DoxyCodeLine{16534     \{}
\DoxyCodeLine{16535         std::map<string\_t, CharType> bjdtype = \{\{\textcolor{stringliteral}{"{}uint8"{}}, \textcolor{charliteral}{'U'}\},  \{\textcolor{stringliteral}{"{}int8"{}}, \textcolor{charliteral}{'i'}\},  \{\textcolor{stringliteral}{"{}uint16"{}}, \textcolor{charliteral}{'u'}\}, \{\textcolor{stringliteral}{"{}int16"{}}, \textcolor{charliteral}{'I'}\},}
\DoxyCodeLine{16536             \{\textcolor{stringliteral}{"{}uint32"{}}, \textcolor{charliteral}{'m'}\}, \{\textcolor{stringliteral}{"{}int32"{}}, \textcolor{charliteral}{'l'}\}, \{\textcolor{stringliteral}{"{}uint64"{}}, \textcolor{charliteral}{'M'}\}, \{\textcolor{stringliteral}{"{}int64"{}}, \textcolor{charliteral}{'L'}\}, \{\textcolor{stringliteral}{"{}single"{}}, \textcolor{charliteral}{'d'}\}, \{\textcolor{stringliteral}{"{}double"{}}, \textcolor{charliteral}{'D'}\}, \{\textcolor{stringliteral}{"{}char"{}}, \textcolor{charliteral}{'C'}\}}
\DoxyCodeLine{16537         \};}
\DoxyCodeLine{16538 }
\DoxyCodeLine{16539         string\_t \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}} = \textcolor{stringliteral}{"{}\_ArrayType\_"{}};}
\DoxyCodeLine{16540         \textcolor{keyword}{auto} it = bjdtype.find(\textcolor{keyword}{static\_cast<}string\_t\textcolor{keyword}{>}(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})));}
\DoxyCodeLine{16541         \textcolor{keywordflow}{if} (it == bjdtype.end())}
\DoxyCodeLine{16542         \{}
\DoxyCodeLine{16543             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{16544         \}}
\DoxyCodeLine{16545         CharType dtype = it-\/>second;}
\DoxyCodeLine{16546 }
\DoxyCodeLine{16547         \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}} = \textcolor{stringliteral}{"{}\_ArraySize\_"{}};}
\DoxyCodeLine{16548         std::size\_t len = (\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}).empty() ? 0 : 1);}
\DoxyCodeLine{16549         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16550         \{}
\DoxyCodeLine{16551             len *= \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(el.m\_value.number\_unsigned);}
\DoxyCodeLine{16552         \}}
\DoxyCodeLine{16553 }
\DoxyCodeLine{16554         \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}} = \textcolor{stringliteral}{"{}\_ArrayData\_"{}};}
\DoxyCodeLine{16555         \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}).size() != len)}
\DoxyCodeLine{16556         \{}
\DoxyCodeLine{16557             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{16558         \}}
\DoxyCodeLine{16559 }
\DoxyCodeLine{16560         oa-\/>write\_character(\textcolor{charliteral}{'['});}
\DoxyCodeLine{16561         oa-\/>write\_character(\textcolor{charliteral}{'\$'});}
\DoxyCodeLine{16562         oa-\/>write\_character(dtype);}
\DoxyCodeLine{16563         oa-\/>write\_character(\textcolor{charliteral}{'\#'});}
\DoxyCodeLine{16564 }
\DoxyCodeLine{16565         \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}} = \textcolor{stringliteral}{"{}\_ArraySize\_"{}};}
\DoxyCodeLine{16566         write\_ubjson(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}), use\_count, use\_type, \textcolor{keyword}{true},  \textcolor{keyword}{true});}
\DoxyCodeLine{16567 }
\DoxyCodeLine{16568         \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}} = \textcolor{stringliteral}{"{}\_ArrayData\_"{}};}
\DoxyCodeLine{16569         \textcolor{keywordflow}{if} (dtype == \textcolor{charliteral}{'U'} || dtype == \textcolor{charliteral}{'C'})}
\DoxyCodeLine{16570         \{}
\DoxyCodeLine{16571             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16572             \{}
\DoxyCodeLine{16573                 write\_number(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(el.m\_value.number\_unsigned), \textcolor{keyword}{true});}
\DoxyCodeLine{16574             \}}
\DoxyCodeLine{16575         \}}
\DoxyCodeLine{16576         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dtype == \textcolor{charliteral}{'i'})}
\DoxyCodeLine{16577         \{}
\DoxyCodeLine{16578             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16579             \{}
\DoxyCodeLine{16580                 write\_number(\textcolor{keyword}{static\_cast<}std::int8\_t\textcolor{keyword}{>}(el.m\_value.number\_integer), \textcolor{keyword}{true});}
\DoxyCodeLine{16581             \}}
\DoxyCodeLine{16582         \}}
\DoxyCodeLine{16583         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dtype == \textcolor{charliteral}{'u'})}
\DoxyCodeLine{16584         \{}
\DoxyCodeLine{16585             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16586             \{}
\DoxyCodeLine{16587                 write\_number(\textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(el.m\_value.number\_unsigned), \textcolor{keyword}{true});}
\DoxyCodeLine{16588             \}}
\DoxyCodeLine{16589         \}}
\DoxyCodeLine{16590         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dtype == \textcolor{charliteral}{'I'})}
\DoxyCodeLine{16591         \{}
\DoxyCodeLine{16592             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16593             \{}
\DoxyCodeLine{16594                 write\_number(\textcolor{keyword}{static\_cast<}std::int16\_t\textcolor{keyword}{>}(el.m\_value.number\_integer), \textcolor{keyword}{true});}
\DoxyCodeLine{16595             \}}
\DoxyCodeLine{16596         \}}
\DoxyCodeLine{16597         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dtype == \textcolor{charliteral}{'m'})}
\DoxyCodeLine{16598         \{}
\DoxyCodeLine{16599             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16600             \{}
\DoxyCodeLine{16601                 write\_number(\textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(el.m\_value.number\_unsigned), \textcolor{keyword}{true});}
\DoxyCodeLine{16602             \}}
\DoxyCodeLine{16603         \}}
\DoxyCodeLine{16604         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dtype == \textcolor{charliteral}{'l'})}
\DoxyCodeLine{16605         \{}
\DoxyCodeLine{16606             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16607             \{}
\DoxyCodeLine{16608                 write\_number(\textcolor{keyword}{static\_cast<}std::int32\_t\textcolor{keyword}{>}(el.m\_value.number\_integer), \textcolor{keyword}{true});}
\DoxyCodeLine{16609             \}}
\DoxyCodeLine{16610         \}}
\DoxyCodeLine{16611         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dtype == \textcolor{charliteral}{'M'})}
\DoxyCodeLine{16612         \{}
\DoxyCodeLine{16613             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16614             \{}
\DoxyCodeLine{16615                 write\_number(\textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(el.m\_value.number\_unsigned), \textcolor{keyword}{true});}
\DoxyCodeLine{16616             \}}
\DoxyCodeLine{16617         \}}
\DoxyCodeLine{16618         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dtype == \textcolor{charliteral}{'L'})}
\DoxyCodeLine{16619         \{}
\DoxyCodeLine{16620             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16621             \{}
\DoxyCodeLine{16622                 write\_number(\textcolor{keyword}{static\_cast<}std::int64\_t\textcolor{keyword}{>}(el.m\_value.number\_integer), \textcolor{keyword}{true});}
\DoxyCodeLine{16623             \}}
\DoxyCodeLine{16624         \}}
\DoxyCodeLine{16625         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dtype == \textcolor{charliteral}{'d'})}
\DoxyCodeLine{16626         \{}
\DoxyCodeLine{16627             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16628             \{}
\DoxyCodeLine{16629                 write\_number(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(el.m\_value.number\_float), \textcolor{keyword}{true});}
\DoxyCodeLine{16630             \}}
\DoxyCodeLine{16631         \}}
\DoxyCodeLine{16632         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dtype == \textcolor{charliteral}{'D'})}
\DoxyCodeLine{16633         \{}
\DoxyCodeLine{16634             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}.at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{16635             \{}
\DoxyCodeLine{16636                 write\_number(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(el.m\_value.number\_float), \textcolor{keyword}{true});}
\DoxyCodeLine{16637             \}}
\DoxyCodeLine{16638         \}}
\DoxyCodeLine{16639         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{16640     \}}
\DoxyCodeLine{16641 }
\DoxyCodeLine{16643     \textcolor{comment}{// Utility functions //}}
\DoxyCodeLine{16645 \textcolor{comment}{}}
\DoxyCodeLine{16646     \textcolor{comment}{/*}}
\DoxyCodeLine{16647 \textcolor{comment}{    @brief write a number to output input}}
\DoxyCodeLine{16648 \textcolor{comment}{    @param[in] n number of type @a NumberType}}
\DoxyCodeLine{16649 \textcolor{comment}{    @param[in] OutputIsLittleEndian Set to true if output data is}}
\DoxyCodeLine{16650 \textcolor{comment}{                                 required to be little endian}}
\DoxyCodeLine{16651 \textcolor{comment}{    @tparam NumberType the type of the number}}
\DoxyCodeLine{16652 \textcolor{comment}{}}
\DoxyCodeLine{16653 \textcolor{comment}{    @note This function needs to respect the system's endianness, because bytes}}
\DoxyCodeLine{16654 \textcolor{comment}{          in CBOR, MessagePack, and UBJSON are stored in network order (big}}
\DoxyCodeLine{16655 \textcolor{comment}{          endian) and therefore need reordering on little endian systems.}}
\DoxyCodeLine{16656 \textcolor{comment}{          On the other hand, BSON and BJData use little endian and should reorder}}
\DoxyCodeLine{16657 \textcolor{comment}{          on big endian systems.}}
\DoxyCodeLine{16658 \textcolor{comment}{    */}}
\DoxyCodeLine{16659     \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumberType>}
\DoxyCodeLine{16660     \textcolor{keywordtype}{void} write\_number(\textcolor{keyword}{const} NumberType n, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} OutputIsLittleEndian = \textcolor{keyword}{false})}
\DoxyCodeLine{16661     \{}
\DoxyCodeLine{16662         \textcolor{comment}{// step 1: write number to array of length NumberType}}
\DoxyCodeLine{16663         std::array<CharType, \textcolor{keyword}{sizeof}(NumberType)> vec\{\};}
\DoxyCodeLine{16664         std::memcpy(vec.data(), \&n, \textcolor{keyword}{sizeof}(NumberType));}
\DoxyCodeLine{16665 }
\DoxyCodeLine{16666         \textcolor{comment}{// step 2: write array to output (with possible reordering)}}
\DoxyCodeLine{16667         \textcolor{keywordflow}{if} (is\_little\_endian != OutputIsLittleEndian)}
\DoxyCodeLine{16668         \{}
\DoxyCodeLine{16669             \textcolor{comment}{// reverse byte order prior to conversion if necessary}}
\DoxyCodeLine{16670             std::reverse(vec.begin(), vec.end());}
\DoxyCodeLine{16671         \}}
\DoxyCodeLine{16672 }
\DoxyCodeLine{16673         oa-\/>write\_characters(vec.data(), \textcolor{keyword}{sizeof}(NumberType));}
\DoxyCodeLine{16674     \}}
\DoxyCodeLine{16675 }
\DoxyCodeLine{16676     \textcolor{keywordtype}{void} write\_compact\_float(\textcolor{keyword}{const} number\_float\_t n, \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{detail::input\_format\_t}} format)}
\DoxyCodeLine{16677     \{}
\DoxyCodeLine{16678 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{16679 \textcolor{preprocessor}{\#pragma GCC diagnostic push}}
\DoxyCodeLine{16680 \textcolor{preprocessor}{\#pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}}}
\DoxyCodeLine{16681 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16682         \textcolor{keywordflow}{if} (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(n) >= \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(std::numeric\_limits<float>::lowest()) \&\&}
\DoxyCodeLine{16683                 \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(n) <= \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}((std::numeric\_limits<float>::max)()) \&\&}
\DoxyCodeLine{16684                 \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(n)) == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(n))}
\DoxyCodeLine{16685         \{}
\DoxyCodeLine{16686             oa-\/>write\_character(format == detail::input\_format\_t::cbor}
\DoxyCodeLine{16687                                 ? get\_cbor\_float\_prefix(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(n))}
\DoxyCodeLine{16688                                 : get\_msgpack\_float\_prefix(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(n)));}
\DoxyCodeLine{16689             write\_number(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(n));}
\DoxyCodeLine{16690         \}}
\DoxyCodeLine{16691         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16692         \{}
\DoxyCodeLine{16693             oa-\/>write\_character(format == detail::input\_format\_t::cbor}
\DoxyCodeLine{16694                                 ? get\_cbor\_float\_prefix(n)}
\DoxyCodeLine{16695                                 : get\_msgpack\_float\_prefix(n));}
\DoxyCodeLine{16696             write\_number(n);}
\DoxyCodeLine{16697         \}}
\DoxyCodeLine{16698 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{16699 \textcolor{preprocessor}{\#pragma GCC diagnostic pop}}
\DoxyCodeLine{16700 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16701     \}}
\DoxyCodeLine{16702 }
\DoxyCodeLine{16703   \textcolor{keyword}{public}:}
\DoxyCodeLine{16704     \textcolor{comment}{// The following to\_char\_type functions are implement the conversion}}
\DoxyCodeLine{16705     \textcolor{comment}{// between uint8\_t and CharType. In case CharType is not unsigned,}}
\DoxyCodeLine{16706     \textcolor{comment}{// such a conversion is required to allow values greater than 128.}}
\DoxyCodeLine{16707     \textcolor{comment}{// See <https://github.com/nlohmann/json/issues/1286> for a discussion.}}
\DoxyCodeLine{16708     \textcolor{keyword}{template} < \textcolor{keyword}{typename} C = CharType,}
\DoxyCodeLine{16709                enable\_if\_t < std::is\_signed<C>::value \&\& std::is\_signed<char>::value > * = \textcolor{keyword}{nullptr} >}
\DoxyCodeLine{16710     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} CharType to\_char\_type(std::uint8\_t x) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{16711     \{}
\DoxyCodeLine{16712         \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&x);}
\DoxyCodeLine{16713     \}}
\DoxyCodeLine{16714 }
\DoxyCodeLine{16715     \textcolor{keyword}{template} < \textcolor{keyword}{typename} C = CharType,}
\DoxyCodeLine{16716                enable\_if\_t < std::is\_signed<C>::value \&\& std::is\_unsigned<char>::value > * = \textcolor{keyword}{nullptr} >}
\DoxyCodeLine{16717     \textcolor{keyword}{static} CharType to\_char\_type(std::uint8\_t x) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{16718     \{}
\DoxyCodeLine{16719         \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(std::uint8\_t) == \textcolor{keyword}{sizeof}(CharType), \textcolor{stringliteral}{"{}size of CharType must be equal to std::uint8\_t"{}});}
\DoxyCodeLine{16720         \textcolor{keyword}{static\_assert}(std::is\_trivial<CharType>::value, \textcolor{stringliteral}{"{}CharType must be trivial"{}});}
\DoxyCodeLine{16721         CharType result;}
\DoxyCodeLine{16722         std::memcpy(\&result, \&x, \textcolor{keyword}{sizeof}(x));}
\DoxyCodeLine{16723         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{16724     \}}
\DoxyCodeLine{16725 }
\DoxyCodeLine{16726     \textcolor{keyword}{template}<\textcolor{keyword}{typename} C = CharType,}
\DoxyCodeLine{16727              enable\_if\_t<std::is\_unsigned<C>::value>* = \textcolor{keyword}{nullptr}>}
\DoxyCodeLine{16728     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} CharType to\_char\_type(std::uint8\_t x) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{16729     \{}
\DoxyCodeLine{16730         \textcolor{keywordflow}{return} x;}
\DoxyCodeLine{16731     \}}
\DoxyCodeLine{16732 }
\DoxyCodeLine{16733     \textcolor{keyword}{template} < \textcolor{keyword}{typename} InputCharType, \textcolor{keyword}{typename} C = CharType,}
\DoxyCodeLine{16734                enable\_if\_t <}
\DoxyCodeLine{16735                    std::is\_signed<C>::value \&\&}
\DoxyCodeLine{16736                    std::is\_signed<char>::value \&\&}
\DoxyCodeLine{16737                    std::is\_same<char, typename std::remove\_cv<InputCharType>::type>::value}
\DoxyCodeLine{16738                    > * = \textcolor{keyword}{nullptr} >}
\DoxyCodeLine{16739     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} CharType to\_char\_type(InputCharType x) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{16740     \{}
\DoxyCodeLine{16741         \textcolor{keywordflow}{return} x;}
\DoxyCodeLine{16742     \}}
\DoxyCodeLine{16743 }
\DoxyCodeLine{16744   \textcolor{keyword}{private}:}
\DoxyCodeLine{16746     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_little\_endian = little\_endianness();}
\DoxyCodeLine{16747 }
\DoxyCodeLine{16749     output\_adapter\_t<CharType> oa = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{16750 \};}
\DoxyCodeLine{16751 }
\DoxyCodeLine{16752 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{16753 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{16754 }
\DoxyCodeLine{16755 \textcolor{comment}{// \#include <nlohmann/detail/output/output\_adapters.hpp>}}
\DoxyCodeLine{16756 }
\DoxyCodeLine{16757 \textcolor{comment}{// \#include <nlohmann/detail/output/serializer.hpp>}}
\DoxyCodeLine{16758 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{16759 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{16760 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{16761 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{16762 \textcolor{comment}{//}}
\DoxyCodeLine{16763 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2008-\/2009 Bjrn Hoehrmann <bjoern@hoehrmann.de>}}
\DoxyCodeLine{16764 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{16765 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{16766 }
\DoxyCodeLine{16767 }
\DoxyCodeLine{16768 }
\DoxyCodeLine{16769 \textcolor{preprocessor}{\#include <algorithm>} \textcolor{comment}{// reverse, remove, fill, find, none\_of}}
\DoxyCodeLine{16770 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{16771 \textcolor{preprocessor}{\#include <clocale>} \textcolor{comment}{// localeconv, lconv}}
\DoxyCodeLine{16772 \textcolor{preprocessor}{\#include <cmath>} \textcolor{comment}{// labs, isfinite, isnan, signbit}}
\DoxyCodeLine{16773 \textcolor{preprocessor}{\#include <cstddef>} \textcolor{comment}{// size\_t, ptrdiff\_t}}
\DoxyCodeLine{16774 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// uint8\_t}}
\DoxyCodeLine{16775 \textcolor{preprocessor}{\#include <cstdio>} \textcolor{comment}{// snprintf}}
\DoxyCodeLine{16776 \textcolor{preprocessor}{\#include <limits>} \textcolor{comment}{// numeric\_limits}}
\DoxyCodeLine{16777 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// string, char\_traits}}
\DoxyCodeLine{16778 \textcolor{preprocessor}{\#include <iomanip>} \textcolor{comment}{// setfill, setw}}
\DoxyCodeLine{16779 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// is\_same}}
\DoxyCodeLine{16780 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// move}}
\DoxyCodeLine{16781 }
\DoxyCodeLine{16782 \textcolor{comment}{// \#include <nlohmann/detail/conversions/to\_chars.hpp>}}
\DoxyCodeLine{16783 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{16784 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{16785 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{16786 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{16787 \textcolor{comment}{//}}
\DoxyCodeLine{16788 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2009 Florian Loitsch <https://florian.loitsch.com/>}}
\DoxyCodeLine{16789 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{16790 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{16791 }
\DoxyCodeLine{16792 }
\DoxyCodeLine{16793 }
\DoxyCodeLine{16794 \textcolor{preprocessor}{\#include <array>} \textcolor{comment}{// array}}
\DoxyCodeLine{16795 \textcolor{preprocessor}{\#include <cmath>}   \textcolor{comment}{// signbit, isfinite}}
\DoxyCodeLine{16796 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// intN\_t, uintN\_t}}
\DoxyCodeLine{16797 \textcolor{preprocessor}{\#include <cstring>} \textcolor{comment}{// memcpy, memmove}}
\DoxyCodeLine{16798 \textcolor{preprocessor}{\#include <limits>} \textcolor{comment}{// numeric\_limits}}
\DoxyCodeLine{16799 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// conditional}}
\DoxyCodeLine{16800 }
\DoxyCodeLine{16801 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{16802 }
\DoxyCodeLine{16803 }
\DoxyCodeLine{16804 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{16805 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{16806 \{}
\DoxyCodeLine{16807 }
\DoxyCodeLine{16827 \textcolor{keyword}{namespace }dtoa\_impl}
\DoxyCodeLine{16828 \{}
\DoxyCodeLine{16829 }
\DoxyCodeLine{16830 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Target, \textcolor{keyword}{typename} Source>}
\DoxyCodeLine{16831 Target reinterpret\_bits(\textcolor{keyword}{const} Source source)}
\DoxyCodeLine{16832 \{}
\DoxyCodeLine{16833     \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(Target) == \textcolor{keyword}{sizeof}(Source), \textcolor{stringliteral}{"{}size mismatch"{}});}
\DoxyCodeLine{16834 }
\DoxyCodeLine{16835     Target target;}
\DoxyCodeLine{16836     std::memcpy(\&target, \&source, \textcolor{keyword}{sizeof}(Source));}
\DoxyCodeLine{16837     \textcolor{keywordflow}{return} target;}
\DoxyCodeLine{16838 \}}
\DoxyCodeLine{16839 }
\DoxyCodeLine{16840 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} \textcolor{comment}{// f * 2\string^e}}
\DoxyCodeLine{16841 \{}
\DoxyCodeLine{16842     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kPrecision = 64; \textcolor{comment}{// = q}}
\DoxyCodeLine{16843 }
\DoxyCodeLine{16844     std::uint64\_t f = 0;}
\DoxyCodeLine{16845     \textcolor{keywordtype}{int} e = 0;}
\DoxyCodeLine{16846 }
\DoxyCodeLine{16847     \textcolor{keyword}{constexpr} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(std::uint64\_t f\_, \textcolor{keywordtype}{int} e\_) noexcept : f(f\_), e(e\_) \{\}}
\DoxyCodeLine{16848 }
\DoxyCodeLine{16853     \textcolor{keyword}{static} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a75142bace0b78b1e1433b1d35a7ff252}{sub}}(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}\& x, \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}\& y) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{16854     \{}
\DoxyCodeLine{16855         JSON\_ASSERT(x.e == y.e);}
\DoxyCodeLine{16856         JSON\_ASSERT(x.f >= y.f);}
\DoxyCodeLine{16857 }
\DoxyCodeLine{16858         \textcolor{keywordflow}{return} \{x.f -\/ y.f, x.e\};}
\DoxyCodeLine{16859     \}}
\DoxyCodeLine{16860 }
\DoxyCodeLine{16865     \textcolor{keyword}{static} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a046c61f2c13411677eedfb5b9b7a8226}{mul}}(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}\& x, \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}\& y) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{16866     \{}
\DoxyCodeLine{16867         \textcolor{keyword}{static\_assert}(kPrecision == 64, \textcolor{stringliteral}{"{}internal error"{}});}
\DoxyCodeLine{16868 }
\DoxyCodeLine{16869         \textcolor{comment}{// Computes:}}
\DoxyCodeLine{16870         \textcolor{comment}{//  f = round((x.f * y.f) / 2\string^q)}}
\DoxyCodeLine{16871         \textcolor{comment}{//  e = x.e + y.e + q}}
\DoxyCodeLine{16872 }
\DoxyCodeLine{16873         \textcolor{comment}{// Emulate the 64-\/bit * 64-\/bit multiplication:}}
\DoxyCodeLine{16874         \textcolor{comment}{//}}
\DoxyCodeLine{16875         \textcolor{comment}{// p = u * v}}
\DoxyCodeLine{16876         \textcolor{comment}{//   = (u\_lo + 2\string^32 u\_hi) (v\_lo + 2\string^32 v\_hi)}}
\DoxyCodeLine{16877         \textcolor{comment}{//   = (u\_lo v\_lo         ) + 2\string^32 ((u\_lo v\_hi         ) + (u\_hi v\_lo         )) + 2\string^64 (u\_hi v\_hi         )}}
\DoxyCodeLine{16878         \textcolor{comment}{//   = (p0                ) + 2\string^32 ((p1                ) + (p2                )) + 2\string^64 (p3                )}}
\DoxyCodeLine{16879         \textcolor{comment}{//   = (p0\_lo + 2\string^32 p0\_hi) + 2\string^32 ((p1\_lo + 2\string^32 p1\_hi) + (p2\_lo + 2\string^32 p2\_hi)) + 2\string^64 (p3                )}}
\DoxyCodeLine{16880         \textcolor{comment}{//   = (p0\_lo             ) + 2\string^32 (p0\_hi + p1\_lo + p2\_lo                      ) + 2\string^64 (p1\_hi + p2\_hi + p3)}}
\DoxyCodeLine{16881         \textcolor{comment}{//   = (p0\_lo             ) + 2\string^32 (Q                                          ) + 2\string^64 (H                 )}}
\DoxyCodeLine{16882         \textcolor{comment}{//   = (p0\_lo             ) + 2\string^32 (Q\_lo + 2\string^32 Q\_hi                           ) + 2\string^64 (H                 )}}
\DoxyCodeLine{16883         \textcolor{comment}{//}}
\DoxyCodeLine{16884         \textcolor{comment}{// (Since Q might be larger than 2\string^32 -\/ 1)}}
\DoxyCodeLine{16885         \textcolor{comment}{//}}
\DoxyCodeLine{16886         \textcolor{comment}{//   = (p0\_lo + 2\string^32 Q\_lo) + 2\string^64 (Q\_hi + H)}}
\DoxyCodeLine{16887         \textcolor{comment}{//}}
\DoxyCodeLine{16888         \textcolor{comment}{// (Q\_hi + H does not overflow a 64-\/bit int)}}
\DoxyCodeLine{16889         \textcolor{comment}{//}}
\DoxyCodeLine{16890         \textcolor{comment}{//   = p\_lo + 2\string^64 p\_hi}}
\DoxyCodeLine{16891 }
\DoxyCodeLine{16892         \textcolor{keyword}{const} std::uint64\_t u\_lo = x.f \& 0xFFFFFFFFu;}
\DoxyCodeLine{16893         \textcolor{keyword}{const} std::uint64\_t u\_hi = x.f >> 32u;}
\DoxyCodeLine{16894         \textcolor{keyword}{const} std::uint64\_t v\_lo = y.f \& 0xFFFFFFFFu;}
\DoxyCodeLine{16895         \textcolor{keyword}{const} std::uint64\_t v\_hi = y.f >> 32u;}
\DoxyCodeLine{16896 }
\DoxyCodeLine{16897         \textcolor{keyword}{const} std::uint64\_t p0 = u\_lo * v\_lo;}
\DoxyCodeLine{16898         \textcolor{keyword}{const} std::uint64\_t p1 = u\_lo * v\_hi;}
\DoxyCodeLine{16899         \textcolor{keyword}{const} std::uint64\_t p2 = u\_hi * v\_lo;}
\DoxyCodeLine{16900         \textcolor{keyword}{const} std::uint64\_t p3 = u\_hi * v\_hi;}
\DoxyCodeLine{16901 }
\DoxyCodeLine{16902         \textcolor{keyword}{const} std::uint64\_t p0\_hi = p0 >> 32u;}
\DoxyCodeLine{16903         \textcolor{keyword}{const} std::uint64\_t p1\_lo = p1 \& 0xFFFFFFFFu;}
\DoxyCodeLine{16904         \textcolor{keyword}{const} std::uint64\_t p1\_hi = p1 >> 32u;}
\DoxyCodeLine{16905         \textcolor{keyword}{const} std::uint64\_t p2\_lo = p2 \& 0xFFFFFFFFu;}
\DoxyCodeLine{16906         \textcolor{keyword}{const} std::uint64\_t p2\_hi = p2 >> 32u;}
\DoxyCodeLine{16907 }
\DoxyCodeLine{16908         std::uint64\_t Q = p0\_hi + p1\_lo + p2\_lo;}
\DoxyCodeLine{16909 }
\DoxyCodeLine{16910         \textcolor{comment}{// The full product might now be computed as}}
\DoxyCodeLine{16911         \textcolor{comment}{//}}
\DoxyCodeLine{16912         \textcolor{comment}{// p\_hi = p3 + p2\_hi + p1\_hi + (Q >> 32)}}
\DoxyCodeLine{16913         \textcolor{comment}{// p\_lo = p0\_lo + (Q << 32)}}
\DoxyCodeLine{16914         \textcolor{comment}{//}}
\DoxyCodeLine{16915         \textcolor{comment}{// But in this particular case here, the full p\_lo is not required.}}
\DoxyCodeLine{16916         \textcolor{comment}{// Effectively we only need to add the highest bit in p\_lo to p\_hi (and}}
\DoxyCodeLine{16917         \textcolor{comment}{// Q\_hi + 1 does not overflow).}}
\DoxyCodeLine{16918 }
\DoxyCodeLine{16919         Q += std::uint64\_t\{1\} << (64u -\/ 32u -\/ 1u); \textcolor{comment}{// round, ties up}}
\DoxyCodeLine{16920 }
\DoxyCodeLine{16921         \textcolor{keyword}{const} std::uint64\_t h = p3 + p2\_hi + p1\_hi + (Q >> 32u);}
\DoxyCodeLine{16922 }
\DoxyCodeLine{16923         \textcolor{keywordflow}{return} \{h, x.e + y.e + 64\};}
\DoxyCodeLine{16924     \}}
\DoxyCodeLine{16925 }
\DoxyCodeLine{16930     \textcolor{keyword}{static} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a5bad735c2cb50b194938a8a89b82f6ed}{normalize}}(\mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} x) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{16931     \{}
\DoxyCodeLine{16932         JSON\_ASSERT(x.f != 0);}
\DoxyCodeLine{16933 }
\DoxyCodeLine{16934         \textcolor{keywordflow}{while} ((x.f >> 63u) == 0)}
\DoxyCodeLine{16935         \{}
\DoxyCodeLine{16936             x.f <<= 1u;}
\DoxyCodeLine{16937             x.e-\/-\/;}
\DoxyCodeLine{16938         \}}
\DoxyCodeLine{16939 }
\DoxyCodeLine{16940         \textcolor{keywordflow}{return} x;}
\DoxyCodeLine{16941     \}}
\DoxyCodeLine{16942 }
\DoxyCodeLine{16947     \textcolor{keyword}{static} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp_a5a9ce83c6c1663c9aaac7ffd9009b971}{normalize\_to}}(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}\& x, \textcolor{keyword}{const} \textcolor{keywordtype}{int} target\_exponent) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{16948     \{}
\DoxyCodeLine{16949         \textcolor{keyword}{const} \textcolor{keywordtype}{int} delta = x.e -\/ target\_exponent;}
\DoxyCodeLine{16950 }
\DoxyCodeLine{16951         JSON\_ASSERT(delta >= 0);}
\DoxyCodeLine{16952         JSON\_ASSERT(((x.f << delta) >> delta) == x.f);}
\DoxyCodeLine{16953 }
\DoxyCodeLine{16954         \textcolor{keywordflow}{return} \{x.f << delta, target\_exponent\};}
\DoxyCodeLine{16955     \}}
\DoxyCodeLine{16956 \};}
\DoxyCodeLine{16957 }
\DoxyCodeLine{16958 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1boundaries}{boundaries}}}
\DoxyCodeLine{16959 \{}
\DoxyCodeLine{16960     \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w;}
\DoxyCodeLine{16961     \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} minus;}
\DoxyCodeLine{16962     \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} plus;}
\DoxyCodeLine{16963 \};}
\DoxyCodeLine{16964 }
\DoxyCodeLine{16971 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FloatType>}
\DoxyCodeLine{16972 \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1boundaries}{boundaries}} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a6a5ccf11847aab7a0f42f587b33935df}{compute\_boundaries}}(FloatType value)}
\DoxyCodeLine{16973 \{}
\DoxyCodeLine{16974     JSON\_ASSERT(std::isfinite(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}));}
\DoxyCodeLine{16975     JSON\_ASSERT(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} > 0);}
\DoxyCodeLine{16976 }
\DoxyCodeLine{16977     \textcolor{comment}{// Convert the IEEE representation into a diyfp.}}
\DoxyCodeLine{16978     \textcolor{comment}{//}}
\DoxyCodeLine{16979     \textcolor{comment}{// If v is denormal:}}
\DoxyCodeLine{16980     \textcolor{comment}{//      value = 0.F * 2\string^(1 -\/ bias) = (          F) * 2\string^(1 -\/ bias -\/ (p-\/1))}}
\DoxyCodeLine{16981     \textcolor{comment}{// If v is normalized:}}
\DoxyCodeLine{16982     \textcolor{comment}{//      value = 1.F * 2\string^(E -\/ bias) = (2\string^(p-\/1) + F) * 2\string^(E -\/ bias -\/ (p-\/1))}}
\DoxyCodeLine{16983 }
\DoxyCodeLine{16984     \textcolor{keyword}{static\_assert}(std::numeric\_limits<FloatType>::is\_iec559,}
\DoxyCodeLine{16985                   \textcolor{stringliteral}{"{}internal error: dtoa\_short requires an IEEE-\/754 floating-\/point implementation"{}});}
\DoxyCodeLine{16986 }
\DoxyCodeLine{16987     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int}      kPrecision = std::numeric\_limits<FloatType>::digits; \textcolor{comment}{// = p (includes the hidden bit)}}
\DoxyCodeLine{16988     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int}      kBias      = std::numeric\_limits<FloatType>::max\_exponent -\/ 1 + (kPrecision -\/ 1);}
\DoxyCodeLine{16989     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int}      kMinExp    = 1 -\/ kBias;}
\DoxyCodeLine{16990     \textcolor{keyword}{constexpr} std::uint64\_t kHiddenBit = std::uint64\_t\{1\} << (kPrecision -\/ 1); \textcolor{comment}{// = 2\string^(p-\/1)}}
\DoxyCodeLine{16991 }
\DoxyCodeLine{16992     \textcolor{keyword}{using }bits\_type = \textcolor{keyword}{typename} std::conditional<kPrecision == 24, std::uint32\_t, std::uint64\_t >::type;}
\DoxyCodeLine{16993 }
\DoxyCodeLine{16994     \textcolor{keyword}{const} \textcolor{keyword}{auto} bits = \textcolor{keyword}{static\_cast<}std::uint64\_t\textcolor{keyword}{>}(reinterpret\_bits<bits\_type>(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}));}
\DoxyCodeLine{16995     \textcolor{keyword}{const} std::uint64\_t E = bits >> (kPrecision -\/ 1);}
\DoxyCodeLine{16996     \textcolor{keyword}{const} std::uint64\_t F = bits \& (kHiddenBit -\/ 1);}
\DoxyCodeLine{16997 }
\DoxyCodeLine{16998     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_denormal = E == 0;}
\DoxyCodeLine{16999     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} v = is\_denormal}
\DoxyCodeLine{17000                     ? \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(F, kMinExp)}
\DoxyCodeLine{17001                     : \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(F + kHiddenBit, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(E) -\/ kBias);}
\DoxyCodeLine{17002 }
\DoxyCodeLine{17003     \textcolor{comment}{// Compute the boundaries m-\/ and m+ of the floating-\/point value}}
\DoxyCodeLine{17004     \textcolor{comment}{// v = f * 2\string^e.}}
\DoxyCodeLine{17005     \textcolor{comment}{//}}
\DoxyCodeLine{17006     \textcolor{comment}{// Determine v-\/ and v+, the floating-\/point predecessor and successor if v,}}
\DoxyCodeLine{17007     \textcolor{comment}{// respectively.}}
\DoxyCodeLine{17008     \textcolor{comment}{//}}
\DoxyCodeLine{17009     \textcolor{comment}{//      v-\/ = v -\/ 2\string^e        if f != 2\string^(p-\/1) or e == e\_min                (A)}}
\DoxyCodeLine{17010     \textcolor{comment}{//         = v -\/ 2\string^(e-\/1)    if f == 2\string^(p-\/1) and e > e\_min                (B)}}
\DoxyCodeLine{17011     \textcolor{comment}{//}}
\DoxyCodeLine{17012     \textcolor{comment}{//      v+ = v + 2\string^e}}
\DoxyCodeLine{17013     \textcolor{comment}{//}}
\DoxyCodeLine{17014     \textcolor{comment}{// Let m-\/ = (v-\/ + v) / 2 and m+ = (v + v+) / 2. All real numbers \_strictly\_}}
\DoxyCodeLine{17015     \textcolor{comment}{// between m-\/ and m+ round to v, regardless of how the input rounding}}
\DoxyCodeLine{17016     \textcolor{comment}{// algorithm breaks ties.}}
\DoxyCodeLine{17017     \textcolor{comment}{//}}
\DoxyCodeLine{17018     \textcolor{comment}{//      -\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/  (A)}}
\DoxyCodeLine{17019     \textcolor{comment}{//         v-\/            m-\/            v             m+            v+}}
\DoxyCodeLine{17020     \textcolor{comment}{//}}
\DoxyCodeLine{17021     \textcolor{comment}{//      -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/  (B)}}
\DoxyCodeLine{17022     \textcolor{comment}{//                       v-\/     m-\/     v             m+            v+}}
\DoxyCodeLine{17023 }
\DoxyCodeLine{17024     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} lower\_boundary\_is\_closer = F == 0 \&\& E > 1;}
\DoxyCodeLine{17025     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\_plus = \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(2 * v.f + 1, v.e -\/ 1);}
\DoxyCodeLine{17026     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\_minus = lower\_boundary\_is\_closer}
\DoxyCodeLine{17027                           ? \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(4 * v.f -\/ 1, v.e -\/ 2)  \textcolor{comment}{// (B)}}
\DoxyCodeLine{17028                           : \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}}(2 * v.f -\/ 1, v.e -\/ 1); \textcolor{comment}{// (A)}}
\DoxyCodeLine{17029 }
\DoxyCodeLine{17030     \textcolor{comment}{// Determine the normalized w+ = m+.}}
\DoxyCodeLine{17031     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w\_plus = diyfp::normalize(m\_plus);}
\DoxyCodeLine{17032 }
\DoxyCodeLine{17033     \textcolor{comment}{// Determine w-\/ = m-\/ such that e\_(w-\/) = e\_(w+).}}
\DoxyCodeLine{17034     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w\_minus = diyfp::normalize\_to(m\_minus, w\_plus.e);}
\DoxyCodeLine{17035 }
\DoxyCodeLine{17036     \textcolor{keywordflow}{return} \{diyfp::normalize(v), w\_minus, w\_plus\};}
\DoxyCodeLine{17037 \}}
\DoxyCodeLine{17038 }
\DoxyCodeLine{17039 \textcolor{comment}{// Given normalized diyfp w, Grisu needs to find a (normalized) cached}}
\DoxyCodeLine{17040 \textcolor{comment}{// power-\/of-\/ten c, such that the exponent of the product c * w = f * 2\string^e lies}}
\DoxyCodeLine{17041 \textcolor{comment}{// within a certain range [alpha, gamma] (Definition 3.2 from [1])}}
\DoxyCodeLine{17042 \textcolor{comment}{//}}
\DoxyCodeLine{17043 \textcolor{comment}{//      alpha <= e = e\_c + e\_w + q <= gamma}}
\DoxyCodeLine{17044 \textcolor{comment}{//}}
\DoxyCodeLine{17045 \textcolor{comment}{// or}}
\DoxyCodeLine{17046 \textcolor{comment}{//}}
\DoxyCodeLine{17047 \textcolor{comment}{//      f\_c * f\_w * 2\string^alpha <= f\_c 2\string^(e\_c) * f\_w 2\string^(e\_w) * 2\string^q}}
\DoxyCodeLine{17048 \textcolor{comment}{//                          <= f\_c * f\_w * 2\string^gamma}}
\DoxyCodeLine{17049 \textcolor{comment}{//}}
\DoxyCodeLine{17050 \textcolor{comment}{// Since c and w are normalized, i.e. 2\string^(q-\/1) <= f < 2\string^q, this implies}}
\DoxyCodeLine{17051 \textcolor{comment}{//}}
\DoxyCodeLine{17052 \textcolor{comment}{//      2\string^(q-\/1) * 2\string^(q-\/1) * 2\string^alpha <= c * w * 2\string^q < 2\string^q * 2\string^q * 2\string^gamma}}
\DoxyCodeLine{17053 \textcolor{comment}{//}}
\DoxyCodeLine{17054 \textcolor{comment}{// or}}
\DoxyCodeLine{17055 \textcolor{comment}{//}}
\DoxyCodeLine{17056 \textcolor{comment}{//      2\string^(q -\/ 2 + alpha) <= c * w < 2\string^(q + gamma)}}
\DoxyCodeLine{17057 \textcolor{comment}{//}}
\DoxyCodeLine{17058 \textcolor{comment}{// The choice of (alpha,gamma) determines the size of the table and the form of}}
\DoxyCodeLine{17059 \textcolor{comment}{// the digit generation procedure. Using (alpha,gamma)=(-\/60,-\/32) works out well}}
\DoxyCodeLine{17060 \textcolor{comment}{// in practice:}}
\DoxyCodeLine{17061 \textcolor{comment}{//}}
\DoxyCodeLine{17062 \textcolor{comment}{// The idea is to cut the number c * w = f * 2\string^e into two parts, which can be}}
\DoxyCodeLine{17063 \textcolor{comment}{// processed independently: An integral part p1, and a fractional part p2:}}
\DoxyCodeLine{17064 \textcolor{comment}{//}}
\DoxyCodeLine{17065 \textcolor{comment}{//      f * 2\string^e = ( (f div 2\string^-\/e) * 2\string^-\/e + (f mod 2\string^-\/e) ) * 2\string^e}}
\DoxyCodeLine{17066 \textcolor{comment}{//              = (f div 2\string^-\/e) + (f mod 2\string^-\/e) * 2\string^e}}
\DoxyCodeLine{17067 \textcolor{comment}{//              = p1 + p2 * 2\string^e}}
\DoxyCodeLine{17068 \textcolor{comment}{//}}
\DoxyCodeLine{17069 \textcolor{comment}{// The conversion of p1 into decimal form requires a series of divisions and}}
\DoxyCodeLine{17070 \textcolor{comment}{// modulos by (a power of) 10. These operations are faster for 32-\/bit than for}}
\DoxyCodeLine{17071 \textcolor{comment}{// 64-\/bit integers, so p1 should ideally fit into a 32-\/bit integer. This can be}}
\DoxyCodeLine{17072 \textcolor{comment}{// achieved by choosing}}
\DoxyCodeLine{17073 \textcolor{comment}{//}}
\DoxyCodeLine{17074 \textcolor{comment}{//      -\/e >= 32   or   e <= -\/32 := gamma}}
\DoxyCodeLine{17075 \textcolor{comment}{//}}
\DoxyCodeLine{17076 \textcolor{comment}{// In order to convert the fractional part}}
\DoxyCodeLine{17077 \textcolor{comment}{//}}
\DoxyCodeLine{17078 \textcolor{comment}{//      p2 * 2\string^e = p2 / 2\string^-\/e = d[-\/1] / 10\string^1 + d[-\/2] / 10\string^2 + ...}}
\DoxyCodeLine{17079 \textcolor{comment}{//}}
\DoxyCodeLine{17080 \textcolor{comment}{// into decimal form, the fraction is repeatedly multiplied by 10 and the digits}}
\DoxyCodeLine{17081 \textcolor{comment}{// d[-\/i] are extracted in order:}}
\DoxyCodeLine{17082 \textcolor{comment}{//}}
\DoxyCodeLine{17083 \textcolor{comment}{//      (10 * p2) div 2\string^-\/e = d[-\/1]}}
\DoxyCodeLine{17084 \textcolor{comment}{//      (10 * p2) mod 2\string^-\/e = d[-\/2] / 10\string^1 + ...}}
\DoxyCodeLine{17085 \textcolor{comment}{//}}
\DoxyCodeLine{17086 \textcolor{comment}{// The multiplication by 10 must not overflow. It is sufficient to choose}}
\DoxyCodeLine{17087 \textcolor{comment}{//}}
\DoxyCodeLine{17088 \textcolor{comment}{//      10 * p2 < 16 * p2 = 2\string^4 * p2 <= 2\string^64.}}
\DoxyCodeLine{17089 \textcolor{comment}{//}}
\DoxyCodeLine{17090 \textcolor{comment}{// Since p2 = f mod 2\string^-\/e < 2\string^-\/e,}}
\DoxyCodeLine{17091 \textcolor{comment}{//}}
\DoxyCodeLine{17092 \textcolor{comment}{//      -\/e <= 60   or   e >= -\/60 := alpha}}
\DoxyCodeLine{17093 }
\DoxyCodeLine{17094 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kAlpha = -\/60;}
\DoxyCodeLine{17095 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kGamma = -\/32;}
\DoxyCodeLine{17096 }
\DoxyCodeLine{17097 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1cached__power}{cached\_power}} \textcolor{comment}{// c = f * 2\string^e \string~= 10\string^k}}
\DoxyCodeLine{17098 \{}
\DoxyCodeLine{17099     std::uint64\_t f;}
\DoxyCodeLine{17100     \textcolor{keywordtype}{int} e;}
\DoxyCodeLine{17101     \textcolor{keywordtype}{int} k;}
\DoxyCodeLine{17102 \};}
\DoxyCodeLine{17103 }
\DoxyCodeLine{17111 \textcolor{keyword}{inline} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1cached__power}{cached\_power}} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a29ae6574f6be09a5c8ab08da9a3f71b4}{get\_cached\_power\_for\_binary\_exponent}}(\textcolor{keywordtype}{int} e)}
\DoxyCodeLine{17112 \{}
\DoxyCodeLine{17113     \textcolor{comment}{// Now}}
\DoxyCodeLine{17114     \textcolor{comment}{//}}
\DoxyCodeLine{17115     \textcolor{comment}{//      alpha <= e\_c + e + q <= gamma                                    (1)}}
\DoxyCodeLine{17116     \textcolor{comment}{//      ==> f\_c * 2\string^alpha <= c * 2\string^e * 2\string^q}}
\DoxyCodeLine{17117     \textcolor{comment}{//}}
\DoxyCodeLine{17118     \textcolor{comment}{// and since the c's are normalized, 2\string^(q-\/1) <= f\_c,}}
\DoxyCodeLine{17119     \textcolor{comment}{//}}
\DoxyCodeLine{17120     \textcolor{comment}{//      ==> 2\string^(q -\/ 1 + alpha) <= c * 2\string^(e + q)}}
\DoxyCodeLine{17121     \textcolor{comment}{//      ==> 2\string^(alpha -\/ e -\/ 1) <= c}}
\DoxyCodeLine{17122     \textcolor{comment}{//}}
\DoxyCodeLine{17123     \textcolor{comment}{// If c were an exact power of ten, i.e. c = 10\string^k, one may determine k as}}
\DoxyCodeLine{17124     \textcolor{comment}{//}}
\DoxyCodeLine{17125     \textcolor{comment}{//      k = ceil( log\_10( 2\string^(alpha -\/ e -\/ 1) ) )}}
\DoxyCodeLine{17126     \textcolor{comment}{//        = ceil( (alpha -\/ e -\/ 1) * log\_10(2) )}}
\DoxyCodeLine{17127     \textcolor{comment}{//}}
\DoxyCodeLine{17128     \textcolor{comment}{// From the paper:}}
\DoxyCodeLine{17129     \textcolor{comment}{// "{}In theory the result of the procedure could be wrong since c is rounded,}}
\DoxyCodeLine{17130     \textcolor{comment}{//  and the computation itself is approximated [...]. In practice, however,}}
\DoxyCodeLine{17131     \textcolor{comment}{//  this simple function is sufficient."{}}}
\DoxyCodeLine{17132     \textcolor{comment}{//}}
\DoxyCodeLine{17133     \textcolor{comment}{// For IEEE double precision floating-\/point numbers converted into}}
\DoxyCodeLine{17134     \textcolor{comment}{// normalized diyfp's w = f * 2\string^e, with q = 64,}}
\DoxyCodeLine{17135     \textcolor{comment}{//}}
\DoxyCodeLine{17136     \textcolor{comment}{//      e >= -\/1022      (min IEEE exponent)}}
\DoxyCodeLine{17137     \textcolor{comment}{//           -\/52        (p -\/ 1)}}
\DoxyCodeLine{17138     \textcolor{comment}{//           -\/52        (p -\/ 1, possibly normalize denormal IEEE numbers)}}
\DoxyCodeLine{17139     \textcolor{comment}{//           -\/11        (normalize the diyfp)}}
\DoxyCodeLine{17140     \textcolor{comment}{//         = -\/1137}}
\DoxyCodeLine{17141     \textcolor{comment}{//}}
\DoxyCodeLine{17142     \textcolor{comment}{// and}}
\DoxyCodeLine{17143     \textcolor{comment}{//}}
\DoxyCodeLine{17144     \textcolor{comment}{//      e <= +1023      (max IEEE exponent)}}
\DoxyCodeLine{17145     \textcolor{comment}{//           -\/52        (p -\/ 1)}}
\DoxyCodeLine{17146     \textcolor{comment}{//           -\/11        (normalize the diyfp)}}
\DoxyCodeLine{17147     \textcolor{comment}{//         = 960}}
\DoxyCodeLine{17148     \textcolor{comment}{//}}
\DoxyCodeLine{17149     \textcolor{comment}{// This binary exponent range [-\/1137,960] results in a decimal exponent}}
\DoxyCodeLine{17150     \textcolor{comment}{// range [-\/307,324]. One does not need to store a cached power for each}}
\DoxyCodeLine{17151     \textcolor{comment}{// k in this range. For each such k it suffices to find a cached power}}
\DoxyCodeLine{17152     \textcolor{comment}{// such that the exponent of the product lies in [alpha,gamma].}}
\DoxyCodeLine{17153     \textcolor{comment}{// This implies that the difference of the decimal exponents of adjacent}}
\DoxyCodeLine{17154     \textcolor{comment}{// table entries must be less than or equal to}}
\DoxyCodeLine{17155     \textcolor{comment}{//}}
\DoxyCodeLine{17156     \textcolor{comment}{//      floor( (gamma -\/ alpha) * log\_10(2) ) = 8.}}
\DoxyCodeLine{17157     \textcolor{comment}{//}}
\DoxyCodeLine{17158     \textcolor{comment}{// (A smaller distance gamma-\/alpha would require a larger table.)}}
\DoxyCodeLine{17159 }
\DoxyCodeLine{17160     \textcolor{comment}{// NB:}}
\DoxyCodeLine{17161     \textcolor{comment}{// Actually this function returns c, such that -\/60 <= e\_c + e + 64 <= -\/34.}}
\DoxyCodeLine{17162 }
\DoxyCodeLine{17163     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kCachedPowersMinDecExp = -\/300;}
\DoxyCodeLine{17164     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kCachedPowersDecStep = 8;}
\DoxyCodeLine{17165 }
\DoxyCodeLine{17166     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::array<cached\_power, 79> kCachedPowers =}
\DoxyCodeLine{17167     \{}
\DoxyCodeLine{17168         \{}
\DoxyCodeLine{17169             \{ 0xAB70FE17C79AC6CA, -\/1060, -\/300 \},}
\DoxyCodeLine{17170             \{ 0xFF77B1FCBEBCDC4F, -\/1034, -\/292 \},}
\DoxyCodeLine{17171             \{ 0xBE5691EF416BD60C, -\/1007, -\/284 \},}
\DoxyCodeLine{17172             \{ 0x8DD01FAD907FFC3C,  -\/980, -\/276 \},}
\DoxyCodeLine{17173             \{ 0xD3515C2831559A83,  -\/954, -\/268 \},}
\DoxyCodeLine{17174             \{ 0x9D71AC8FADA6C9B5,  -\/927, -\/260 \},}
\DoxyCodeLine{17175             \{ 0xEA9C227723EE8BCB,  -\/901, -\/252 \},}
\DoxyCodeLine{17176             \{ 0xAECC49914078536D,  -\/874, -\/244 \},}
\DoxyCodeLine{17177             \{ 0x823C12795DB6CE57,  -\/847, -\/236 \},}
\DoxyCodeLine{17178             \{ 0xC21094364DFB5637,  -\/821, -\/228 \},}
\DoxyCodeLine{17179             \{ 0x9096EA6F3848984F,  -\/794, -\/220 \},}
\DoxyCodeLine{17180             \{ 0xD77485CB25823AC7,  -\/768, -\/212 \},}
\DoxyCodeLine{17181             \{ 0xA086CFCD97BF97F4,  -\/741, -\/204 \},}
\DoxyCodeLine{17182             \{ 0xEF340A98172AACE5,  -\/715, -\/196 \},}
\DoxyCodeLine{17183             \{ 0xB23867FB2A35B28E,  -\/688, -\/188 \},}
\DoxyCodeLine{17184             \{ 0x84C8D4DFD2C63F3B,  -\/661, -\/180 \},}
\DoxyCodeLine{17185             \{ 0xC5DD44271AD3CDBA,  -\/635, -\/172 \},}
\DoxyCodeLine{17186             \{ 0x936B9FCEBB25C996,  -\/608, -\/164 \},}
\DoxyCodeLine{17187             \{ 0xDBAC6C247D62A584,  -\/582, -\/156 \},}
\DoxyCodeLine{17188             \{ 0xA3AB66580D5FDAF6,  -\/555, -\/148 \},}
\DoxyCodeLine{17189             \{ 0xF3E2F893DEC3F126,  -\/529, -\/140 \},}
\DoxyCodeLine{17190             \{ 0xB5B5ADA8AAFF80B8,  -\/502, -\/132 \},}
\DoxyCodeLine{17191             \{ 0x87625F056C7C4A8B,  -\/475, -\/124 \},}
\DoxyCodeLine{17192             \{ 0xC9BCFF6034C13053,  -\/449, -\/116 \},}
\DoxyCodeLine{17193             \{ 0x964E858C91BA2655,  -\/422, -\/108 \},}
\DoxyCodeLine{17194             \{ 0xDFF9772470297EBD,  -\/396, -\/100 \},}
\DoxyCodeLine{17195             \{ 0xA6DFBD9FB8E5B88F,  -\/369,  -\/92 \},}
\DoxyCodeLine{17196             \{ 0xF8A95FCF88747D94,  -\/343,  -\/84 \},}
\DoxyCodeLine{17197             \{ 0xB94470938FA89BCF,  -\/316,  -\/76 \},}
\DoxyCodeLine{17198             \{ 0x8A08F0F8BF0F156B,  -\/289,  -\/68 \},}
\DoxyCodeLine{17199             \{ 0xCDB02555653131B6,  -\/263,  -\/60 \},}
\DoxyCodeLine{17200             \{ 0x993FE2C6D07B7FAC,  -\/236,  -\/52 \},}
\DoxyCodeLine{17201             \{ 0xE45C10C42A2B3B06,  -\/210,  -\/44 \},}
\DoxyCodeLine{17202             \{ 0xAA242499697392D3,  -\/183,  -\/36 \},}
\DoxyCodeLine{17203             \{ 0xFD87B5F28300CA0E,  -\/157,  -\/28 \},}
\DoxyCodeLine{17204             \{ 0xBCE5086492111AEB,  -\/130,  -\/20 \},}
\DoxyCodeLine{17205             \{ 0x8CBCCC096F5088CC,  -\/103,  -\/12 \},}
\DoxyCodeLine{17206             \{ 0xD1B71758E219652C,   -\/77,   -\/4 \},}
\DoxyCodeLine{17207             \{ 0x9C40000000000000,   -\/50,    4 \},}
\DoxyCodeLine{17208             \{ 0xE8D4A51000000000,   -\/24,   12 \},}
\DoxyCodeLine{17209             \{ 0xAD78EBC5AC620000,     3,   20 \},}
\DoxyCodeLine{17210             \{ 0x813F3978F8940984,    30,   28 \},}
\DoxyCodeLine{17211             \{ 0xC097CE7BC90715B3,    56,   36 \},}
\DoxyCodeLine{17212             \{ 0x8F7E32CE7BEA5C70,    83,   44 \},}
\DoxyCodeLine{17213             \{ 0xD5D238A4ABE98068,   109,   52 \},}
\DoxyCodeLine{17214             \{ 0x9F4F2726179A2245,   136,   60 \},}
\DoxyCodeLine{17215             \{ 0xED63A231D4C4FB27,   162,   68 \},}
\DoxyCodeLine{17216             \{ 0xB0DE65388CC8ADA8,   189,   76 \},}
\DoxyCodeLine{17217             \{ 0x83C7088E1AAB65DB,   216,   84 \},}
\DoxyCodeLine{17218             \{ 0xC45D1DF942711D9A,   242,   92 \},}
\DoxyCodeLine{17219             \{ 0x924D692CA61BE758,   269,  100 \},}
\DoxyCodeLine{17220             \{ 0xDA01EE641A708DEA,   295,  108 \},}
\DoxyCodeLine{17221             \{ 0xA26DA3999AEF774A,   322,  116 \},}
\DoxyCodeLine{17222             \{ 0xF209787BB47D6B85,   348,  124 \},}
\DoxyCodeLine{17223             \{ 0xB454E4A179DD1877,   375,  132 \},}
\DoxyCodeLine{17224             \{ 0x865B86925B9BC5C2,   402,  140 \},}
\DoxyCodeLine{17225             \{ 0xC83553C5C8965D3D,   428,  148 \},}
\DoxyCodeLine{17226             \{ 0x952AB45CFA97A0B3,   455,  156 \},}
\DoxyCodeLine{17227             \{ 0xDE469FBD99A05FE3,   481,  164 \},}
\DoxyCodeLine{17228             \{ 0xA59BC234DB398C25,   508,  172 \},}
\DoxyCodeLine{17229             \{ 0xF6C69A72A3989F5C,   534,  180 \},}
\DoxyCodeLine{17230             \{ 0xB7DCBF5354E9BECE,   561,  188 \},}
\DoxyCodeLine{17231             \{ 0x88FCF317F22241E2,   588,  196 \},}
\DoxyCodeLine{17232             \{ 0xCC20CE9BD35C78A5,   614,  204 \},}
\DoxyCodeLine{17233             \{ 0x98165AF37B2153DF,   641,  212 \},}
\DoxyCodeLine{17234             \{ 0xE2A0B5DC971F303A,   667,  220 \},}
\DoxyCodeLine{17235             \{ 0xA8D9D1535CE3B396,   694,  228 \},}
\DoxyCodeLine{17236             \{ 0xFB9B7CD9A4A7443C,   720,  236 \},}
\DoxyCodeLine{17237             \{ 0xBB764C4CA7A44410,   747,  244 \},}
\DoxyCodeLine{17238             \{ 0x8BAB8EEFB6409C1A,   774,  252 \},}
\DoxyCodeLine{17239             \{ 0xD01FEF10A657842C,   800,  260 \},}
\DoxyCodeLine{17240             \{ 0x9B10A4E5E9913129,   827,  268 \},}
\DoxyCodeLine{17241             \{ 0xE7109BFBA19C0C9D,   853,  276 \},}
\DoxyCodeLine{17242             \{ 0xAC2820D9623BF429,   880,  284 \},}
\DoxyCodeLine{17243             \{ 0x80444B5E7AA7CF85,   907,  292 \},}
\DoxyCodeLine{17244             \{ 0xBF21E44003ACDD2D,   933,  300 \},}
\DoxyCodeLine{17245             \{ 0x8E679C2F5E44FF8F,   960,  308 \},}
\DoxyCodeLine{17246             \{ 0xD433179D9C8CB841,   986,  316 \},}
\DoxyCodeLine{17247             \{ 0x9E19DB92B4E31BA9,  1013,  324 \},}
\DoxyCodeLine{17248         \}}
\DoxyCodeLine{17249     \};}
\DoxyCodeLine{17250 }
\DoxyCodeLine{17251     \textcolor{comment}{// This computation gives exactly the same results for k as}}
\DoxyCodeLine{17252     \textcolor{comment}{//      k = ceil((kAlpha -\/ e -\/ 1) * 0.30102999566398114)}}
\DoxyCodeLine{17253     \textcolor{comment}{// for |e| <= 1500, but doesn't require floating-\/point operations.}}
\DoxyCodeLine{17254     \textcolor{comment}{// NB: log\_10(2) \string~= 78913 / 2\string^18}}
\DoxyCodeLine{17255     JSON\_ASSERT(e >= -\/1500);}
\DoxyCodeLine{17256     JSON\_ASSERT(e <=  1500);}
\DoxyCodeLine{17257     \textcolor{keyword}{const} \textcolor{keywordtype}{int} f = kAlpha -\/ e -\/ 1;}
\DoxyCodeLine{17258     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = (f * 78913) / (1 << 18) + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(f > 0);}
\DoxyCodeLine{17259 }
\DoxyCodeLine{17260     \textcolor{keyword}{const} \textcolor{keywordtype}{int} index = (-\/kCachedPowersMinDecExp + k + (kCachedPowersDecStep -\/ 1)) / kCachedPowersDecStep;}
\DoxyCodeLine{17261     JSON\_ASSERT(index >= 0);}
\DoxyCodeLine{17262     JSON\_ASSERT(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(index) < kCachedPowers.size());}
\DoxyCodeLine{17263 }
\DoxyCodeLine{17264     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1cached__power}{cached\_power}} cached = kCachedPowers[\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(index)];}
\DoxyCodeLine{17265     JSON\_ASSERT(kAlpha <= cached.e + e + 64);}
\DoxyCodeLine{17266     JSON\_ASSERT(kGamma >= cached.e + e + 64);}
\DoxyCodeLine{17267 }
\DoxyCodeLine{17268     \textcolor{keywordflow}{return} cached;}
\DoxyCodeLine{17269 \}}
\DoxyCodeLine{17270 }
\DoxyCodeLine{17275 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a04eb234a28617519974fc962cd4da666}{find\_largest\_pow10}}(\textcolor{keyword}{const} std::uint32\_t n, std::uint32\_t\& pow10)}
\DoxyCodeLine{17276 \{}
\DoxyCodeLine{17277     \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{17278     \textcolor{keywordflow}{if} (n >= 1000000000)}
\DoxyCodeLine{17279     \{}
\DoxyCodeLine{17280         pow10 = 1000000000;}
\DoxyCodeLine{17281         \textcolor{keywordflow}{return} 10;}
\DoxyCodeLine{17282     \}}
\DoxyCodeLine{17283     \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{17284     \textcolor{keywordflow}{if} (n >= 100000000)}
\DoxyCodeLine{17285     \{}
\DoxyCodeLine{17286         pow10 = 100000000;}
\DoxyCodeLine{17287         \textcolor{keywordflow}{return}  9;}
\DoxyCodeLine{17288     \}}
\DoxyCodeLine{17289     \textcolor{keywordflow}{if} (n >= 10000000)}
\DoxyCodeLine{17290     \{}
\DoxyCodeLine{17291         pow10 = 10000000;}
\DoxyCodeLine{17292         \textcolor{keywordflow}{return}  8;}
\DoxyCodeLine{17293     \}}
\DoxyCodeLine{17294     \textcolor{keywordflow}{if} (n >= 1000000)}
\DoxyCodeLine{17295     \{}
\DoxyCodeLine{17296         pow10 = 1000000;}
\DoxyCodeLine{17297         \textcolor{keywordflow}{return}  7;}
\DoxyCodeLine{17298     \}}
\DoxyCodeLine{17299     \textcolor{keywordflow}{if} (n >= 100000)}
\DoxyCodeLine{17300     \{}
\DoxyCodeLine{17301         pow10 = 100000;}
\DoxyCodeLine{17302         \textcolor{keywordflow}{return}  6;}
\DoxyCodeLine{17303     \}}
\DoxyCodeLine{17304     \textcolor{keywordflow}{if} (n >= 10000)}
\DoxyCodeLine{17305     \{}
\DoxyCodeLine{17306         pow10 = 10000;}
\DoxyCodeLine{17307         \textcolor{keywordflow}{return}  5;}
\DoxyCodeLine{17308     \}}
\DoxyCodeLine{17309     \textcolor{keywordflow}{if} (n >= 1000)}
\DoxyCodeLine{17310     \{}
\DoxyCodeLine{17311         pow10 = 1000;}
\DoxyCodeLine{17312         \textcolor{keywordflow}{return}  4;}
\DoxyCodeLine{17313     \}}
\DoxyCodeLine{17314     \textcolor{keywordflow}{if} (n >= 100)}
\DoxyCodeLine{17315     \{}
\DoxyCodeLine{17316         pow10 = 100;}
\DoxyCodeLine{17317         \textcolor{keywordflow}{return}  3;}
\DoxyCodeLine{17318     \}}
\DoxyCodeLine{17319     \textcolor{keywordflow}{if} (n >= 10)}
\DoxyCodeLine{17320     \{}
\DoxyCodeLine{17321         pow10 = 10;}
\DoxyCodeLine{17322         \textcolor{keywordflow}{return}  2;}
\DoxyCodeLine{17323     \}}
\DoxyCodeLine{17324 }
\DoxyCodeLine{17325     pow10 = 1;}
\DoxyCodeLine{17326     \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{17327 \}}
\DoxyCodeLine{17328 }
\DoxyCodeLine{17329 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} grisu2\_round(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{int} len, std::uint64\_t dist, std::uint64\_t delta,}
\DoxyCodeLine{17330                          std::uint64\_t rest, std::uint64\_t ten\_k)}
\DoxyCodeLine{17331 \{}
\DoxyCodeLine{17332     JSON\_ASSERT(len >= 1);}
\DoxyCodeLine{17333     JSON\_ASSERT(dist <= delta);}
\DoxyCodeLine{17334     JSON\_ASSERT(rest <= delta);}
\DoxyCodeLine{17335     JSON\_ASSERT(ten\_k > 0);}
\DoxyCodeLine{17336 }
\DoxyCodeLine{17337     \textcolor{comment}{//               <-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ delta -\/-\/-\/-\/>}}
\DoxyCodeLine{17338     \textcolor{comment}{//                                  <-\/-\/-\/-\/ dist -\/-\/-\/-\/-\/-\/-\/-\/-\/>}}
\DoxyCodeLine{17339     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{17340     \textcolor{comment}{//               M-\/                 w                   M+}}
\DoxyCodeLine{17341     \textcolor{comment}{//}}
\DoxyCodeLine{17342     \textcolor{comment}{//                                  ten\_k}}
\DoxyCodeLine{17343     \textcolor{comment}{//                                <-\/-\/-\/-\/-\/-\/>}}
\DoxyCodeLine{17344     \textcolor{comment}{//                                       <-\/-\/-\/-\/ rest -\/-\/-\/-\/>}}
\DoxyCodeLine{17345     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{17346     \textcolor{comment}{//                                  w    V}}
\DoxyCodeLine{17347     \textcolor{comment}{//                                       = buf * 10\string^k}}
\DoxyCodeLine{17348     \textcolor{comment}{//}}
\DoxyCodeLine{17349     \textcolor{comment}{// ten\_k represents a unit-\/in-\/the-\/last-\/place in the decimal representation}}
\DoxyCodeLine{17350     \textcolor{comment}{// stored in buf.}}
\DoxyCodeLine{17351     \textcolor{comment}{// Decrement buf by ten\_k while this takes buf closer to w.}}
\DoxyCodeLine{17352 }
\DoxyCodeLine{17353     \textcolor{comment}{// The tests are written in this order to avoid overflow in unsigned}}
\DoxyCodeLine{17354     \textcolor{comment}{// integer arithmetic.}}
\DoxyCodeLine{17355 }
\DoxyCodeLine{17356     \textcolor{keywordflow}{while} (rest < dist}
\DoxyCodeLine{17357             \&\& delta -\/ rest >= ten\_k}
\DoxyCodeLine{17358             \&\& (rest + ten\_k < dist || dist -\/ rest > rest + ten\_k -\/ dist))}
\DoxyCodeLine{17359     \{}
\DoxyCodeLine{17360         JSON\_ASSERT(buf[len -\/ 1] != \textcolor{charliteral}{'0'});}
\DoxyCodeLine{17361         buf[len -\/ 1]-\/-\/;}
\DoxyCodeLine{17362         rest += ten\_k;}
\DoxyCodeLine{17363     \}}
\DoxyCodeLine{17364 \}}
\DoxyCodeLine{17365 }
\DoxyCodeLine{17370 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_ae877aa13ab872c99a1c614e5e1524807}{grisu2\_digit\_gen}}(\textcolor{keywordtype}{char}* buffer, \textcolor{keywordtype}{int}\& length, \textcolor{keywordtype}{int}\& decimal\_exponent,}
\DoxyCodeLine{17371                              \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\_minus, \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w, \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\_plus)}
\DoxyCodeLine{17372 \{}
\DoxyCodeLine{17373     \textcolor{keyword}{static\_assert}(kAlpha >= -\/60, \textcolor{stringliteral}{"{}internal error"{}});}
\DoxyCodeLine{17374     \textcolor{keyword}{static\_assert}(kGamma <= -\/32, \textcolor{stringliteral}{"{}internal error"{}});}
\DoxyCodeLine{17375 }
\DoxyCodeLine{17376     \textcolor{comment}{// Generates the digits (and the exponent) of a decimal floating-\/point}}
\DoxyCodeLine{17377     \textcolor{comment}{// number V = buffer * 10\string^decimal\_exponent in the range [M-\/, M+]. The diyfp's}}
\DoxyCodeLine{17378     \textcolor{comment}{// w, M-\/ and M+ share the same exponent e, which satisfies alpha <= e <= gamma.}}
\DoxyCodeLine{17379     \textcolor{comment}{//}}
\DoxyCodeLine{17380     \textcolor{comment}{//               <-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ delta -\/-\/-\/-\/>}}
\DoxyCodeLine{17381     \textcolor{comment}{//                                  <-\/-\/-\/-\/ dist -\/-\/-\/-\/-\/-\/-\/-\/-\/>}}
\DoxyCodeLine{17382     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{17383     \textcolor{comment}{//               M-\/                 w                   M+}}
\DoxyCodeLine{17384     \textcolor{comment}{//}}
\DoxyCodeLine{17385     \textcolor{comment}{// Grisu2 generates the digits of M+ from left to right and stops as soon as}}
\DoxyCodeLine{17386     \textcolor{comment}{// V is in [M-\/,M+].}}
\DoxyCodeLine{17387 }
\DoxyCodeLine{17388     JSON\_ASSERT(M\_plus.e >= kAlpha);}
\DoxyCodeLine{17389     JSON\_ASSERT(M\_plus.e <= kGamma);}
\DoxyCodeLine{17390 }
\DoxyCodeLine{17391     std::uint64\_t delta = diyfp::sub(M\_plus, M\_minus).f; \textcolor{comment}{// (significand of (M+ -\/ M-\/), implicit exponent is e)}}
\DoxyCodeLine{17392     std::uint64\_t dist  = diyfp::sub(M\_plus, w      ).f; \textcolor{comment}{// (significand of (M+ -\/ w ), implicit exponent is e)}}
\DoxyCodeLine{17393 }
\DoxyCodeLine{17394     \textcolor{comment}{// Split M+ = f * 2\string^e into two parts p1 and p2 (note: e < 0):}}
\DoxyCodeLine{17395     \textcolor{comment}{//}}
\DoxyCodeLine{17396     \textcolor{comment}{//      M+ = f * 2\string^e}}
\DoxyCodeLine{17397     \textcolor{comment}{//         = ((f div 2\string^-\/e) * 2\string^-\/e + (f mod 2\string^-\/e)) * 2\string^e}}
\DoxyCodeLine{17398     \textcolor{comment}{//         = ((p1        ) * 2\string^-\/e + (p2        )) * 2\string^e}}
\DoxyCodeLine{17399     \textcolor{comment}{//         = p1 + p2 * 2\string^e}}
\DoxyCodeLine{17400 }
\DoxyCodeLine{17401     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} one(std::uint64\_t\{1\} << -\/M\_plus.e, M\_plus.e);}
\DoxyCodeLine{17402 }
\DoxyCodeLine{17403     \textcolor{keyword}{auto} p1 = \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(M\_plus.f >> -\/one.e); \textcolor{comment}{// p1 = f div 2\string^-\/e (Since -\/e >= 32, p1 fits into a 32-\/bit int.)}}
\DoxyCodeLine{17404     std::uint64\_t p2 = M\_plus.f \& (one.f -\/ 1);                    \textcolor{comment}{// p2 = f mod 2\string^-\/e}}
\DoxyCodeLine{17405 }
\DoxyCodeLine{17406     \textcolor{comment}{// 1)}}
\DoxyCodeLine{17407     \textcolor{comment}{//}}
\DoxyCodeLine{17408     \textcolor{comment}{// Generate the digits of the integral part p1 = d[n-\/1]...d[1]d[0]}}
\DoxyCodeLine{17409 }
\DoxyCodeLine{17410     JSON\_ASSERT(p1 > 0);}
\DoxyCodeLine{17411 }
\DoxyCodeLine{17412     std::uint32\_t pow10\{\};}
\DoxyCodeLine{17413     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a04eb234a28617519974fc962cd4da666}{find\_largest\_pow10}}(p1, pow10);}
\DoxyCodeLine{17414 }
\DoxyCodeLine{17415     \textcolor{comment}{//      10\string^(k-\/1) <= p1 < 10\string^k, pow10 = 10\string^(k-\/1)}}
\DoxyCodeLine{17416     \textcolor{comment}{//}}
\DoxyCodeLine{17417     \textcolor{comment}{//      p1 = (p1 div 10\string^(k-\/1)) * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))}}
\DoxyCodeLine{17418     \textcolor{comment}{//         = (d[k-\/1]         ) * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))}}
\DoxyCodeLine{17419     \textcolor{comment}{//}}
\DoxyCodeLine{17420     \textcolor{comment}{//      M+ = p1                                             + p2 * 2\string^e}}
\DoxyCodeLine{17421     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))          + p2 * 2\string^e}}
\DoxyCodeLine{17422     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + ((p1 mod 10\string^(k-\/1)) * 2\string^-\/e + p2) * 2\string^e}}
\DoxyCodeLine{17423     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + (                         rest) * 2\string^e}}
\DoxyCodeLine{17424     \textcolor{comment}{//}}
\DoxyCodeLine{17425     \textcolor{comment}{// Now generate the digits d[n] of p1 from left to right (n = k-\/1,...,0)}}
\DoxyCodeLine{17426     \textcolor{comment}{//}}
\DoxyCodeLine{17427     \textcolor{comment}{//      p1 = d[k-\/1]...d[n] * 10\string^n + d[n-\/1]...d[0]}}
\DoxyCodeLine{17428     \textcolor{comment}{//}}
\DoxyCodeLine{17429     \textcolor{comment}{// but stop as soon as}}
\DoxyCodeLine{17430     \textcolor{comment}{//}}
\DoxyCodeLine{17431     \textcolor{comment}{//      rest * 2\string^e = (d[n-\/1]...d[0] * 2\string^-\/e + p2) * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{17432 }
\DoxyCodeLine{17433     \textcolor{keywordtype}{int} n = k;}
\DoxyCodeLine{17434     \textcolor{keywordflow}{while} (n > 0)}
\DoxyCodeLine{17435     \{}
\DoxyCodeLine{17436         \textcolor{comment}{// Invariants:}}
\DoxyCodeLine{17437         \textcolor{comment}{//      M+ = buffer * 10\string^n + (p1 + p2 * 2\string^e)    (buffer = 0 for n = k)}}
\DoxyCodeLine{17438         \textcolor{comment}{//      pow10 = 10\string^(n-\/1) <= p1 < 10\string^n}}
\DoxyCodeLine{17439         \textcolor{comment}{//}}
\DoxyCodeLine{17440         \textcolor{keyword}{const} std::uint32\_t d = p1 / pow10;  \textcolor{comment}{// d = p1 div 10\string^(n-\/1)}}
\DoxyCodeLine{17441         \textcolor{keyword}{const} std::uint32\_t r = p1 \% pow10;  \textcolor{comment}{// r = p1 mod 10\string^(n-\/1)}}
\DoxyCodeLine{17442         \textcolor{comment}{//}}
\DoxyCodeLine{17443         \textcolor{comment}{//      M+ = buffer * 10\string^n + (d * 10\string^(n-\/1) + r) + p2 * 2\string^e}}
\DoxyCodeLine{17444         \textcolor{comment}{//         = (buffer * 10 + d) * 10\string^(n-\/1) + (r + p2 * 2\string^e)}}
\DoxyCodeLine{17445         \textcolor{comment}{//}}
\DoxyCodeLine{17446         JSON\_ASSERT(d <= 9);}
\DoxyCodeLine{17447         buffer[length++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + d); \textcolor{comment}{// buffer := buffer * 10 + d}}
\DoxyCodeLine{17448         \textcolor{comment}{//}}
\DoxyCodeLine{17449         \textcolor{comment}{//      M+ = buffer * 10\string^(n-\/1) + (r + p2 * 2\string^e)}}
\DoxyCodeLine{17450         \textcolor{comment}{//}}
\DoxyCodeLine{17451         p1 = r;}
\DoxyCodeLine{17452         n-\/-\/;}
\DoxyCodeLine{17453         \textcolor{comment}{//}}
\DoxyCodeLine{17454         \textcolor{comment}{//      M+ = buffer * 10\string^n + (p1 + p2 * 2\string^e)}}
\DoxyCodeLine{17455         \textcolor{comment}{//      pow10 = 10\string^n}}
\DoxyCodeLine{17456         \textcolor{comment}{//}}
\DoxyCodeLine{17457 }
\DoxyCodeLine{17458         \textcolor{comment}{// Now check if enough digits have been generated.}}
\DoxyCodeLine{17459         \textcolor{comment}{// Compute}}
\DoxyCodeLine{17460         \textcolor{comment}{//}}
\DoxyCodeLine{17461         \textcolor{comment}{//      p1 + p2 * 2\string^e = (p1 * 2\string^-\/e + p2) * 2\string^e = rest * 2\string^e}}
\DoxyCodeLine{17462         \textcolor{comment}{//}}
\DoxyCodeLine{17463         \textcolor{comment}{// Note:}}
\DoxyCodeLine{17464         \textcolor{comment}{// Since rest and delta share the same exponent e, it suffices to}}
\DoxyCodeLine{17465         \textcolor{comment}{// compare the significands.}}
\DoxyCodeLine{17466         \textcolor{keyword}{const} std::uint64\_t rest = (std::uint64\_t\{p1\} << -\/one.e) + p2;}
\DoxyCodeLine{17467         \textcolor{keywordflow}{if} (rest <= delta)}
\DoxyCodeLine{17468         \{}
\DoxyCodeLine{17469             \textcolor{comment}{// V = buffer * 10\string^n, with M-\/ <= V <= M+.}}
\DoxyCodeLine{17470 }
\DoxyCodeLine{17471             decimal\_exponent += n;}
\DoxyCodeLine{17472 }
\DoxyCodeLine{17473             \textcolor{comment}{// We may now just stop. But instead look if the buffer could be}}
\DoxyCodeLine{17474             \textcolor{comment}{// decremented to bring V closer to w.}}
\DoxyCodeLine{17475             \textcolor{comment}{//}}
\DoxyCodeLine{17476             \textcolor{comment}{// pow10 = 10\string^n is now 1 ulp in the decimal representation V.}}
\DoxyCodeLine{17477             \textcolor{comment}{// The rounding procedure works with diyfp's with an implicit}}
\DoxyCodeLine{17478             \textcolor{comment}{// exponent of e.}}
\DoxyCodeLine{17479             \textcolor{comment}{//}}
\DoxyCodeLine{17480             \textcolor{comment}{//      10\string^n = (10\string^n * 2\string^-\/e) * 2\string^e = ulp * 2\string^e}}
\DoxyCodeLine{17481             \textcolor{comment}{//}}
\DoxyCodeLine{17482             \textcolor{keyword}{const} std::uint64\_t ten\_n = std::uint64\_t\{pow10\} << -\/one.e;}
\DoxyCodeLine{17483             grisu2\_round(buffer, length, dist, delta, rest, ten\_n);}
\DoxyCodeLine{17484 }
\DoxyCodeLine{17485             \textcolor{keywordflow}{return};}
\DoxyCodeLine{17486         \}}
\DoxyCodeLine{17487 }
\DoxyCodeLine{17488         pow10 /= 10;}
\DoxyCodeLine{17489         \textcolor{comment}{//}}
\DoxyCodeLine{17490         \textcolor{comment}{//      pow10 = 10\string^(n-\/1) <= p1 < 10\string^n}}
\DoxyCodeLine{17491         \textcolor{comment}{// Invariants restored.}}
\DoxyCodeLine{17492     \}}
\DoxyCodeLine{17493 }
\DoxyCodeLine{17494     \textcolor{comment}{// 2)}}
\DoxyCodeLine{17495     \textcolor{comment}{//}}
\DoxyCodeLine{17496     \textcolor{comment}{// The digits of the integral part have been generated:}}
\DoxyCodeLine{17497     \textcolor{comment}{//}}
\DoxyCodeLine{17498     \textcolor{comment}{//      M+ = d[k-\/1]...d[1]d[0] + p2 * 2\string^e}}
\DoxyCodeLine{17499     \textcolor{comment}{//         = buffer            + p2 * 2\string^e}}
\DoxyCodeLine{17500     \textcolor{comment}{//}}
\DoxyCodeLine{17501     \textcolor{comment}{// Now generate the digits of the fractional part p2 * 2\string^e.}}
\DoxyCodeLine{17502     \textcolor{comment}{//}}
\DoxyCodeLine{17503     \textcolor{comment}{// Note:}}
\DoxyCodeLine{17504     \textcolor{comment}{// No decimal point is generated: the exponent is adjusted instead.}}
\DoxyCodeLine{17505     \textcolor{comment}{//}}
\DoxyCodeLine{17506     \textcolor{comment}{// p2 actually represents the fraction}}
\DoxyCodeLine{17507     \textcolor{comment}{//}}
\DoxyCodeLine{17508     \textcolor{comment}{//      p2 * 2\string^e}}
\DoxyCodeLine{17509     \textcolor{comment}{//          = p2 / 2\string^-\/e}}
\DoxyCodeLine{17510     \textcolor{comment}{//          = d[-\/1] / 10\string^1 + d[-\/2] / 10\string^2 + ...}}
\DoxyCodeLine{17511     \textcolor{comment}{//}}
\DoxyCodeLine{17512     \textcolor{comment}{// Now generate the digits d[-\/m] of p1 from left to right (m = 1,2,...)}}
\DoxyCodeLine{17513     \textcolor{comment}{//}}
\DoxyCodeLine{17514     \textcolor{comment}{//      p2 * 2\string^e = d[-\/1]d[-\/2]...d[-\/m] * 10\string^-\/m}}
\DoxyCodeLine{17515     \textcolor{comment}{//                      + 10\string^-\/m * (d[-\/m-\/1] / 10\string^1 + d[-\/m-\/2] / 10\string^2 + ...)}}
\DoxyCodeLine{17516     \textcolor{comment}{//}}
\DoxyCodeLine{17517     \textcolor{comment}{// using}}
\DoxyCodeLine{17518     \textcolor{comment}{//}}
\DoxyCodeLine{17519     \textcolor{comment}{//      10\string^m * p2 = ((10\string^m * p2) div 2\string^-\/e) * 2\string^-\/e + ((10\string^m * p2) mod 2\string^-\/e)}}
\DoxyCodeLine{17520     \textcolor{comment}{//                = (                   d) * 2\string^-\/e + (                   r)}}
\DoxyCodeLine{17521     \textcolor{comment}{//}}
\DoxyCodeLine{17522     \textcolor{comment}{// or}}
\DoxyCodeLine{17523     \textcolor{comment}{//      10\string^m * p2 * 2\string^e = d + r * 2\string^e}}
\DoxyCodeLine{17524     \textcolor{comment}{//}}
\DoxyCodeLine{17525     \textcolor{comment}{// i.e.}}
\DoxyCodeLine{17526     \textcolor{comment}{//}}
\DoxyCodeLine{17527     \textcolor{comment}{//      M+ = buffer + p2 * 2\string^e}}
\DoxyCodeLine{17528     \textcolor{comment}{//         = buffer + 10\string^-\/m * (d + r * 2\string^e)}}
\DoxyCodeLine{17529     \textcolor{comment}{//         = (buffer * 10\string^m + d) * 10\string^-\/m + 10\string^-\/m * r * 2\string^e}}
\DoxyCodeLine{17530     \textcolor{comment}{//}}
\DoxyCodeLine{17531     \textcolor{comment}{// and stop as soon as 10\string^-\/m * r * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{17532 }
\DoxyCodeLine{17533     JSON\_ASSERT(p2 > delta);}
\DoxyCodeLine{17534 }
\DoxyCodeLine{17535     \textcolor{keywordtype}{int} m = 0;}
\DoxyCodeLine{17536     \textcolor{keywordflow}{for} (;;)}
\DoxyCodeLine{17537     \{}
\DoxyCodeLine{17538         \textcolor{comment}{// Invariant:}}
\DoxyCodeLine{17539         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * (d[-\/m-\/1] / 10 + d[-\/m-\/2] / 10\string^2 + ...) * 2\string^e}}
\DoxyCodeLine{17540         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (p2                                 ) * 2\string^e}}
\DoxyCodeLine{17541         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (10 * p2)                   ) * 2\string^e}}
\DoxyCodeLine{17542         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * ((10*p2 div 2\string^-\/e) * 2\string^-\/e + (10*p2 mod 2\string^-\/e)) * 2\string^e}}
\DoxyCodeLine{17543         \textcolor{comment}{//}}
\DoxyCodeLine{17544         JSON\_ASSERT(p2 <= (std::numeric\_limits<std::uint64\_t>::max)() / 10);}
\DoxyCodeLine{17545         p2 *= 10;}
\DoxyCodeLine{17546         \textcolor{keyword}{const} std::uint64\_t d = p2 >> -\/one.e;     \textcolor{comment}{// d = (10 * p2) div 2\string^-\/e}}
\DoxyCodeLine{17547         \textcolor{keyword}{const} std::uint64\_t r = p2 \& (one.f -\/ 1); \textcolor{comment}{// r = (10 * p2) mod 2\string^-\/e}}
\DoxyCodeLine{17548         \textcolor{comment}{//}}
\DoxyCodeLine{17549         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (d * 2\string^-\/e + r) * 2\string^e}}
\DoxyCodeLine{17550         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (d + r * 2\string^e))}}
\DoxyCodeLine{17551         \textcolor{comment}{//         = (buffer * 10 + d) * 10\string^(-\/m-\/1) + 10\string^(-\/m-\/1) * r * 2\string^e}}
\DoxyCodeLine{17552         \textcolor{comment}{//}}
\DoxyCodeLine{17553         JSON\_ASSERT(d <= 9);}
\DoxyCodeLine{17554         buffer[length++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + d); \textcolor{comment}{// buffer := buffer * 10 + d}}
\DoxyCodeLine{17555         \textcolor{comment}{//}}
\DoxyCodeLine{17556         \textcolor{comment}{//      M+ = buffer * 10\string^(-\/m-\/1) + 10\string^(-\/m-\/1) * r * 2\string^e}}
\DoxyCodeLine{17557         \textcolor{comment}{//}}
\DoxyCodeLine{17558         p2 = r;}
\DoxyCodeLine{17559         m++;}
\DoxyCodeLine{17560         \textcolor{comment}{//}}
\DoxyCodeLine{17561         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * p2 * 2\string^e}}
\DoxyCodeLine{17562         \textcolor{comment}{// Invariant restored.}}
\DoxyCodeLine{17563 }
\DoxyCodeLine{17564         \textcolor{comment}{// Check if enough digits have been generated.}}
\DoxyCodeLine{17565         \textcolor{comment}{//}}
\DoxyCodeLine{17566         \textcolor{comment}{//      10\string^-\/m * p2 * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{17567         \textcolor{comment}{//              p2 * 2\string^e <= 10\string^m * delta * 2\string^e}}
\DoxyCodeLine{17568         \textcolor{comment}{//                    p2 <= 10\string^m * delta}}
\DoxyCodeLine{17569         delta *= 10;}
\DoxyCodeLine{17570         dist  *= 10;}
\DoxyCodeLine{17571         \textcolor{keywordflow}{if} (p2 <= delta)}
\DoxyCodeLine{17572         \{}
\DoxyCodeLine{17573             \textcolor{keywordflow}{break};}
\DoxyCodeLine{17574         \}}
\DoxyCodeLine{17575     \}}
\DoxyCodeLine{17576 }
\DoxyCodeLine{17577     \textcolor{comment}{// V = buffer * 10\string^-\/m, with M-\/ <= V <= M+.}}
\DoxyCodeLine{17578 }
\DoxyCodeLine{17579     decimal\_exponent -\/= m;}
\DoxyCodeLine{17580 }
\DoxyCodeLine{17581     \textcolor{comment}{// 1 ulp in the decimal representation is now 10\string^-\/m.}}
\DoxyCodeLine{17582     \textcolor{comment}{// Since delta and dist are now scaled by 10\string^m, we need to do the}}
\DoxyCodeLine{17583     \textcolor{comment}{// same with ulp in order to keep the units in sync.}}
\DoxyCodeLine{17584     \textcolor{comment}{//}}
\DoxyCodeLine{17585     \textcolor{comment}{//      10\string^m * 10\string^-\/m = 1 = 2\string^-\/e * 2\string^e = ten\_m * 2\string^e}}
\DoxyCodeLine{17586     \textcolor{comment}{//}}
\DoxyCodeLine{17587     \textcolor{keyword}{const} std::uint64\_t ten\_m = one.f;}
\DoxyCodeLine{17588     grisu2\_round(buffer, length, dist, delta, p2, ten\_m);}
\DoxyCodeLine{17589 }
\DoxyCodeLine{17590     \textcolor{comment}{// By construction this algorithm generates the shortest possible decimal}}
\DoxyCodeLine{17591     \textcolor{comment}{// number (Loitsch, Theorem 6.2) which rounds back to w.}}
\DoxyCodeLine{17592     \textcolor{comment}{// For an input number of precision p, at least}}
\DoxyCodeLine{17593     \textcolor{comment}{//}}
\DoxyCodeLine{17594     \textcolor{comment}{//      N = 1 + ceil(p * log\_10(2))}}
\DoxyCodeLine{17595     \textcolor{comment}{//}}
\DoxyCodeLine{17596     \textcolor{comment}{// decimal digits are sufficient to identify all binary floating-\/point}}
\DoxyCodeLine{17597     \textcolor{comment}{// numbers (Matula, "{}In-\/and-\/Out conversions"{}).}}
\DoxyCodeLine{17598     \textcolor{comment}{// This implies that the algorithm does not produce more than N decimal}}
\DoxyCodeLine{17599     \textcolor{comment}{// digits.}}
\DoxyCodeLine{17600     \textcolor{comment}{//}}
\DoxyCodeLine{17601     \textcolor{comment}{//      N = 17 for p = 53 (IEEE double precision)}}
\DoxyCodeLine{17602     \textcolor{comment}{//      N = 9  for p = 24 (IEEE single precision)}}
\DoxyCodeLine{17603 \}}
\DoxyCodeLine{17604 }
\DoxyCodeLine{17610 JSON\_HEDLEY\_NON\_NULL(1)}
\DoxyCodeLine{17611 inline \textcolor{keywordtype}{void} grisu2(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{int}\& len, \textcolor{keywordtype}{int}\& decimal\_exponent,}
\DoxyCodeLine{17612                    \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\_minus, \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} v, \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\_plus)}
\DoxyCodeLine{17613 \{}
\DoxyCodeLine{17614     JSON\_ASSERT(m\_plus.e == m\_minus.e);}
\DoxyCodeLine{17615     JSON\_ASSERT(m\_plus.e == v.e);}
\DoxyCodeLine{17616 }
\DoxyCodeLine{17617     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/    (A)}}
\DoxyCodeLine{17618     \textcolor{comment}{//          m-\/                      v                       m+}}
\DoxyCodeLine{17619     \textcolor{comment}{//}}
\DoxyCodeLine{17620     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/    (B)}}
\DoxyCodeLine{17621     \textcolor{comment}{//                      m-\/          v                       m+}}
\DoxyCodeLine{17622     \textcolor{comment}{//}}
\DoxyCodeLine{17623     \textcolor{comment}{// First scale v (and m-\/ and m+) such that the exponent is in the range}}
\DoxyCodeLine{17624     \textcolor{comment}{// [alpha, gamma].}}
\DoxyCodeLine{17625 }
\DoxyCodeLine{17626     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1cached__power}{cached\_power}} cached = \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a29ae6574f6be09a5c8ab08da9a3f71b4}{get\_cached\_power\_for\_binary\_exponent}}(m\_plus.e);}
\DoxyCodeLine{17627 }
\DoxyCodeLine{17628     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} c\_minus\_k(cached.f, cached.e); \textcolor{comment}{// = c \string~= 10\string^-\/k}}
\DoxyCodeLine{17629 }
\DoxyCodeLine{17630     \textcolor{comment}{// The exponent of the products is = v.e + c\_minus\_k.e + q and is in the range [alpha,gamma]}}
\DoxyCodeLine{17631     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w       = diyfp::mul(v,       c\_minus\_k);}
\DoxyCodeLine{17632     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w\_minus = diyfp::mul(m\_minus, c\_minus\_k);}
\DoxyCodeLine{17633     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} w\_plus  = diyfp::mul(m\_plus,  c\_minus\_k);}
\DoxyCodeLine{17634 }
\DoxyCodeLine{17635     \textcolor{comment}{//  -\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/}}
\DoxyCodeLine{17636     \textcolor{comment}{//          w-\/                      w                       w+}}
\DoxyCodeLine{17637     \textcolor{comment}{//          = c*m-\/                  = c*v                   = c*m+}}
\DoxyCodeLine{17638     \textcolor{comment}{//}}
\DoxyCodeLine{17639     \textcolor{comment}{// diyfp::mul rounds its result and c\_minus\_k is approximated too. w, w-\/ and}}
\DoxyCodeLine{17640     \textcolor{comment}{// w+ are now off by a small amount.}}
\DoxyCodeLine{17641     \textcolor{comment}{// In fact:}}
\DoxyCodeLine{17642     \textcolor{comment}{//}}
\DoxyCodeLine{17643     \textcolor{comment}{//      w -\/ v * 10\string^k < 1 ulp}}
\DoxyCodeLine{17644     \textcolor{comment}{//}}
\DoxyCodeLine{17645     \textcolor{comment}{// To account for this inaccuracy, add resp. subtract 1 ulp.}}
\DoxyCodeLine{17646     \textcolor{comment}{//}}
\DoxyCodeLine{17647     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{17648     \textcolor{comment}{//          w-\/  M-\/                  w                   M+  w+}}
\DoxyCodeLine{17649     \textcolor{comment}{//}}
\DoxyCodeLine{17650     \textcolor{comment}{// Now any number in [M-\/, M+] (bounds included) will round to w when input,}}
\DoxyCodeLine{17651     \textcolor{comment}{// regardless of how the input rounding algorithm breaks ties.}}
\DoxyCodeLine{17652     \textcolor{comment}{//}}
\DoxyCodeLine{17653     \textcolor{comment}{// And digit\_gen generates the shortest possible such number in [M-\/, M+].}}
\DoxyCodeLine{17654     \textcolor{comment}{// Note that this does not mean that Grisu2 always generates the shortest}}
\DoxyCodeLine{17655     \textcolor{comment}{// possible number in the interval (m-\/, m+).}}
\DoxyCodeLine{17656     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\_minus(w\_minus.f + 1, w\_minus.e);}
\DoxyCodeLine{17657     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\_plus (w\_plus.f  -\/ 1, w\_plus.e );}
\DoxyCodeLine{17658 }
\DoxyCodeLine{17659     decimal\_exponent = -\/cached.k; \textcolor{comment}{// = -\/(-\/k) = k}}
\DoxyCodeLine{17660 }
\DoxyCodeLine{17661     \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_ae877aa13ab872c99a1c614e5e1524807}{grisu2\_digit\_gen}}(buf, len, decimal\_exponent, M\_minus, w, M\_plus);}
\DoxyCodeLine{17662 \}}
\DoxyCodeLine{17663 }
\DoxyCodeLine{17669 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FloatType>}
\DoxyCodeLine{17670 JSON\_HEDLEY\_NON\_NULL(1)}
\DoxyCodeLine{17671 void grisu2(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{int}\& len, \textcolor{keywordtype}{int}\& decimal\_exponent, FloatType value)}
\DoxyCodeLine{17672 \{}
\DoxyCodeLine{17673     \textcolor{keyword}{static\_assert}(diyfp::kPrecision >= std::numeric\_limits<FloatType>::digits + 3,}
\DoxyCodeLine{17674                   \textcolor{stringliteral}{"{}internal error: not enough precision"{}});}
\DoxyCodeLine{17675 }
\DoxyCodeLine{17676     JSON\_ASSERT(std::isfinite(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}));}
\DoxyCodeLine{17677     JSON\_ASSERT(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} > 0);}
\DoxyCodeLine{17678 }
\DoxyCodeLine{17679     \textcolor{comment}{// If the neighbors (and boundaries) of 'value' are always computed for double-\/precision}}
\DoxyCodeLine{17680     \textcolor{comment}{// numbers, all float's can be recovered using strtod (and strtof). However, the resulting}}
\DoxyCodeLine{17681     \textcolor{comment}{// decimal representations are not exactly "{}short"{}.}}
\DoxyCodeLine{17682     \textcolor{comment}{//}}
\DoxyCodeLine{17683     \textcolor{comment}{// The documentation for 'std::to\_chars' (https://en.cppreference.com/w/cpp/utility/to\_chars)}}
\DoxyCodeLine{17684     \textcolor{comment}{// says "{}value is converted to a string as if by std::sprintf in the default ("{}C"{}) locale"{}}}
\DoxyCodeLine{17685     \textcolor{comment}{// and since sprintf promotes floats to doubles, I think this is exactly what 'std::to\_chars'}}
\DoxyCodeLine{17686     \textcolor{comment}{// does.}}
\DoxyCodeLine{17687     \textcolor{comment}{// On the other hand, the documentation for 'std::to\_chars' requires that "{}parsing the}}
\DoxyCodeLine{17688     \textcolor{comment}{// representation using the corresponding std::from\_chars function recovers value exactly"{}. That}}
\DoxyCodeLine{17689     \textcolor{comment}{// indicates that single precision floating-\/point numbers should be recovered using}}
\DoxyCodeLine{17690     \textcolor{comment}{// 'std::strtof'.}}
\DoxyCodeLine{17691     \textcolor{comment}{//}}
\DoxyCodeLine{17692     \textcolor{comment}{// NB: If the neighbors are computed for single-\/precision numbers, there is a single float}}
\DoxyCodeLine{17693     \textcolor{comment}{//     (7.0385307e-\/26f) which can't be recovered using strtod. The resulting double precision}}
\DoxyCodeLine{17694     \textcolor{comment}{//     value is off by 1 ulp.}}
\DoxyCodeLine{17695 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{17696     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1boundaries}{boundaries}} w = \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a6a5ccf11847aab7a0f42f587b33935df}{compute\_boundaries}}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}));}
\DoxyCodeLine{17697 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17698     \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1dtoa__impl_1_1boundaries}{boundaries}} w = \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_a6a5ccf11847aab7a0f42f587b33935df}{compute\_boundaries}}(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}});}
\DoxyCodeLine{17699 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17700 }
\DoxyCodeLine{17701     \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_ad549352ed1a9676a092d143a2daa3dee}{grisu2}}(buf, len, decimal\_exponent, w.minus, w.w, w.plus);}
\DoxyCodeLine{17702 \}}
\DoxyCodeLine{17703 }
\DoxyCodeLine{17709 JSON\_HEDLEY\_NON\_NULL(1)}
\DoxyCodeLine{17710 JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{17711 inline \textcolor{keywordtype}{char}* append\_exponent(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{int} e)}
\DoxyCodeLine{17712 \{}
\DoxyCodeLine{17713     JSON\_ASSERT(e > -\/1000);}
\DoxyCodeLine{17714     JSON\_ASSERT(e <  1000);}
\DoxyCodeLine{17715 }
\DoxyCodeLine{17716     \textcolor{keywordflow}{if} (e < 0)}
\DoxyCodeLine{17717     \{}
\DoxyCodeLine{17718         e = -\/e;}
\DoxyCodeLine{17719         *buf++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{17720     \}}
\DoxyCodeLine{17721     \textcolor{keywordflow}{else}}
\DoxyCodeLine{17722     \{}
\DoxyCodeLine{17723         *buf++ = \textcolor{charliteral}{'+'};}
\DoxyCodeLine{17724     \}}
\DoxyCodeLine{17725 }
\DoxyCodeLine{17726     \textcolor{keyword}{auto} k = \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(e);}
\DoxyCodeLine{17727     \textcolor{keywordflow}{if} (k < 10)}
\DoxyCodeLine{17728     \{}
\DoxyCodeLine{17729         \textcolor{comment}{// Always print at least two digits in the exponent.}}
\DoxyCodeLine{17730         \textcolor{comment}{// This is for compatibility with printf("{}\%g"{}).}}
\DoxyCodeLine{17731         *buf++ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{17732         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{17733     \}}
\DoxyCodeLine{17734     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (k < 100)}
\DoxyCodeLine{17735     \{}
\DoxyCodeLine{17736         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 10);}
\DoxyCodeLine{17737         k \%= 10;}
\DoxyCodeLine{17738         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{17739     \}}
\DoxyCodeLine{17740     \textcolor{keywordflow}{else}}
\DoxyCodeLine{17741     \{}
\DoxyCodeLine{17742         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 100);}
\DoxyCodeLine{17743         k \%= 100;}
\DoxyCodeLine{17744         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 10);}
\DoxyCodeLine{17745         k \%= 10;}
\DoxyCodeLine{17746         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{17747     \}}
\DoxyCodeLine{17748 }
\DoxyCodeLine{17749     \textcolor{keywordflow}{return} buf;}
\DoxyCodeLine{17750 \}}
\DoxyCodeLine{17751 }
\DoxyCodeLine{17761 JSON\_HEDLEY\_NON\_NULL(1)}
\DoxyCodeLine{17762 JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{17763 inline \textcolor{keywordtype}{char}* format\_buffer(\textcolor{keywordtype}{char}* buf, \textcolor{keywordtype}{int} len, \textcolor{keywordtype}{int} decimal\_exponent,}
\DoxyCodeLine{17764                            \textcolor{keywordtype}{int} min\_exp, \textcolor{keywordtype}{int} max\_exp)}
\DoxyCodeLine{17765 \{}
\DoxyCodeLine{17766     JSON\_ASSERT(min\_exp < 0);}
\DoxyCodeLine{17767     JSON\_ASSERT(max\_exp > 0);}
\DoxyCodeLine{17768 }
\DoxyCodeLine{17769     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = len;}
\DoxyCodeLine{17770     \textcolor{keyword}{const} \textcolor{keywordtype}{int} n = len + decimal\_exponent;}
\DoxyCodeLine{17771 }
\DoxyCodeLine{17772     \textcolor{comment}{// v = buf * 10\string^(n-\/k)}}
\DoxyCodeLine{17773     \textcolor{comment}{// k is the length of the buffer (number of decimal digits)}}
\DoxyCodeLine{17774     \textcolor{comment}{// n is the position of the decimal point relative to the start of the buffer.}}
\DoxyCodeLine{17775 }
\DoxyCodeLine{17776     \textcolor{keywordflow}{if} (k <= n \&\& n <= max\_exp)}
\DoxyCodeLine{17777     \{}
\DoxyCodeLine{17778         \textcolor{comment}{// digits[000]}}
\DoxyCodeLine{17779         \textcolor{comment}{// len <= max\_exp + 2}}
\DoxyCodeLine{17780 }
\DoxyCodeLine{17781         std::memset(buf + k, \textcolor{charliteral}{'0'}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n) -\/ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k));}
\DoxyCodeLine{17782         \textcolor{comment}{// Make it look like a floating-\/point number (\#362, \#378)}}
\DoxyCodeLine{17783         buf[n + 0] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{17784         buf[n + 1] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{17785         \textcolor{keywordflow}{return} buf + (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n) + 2);}
\DoxyCodeLine{17786     \}}
\DoxyCodeLine{17787 }
\DoxyCodeLine{17788     \textcolor{keywordflow}{if} (0 < n \&\& n <= max\_exp)}
\DoxyCodeLine{17789     \{}
\DoxyCodeLine{17790         \textcolor{comment}{// dig.its}}
\DoxyCodeLine{17791         \textcolor{comment}{// len <= max\_digits10 + 1}}
\DoxyCodeLine{17792 }
\DoxyCodeLine{17793         JSON\_ASSERT(k > n);}
\DoxyCodeLine{17794 }
\DoxyCodeLine{17795         std::memmove(buf + (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n) + 1), buf + n, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k) -\/ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n));}
\DoxyCodeLine{17796         buf[n] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{17797         \textcolor{keywordflow}{return} buf + (\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k) + 1U);}
\DoxyCodeLine{17798     \}}
\DoxyCodeLine{17799 }
\DoxyCodeLine{17800     \textcolor{keywordflow}{if} (min\_exp < n \&\& n <= 0)}
\DoxyCodeLine{17801     \{}
\DoxyCodeLine{17802         \textcolor{comment}{// 0.[000]digits}}
\DoxyCodeLine{17803         \textcolor{comment}{// len <= 2 + (-\/min\_exp -\/ 1) + max\_digits10}}
\DoxyCodeLine{17804 }
\DoxyCodeLine{17805         std::memmove(buf + (2 + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(-\/n)), buf, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k));}
\DoxyCodeLine{17806         buf[0] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{17807         buf[1] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{17808         std::memset(buf + 2, \textcolor{charliteral}{'0'}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(-\/n));}
\DoxyCodeLine{17809         \textcolor{keywordflow}{return} buf + (2U + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(-\/n) + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k));}
\DoxyCodeLine{17810     \}}
\DoxyCodeLine{17811 }
\DoxyCodeLine{17812     \textcolor{keywordflow}{if} (k == 1)}
\DoxyCodeLine{17813     \{}
\DoxyCodeLine{17814         \textcolor{comment}{// dE+123}}
\DoxyCodeLine{17815         \textcolor{comment}{// len <= 1 + 5}}
\DoxyCodeLine{17816 }
\DoxyCodeLine{17817         buf += 1;}
\DoxyCodeLine{17818     \}}
\DoxyCodeLine{17819     \textcolor{keywordflow}{else}}
\DoxyCodeLine{17820     \{}
\DoxyCodeLine{17821         \textcolor{comment}{// d.igitsE+123}}
\DoxyCodeLine{17822         \textcolor{comment}{// len <= max\_digits10 + 1 + 5}}
\DoxyCodeLine{17823 }
\DoxyCodeLine{17824         std::memmove(buf + 2, buf + 1, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k) -\/ 1);}
\DoxyCodeLine{17825         buf[1] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{17826         buf += 1 + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k);}
\DoxyCodeLine{17827     \}}
\DoxyCodeLine{17828 }
\DoxyCodeLine{17829     *buf++ = \textcolor{charliteral}{'e'};}
\DoxyCodeLine{17830     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacedetail_1_1dtoa__impl_aec9f6655c3b629aeb0e8c887aea5da87}{append\_exponent}}(buf, n -\/ 1);}
\DoxyCodeLine{17831 \}}
\DoxyCodeLine{17832 }
\DoxyCodeLine{17833 \}  \textcolor{comment}{// namespace dtoa\_impl}}
\DoxyCodeLine{17834 }
\DoxyCodeLine{17845 \textcolor{keyword}{template}<\textcolor{keyword}{typename} FloatType>}
\DoxyCodeLine{17846 JSON\_HEDLEY\_NON\_NULL(1, 2)}
\DoxyCodeLine{17847 JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{17848 \textcolor{keywordtype}{char}* to\_chars(\textcolor{keywordtype}{char}* first, const \textcolor{keywordtype}{char}* last, FloatType value)}
\DoxyCodeLine{17849 \{}
\DoxyCodeLine{17850     \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(last); \textcolor{comment}{// maybe unused -\/ fix warning}}
\DoxyCodeLine{17851     JSON\_ASSERT(std::isfinite(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}));}
\DoxyCodeLine{17852 }
\DoxyCodeLine{17853     \textcolor{comment}{// Use signbit(value) instead of (value < 0) since signbit works for -\/0.}}
\DoxyCodeLine{17854     \textcolor{keywordflow}{if} (std::signbit(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}))}
\DoxyCodeLine{17855     \{}
\DoxyCodeLine{17856         \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} = -\/\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}};}
\DoxyCodeLine{17857         *first++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{17858     \}}
\DoxyCodeLine{17859 }
\DoxyCodeLine{17860 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{17861 \textcolor{preprocessor}{\#pragma GCC diagnostic push}}
\DoxyCodeLine{17862 \textcolor{preprocessor}{\#pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}}}
\DoxyCodeLine{17863 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17864     \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}} == 0) \textcolor{comment}{// +-\/0}}
\DoxyCodeLine{17865     \{}
\DoxyCodeLine{17866         *first++ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{17867         \textcolor{comment}{// Make it look like a floating-\/point number (\#362, \#378)}}
\DoxyCodeLine{17868         *first++ = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{17869         *first++ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{17870         \textcolor{keywordflow}{return} first;}
\DoxyCodeLine{17871     \}}
\DoxyCodeLine{17872 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{17873 \textcolor{preprocessor}{\#pragma GCC diagnostic pop}}
\DoxyCodeLine{17874 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17875 }
\DoxyCodeLine{17876     JSON\_ASSERT(last -\/ first >= std::numeric\_limits<FloatType>::max\_digits10);}
\DoxyCodeLine{17877 }
\DoxyCodeLine{17878     \textcolor{comment}{// Compute v = buffer * 10\string^decimal\_exponent.}}
\DoxyCodeLine{17879     \textcolor{comment}{// The decimal digits are stored in the buffer, which needs to be interpreted}}
\DoxyCodeLine{17880     \textcolor{comment}{// as an unsigned decimal integer.}}
\DoxyCodeLine{17881     \textcolor{comment}{// len is the length of the buffer, i.e. the number of decimal digits.}}
\DoxyCodeLine{17882     \textcolor{keywordtype}{int} len = 0;}
\DoxyCodeLine{17883     \textcolor{keywordtype}{int} decimal\_exponent = 0;}
\DoxyCodeLine{17884     dtoa\_impl::grisu2(first, len, decimal\_exponent, \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}});}
\DoxyCodeLine{17885 }
\DoxyCodeLine{17886     JSON\_ASSERT(len <= std::numeric\_limits<FloatType>::max\_digits10);}
\DoxyCodeLine{17887 }
\DoxyCodeLine{17888     \textcolor{comment}{// Format the buffer like printf("{}\%.*g"{}, prec, value)}}
\DoxyCodeLine{17889     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kMinExp = -\/4;}
\DoxyCodeLine{17890     \textcolor{comment}{// Use digits10 here to increase compatibility with version 2.}}
\DoxyCodeLine{17891     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} kMaxExp = std::numeric\_limits<FloatType>::digits10;}
\DoxyCodeLine{17892 }
\DoxyCodeLine{17893     JSON\_ASSERT(last -\/ first >= kMaxExp + 2);}
\DoxyCodeLine{17894     JSON\_ASSERT(last -\/ first >= 2 + (-\/kMinExp -\/ 1) + std::numeric\_limits<FloatType>::max\_digits10);}
\DoxyCodeLine{17895     JSON\_ASSERT(last -\/ first >= std::numeric\_limits<FloatType>::max\_digits10 + 6);}
\DoxyCodeLine{17896 }
\DoxyCodeLine{17897     \textcolor{keywordflow}{return} dtoa\_impl::format\_buffer(first, len, decimal\_exponent, kMinExp, kMaxExp);}
\DoxyCodeLine{17898 \}}
\DoxyCodeLine{17899 }
\DoxyCodeLine{17900 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{17901 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{17902 }
\DoxyCodeLine{17903 \textcolor{comment}{// \#include <nlohmann/detail/exceptions.hpp>}}
\DoxyCodeLine{17904 }
\DoxyCodeLine{17905 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{17906 }
\DoxyCodeLine{17907 \textcolor{comment}{// \#include <nlohmann/detail/meta/cpp\_future.hpp>}}
\DoxyCodeLine{17908 }
\DoxyCodeLine{17909 \textcolor{comment}{// \#include <nlohmann/detail/output/binary\_writer.hpp>}}
\DoxyCodeLine{17910 }
\DoxyCodeLine{17911 \textcolor{comment}{// \#include <nlohmann/detail/output/output\_adapters.hpp>}}
\DoxyCodeLine{17912 }
\DoxyCodeLine{17913 \textcolor{comment}{// \#include <nlohmann/detail/string\_concat.hpp>}}
\DoxyCodeLine{17914 }
\DoxyCodeLine{17915 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{17916 }
\DoxyCodeLine{17917 }
\DoxyCodeLine{17918 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{17919 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail}{detail}}}
\DoxyCodeLine{17920 \{}
\DoxyCodeLine{17921 }
\DoxyCodeLine{17923 \textcolor{comment}{// serialization //}}
\DoxyCodeLine{17925 \textcolor{comment}{}}
\DoxyCodeLine{17927 \textcolor{keyword}{enum class} \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298}{error\_handler\_t}}}
\DoxyCodeLine{17928 \{}
\DoxyCodeLine{17929     \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298a2133fd717402a7966ee88d06f9e0b792}{strict}},  }
\DoxyCodeLine{17930     \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298a9dde360102c103867bd2f45872f1129c}{replace}}, }
\DoxyCodeLine{17931     \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592a567bc1d268f135496de3d5b946b691f3}{ignore}}   }
\DoxyCodeLine{17932 \};}
\DoxyCodeLine{17933 }
\DoxyCodeLine{17934 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{17935 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1serializer}{serializer}}}
\DoxyCodeLine{17936 \{}
\DoxyCodeLine{17937     \textcolor{keyword}{using }string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{17938     \textcolor{keyword}{using }number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{17939     \textcolor{keyword}{using }number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{17940     \textcolor{keyword}{using }number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{17941     \textcolor{keyword}{using }binary\_char\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t::value\_type;}
\DoxyCodeLine{17942     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::uint8\_t UTF8\_ACCEPT = 0;}
\DoxyCodeLine{17943     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::uint8\_t UTF8\_REJECT = 1;}
\DoxyCodeLine{17944 }
\DoxyCodeLine{17945   \textcolor{keyword}{public}:}
\DoxyCodeLine{17951     \mbox{\hyperlink{classdetail_1_1serializer_a3d025f3aa1e8661554858b8aaab08c3b}{serializer}}(\mbox{\hyperlink{namespacedetail_a160eb5d333fe01b259af32d3d4798a7b}{output\_adapter\_t<char>}} s, \textcolor{keyword}{const} \textcolor{keywordtype}{char} ichar,}
\DoxyCodeLine{17952                \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298}{error\_handler\_t}} error\_handler\_ = error\_handler\_t::strict)}
\DoxyCodeLine{17953         : o(std::move(s))}
\DoxyCodeLine{17954         , loc(std::localeconv())}
\DoxyCodeLine{17955         , thousands\_sep(loc-\/>thousands\_sep == nullptr ? \textcolor{stringliteral}{'\(\backslash\)0'} : std::char\_traits<char>::to\_char\_type(* (loc-\/>thousands\_sep)))}
\DoxyCodeLine{17956         , decimal\_point(loc-\/>decimal\_point == nullptr ? \textcolor{stringliteral}{'\(\backslash\)0'} : std::char\_traits<char>::to\_char\_type(* (loc-\/>decimal\_point)))}
\DoxyCodeLine{17957         , indent\_char(ichar)}
\DoxyCodeLine{17958         , indent\_string(512, indent\_char)}
\DoxyCodeLine{17959         , error\_handler(error\_handler\_)}
\DoxyCodeLine{17960     \{\}}
\DoxyCodeLine{17961 }
\DoxyCodeLine{17962     \textcolor{comment}{// delete because of pointer members}}
\DoxyCodeLine{17963     \mbox{\hyperlink{classdetail_1_1serializer}{serializer}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1serializer}{serializer}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{17964     \mbox{\hyperlink{classdetail_1_1serializer}{serializer}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1serializer}{serializer}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{17965     \mbox{\hyperlink{classdetail_1_1serializer}{serializer}}(\mbox{\hyperlink{classdetail_1_1serializer}{serializer}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{17966     \mbox{\hyperlink{classdetail_1_1serializer}{serializer}}\& operator=(\mbox{\hyperlink{classdetail_1_1serializer}{serializer}}\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{17967     \mbox{\hyperlink{classdetail_1_1serializer}{\string~serializer}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{17968 }
\DoxyCodeLine{17991     \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1serializer_ae73c1bac64bcc810923b9f1261af8b09}{dump}}(\textcolor{keyword}{const} BasicJsonType\& val,}
\DoxyCodeLine{17992               \textcolor{keyword}{const} \textcolor{keywordtype}{bool} pretty\_print,}
\DoxyCodeLine{17993               \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ensure\_ascii,}
\DoxyCodeLine{17994               \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} indent\_step,}
\DoxyCodeLine{17995               \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} current\_indent = 0)}
\DoxyCodeLine{17996     \{}
\DoxyCodeLine{17997         \textcolor{keywordflow}{switch} (val.m\_type)}
\DoxyCodeLine{17998         \{}
\DoxyCodeLine{17999             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{18000             \{}
\DoxyCodeLine{18001                 \textcolor{keywordflow}{if} (val.m\_value.object-\/>empty())}
\DoxyCodeLine{18002                 \{}
\DoxyCodeLine{18003                     o-\/>write\_characters(\textcolor{stringliteral}{"{}\{\}"{}}, 2);}
\DoxyCodeLine{18004                     \textcolor{keywordflow}{return};}
\DoxyCodeLine{18005                 \}}
\DoxyCodeLine{18006 }
\DoxyCodeLine{18007                 \textcolor{keywordflow}{if} (pretty\_print)}
\DoxyCodeLine{18008                 \{}
\DoxyCodeLine{18009                     o-\/>write\_characters(\textcolor{stringliteral}{"{}\{\(\backslash\)n"{}}, 2);}
\DoxyCodeLine{18010 }
\DoxyCodeLine{18011                     \textcolor{comment}{// variable to hold indentation for recursive calls}}
\DoxyCodeLine{18012                     \textcolor{keyword}{const} \textcolor{keyword}{auto} new\_indent = current\_indent + indent\_step;}
\DoxyCodeLine{18013                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(indent\_string.size() < new\_indent))}
\DoxyCodeLine{18014                     \{}
\DoxyCodeLine{18015                         indent\_string.resize(indent\_string.size() * 2, \textcolor{charliteral}{' '});}
\DoxyCodeLine{18016                     \}}
\DoxyCodeLine{18017 }
\DoxyCodeLine{18018                     \textcolor{comment}{// first n-\/1 elements}}
\DoxyCodeLine{18019                     \textcolor{keyword}{auto} i = val.m\_value.object-\/>cbegin();}
\DoxyCodeLine{18020                     \textcolor{keywordflow}{for} (std::size\_t cnt = 0; cnt < val.m\_value.object-\/>size() -\/ 1; ++cnt, ++i)}
\DoxyCodeLine{18021                     \{}
\DoxyCodeLine{18022                         o-\/>write\_characters(indent\_string.c\_str(), new\_indent);}
\DoxyCodeLine{18023                         o-\/>write\_character(\textcolor{charliteral}{'\(\backslash\)"{}'});}
\DoxyCodeLine{18024                         dump\_escaped(i-\/>first, ensure\_ascii);}
\DoxyCodeLine{18025                         o-\/>write\_characters(\textcolor{stringliteral}{"{}\(\backslash\)"{}: "{}}, 3);}
\DoxyCodeLine{18026                         dump(i-\/>second, \textcolor{keyword}{true}, ensure\_ascii, indent\_step, new\_indent);}
\DoxyCodeLine{18027                         o-\/>write\_characters(\textcolor{stringliteral}{"{},\(\backslash\)n"{}}, 2);}
\DoxyCodeLine{18028                     \}}
\DoxyCodeLine{18029 }
\DoxyCodeLine{18030                     \textcolor{comment}{// last element}}
\DoxyCodeLine{18031                     JSON\_ASSERT(i != val.m\_value.object-\/>cend());}
\DoxyCodeLine{18032                     JSON\_ASSERT(std::next(i) == val.m\_value.object-\/>cend());}
\DoxyCodeLine{18033                     o-\/>write\_characters(indent\_string.c\_str(), new\_indent);}
\DoxyCodeLine{18034                     o-\/>write\_character(\textcolor{charliteral}{'\(\backslash\)"{}'});}
\DoxyCodeLine{18035                     dump\_escaped(i-\/>first, ensure\_ascii);}
\DoxyCodeLine{18036                     o-\/>write\_characters(\textcolor{stringliteral}{"{}\(\backslash\)"{}: "{}}, 3);}
\DoxyCodeLine{18037                     dump(i-\/>second, \textcolor{keyword}{true}, ensure\_ascii, indent\_step, new\_indent);}
\DoxyCodeLine{18038 }
\DoxyCodeLine{18039                     o-\/>write\_character(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{18040                     o-\/>write\_characters(indent\_string.c\_str(), current\_indent);}
\DoxyCodeLine{18041                     o-\/>write\_character(\textcolor{charliteral}{'\}'});}
\DoxyCodeLine{18042                 \}}
\DoxyCodeLine{18043                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{18044                 \{}
\DoxyCodeLine{18045                     o-\/>write\_character(\textcolor{charliteral}{'\{'});}
\DoxyCodeLine{18046 }
\DoxyCodeLine{18047                     \textcolor{comment}{// first n-\/1 elements}}
\DoxyCodeLine{18048                     \textcolor{keyword}{auto} i = val.m\_value.object-\/>cbegin();}
\DoxyCodeLine{18049                     \textcolor{keywordflow}{for} (std::size\_t cnt = 0; cnt < val.m\_value.object-\/>size() -\/ 1; ++cnt, ++i)}
\DoxyCodeLine{18050                     \{}
\DoxyCodeLine{18051                         o-\/>write\_character(\textcolor{charliteral}{'\(\backslash\)"{}'});}
\DoxyCodeLine{18052                         dump\_escaped(i-\/>first, ensure\_ascii);}
\DoxyCodeLine{18053                         o-\/>write\_characters(\textcolor{stringliteral}{"{}\(\backslash\)"{}:"{}}, 2);}
\DoxyCodeLine{18054                         dump(i-\/>second, \textcolor{keyword}{false}, ensure\_ascii, indent\_step, current\_indent);}
\DoxyCodeLine{18055                         o-\/>write\_character(\textcolor{charliteral}{','});}
\DoxyCodeLine{18056                     \}}
\DoxyCodeLine{18057 }
\DoxyCodeLine{18058                     \textcolor{comment}{// last element}}
\DoxyCodeLine{18059                     JSON\_ASSERT(i != val.m\_value.object-\/>cend());}
\DoxyCodeLine{18060                     JSON\_ASSERT(std::next(i) == val.m\_value.object-\/>cend());}
\DoxyCodeLine{18061                     o-\/>write\_character(\textcolor{charliteral}{'\(\backslash\)"{}'});}
\DoxyCodeLine{18062                     dump\_escaped(i-\/>first, ensure\_ascii);}
\DoxyCodeLine{18063                     o-\/>write\_characters(\textcolor{stringliteral}{"{}\(\backslash\)"{}:"{}}, 2);}
\DoxyCodeLine{18064                     dump(i-\/>second, \textcolor{keyword}{false}, ensure\_ascii, indent\_step, current\_indent);}
\DoxyCodeLine{18065 }
\DoxyCodeLine{18066                     o-\/>write\_character(\textcolor{charliteral}{'\}'});}
\DoxyCodeLine{18067                 \}}
\DoxyCodeLine{18068 }
\DoxyCodeLine{18069                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{18070             \}}
\DoxyCodeLine{18071 }
\DoxyCodeLine{18072             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{18073             \{}
\DoxyCodeLine{18074                 \textcolor{keywordflow}{if} (val.m\_value.array-\/>empty())}
\DoxyCodeLine{18075                 \{}
\DoxyCodeLine{18076                     o-\/>write\_characters(\textcolor{stringliteral}{"{}[]"{}}, 2);}
\DoxyCodeLine{18077                     \textcolor{keywordflow}{return};}
\DoxyCodeLine{18078                 \}}
\DoxyCodeLine{18079 }
\DoxyCodeLine{18080                 \textcolor{keywordflow}{if} (pretty\_print)}
\DoxyCodeLine{18081                 \{}
\DoxyCodeLine{18082                     o-\/>write\_characters(\textcolor{stringliteral}{"{}[\(\backslash\)n"{}}, 2);}
\DoxyCodeLine{18083 }
\DoxyCodeLine{18084                     \textcolor{comment}{// variable to hold indentation for recursive calls}}
\DoxyCodeLine{18085                     \textcolor{keyword}{const} \textcolor{keyword}{auto} new\_indent = current\_indent + indent\_step;}
\DoxyCodeLine{18086                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(indent\_string.size() < new\_indent))}
\DoxyCodeLine{18087                     \{}
\DoxyCodeLine{18088                         indent\_string.resize(indent\_string.size() * 2, \textcolor{charliteral}{' '});}
\DoxyCodeLine{18089                     \}}
\DoxyCodeLine{18090 }
\DoxyCodeLine{18091                     \textcolor{comment}{// first n-\/1 elements}}
\DoxyCodeLine{18092                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = val.m\_value.array-\/>cbegin();}
\DoxyCodeLine{18093                             i != val.m\_value.array-\/>cend() -\/ 1; ++i)}
\DoxyCodeLine{18094                     \{}
\DoxyCodeLine{18095                         o-\/>write\_characters(indent\_string.c\_str(), new\_indent);}
\DoxyCodeLine{18096                         dump(*i, \textcolor{keyword}{true}, ensure\_ascii, indent\_step, new\_indent);}
\DoxyCodeLine{18097                         o-\/>write\_characters(\textcolor{stringliteral}{"{},\(\backslash\)n"{}}, 2);}
\DoxyCodeLine{18098                     \}}
\DoxyCodeLine{18099 }
\DoxyCodeLine{18100                     \textcolor{comment}{// last element}}
\DoxyCodeLine{18101                     JSON\_ASSERT(!val.m\_value.array-\/>empty());}
\DoxyCodeLine{18102                     o-\/>write\_characters(indent\_string.c\_str(), new\_indent);}
\DoxyCodeLine{18103                     dump(val.m\_value.array-\/>back(), \textcolor{keyword}{true}, ensure\_ascii, indent\_step, new\_indent);}
\DoxyCodeLine{18104 }
\DoxyCodeLine{18105                     o-\/>write\_character(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{18106                     o-\/>write\_characters(indent\_string.c\_str(), current\_indent);}
\DoxyCodeLine{18107                     o-\/>write\_character(\textcolor{charliteral}{']'});}
\DoxyCodeLine{18108                 \}}
\DoxyCodeLine{18109                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{18110                 \{}
\DoxyCodeLine{18111                     o-\/>write\_character(\textcolor{charliteral}{'['});}
\DoxyCodeLine{18112 }
\DoxyCodeLine{18113                     \textcolor{comment}{// first n-\/1 elements}}
\DoxyCodeLine{18114                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = val.m\_value.array-\/>cbegin();}
\DoxyCodeLine{18115                             i != val.m\_value.array-\/>cend() -\/ 1; ++i)}
\DoxyCodeLine{18116                     \{}
\DoxyCodeLine{18117                         dump(*i, \textcolor{keyword}{false}, ensure\_ascii, indent\_step, current\_indent);}
\DoxyCodeLine{18118                         o-\/>write\_character(\textcolor{charliteral}{','});}
\DoxyCodeLine{18119                     \}}
\DoxyCodeLine{18120 }
\DoxyCodeLine{18121                     \textcolor{comment}{// last element}}
\DoxyCodeLine{18122                     JSON\_ASSERT(!val.m\_value.array-\/>empty());}
\DoxyCodeLine{18123                     dump(val.m\_value.array-\/>back(), \textcolor{keyword}{false}, ensure\_ascii, indent\_step, current\_indent);}
\DoxyCodeLine{18124 }
\DoxyCodeLine{18125                     o-\/>write\_character(\textcolor{charliteral}{']'});}
\DoxyCodeLine{18126                 \}}
\DoxyCodeLine{18127 }
\DoxyCodeLine{18128                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{18129             \}}
\DoxyCodeLine{18130 }
\DoxyCodeLine{18131             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{18132             \{}
\DoxyCodeLine{18133                 o-\/>write\_character(\textcolor{charliteral}{'\(\backslash\)"{}'});}
\DoxyCodeLine{18134                 dump\_escaped(*val.m\_value.string, ensure\_ascii);}
\DoxyCodeLine{18135                 o-\/>write\_character(\textcolor{charliteral}{'\(\backslash\)"{}'});}
\DoxyCodeLine{18136                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{18137             \}}
\DoxyCodeLine{18138 }
\DoxyCodeLine{18139             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{18140             \{}
\DoxyCodeLine{18141                 \textcolor{keywordflow}{if} (pretty\_print)}
\DoxyCodeLine{18142                 \{}
\DoxyCodeLine{18143                     o-\/>write\_characters(\textcolor{stringliteral}{"{}\{\(\backslash\)n"{}}, 2);}
\DoxyCodeLine{18144 }
\DoxyCodeLine{18145                     \textcolor{comment}{// variable to hold indentation for recursive calls}}
\DoxyCodeLine{18146                     \textcolor{keyword}{const} \textcolor{keyword}{auto} new\_indent = current\_indent + indent\_step;}
\DoxyCodeLine{18147                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(indent\_string.size() < new\_indent))}
\DoxyCodeLine{18148                     \{}
\DoxyCodeLine{18149                         indent\_string.resize(indent\_string.size() * 2, \textcolor{charliteral}{' '});}
\DoxyCodeLine{18150                     \}}
\DoxyCodeLine{18151 }
\DoxyCodeLine{18152                     o-\/>write\_characters(indent\_string.c\_str(), new\_indent);}
\DoxyCodeLine{18153 }
\DoxyCodeLine{18154                     o-\/>write\_characters(\textcolor{stringliteral}{"{}\(\backslash\)"{}bytes\(\backslash\)"{}: ["{}}, 10);}
\DoxyCodeLine{18155 }
\DoxyCodeLine{18156                     \textcolor{keywordflow}{if} (!val.m\_value.binary-\/>empty())}
\DoxyCodeLine{18157                     \{}
\DoxyCodeLine{18158                         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = val.m\_value.binary-\/>cbegin();}
\DoxyCodeLine{18159                                 i != val.m\_value.binary-\/>cend() -\/ 1; ++i)}
\DoxyCodeLine{18160                         \{}
\DoxyCodeLine{18161                             dump\_integer(*i);}
\DoxyCodeLine{18162                             o-\/>write\_characters(\textcolor{stringliteral}{"{}, "{}}, 2);}
\DoxyCodeLine{18163                         \}}
\DoxyCodeLine{18164                         dump\_integer(val.m\_value.binary-\/>back());}
\DoxyCodeLine{18165                     \}}
\DoxyCodeLine{18166 }
\DoxyCodeLine{18167                     o-\/>write\_characters(\textcolor{stringliteral}{"{}],\(\backslash\)n"{}}, 3);}
\DoxyCodeLine{18168                     o-\/>write\_characters(indent\_string.c\_str(), new\_indent);}
\DoxyCodeLine{18169 }
\DoxyCodeLine{18170                     o-\/>write\_characters(\textcolor{stringliteral}{"{}\(\backslash\)"{}subtype\(\backslash\)"{}: "{}}, 11);}
\DoxyCodeLine{18171                     \textcolor{keywordflow}{if} (val.m\_value.binary-\/>has\_subtype())}
\DoxyCodeLine{18172                     \{}
\DoxyCodeLine{18173                         dump\_integer(val.m\_value.binary-\/>subtype());}
\DoxyCodeLine{18174                     \}}
\DoxyCodeLine{18175                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{18176                     \{}
\DoxyCodeLine{18177                         o-\/>write\_characters(\textcolor{stringliteral}{"{}null"{}}, 4);}
\DoxyCodeLine{18178                     \}}
\DoxyCodeLine{18179                     o-\/>write\_character(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{18180                     o-\/>write\_characters(indent\_string.c\_str(), current\_indent);}
\DoxyCodeLine{18181                     o-\/>write\_character(\textcolor{charliteral}{'\}'});}
\DoxyCodeLine{18182                 \}}
\DoxyCodeLine{18183                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{18184                 \{}
\DoxyCodeLine{18185                     o-\/>write\_characters(\textcolor{stringliteral}{"{}\{\(\backslash\)"{}bytes\(\backslash\)"{}:["{}}, 10);}
\DoxyCodeLine{18186 }
\DoxyCodeLine{18187                     \textcolor{keywordflow}{if} (!val.m\_value.binary-\/>empty())}
\DoxyCodeLine{18188                     \{}
\DoxyCodeLine{18189                         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = val.m\_value.binary-\/>cbegin();}
\DoxyCodeLine{18190                                 i != val.m\_value.binary-\/>cend() -\/ 1; ++i)}
\DoxyCodeLine{18191                         \{}
\DoxyCodeLine{18192                             dump\_integer(*i);}
\DoxyCodeLine{18193                             o-\/>write\_character(\textcolor{charliteral}{','});}
\DoxyCodeLine{18194                         \}}
\DoxyCodeLine{18195                         dump\_integer(val.m\_value.binary-\/>back());}
\DoxyCodeLine{18196                     \}}
\DoxyCodeLine{18197 }
\DoxyCodeLine{18198                     o-\/>write\_characters(\textcolor{stringliteral}{"{}],\(\backslash\)"{}subtype\(\backslash\)"{}:"{}}, 12);}
\DoxyCodeLine{18199                     \textcolor{keywordflow}{if} (val.m\_value.binary-\/>has\_subtype())}
\DoxyCodeLine{18200                     \{}
\DoxyCodeLine{18201                         dump\_integer(val.m\_value.binary-\/>subtype());}
\DoxyCodeLine{18202                         o-\/>write\_character(\textcolor{charliteral}{'\}'});}
\DoxyCodeLine{18203                     \}}
\DoxyCodeLine{18204                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{18205                     \{}
\DoxyCodeLine{18206                         o-\/>write\_characters(\textcolor{stringliteral}{"{}null\}"{}}, 5);}
\DoxyCodeLine{18207                     \}}
\DoxyCodeLine{18208                 \}}
\DoxyCodeLine{18209                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{18210             \}}
\DoxyCodeLine{18211 }
\DoxyCodeLine{18212             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{18213             \{}
\DoxyCodeLine{18214                 \textcolor{keywordflow}{if} (val.m\_value.boolean)}
\DoxyCodeLine{18215                 \{}
\DoxyCodeLine{18216                     o-\/>write\_characters(\textcolor{stringliteral}{"{}true"{}}, 4);}
\DoxyCodeLine{18217                 \}}
\DoxyCodeLine{18218                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{18219                 \{}
\DoxyCodeLine{18220                     o-\/>write\_characters(\textcolor{stringliteral}{"{}false"{}}, 5);}
\DoxyCodeLine{18221                 \}}
\DoxyCodeLine{18222                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{18223             \}}
\DoxyCodeLine{18224 }
\DoxyCodeLine{18225             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{18226             \{}
\DoxyCodeLine{18227                 dump\_integer(val.m\_value.number\_integer);}
\DoxyCodeLine{18228                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{18229             \}}
\DoxyCodeLine{18230 }
\DoxyCodeLine{18231             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{18232             \{}
\DoxyCodeLine{18233                 dump\_integer(val.m\_value.number\_unsigned);}
\DoxyCodeLine{18234                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{18235             \}}
\DoxyCodeLine{18236 }
\DoxyCodeLine{18237             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{18238             \{}
\DoxyCodeLine{18239                 dump\_float(val.m\_value.number\_float);}
\DoxyCodeLine{18240                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{18241             \}}
\DoxyCodeLine{18242 }
\DoxyCodeLine{18243             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{18244             \{}
\DoxyCodeLine{18245                 o-\/>write\_characters(\textcolor{stringliteral}{"{}<discarded>"{}}, 11);}
\DoxyCodeLine{18246                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{18247             \}}
\DoxyCodeLine{18248 }
\DoxyCodeLine{18249             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{18250             \{}
\DoxyCodeLine{18251                 o-\/>write\_characters(\textcolor{stringliteral}{"{}null"{}}, 4);}
\DoxyCodeLine{18252                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{18253             \}}
\DoxyCodeLine{18254 }
\DoxyCodeLine{18255             \textcolor{keywordflow}{default}:            \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{18256                 JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{18257         \}}
\DoxyCodeLine{18258     \}}
\DoxyCodeLine{18259 }
\DoxyCodeLine{18260   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{18275     \textcolor{keywordtype}{void} dump\_escaped(\textcolor{keyword}{const} string\_t\& s, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ensure\_ascii)}
\DoxyCodeLine{18276     \{}
\DoxyCodeLine{18277         std::uint32\_t codepoint\{\};}
\DoxyCodeLine{18278         std::uint8\_t state = UTF8\_ACCEPT;}
\DoxyCodeLine{18279         std::size\_t bytes = 0;  \textcolor{comment}{// number of bytes written to string\_buffer}}
\DoxyCodeLine{18280 }
\DoxyCodeLine{18281         \textcolor{comment}{// number of bytes written at the point of the last valid byte}}
\DoxyCodeLine{18282         std::size\_t bytes\_after\_last\_accept = 0;}
\DoxyCodeLine{18283         std::size\_t undumped\_chars = 0;}
\DoxyCodeLine{18284 }
\DoxyCodeLine{18285         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < s.size(); ++i)}
\DoxyCodeLine{18286         \{}
\DoxyCodeLine{18287             \textcolor{keyword}{const} \textcolor{keyword}{auto} \textcolor{keywordtype}{byte} = \textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(s[i]);}
\DoxyCodeLine{18288 }
\DoxyCodeLine{18289             \textcolor{keywordflow}{switch} (decode(state, codepoint, \textcolor{keywordtype}{byte}))}
\DoxyCodeLine{18290             \{}
\DoxyCodeLine{18291                 \textcolor{keywordflow}{case} UTF8\_ACCEPT:  \textcolor{comment}{// decode found a new code point}}
\DoxyCodeLine{18292                 \{}
\DoxyCodeLine{18293                     \textcolor{keywordflow}{switch} (codepoint)}
\DoxyCodeLine{18294                     \{}
\DoxyCodeLine{18295                         \textcolor{keywordflow}{case} 0x08: \textcolor{comment}{// backspace}}
\DoxyCodeLine{18296                         \{}
\DoxyCodeLine{18297                             string\_buffer[bytes++] = \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};}
\DoxyCodeLine{18298                             string\_buffer[bytes++] = \textcolor{charliteral}{'b'};}
\DoxyCodeLine{18299                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{18300                         \}}
\DoxyCodeLine{18301 }
\DoxyCodeLine{18302                         \textcolor{keywordflow}{case} 0x09: \textcolor{comment}{// horizontal tab}}
\DoxyCodeLine{18303                         \{}
\DoxyCodeLine{18304                             string\_buffer[bytes++] = \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};}
\DoxyCodeLine{18305                             string\_buffer[bytes++] = \textcolor{charliteral}{'t'};}
\DoxyCodeLine{18306                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{18307                         \}}
\DoxyCodeLine{18308 }
\DoxyCodeLine{18309                         \textcolor{keywordflow}{case} 0x0A: \textcolor{comment}{// newline}}
\DoxyCodeLine{18310                         \{}
\DoxyCodeLine{18311                             string\_buffer[bytes++] = \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};}
\DoxyCodeLine{18312                             string\_buffer[bytes++] = \textcolor{charliteral}{'n'};}
\DoxyCodeLine{18313                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{18314                         \}}
\DoxyCodeLine{18315 }
\DoxyCodeLine{18316                         \textcolor{keywordflow}{case} 0x0C: \textcolor{comment}{// formfeed}}
\DoxyCodeLine{18317                         \{}
\DoxyCodeLine{18318                             string\_buffer[bytes++] = \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};}
\DoxyCodeLine{18319                             string\_buffer[bytes++] = \textcolor{charliteral}{'f'};}
\DoxyCodeLine{18320                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{18321                         \}}
\DoxyCodeLine{18322 }
\DoxyCodeLine{18323                         \textcolor{keywordflow}{case} 0x0D: \textcolor{comment}{// carriage return}}
\DoxyCodeLine{18324                         \{}
\DoxyCodeLine{18325                             string\_buffer[bytes++] = \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};}
\DoxyCodeLine{18326                             string\_buffer[bytes++] = \textcolor{charliteral}{'r'};}
\DoxyCodeLine{18327                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{18328                         \}}
\DoxyCodeLine{18329 }
\DoxyCodeLine{18330                         \textcolor{keywordflow}{case} 0x22: \textcolor{comment}{// quotation mark}}
\DoxyCodeLine{18331                         \{}
\DoxyCodeLine{18332                             string\_buffer[bytes++] = \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};}
\DoxyCodeLine{18333                             string\_buffer[bytes++] = \textcolor{charliteral}{'\(\backslash\)"{}'};}
\DoxyCodeLine{18334                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{18335                         \}}
\DoxyCodeLine{18336 }
\DoxyCodeLine{18337                         \textcolor{keywordflow}{case} 0x5C: \textcolor{comment}{// reverse solidus}}
\DoxyCodeLine{18338                         \{}
\DoxyCodeLine{18339                             string\_buffer[bytes++] = \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};}
\DoxyCodeLine{18340                             string\_buffer[bytes++] = \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};}
\DoxyCodeLine{18341                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{18342                         \}}
\DoxyCodeLine{18343 }
\DoxyCodeLine{18344                         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{18345                         \{}
\DoxyCodeLine{18346                             \textcolor{comment}{// escape control characters (0x00..0x1F) or, if}}
\DoxyCodeLine{18347                             \textcolor{comment}{// ensure\_ascii parameter is used, non-\/ASCII characters}}
\DoxyCodeLine{18348                             \textcolor{keywordflow}{if} ((codepoint <= 0x1F) || (ensure\_ascii \&\& (codepoint >= 0x7F)))}
\DoxyCodeLine{18349                             \{}
\DoxyCodeLine{18350                                 \textcolor{keywordflow}{if} (codepoint <= 0xFFFF)}
\DoxyCodeLine{18351                                 \{}
\DoxyCodeLine{18352                                     \textcolor{comment}{// NOLINTNEXTLINE(cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{18353                                     \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}((std::snprintf)(string\_buffer.data() + bytes, 7, \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)u\%04x"{}},}
\DoxyCodeLine{18354                                                                       \textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(codepoint)));}
\DoxyCodeLine{18355                                     bytes += 6;}
\DoxyCodeLine{18356                                 \}}
\DoxyCodeLine{18357                                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{18358                                 \{}
\DoxyCodeLine{18359                                     \textcolor{comment}{// NOLINTNEXTLINE(cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{18360                                     \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}((std::snprintf)(string\_buffer.data() + bytes, 13, \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)u\%04x\(\backslash\)\(\backslash\)u\%04x"{}},}
\DoxyCodeLine{18361                                                                       \textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(0xD7C0u + (codepoint >> 10u)),}
\DoxyCodeLine{18362                                                                       \textcolor{keyword}{static\_cast<}std::uint16\_t\textcolor{keyword}{>}(0xDC00u + (codepoint \& 0x3FFu))));}
\DoxyCodeLine{18363                                     bytes += 12;}
\DoxyCodeLine{18364                                 \}}
\DoxyCodeLine{18365                             \}}
\DoxyCodeLine{18366                             \textcolor{keywordflow}{else}}
\DoxyCodeLine{18367                             \{}
\DoxyCodeLine{18368                                 \textcolor{comment}{// copy byte to buffer (all previous bytes}}
\DoxyCodeLine{18369                                 \textcolor{comment}{// been copied have in default case above)}}
\DoxyCodeLine{18370                                 string\_buffer[bytes++] = s[i];}
\DoxyCodeLine{18371                             \}}
\DoxyCodeLine{18372                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{18373                         \}}
\DoxyCodeLine{18374                     \}}
\DoxyCodeLine{18375 }
\DoxyCodeLine{18376                     \textcolor{comment}{// write buffer and reset index; there must be 13 bytes}}
\DoxyCodeLine{18377                     \textcolor{comment}{// left, as this is the maximal number of bytes to be}}
\DoxyCodeLine{18378                     \textcolor{comment}{// written ("{}\(\backslash\)uxxxx\(\backslash\)uxxxx\(\backslash\)0"{}) for one code point}}
\DoxyCodeLine{18379                     \textcolor{keywordflow}{if} (string\_buffer.size() -\/ bytes < 13)}
\DoxyCodeLine{18380                     \{}
\DoxyCodeLine{18381                         o-\/>write\_characters(string\_buffer.data(), bytes);}
\DoxyCodeLine{18382                         bytes = 0;}
\DoxyCodeLine{18383                     \}}
\DoxyCodeLine{18384 }
\DoxyCodeLine{18385                     \textcolor{comment}{// remember the byte position of this accept}}
\DoxyCodeLine{18386                     bytes\_after\_last\_accept = bytes;}
\DoxyCodeLine{18387                     undumped\_chars = 0;}
\DoxyCodeLine{18388                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{18389                 \}}
\DoxyCodeLine{18390 }
\DoxyCodeLine{18391                 \textcolor{keywordflow}{case} UTF8\_REJECT:  \textcolor{comment}{// decode found invalid UTF-\/8 byte}}
\DoxyCodeLine{18392                 \{}
\DoxyCodeLine{18393                     \textcolor{keywordflow}{switch} (error\_handler)}
\DoxyCodeLine{18394                     \{}
\DoxyCodeLine{18395                         \textcolor{keywordflow}{case} error\_handler\_t::strict:}
\DoxyCodeLine{18396                         \{}
\DoxyCodeLine{18397                             JSON\_THROW(type\_error::create(316, concat(\textcolor{stringliteral}{"{}invalid UTF-\/8 byte at index "{}}, std::to\_string(i), \textcolor{stringliteral}{"{}: 0x"{}}, hex\_bytes(\textcolor{keywordtype}{byte} | 0)), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{18398                         \}}
\DoxyCodeLine{18399 }
\DoxyCodeLine{18400                         \textcolor{keywordflow}{case} error\_handler\_t::ignore:}
\DoxyCodeLine{18401                         \textcolor{keywordflow}{case} error\_handler\_t::replace:}
\DoxyCodeLine{18402                         \{}
\DoxyCodeLine{18403                             \textcolor{comment}{// in case we saw this character the first time, we}}
\DoxyCodeLine{18404                             \textcolor{comment}{// would like to read it again, because the byte}}
\DoxyCodeLine{18405                             \textcolor{comment}{// may be OK for itself, but just not OK for the}}
\DoxyCodeLine{18406                             \textcolor{comment}{// previous sequence}}
\DoxyCodeLine{18407                             \textcolor{keywordflow}{if} (undumped\_chars > 0)}
\DoxyCodeLine{18408                             \{}
\DoxyCodeLine{18409                                 -\/-\/i;}
\DoxyCodeLine{18410                             \}}
\DoxyCodeLine{18411 }
\DoxyCodeLine{18412                             \textcolor{comment}{// reset length buffer to the last accepted index;}}
\DoxyCodeLine{18413                             \textcolor{comment}{// thus removing/ignoring the invalid characters}}
\DoxyCodeLine{18414                             bytes = bytes\_after\_last\_accept;}
\DoxyCodeLine{18415 }
\DoxyCodeLine{18416                             \textcolor{keywordflow}{if} (error\_handler == error\_handler\_t::replace)}
\DoxyCodeLine{18417                             \{}
\DoxyCodeLine{18418                                 \textcolor{comment}{// add a replacement character}}
\DoxyCodeLine{18419                                 \textcolor{keywordflow}{if} (ensure\_ascii)}
\DoxyCodeLine{18420                                 \{}
\DoxyCodeLine{18421                                     string\_buffer[bytes++] = \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};}
\DoxyCodeLine{18422                                     string\_buffer[bytes++] = \textcolor{charliteral}{'u'};}
\DoxyCodeLine{18423                                     string\_buffer[bytes++] = \textcolor{charliteral}{'f'};}
\DoxyCodeLine{18424                                     string\_buffer[bytes++] = \textcolor{charliteral}{'f'};}
\DoxyCodeLine{18425                                     string\_buffer[bytes++] = \textcolor{charliteral}{'f'};}
\DoxyCodeLine{18426                                     string\_buffer[bytes++] = \textcolor{charliteral}{'d'};}
\DoxyCodeLine{18427                                 \}}
\DoxyCodeLine{18428                                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{18429                                 \{}
\DoxyCodeLine{18430                                     string\_buffer[bytes++] = \mbox{\hyperlink{classdetail_1_1binary__writer}{detail::binary\_writer<BasicJsonType, char>::to\_char\_type}}(\textcolor{stringliteral}{'\(\backslash\)xEF'});}
\DoxyCodeLine{18431                                     string\_buffer[bytes++] = \mbox{\hyperlink{classdetail_1_1binary__writer}{detail::binary\_writer<BasicJsonType, char>::to\_char\_type}}(\textcolor{stringliteral}{'\(\backslash\)xBF'});}
\DoxyCodeLine{18432                                     string\_buffer[bytes++] = \mbox{\hyperlink{classdetail_1_1binary__writer}{detail::binary\_writer<BasicJsonType, char>::to\_char\_type}}(\textcolor{stringliteral}{'\(\backslash\)xBD'});}
\DoxyCodeLine{18433                                 \}}
\DoxyCodeLine{18434 }
\DoxyCodeLine{18435                                 \textcolor{comment}{// write buffer and reset index; there must be 13 bytes}}
\DoxyCodeLine{18436                                 \textcolor{comment}{// left, as this is the maximal number of bytes to be}}
\DoxyCodeLine{18437                                 \textcolor{comment}{// written ("{}\(\backslash\)uxxxx\(\backslash\)uxxxx\(\backslash\)0"{}) for one code point}}
\DoxyCodeLine{18438                                 \textcolor{keywordflow}{if} (string\_buffer.size() -\/ bytes < 13)}
\DoxyCodeLine{18439                                 \{}
\DoxyCodeLine{18440                                     o-\/>write\_characters(string\_buffer.data(), bytes);}
\DoxyCodeLine{18441                                     bytes = 0;}
\DoxyCodeLine{18442                                 \}}
\DoxyCodeLine{18443 }
\DoxyCodeLine{18444                                 bytes\_after\_last\_accept = bytes;}
\DoxyCodeLine{18445                             \}}
\DoxyCodeLine{18446 }
\DoxyCodeLine{18447                             undumped\_chars = 0;}
\DoxyCodeLine{18448 }
\DoxyCodeLine{18449                             \textcolor{comment}{// continue processing the string}}
\DoxyCodeLine{18450                             state = UTF8\_ACCEPT;}
\DoxyCodeLine{18451                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{18452                         \}}
\DoxyCodeLine{18453 }
\DoxyCodeLine{18454                         \textcolor{keywordflow}{default}:            \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{18455                             JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{18456                     \}}
\DoxyCodeLine{18457                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{18458                 \}}
\DoxyCodeLine{18459 }
\DoxyCodeLine{18460                 \textcolor{keywordflow}{default}:  \textcolor{comment}{// decode found yet incomplete multi-\/byte code point}}
\DoxyCodeLine{18461                 \{}
\DoxyCodeLine{18462                     \textcolor{keywordflow}{if} (!ensure\_ascii)}
\DoxyCodeLine{18463                     \{}
\DoxyCodeLine{18464                         \textcolor{comment}{// code point will not be escaped -\/ copy byte to buffer}}
\DoxyCodeLine{18465                         string\_buffer[bytes++] = s[i];}
\DoxyCodeLine{18466                     \}}
\DoxyCodeLine{18467                     ++undumped\_chars;}
\DoxyCodeLine{18468                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{18469                 \}}
\DoxyCodeLine{18470             \}}
\DoxyCodeLine{18471         \}}
\DoxyCodeLine{18472 }
\DoxyCodeLine{18473         \textcolor{comment}{// we finished processing the string}}
\DoxyCodeLine{18474         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(state == UTF8\_ACCEPT))}
\DoxyCodeLine{18475         \{}
\DoxyCodeLine{18476             \textcolor{comment}{// write buffer}}
\DoxyCodeLine{18477             \textcolor{keywordflow}{if} (bytes > 0)}
\DoxyCodeLine{18478             \{}
\DoxyCodeLine{18479                 o-\/>write\_characters(string\_buffer.data(), bytes);}
\DoxyCodeLine{18480             \}}
\DoxyCodeLine{18481         \}}
\DoxyCodeLine{18482         \textcolor{keywordflow}{else}}
\DoxyCodeLine{18483         \{}
\DoxyCodeLine{18484             \textcolor{comment}{// we finish reading, but do not accept: string was incomplete}}
\DoxyCodeLine{18485             \textcolor{keywordflow}{switch} (error\_handler)}
\DoxyCodeLine{18486             \{}
\DoxyCodeLine{18487                 \textcolor{keywordflow}{case} error\_handler\_t::strict:}
\DoxyCodeLine{18488                 \{}
\DoxyCodeLine{18489                     JSON\_THROW(type\_error::create(316, concat(\textcolor{stringliteral}{"{}incomplete UTF-\/8 string; last byte: 0x"{}}, hex\_bytes(\textcolor{keyword}{static\_cast<}std::uint8\_t\textcolor{keyword}{>}(s.back() | 0))), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{18490                 \}}
\DoxyCodeLine{18491 }
\DoxyCodeLine{18492                 \textcolor{keywordflow}{case} error\_handler\_t::ignore:}
\DoxyCodeLine{18493                 \{}
\DoxyCodeLine{18494                     \textcolor{comment}{// write all accepted bytes}}
\DoxyCodeLine{18495                     o-\/>write\_characters(string\_buffer.data(), bytes\_after\_last\_accept);}
\DoxyCodeLine{18496                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{18497                 \}}
\DoxyCodeLine{18498 }
\DoxyCodeLine{18499                 \textcolor{keywordflow}{case} error\_handler\_t::replace:}
\DoxyCodeLine{18500                 \{}
\DoxyCodeLine{18501                     \textcolor{comment}{// write all accepted bytes}}
\DoxyCodeLine{18502                     o-\/>write\_characters(string\_buffer.data(), bytes\_after\_last\_accept);}
\DoxyCodeLine{18503                     \textcolor{comment}{// add a replacement character}}
\DoxyCodeLine{18504                     \textcolor{keywordflow}{if} (ensure\_ascii)}
\DoxyCodeLine{18505                     \{}
\DoxyCodeLine{18506                         o-\/>write\_characters(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)ufffd"{}}, 6);}
\DoxyCodeLine{18507                     \}}
\DoxyCodeLine{18508                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{18509                     \{}
\DoxyCodeLine{18510                         o-\/>write\_characters(\textcolor{stringliteral}{"{}\(\backslash\)xEF\(\backslash\)xBF\(\backslash\)xBD"{}}, 3);}
\DoxyCodeLine{18511                     \}}
\DoxyCodeLine{18512                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{18513                 \}}
\DoxyCodeLine{18514 }
\DoxyCodeLine{18515                 \textcolor{keywordflow}{default}:            \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{18516                     JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{18517             \}}
\DoxyCodeLine{18518         \}}
\DoxyCodeLine{18519     \}}
\DoxyCodeLine{18520 }
\DoxyCodeLine{18521   \textcolor{keyword}{private}:}
\DoxyCodeLine{18530     \textcolor{keyword}{inline} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} count\_digits(number\_unsigned\_t x) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{18531     \{}
\DoxyCodeLine{18532         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_digits = 1;}
\DoxyCodeLine{18533         \textcolor{keywordflow}{for} (;;)}
\DoxyCodeLine{18534         \{}
\DoxyCodeLine{18535             \textcolor{keywordflow}{if} (x < 10)}
\DoxyCodeLine{18536             \{}
\DoxyCodeLine{18537                 \textcolor{keywordflow}{return} n\_digits;}
\DoxyCodeLine{18538             \}}
\DoxyCodeLine{18539             \textcolor{keywordflow}{if} (x < 100)}
\DoxyCodeLine{18540             \{}
\DoxyCodeLine{18541                 \textcolor{keywordflow}{return} n\_digits + 1;}
\DoxyCodeLine{18542             \}}
\DoxyCodeLine{18543             \textcolor{keywordflow}{if} (x < 1000)}
\DoxyCodeLine{18544             \{}
\DoxyCodeLine{18545                 \textcolor{keywordflow}{return} n\_digits + 2;}
\DoxyCodeLine{18546             \}}
\DoxyCodeLine{18547             \textcolor{keywordflow}{if} (x < 10000)}
\DoxyCodeLine{18548             \{}
\DoxyCodeLine{18549                 \textcolor{keywordflow}{return} n\_digits + 3;}
\DoxyCodeLine{18550             \}}
\DoxyCodeLine{18551             x = x / 10000u;}
\DoxyCodeLine{18552             n\_digits += 4;}
\DoxyCodeLine{18553         \}}
\DoxyCodeLine{18554     \}}
\DoxyCodeLine{18555 }
\DoxyCodeLine{18561     \textcolor{keyword}{static} std::string hex\_bytes(std::uint8\_t \textcolor{keywordtype}{byte})}
\DoxyCodeLine{18562     \{}
\DoxyCodeLine{18563         std::string result = \textcolor{stringliteral}{"{}FF"{}};}
\DoxyCodeLine{18564         \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* nibble\_to\_hex = \textcolor{stringliteral}{"{}0123456789ABCDEF"{}};}
\DoxyCodeLine{18565         result[0] = nibble\_to\_hex[\textcolor{keywordtype}{byte} / 16];}
\DoxyCodeLine{18566         result[1] = nibble\_to\_hex[\textcolor{keywordtype}{byte} \% 16];}
\DoxyCodeLine{18567         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{18568     \}}
\DoxyCodeLine{18569 }
\DoxyCodeLine{18570     \textcolor{comment}{// templates to avoid warnings about useless casts}}
\DoxyCodeLine{18571     template <typename NumberType, enable\_if\_t<std::is\_signed<NumberType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{18572     \textcolor{keywordtype}{bool} is\_negative\_number(NumberType x)}
\DoxyCodeLine{18573     \{}
\DoxyCodeLine{18574         \textcolor{keywordflow}{return} x < 0;}
\DoxyCodeLine{18575     \}}
\DoxyCodeLine{18576 }
\DoxyCodeLine{18577     template < typename NumberType, enable\_if\_t <std::is\_unsigned<NumberType>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{18578     \textcolor{keywordtype}{bool} is\_negative\_number(NumberType \textcolor{comment}{/*unused*/})}
\DoxyCodeLine{18579     \{}
\DoxyCodeLine{18580         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{18581     \}}
\DoxyCodeLine{18582 }
\DoxyCodeLine{18592     \textcolor{keyword}{template} < \textcolor{keyword}{typename} NumberType, detail::enable\_if\_t <}
\DoxyCodeLine{18593                    std::is\_integral<NumberType>::value ||}
\DoxyCodeLine{18594                    std::is\_same<NumberType, number\_unsigned\_t>::value ||}
\DoxyCodeLine{18595                    std::is\_same<NumberType, number\_integer\_t>::value ||}
\DoxyCodeLine{18596                    std::is\_same<NumberType, binary\_char\_t>::value,}
\DoxyCodeLine{18597                    \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{18598     \textcolor{keywordtype}{void} dump\_integer(NumberType x)}
\DoxyCodeLine{18599     \{}
\DoxyCodeLine{18600         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} std::array<std::array<char, 2>, 100> digits\_to\_99}
\DoxyCodeLine{18601         \{}
\DoxyCodeLine{18602             \{}
\DoxyCodeLine{18603                 \{\{\textcolor{charliteral}{'0'}, \textcolor{charliteral}{'0'}\}\}, \{\{\textcolor{charliteral}{'0'}, \textcolor{charliteral}{'1'}\}\}, \{\{\textcolor{charliteral}{'0'}, \textcolor{charliteral}{'2'}\}\}, \{\{\textcolor{charliteral}{'0'}, \textcolor{charliteral}{'3'}\}\}, \{\{\textcolor{charliteral}{'0'}, \textcolor{charliteral}{'4'}\}\}, \{\{\textcolor{charliteral}{'0'}, \textcolor{charliteral}{'5'}\}\}, \{\{\textcolor{charliteral}{'0'}, \textcolor{charliteral}{'6'}\}\}, \{\{\textcolor{charliteral}{'0'}, \textcolor{charliteral}{'7'}\}\}, \{\{\textcolor{charliteral}{'0'}, \textcolor{charliteral}{'8'}\}\}, \{\{\textcolor{charliteral}{'0'}, \textcolor{charliteral}{'9'}\}\},}
\DoxyCodeLine{18604                 \{\{\textcolor{charliteral}{'1'}, \textcolor{charliteral}{'0'}\}\}, \{\{\textcolor{charliteral}{'1'}, \textcolor{charliteral}{'1'}\}\}, \{\{\textcolor{charliteral}{'1'}, \textcolor{charliteral}{'2'}\}\}, \{\{\textcolor{charliteral}{'1'}, \textcolor{charliteral}{'3'}\}\}, \{\{\textcolor{charliteral}{'1'}, \textcolor{charliteral}{'4'}\}\}, \{\{\textcolor{charliteral}{'1'}, \textcolor{charliteral}{'5'}\}\}, \{\{\textcolor{charliteral}{'1'}, \textcolor{charliteral}{'6'}\}\}, \{\{\textcolor{charliteral}{'1'}, \textcolor{charliteral}{'7'}\}\}, \{\{\textcolor{charliteral}{'1'}, \textcolor{charliteral}{'8'}\}\}, \{\{\textcolor{charliteral}{'1'}, \textcolor{charliteral}{'9'}\}\},}
\DoxyCodeLine{18605                 \{\{\textcolor{charliteral}{'2'}, \textcolor{charliteral}{'0'}\}\}, \{\{\textcolor{charliteral}{'2'}, \textcolor{charliteral}{'1'}\}\}, \{\{\textcolor{charliteral}{'2'}, \textcolor{charliteral}{'2'}\}\}, \{\{\textcolor{charliteral}{'2'}, \textcolor{charliteral}{'3'}\}\}, \{\{\textcolor{charliteral}{'2'}, \textcolor{charliteral}{'4'}\}\}, \{\{\textcolor{charliteral}{'2'}, \textcolor{charliteral}{'5'}\}\}, \{\{\textcolor{charliteral}{'2'}, \textcolor{charliteral}{'6'}\}\}, \{\{\textcolor{charliteral}{'2'}, \textcolor{charliteral}{'7'}\}\}, \{\{\textcolor{charliteral}{'2'}, \textcolor{charliteral}{'8'}\}\}, \{\{\textcolor{charliteral}{'2'}, \textcolor{charliteral}{'9'}\}\},}
\DoxyCodeLine{18606                 \{\{\textcolor{charliteral}{'3'}, \textcolor{charliteral}{'0'}\}\}, \{\{\textcolor{charliteral}{'3'}, \textcolor{charliteral}{'1'}\}\}, \{\{\textcolor{charliteral}{'3'}, \textcolor{charliteral}{'2'}\}\}, \{\{\textcolor{charliteral}{'3'}, \textcolor{charliteral}{'3'}\}\}, \{\{\textcolor{charliteral}{'3'}, \textcolor{charliteral}{'4'}\}\}, \{\{\textcolor{charliteral}{'3'}, \textcolor{charliteral}{'5'}\}\}, \{\{\textcolor{charliteral}{'3'}, \textcolor{charliteral}{'6'}\}\}, \{\{\textcolor{charliteral}{'3'}, \textcolor{charliteral}{'7'}\}\}, \{\{\textcolor{charliteral}{'3'}, \textcolor{charliteral}{'8'}\}\}, \{\{\textcolor{charliteral}{'3'}, \textcolor{charliteral}{'9'}\}\},}
\DoxyCodeLine{18607                 \{\{\textcolor{charliteral}{'4'}, \textcolor{charliteral}{'0'}\}\}, \{\{\textcolor{charliteral}{'4'}, \textcolor{charliteral}{'1'}\}\}, \{\{\textcolor{charliteral}{'4'}, \textcolor{charliteral}{'2'}\}\}, \{\{\textcolor{charliteral}{'4'}, \textcolor{charliteral}{'3'}\}\}, \{\{\textcolor{charliteral}{'4'}, \textcolor{charliteral}{'4'}\}\}, \{\{\textcolor{charliteral}{'4'}, \textcolor{charliteral}{'5'}\}\}, \{\{\textcolor{charliteral}{'4'}, \textcolor{charliteral}{'6'}\}\}, \{\{\textcolor{charliteral}{'4'}, \textcolor{charliteral}{'7'}\}\}, \{\{\textcolor{charliteral}{'4'}, \textcolor{charliteral}{'8'}\}\}, \{\{\textcolor{charliteral}{'4'}, \textcolor{charliteral}{'9'}\}\},}
\DoxyCodeLine{18608                 \{\{\textcolor{charliteral}{'5'}, \textcolor{charliteral}{'0'}\}\}, \{\{\textcolor{charliteral}{'5'}, \textcolor{charliteral}{'1'}\}\}, \{\{\textcolor{charliteral}{'5'}, \textcolor{charliteral}{'2'}\}\}, \{\{\textcolor{charliteral}{'5'}, \textcolor{charliteral}{'3'}\}\}, \{\{\textcolor{charliteral}{'5'}, \textcolor{charliteral}{'4'}\}\}, \{\{\textcolor{charliteral}{'5'}, \textcolor{charliteral}{'5'}\}\}, \{\{\textcolor{charliteral}{'5'}, \textcolor{charliteral}{'6'}\}\}, \{\{\textcolor{charliteral}{'5'}, \textcolor{charliteral}{'7'}\}\}, \{\{\textcolor{charliteral}{'5'}, \textcolor{charliteral}{'8'}\}\}, \{\{\textcolor{charliteral}{'5'}, \textcolor{charliteral}{'9'}\}\},}
\DoxyCodeLine{18609                 \{\{\textcolor{charliteral}{'6'}, \textcolor{charliteral}{'0'}\}\}, \{\{\textcolor{charliteral}{'6'}, \textcolor{charliteral}{'1'}\}\}, \{\{\textcolor{charliteral}{'6'}, \textcolor{charliteral}{'2'}\}\}, \{\{\textcolor{charliteral}{'6'}, \textcolor{charliteral}{'3'}\}\}, \{\{\textcolor{charliteral}{'6'}, \textcolor{charliteral}{'4'}\}\}, \{\{\textcolor{charliteral}{'6'}, \textcolor{charliteral}{'5'}\}\}, \{\{\textcolor{charliteral}{'6'}, \textcolor{charliteral}{'6'}\}\}, \{\{\textcolor{charliteral}{'6'}, \textcolor{charliteral}{'7'}\}\}, \{\{\textcolor{charliteral}{'6'}, \textcolor{charliteral}{'8'}\}\}, \{\{\textcolor{charliteral}{'6'}, \textcolor{charliteral}{'9'}\}\},}
\DoxyCodeLine{18610                 \{\{\textcolor{charliteral}{'7'}, \textcolor{charliteral}{'0'}\}\}, \{\{\textcolor{charliteral}{'7'}, \textcolor{charliteral}{'1'}\}\}, \{\{\textcolor{charliteral}{'7'}, \textcolor{charliteral}{'2'}\}\}, \{\{\textcolor{charliteral}{'7'}, \textcolor{charliteral}{'3'}\}\}, \{\{\textcolor{charliteral}{'7'}, \textcolor{charliteral}{'4'}\}\}, \{\{\textcolor{charliteral}{'7'}, \textcolor{charliteral}{'5'}\}\}, \{\{\textcolor{charliteral}{'7'}, \textcolor{charliteral}{'6'}\}\}, \{\{\textcolor{charliteral}{'7'}, \textcolor{charliteral}{'7'}\}\}, \{\{\textcolor{charliteral}{'7'}, \textcolor{charliteral}{'8'}\}\}, \{\{\textcolor{charliteral}{'7'}, \textcolor{charliteral}{'9'}\}\},}
\DoxyCodeLine{18611                 \{\{\textcolor{charliteral}{'8'}, \textcolor{charliteral}{'0'}\}\}, \{\{\textcolor{charliteral}{'8'}, \textcolor{charliteral}{'1'}\}\}, \{\{\textcolor{charliteral}{'8'}, \textcolor{charliteral}{'2'}\}\}, \{\{\textcolor{charliteral}{'8'}, \textcolor{charliteral}{'3'}\}\}, \{\{\textcolor{charliteral}{'8'}, \textcolor{charliteral}{'4'}\}\}, \{\{\textcolor{charliteral}{'8'}, \textcolor{charliteral}{'5'}\}\}, \{\{\textcolor{charliteral}{'8'}, \textcolor{charliteral}{'6'}\}\}, \{\{\textcolor{charliteral}{'8'}, \textcolor{charliteral}{'7'}\}\}, \{\{\textcolor{charliteral}{'8'}, \textcolor{charliteral}{'8'}\}\}, \{\{\textcolor{charliteral}{'8'}, \textcolor{charliteral}{'9'}\}\},}
\DoxyCodeLine{18612                 \{\{\textcolor{charliteral}{'9'}, \textcolor{charliteral}{'0'}\}\}, \{\{\textcolor{charliteral}{'9'}, \textcolor{charliteral}{'1'}\}\}, \{\{\textcolor{charliteral}{'9'}, \textcolor{charliteral}{'2'}\}\}, \{\{\textcolor{charliteral}{'9'}, \textcolor{charliteral}{'3'}\}\}, \{\{\textcolor{charliteral}{'9'}, \textcolor{charliteral}{'4'}\}\}, \{\{\textcolor{charliteral}{'9'}, \textcolor{charliteral}{'5'}\}\}, \{\{\textcolor{charliteral}{'9'}, \textcolor{charliteral}{'6'}\}\}, \{\{\textcolor{charliteral}{'9'}, \textcolor{charliteral}{'7'}\}\}, \{\{\textcolor{charliteral}{'9'}, \textcolor{charliteral}{'8'}\}\}, \{\{\textcolor{charliteral}{'9'}, \textcolor{charliteral}{'9'}\}\},}
\DoxyCodeLine{18613             \}}
\DoxyCodeLine{18614         \};}
\DoxyCodeLine{18615 }
\DoxyCodeLine{18616         \textcolor{comment}{// special case for "{}0"{}}}
\DoxyCodeLine{18617         \textcolor{keywordflow}{if} (x == 0)}
\DoxyCodeLine{18618         \{}
\DoxyCodeLine{18619             o-\/>write\_character(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{18620             \textcolor{keywordflow}{return};}
\DoxyCodeLine{18621         \}}
\DoxyCodeLine{18622 }
\DoxyCodeLine{18623         \textcolor{comment}{// use a pointer to fill the buffer}}
\DoxyCodeLine{18624         \textcolor{keyword}{auto} buffer\_ptr = number\_buffer.begin(); \textcolor{comment}{// NOLINT(llvm-\/qualified-\/auto,readability-\/qualified-\/auto,cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{18625 }
\DoxyCodeLine{18626         number\_unsigned\_t abs\_value;}
\DoxyCodeLine{18627 }
\DoxyCodeLine{18628         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_chars\{\};}
\DoxyCodeLine{18629 }
\DoxyCodeLine{18630         \textcolor{keywordflow}{if} (is\_negative\_number(x))}
\DoxyCodeLine{18631         \{}
\DoxyCodeLine{18632             *buffer\_ptr = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{18633             abs\_value = remove\_sign(\textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(x));}
\DoxyCodeLine{18634 }
\DoxyCodeLine{18635             \textcolor{comment}{// account one more byte for the minus sign}}
\DoxyCodeLine{18636             n\_chars = 1 + count\_digits(abs\_value);}
\DoxyCodeLine{18637         \}}
\DoxyCodeLine{18638         \textcolor{keywordflow}{else}}
\DoxyCodeLine{18639         \{}
\DoxyCodeLine{18640             abs\_value = \textcolor{keyword}{static\_cast<}number\_unsigned\_t\textcolor{keyword}{>}(x);}
\DoxyCodeLine{18641             n\_chars = count\_digits(abs\_value);}
\DoxyCodeLine{18642         \}}
\DoxyCodeLine{18643 }
\DoxyCodeLine{18644         \textcolor{comment}{// spare 1 byte for '\(\backslash\)0'}}
\DoxyCodeLine{18645         JSON\_ASSERT(n\_chars < number\_buffer.size() -\/ 1);}
\DoxyCodeLine{18646 }
\DoxyCodeLine{18647         \textcolor{comment}{// jump to the end to generate the string from backward,}}
\DoxyCodeLine{18648         \textcolor{comment}{// so we later avoid reversing the result}}
\DoxyCodeLine{18649         buffer\_ptr += n\_chars;}
\DoxyCodeLine{18650 }
\DoxyCodeLine{18651         \textcolor{comment}{// Fast int2ascii implementation inspired by "{}Fastware"{} talk by Andrei Alexandrescu}}
\DoxyCodeLine{18652         \textcolor{comment}{// See: https://www.youtube.com/watch?v=o4-\/CwDo2zpg}}
\DoxyCodeLine{18653         \textcolor{keywordflow}{while} (abs\_value >= 100)}
\DoxyCodeLine{18654         \{}
\DoxyCodeLine{18655             \textcolor{keyword}{const} \textcolor{keyword}{auto} digits\_index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}((abs\_value \% 100));}
\DoxyCodeLine{18656             abs\_value /= 100;}
\DoxyCodeLine{18657             *(-\/-\/buffer\_ptr) = digits\_to\_99[digits\_index][1];}
\DoxyCodeLine{18658             *(-\/-\/buffer\_ptr) = digits\_to\_99[digits\_index][0];}
\DoxyCodeLine{18659         \}}
\DoxyCodeLine{18660 }
\DoxyCodeLine{18661         \textcolor{keywordflow}{if} (abs\_value >= 10)}
\DoxyCodeLine{18662         \{}
\DoxyCodeLine{18663             \textcolor{keyword}{const} \textcolor{keyword}{auto} digits\_index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(abs\_value);}
\DoxyCodeLine{18664             *(-\/-\/buffer\_ptr) = digits\_to\_99[digits\_index][1];}
\DoxyCodeLine{18665             *(-\/-\/buffer\_ptr) = digits\_to\_99[digits\_index][0];}
\DoxyCodeLine{18666         \}}
\DoxyCodeLine{18667         \textcolor{keywordflow}{else}}
\DoxyCodeLine{18668         \{}
\DoxyCodeLine{18669             *(-\/-\/buffer\_ptr) = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + abs\_value);}
\DoxyCodeLine{18670         \}}
\DoxyCodeLine{18671 }
\DoxyCodeLine{18672         o-\/>write\_characters(number\_buffer.data(), n\_chars);}
\DoxyCodeLine{18673     \}}
\DoxyCodeLine{18674 }
\DoxyCodeLine{18683     \textcolor{keywordtype}{void} dump\_float(number\_float\_t x)}
\DoxyCodeLine{18684     \{}
\DoxyCodeLine{18685         \textcolor{comment}{// NaN / inf}}
\DoxyCodeLine{18686         \textcolor{keywordflow}{if} (!std::isfinite(x))}
\DoxyCodeLine{18687         \{}
\DoxyCodeLine{18688             o-\/>write\_characters(\textcolor{stringliteral}{"{}null"{}}, 4);}
\DoxyCodeLine{18689             \textcolor{keywordflow}{return};}
\DoxyCodeLine{18690         \}}
\DoxyCodeLine{18691 }
\DoxyCodeLine{18692         \textcolor{comment}{// If number\_float\_t is an IEEE-\/754 single or double precision number,}}
\DoxyCodeLine{18693         \textcolor{comment}{// use the Grisu2 algorithm to produce short numbers which are}}
\DoxyCodeLine{18694         \textcolor{comment}{// guaranteed to round-\/trip, using strtof and strtod, resp.}}
\DoxyCodeLine{18695         \textcolor{comment}{//}}
\DoxyCodeLine{18696         \textcolor{comment}{// NB: The test below works if <long double> == <double>.}}
\DoxyCodeLine{18697         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} is\_ieee\_single\_or\_double}
\DoxyCodeLine{18698             = (std::numeric\_limits<number\_float\_t>::is\_iec559 \&\& std::numeric\_limits<number\_float\_t>::digits == 24 \&\& std::numeric\_limits<number\_float\_t>::max\_exponent == 128) ||}
\DoxyCodeLine{18699               (std::numeric\_limits<number\_float\_t>::is\_iec559 \&\& std::numeric\_limits<number\_float\_t>::digits == 53 \&\& std::numeric\_limits<number\_float\_t>::max\_exponent == 1024);}
\DoxyCodeLine{18700 }
\DoxyCodeLine{18701         dump\_float(x, std::integral\_constant<bool, is\_ieee\_single\_or\_double>());}
\DoxyCodeLine{18702     \}}
\DoxyCodeLine{18703 }
\DoxyCodeLine{18704     \textcolor{keywordtype}{void} dump\_float(number\_float\_t x, std::true\_type \textcolor{comment}{/*is\_ieee\_single\_or\_double*/})}
\DoxyCodeLine{18705     \{}
\DoxyCodeLine{18706         \textcolor{keyword}{auto}* begin = number\_buffer.data();}
\DoxyCodeLine{18707         \textcolor{keyword}{auto}* end = ::nlohmann::detail::to\_chars(begin, begin + number\_buffer.size(), x);}
\DoxyCodeLine{18708 }
\DoxyCodeLine{18709         o-\/>write\_characters(begin, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(end -\/ begin));}
\DoxyCodeLine{18710     \}}
\DoxyCodeLine{18711 }
\DoxyCodeLine{18712     \textcolor{keywordtype}{void} dump\_float(number\_float\_t x, std::false\_type \textcolor{comment}{/*is\_ieee\_single\_or\_double*/})}
\DoxyCodeLine{18713     \{}
\DoxyCodeLine{18714         \textcolor{comment}{// get number of digits for a float -\/> text -\/> float round-\/trip}}
\DoxyCodeLine{18715         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} d = std::numeric\_limits<number\_float\_t>::max\_digits10;}
\DoxyCodeLine{18716 }
\DoxyCodeLine{18717         \textcolor{comment}{// the actual conversion}}
\DoxyCodeLine{18718         \textcolor{comment}{// NOLINTNEXTLINE(cppcoreguidelines-\/pro-\/type-\/vararg,hicpp-\/vararg)}}
\DoxyCodeLine{18719         std::ptrdiff\_t len = (std::snprintf)(number\_buffer.data(), number\_buffer.size(), \textcolor{stringliteral}{"{}\%.*g"{}}, d, x);}
\DoxyCodeLine{18720 }
\DoxyCodeLine{18721         \textcolor{comment}{// negative value indicates an error}}
\DoxyCodeLine{18722         JSON\_ASSERT(len > 0);}
\DoxyCodeLine{18723         \textcolor{comment}{// check if buffer was large enough}}
\DoxyCodeLine{18724         JSON\_ASSERT(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len) < number\_buffer.size());}
\DoxyCodeLine{18725 }
\DoxyCodeLine{18726         \textcolor{comment}{// erase thousands separator}}
\DoxyCodeLine{18727         \textcolor{keywordflow}{if} (thousands\_sep != \textcolor{charliteral}{'\(\backslash\)0'})}
\DoxyCodeLine{18728         \{}
\DoxyCodeLine{18729             \textcolor{comment}{// NOLINTNEXTLINE(readability-\/qualified-\/auto,llvm-\/qualified-\/auto): std::remove returns an iterator, see https://github.com/nlohmann/json/issues/3081}}
\DoxyCodeLine{18730             \textcolor{keyword}{const} \textcolor{keyword}{auto} end = std::remove(number\_buffer.begin(), number\_buffer.begin() + len, thousands\_sep);}
\DoxyCodeLine{18731             std::fill(end, number\_buffer.end(), \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{18732             JSON\_ASSERT((end -\/ number\_buffer.begin()) <= len);}
\DoxyCodeLine{18733             len = (end -\/ number\_buffer.begin());}
\DoxyCodeLine{18734         \}}
\DoxyCodeLine{18735 }
\DoxyCodeLine{18736         \textcolor{comment}{// convert decimal point to '.'}}
\DoxyCodeLine{18737         \textcolor{keywordflow}{if} (decimal\_point != \textcolor{charliteral}{'\(\backslash\)0'} \&\& decimal\_point != \textcolor{charliteral}{'.'})}
\DoxyCodeLine{18738         \{}
\DoxyCodeLine{18739             \textcolor{comment}{// NOLINTNEXTLINE(readability-\/qualified-\/auto,llvm-\/qualified-\/auto): std::find returns an iterator, see https://github.com/nlohmann/json/issues/3081}}
\DoxyCodeLine{18740             \textcolor{keyword}{const} \textcolor{keyword}{auto} dec\_pos = std::find(number\_buffer.begin(), number\_buffer.end(), decimal\_point);}
\DoxyCodeLine{18741             \textcolor{keywordflow}{if} (dec\_pos != number\_buffer.end())}
\DoxyCodeLine{18742             \{}
\DoxyCodeLine{18743                 *dec\_pos = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{18744             \}}
\DoxyCodeLine{18745         \}}
\DoxyCodeLine{18746 }
\DoxyCodeLine{18747         o-\/>write\_characters(number\_buffer.data(), \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(len));}
\DoxyCodeLine{18748 }
\DoxyCodeLine{18749         \textcolor{comment}{// determine if we need to append "{}.0"{}}}
\DoxyCodeLine{18750         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value\_is\_int\_like =}
\DoxyCodeLine{18751             std::none\_of(number\_buffer.begin(), number\_buffer.begin() + len + 1,}
\DoxyCodeLine{18752                          [](\textcolor{keywordtype}{char} c)}
\DoxyCodeLine{18753         \{}
\DoxyCodeLine{18754             return c == \textcolor{stringliteral}{'.'} || c == \textcolor{stringliteral}{'e'};}
\DoxyCodeLine{18755         \});}
\DoxyCodeLine{18756 }
\DoxyCodeLine{18757         \textcolor{keywordflow}{if} (value\_is\_int\_like)}
\DoxyCodeLine{18758         \{}
\DoxyCodeLine{18759             o-\/>write\_characters(\textcolor{stringliteral}{"{}.0"{}}, 2);}
\DoxyCodeLine{18760         \}}
\DoxyCodeLine{18761     \}}
\DoxyCodeLine{18762 }
\DoxyCodeLine{18784     \textcolor{keyword}{static} std::uint8\_t decode(std::uint8\_t\& state, std::uint32\_t\& codep, \textcolor{keyword}{const} std::uint8\_t \textcolor{keywordtype}{byte}) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{18785     \{}
\DoxyCodeLine{18786         \textcolor{keyword}{static} \textcolor{keyword}{const} std::array<std::uint8\_t, 400> utf8d =}
\DoxyCodeLine{18787         \{}
\DoxyCodeLine{18788             \{}
\DoxyCodeLine{18789                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \textcolor{comment}{// 00..1F}}
\DoxyCodeLine{18790                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \textcolor{comment}{// 20..3F}}
\DoxyCodeLine{18791                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \textcolor{comment}{// 40..5F}}
\DoxyCodeLine{18792                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \textcolor{comment}{// 60..7F}}
\DoxyCodeLine{18793                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, \textcolor{comment}{// 80..9F}}
\DoxyCodeLine{18794                 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, \textcolor{comment}{// A0..BF}}
\DoxyCodeLine{18795                 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \textcolor{comment}{// C0..DF}}
\DoxyCodeLine{18796                 0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, \textcolor{comment}{// E0..EF}}
\DoxyCodeLine{18797                 0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, \textcolor{comment}{// F0..FF}}
\DoxyCodeLine{18798                 0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, \textcolor{comment}{// s0..s0}}
\DoxyCodeLine{18799                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, \textcolor{comment}{// s1..s2}}
\DoxyCodeLine{18800                 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, \textcolor{comment}{// s3..s4}}
\DoxyCodeLine{18801                 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, \textcolor{comment}{// s5..s6}}
\DoxyCodeLine{18802                 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 \textcolor{comment}{// s7..s8}}
\DoxyCodeLine{18803             \}}
\DoxyCodeLine{18804         \};}
\DoxyCodeLine{18805 }
\DoxyCodeLine{18806         JSON\_ASSERT(\textcolor{keywordtype}{byte} < utf8d.size());}
\DoxyCodeLine{18807         \textcolor{keyword}{const} std::uint8\_t type = utf8d[byte];}
\DoxyCodeLine{18808 }
\DoxyCodeLine{18809         codep = (state != UTF8\_ACCEPT)}
\DoxyCodeLine{18810                 ? (\textcolor{keywordtype}{byte} \& 0x3fu) | (codep << 6u)}
\DoxyCodeLine{18811                 : (0xFFu >> type) \& (byte);}
\DoxyCodeLine{18812 }
\DoxyCodeLine{18813         std::size\_t index = 256u + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(state) * 16u + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(type);}
\DoxyCodeLine{18814         JSON\_ASSERT(index < 400);}
\DoxyCodeLine{18815         state = utf8d[index];}
\DoxyCodeLine{18816         \textcolor{keywordflow}{return} state;}
\DoxyCodeLine{18817     \}}
\DoxyCodeLine{18818 }
\DoxyCodeLine{18819     \textcolor{comment}{/*}}
\DoxyCodeLine{18820 \textcolor{comment}{     * Overload to make the compiler happy while it is instantiating}}
\DoxyCodeLine{18821 \textcolor{comment}{     * dump\_integer for number\_unsigned\_t.}}
\DoxyCodeLine{18822 \textcolor{comment}{     * Must never be called.}}
\DoxyCodeLine{18823 \textcolor{comment}{     */}}
\DoxyCodeLine{18824     number\_unsigned\_t remove\_sign(number\_unsigned\_t x)}
\DoxyCodeLine{18825     \{}
\DoxyCodeLine{18826         JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{18827         \textcolor{keywordflow}{return} x; \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{18828     \}}
\DoxyCodeLine{18829 }
\DoxyCodeLine{18830     \textcolor{comment}{/*}}
\DoxyCodeLine{18831 \textcolor{comment}{     * Helper function for dump\_integer}}
\DoxyCodeLine{18832 \textcolor{comment}{     *}}
\DoxyCodeLine{18833 \textcolor{comment}{     * This function takes a negative signed integer and returns its absolute}}
\DoxyCodeLine{18834 \textcolor{comment}{     * value as unsigned integer. The plus/minus shuffling is necessary as we can}}
\DoxyCodeLine{18835 \textcolor{comment}{     * not directly remove the sign of an arbitrary signed integer as the}}
\DoxyCodeLine{18836 \textcolor{comment}{     * absolute values of INT\_MIN and INT\_MAX are usually not the same. See}}
\DoxyCodeLine{18837 \textcolor{comment}{     * \#1708 for details.}}
\DoxyCodeLine{18838 \textcolor{comment}{     */}}
\DoxyCodeLine{18839     \textcolor{keyword}{inline} number\_unsigned\_t remove\_sign(number\_integer\_t x) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{18840     \{}
\DoxyCodeLine{18841         JSON\_ASSERT(x < 0 \&\& x < (std::numeric\_limits<number\_integer\_t>::max)()); \textcolor{comment}{// NOLINT(misc-\/redundant-\/expression)}}
\DoxyCodeLine{18842         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}number\_unsigned\_t\textcolor{keyword}{>}(-\/(x + 1)) + 1;}
\DoxyCodeLine{18843     \}}
\DoxyCodeLine{18844 }
\DoxyCodeLine{18845   \textcolor{keyword}{private}:}
\DoxyCodeLine{18847     output\_adapter\_t<char> o = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{18848 }
\DoxyCodeLine{18850     std::array<char, 64> number\_buffer\{\{\}\};}
\DoxyCodeLine{18851 }
\DoxyCodeLine{18853     \textcolor{keyword}{const} std::lconv* loc = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{18855     \textcolor{keyword}{const} \textcolor{keywordtype}{char} thousands\_sep = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{18857     \textcolor{keyword}{const} \textcolor{keywordtype}{char} decimal\_point = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{18858 }
\DoxyCodeLine{18860     std::array<char, 512> string\_buffer\{\{\}\};}
\DoxyCodeLine{18861 }
\DoxyCodeLine{18863     \textcolor{keyword}{const} \textcolor{keywordtype}{char} \mbox{\hyperlink{classdetail_1_1serializer_acf6f783e3299d8b18ce4b5d9746f39f6}{indent\_char}};}
\DoxyCodeLine{18865     string\_t \mbox{\hyperlink{classdetail_1_1serializer_a7f6f1d36859514ab42984deb28d2521e}{indent\_string}};}
\DoxyCodeLine{18866 }
\DoxyCodeLine{18868     \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298}{error\_handler\_t}} \mbox{\hyperlink{classdetail_1_1serializer_a79d25c7416dd71a0db8b10988ec360f7}{error\_handler}};}
\DoxyCodeLine{18869 \};}
\DoxyCodeLine{18870 }
\DoxyCodeLine{18871 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{18872 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{18873 }
\DoxyCodeLine{18874 \textcolor{comment}{// \#include <nlohmann/detail/value\_t.hpp>}}
\DoxyCodeLine{18875 }
\DoxyCodeLine{18876 \textcolor{comment}{// \#include <nlohmann/json\_fwd.hpp>}}
\DoxyCodeLine{18877 }
\DoxyCodeLine{18878 \textcolor{comment}{// \#include <nlohmann/ordered\_map.hpp>}}
\DoxyCodeLine{18879 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{18880 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{18881 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{18882 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{18883 \textcolor{comment}{//}}
\DoxyCodeLine{18884 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{18885 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{18886 }
\DoxyCodeLine{18887 }
\DoxyCodeLine{18888 }
\DoxyCodeLine{18889 \textcolor{preprocessor}{\#include <functional>} \textcolor{comment}{// equal\_to, less}}
\DoxyCodeLine{18890 \textcolor{preprocessor}{\#include <initializer\_list>} \textcolor{comment}{// initializer\_list}}
\DoxyCodeLine{18891 \textcolor{preprocessor}{\#include <iterator>} \textcolor{comment}{// input\_iterator\_tag, iterator\_traits}}
\DoxyCodeLine{18892 \textcolor{preprocessor}{\#include <memory>} \textcolor{comment}{// allocator}}
\DoxyCodeLine{18893 \textcolor{preprocessor}{\#include <stdexcept>} \textcolor{comment}{// for out\_of\_range}}
\DoxyCodeLine{18894 \textcolor{preprocessor}{\#include <type\_traits>} \textcolor{comment}{// enable\_if, is\_convertible}}
\DoxyCodeLine{18895 \textcolor{preprocessor}{\#include <utility>} \textcolor{comment}{// pair}}
\DoxyCodeLine{18896 \textcolor{preprocessor}{\#include <vector>} \textcolor{comment}{// vector}}
\DoxyCodeLine{18897 }
\DoxyCodeLine{18898 \textcolor{comment}{// \#include <nlohmann/detail/macro\_scope.hpp>}}
\DoxyCodeLine{18899 }
\DoxyCodeLine{18900 \textcolor{comment}{// \#include <nlohmann/detail/meta/type\_traits.hpp>}}
\DoxyCodeLine{18901 }
\DoxyCodeLine{18902 }
\DoxyCodeLine{18903 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{18904 }
\DoxyCodeLine{18907 \textcolor{keyword}{template} <\textcolor{keyword}{class} Key, \textcolor{keyword}{class} T, \textcolor{keyword}{class} IgnoredLess = std::less<Key>,}
\DoxyCodeLine{18908           \textcolor{keyword}{class} Allocator = std::allocator<std::pair<const Key, T>>>}
\DoxyCodeLine{18909                   \textcolor{keyword}{struct }\mbox{\hyperlink{structordered__map}{ordered\_map}} : std::vector<std::pair<const Key, T>, Allocator>}
\DoxyCodeLine{18910 \{}
\DoxyCodeLine{18911     \textcolor{keyword}{using }key\_type = Key;}
\DoxyCodeLine{18912     \textcolor{keyword}{using }mapped\_type = T;}
\DoxyCodeLine{18913     \textcolor{keyword}{using }Container = std::vector<std::pair<const Key, T>, Allocator>;}
\DoxyCodeLine{18914     \textcolor{keyword}{using }iterator = \textcolor{keyword}{typename} Container::iterator;}
\DoxyCodeLine{18915     \textcolor{keyword}{using }const\_iterator = \textcolor{keyword}{typename} Container::const\_iterator;}
\DoxyCodeLine{18916     \textcolor{keyword}{using }size\_type = \textcolor{keyword}{typename} Container::size\_type;}
\DoxyCodeLine{18917     \textcolor{keyword}{using }value\_type = \textcolor{keyword}{typename} Container::value\_type;}
\DoxyCodeLine{18918 \textcolor{preprocessor}{\#ifdef JSON\_HAS\_CPP\_14}}
\DoxyCodeLine{18919     \textcolor{keyword}{using }key\_compare = std::equal\_to<>;}
\DoxyCodeLine{18920 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{18921     \textcolor{keyword}{using }key\_compare = std::equal\_to<Key>;}
\DoxyCodeLine{18922 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{18923 }
\DoxyCodeLine{18924     \textcolor{comment}{// Explicit constructors instead of `using Container::Container`}}
\DoxyCodeLine{18925     \textcolor{comment}{// otherwise older compilers choke on it (GCC <= 5.5, xcode <= 9.4)}}
\DoxyCodeLine{18926     \mbox{\hyperlink{structordered__map}{ordered\_map}}() \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(Container())) : Container\{\} \{\}}
\DoxyCodeLine{18927     \textcolor{keyword}{explicit} \mbox{\hyperlink{structordered__map}{ordered\_map}}(\textcolor{keyword}{const} Allocator\& alloc) \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(Container(alloc))) : Container\{alloc\} \{\}}
\DoxyCodeLine{18928     \textcolor{keyword}{template} <\textcolor{keyword}{class} It>}
\DoxyCodeLine{18929     \mbox{\hyperlink{structordered__map}{ordered\_map}}(It first, It last, \textcolor{keyword}{const} Allocator\& alloc = Allocator())}
\DoxyCodeLine{18930         : Container\{first, last, alloc\} \{\}}
\DoxyCodeLine{18931     \mbox{\hyperlink{structordered__map}{ordered\_map}}(std::initializer\_list<value\_type> init, \textcolor{keyword}{const} Allocator\& alloc = Allocator() )}
\DoxyCodeLine{18932         : Container\{init, alloc\} \{\}}
\DoxyCodeLine{18933 }
\DoxyCodeLine{18934     std::pair<iterator, bool> emplace(\textcolor{keyword}{const} key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, T\&\& t)}
\DoxyCodeLine{18935     \{}
\DoxyCodeLine{18936         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{18937         \{}
\DoxyCodeLine{18938             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{18939             \{}
\DoxyCodeLine{18940                 \textcolor{keywordflow}{return} \{it, \textcolor{keyword}{false}\};}
\DoxyCodeLine{18941             \}}
\DoxyCodeLine{18942         \}}
\DoxyCodeLine{18943         Container::emplace\_back(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, std::forward<T>(t));}
\DoxyCodeLine{18944         \textcolor{keywordflow}{return} \{std::prev(this-\/>end()), \textcolor{keyword}{true}\};}
\DoxyCodeLine{18945     \}}
\DoxyCodeLine{18946 }
\DoxyCodeLine{18947     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{18948                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{18949     std::pair<iterator, bool> emplace(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, T \&\& t)}
\DoxyCodeLine{18950     \{}
\DoxyCodeLine{18951         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{18952         \{}
\DoxyCodeLine{18953             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{18954             \{}
\DoxyCodeLine{18955                 \textcolor{keywordflow}{return} \{it, \textcolor{keyword}{false}\};}
\DoxyCodeLine{18956             \}}
\DoxyCodeLine{18957         \}}
\DoxyCodeLine{18958         Container::emplace\_back(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}), std::forward<T>(t));}
\DoxyCodeLine{18959         \textcolor{keywordflow}{return} \{std::prev(this-\/>end()), \textcolor{keyword}{true}\};}
\DoxyCodeLine{18960     \}}
\DoxyCodeLine{18961 }
\DoxyCodeLine{18962     T\& operator[](\textcolor{keyword}{const} key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{18963     \{}
\DoxyCodeLine{18964         \textcolor{keywordflow}{return} emplace(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, T\{\}).first-\/>second;}
\DoxyCodeLine{18965     \}}
\DoxyCodeLine{18966 }
\DoxyCodeLine{18967     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{18968                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{18969     T \& operator[](KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{18970     \{}
\DoxyCodeLine{18971         \textcolor{keywordflow}{return} emplace(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}), T\{\}).first-\/>second;}
\DoxyCodeLine{18972     \}}
\DoxyCodeLine{18973 }
\DoxyCodeLine{18974     \textcolor{keyword}{const} T\& operator[](\textcolor{keyword}{const} key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{18975 \textcolor{keyword}{    }\{}
\DoxyCodeLine{18976         \textcolor{keywordflow}{return} at(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}});}
\DoxyCodeLine{18977     \}}
\DoxyCodeLine{18978 }
\DoxyCodeLine{18979     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{18980                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{18981     \textcolor{keyword}{const} T \& operator[](KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{18982 \textcolor{keyword}{    }\{}
\DoxyCodeLine{18983         \textcolor{keywordflow}{return} at(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{18984     \}}
\DoxyCodeLine{18985 }
\DoxyCodeLine{18986     T\& at(\textcolor{keyword}{const} key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{18987     \{}
\DoxyCodeLine{18988         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{18989         \{}
\DoxyCodeLine{18990             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{18991             \{}
\DoxyCodeLine{18992                 \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{18993             \}}
\DoxyCodeLine{18994         \}}
\DoxyCodeLine{18995 }
\DoxyCodeLine{18996         JSON\_THROW(std::out\_of\_range(\textcolor{stringliteral}{"{}key not found"{}}));}
\DoxyCodeLine{18997     \}}
\DoxyCodeLine{18998 }
\DoxyCodeLine{18999     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{19000                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{19001     T \& at(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{19002     \{}
\DoxyCodeLine{19003         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19004         \{}
\DoxyCodeLine{19005             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{19006             \{}
\DoxyCodeLine{19007                 \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{19008             \}}
\DoxyCodeLine{19009         \}}
\DoxyCodeLine{19010 }
\DoxyCodeLine{19011         JSON\_THROW(std::out\_of\_range(\textcolor{stringliteral}{"{}key not found"{}}));}
\DoxyCodeLine{19012     \}}
\DoxyCodeLine{19013 }
\DoxyCodeLine{19014     \textcolor{keyword}{const} T\& at(\textcolor{keyword}{const} key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{19015 \textcolor{keyword}{    }\{}
\DoxyCodeLine{19016         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19017         \{}
\DoxyCodeLine{19018             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{19019             \{}
\DoxyCodeLine{19020                 \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{19021             \}}
\DoxyCodeLine{19022         \}}
\DoxyCodeLine{19023 }
\DoxyCodeLine{19024         JSON\_THROW(std::out\_of\_range(\textcolor{stringliteral}{"{}key not found"{}}));}
\DoxyCodeLine{19025     \}}
\DoxyCodeLine{19026 }
\DoxyCodeLine{19027     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{19028                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{19029     \textcolor{keyword}{const} T \& at(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{19030 \textcolor{keyword}{    }\{}
\DoxyCodeLine{19031         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19032         \{}
\DoxyCodeLine{19033             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{19034             \{}
\DoxyCodeLine{19035                 \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{19036             \}}
\DoxyCodeLine{19037         \}}
\DoxyCodeLine{19038 }
\DoxyCodeLine{19039         JSON\_THROW(std::out\_of\_range(\textcolor{stringliteral}{"{}key not found"{}}));}
\DoxyCodeLine{19040     \}}
\DoxyCodeLine{19041 }
\DoxyCodeLine{19042     size\_type erase(\textcolor{keyword}{const} key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{19043     \{}
\DoxyCodeLine{19044         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19045         \{}
\DoxyCodeLine{19046             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{19047             \{}
\DoxyCodeLine{19048                 \textcolor{comment}{// Since we cannot move const Keys, re-\/construct them in place}}
\DoxyCodeLine{19049                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} next = it; ++next != this-\/>end(); ++it)}
\DoxyCodeLine{19050                 \{}
\DoxyCodeLine{19051                     it-\/>\string~value\_type(); \textcolor{comment}{// Destroy but keep allocation}}
\DoxyCodeLine{19052                     \textcolor{keyword}{new} (\&*it) value\_type\{std::move(*next)\};}
\DoxyCodeLine{19053                 \}}
\DoxyCodeLine{19054                 Container::pop\_back();}
\DoxyCodeLine{19055                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{19056             \}}
\DoxyCodeLine{19057         \}}
\DoxyCodeLine{19058         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{19059     \}}
\DoxyCodeLine{19060 }
\DoxyCodeLine{19061     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{19062                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{19063     size\_type erase(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{19064     \{}
\DoxyCodeLine{19065         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19066         \{}
\DoxyCodeLine{19067             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{19068             \{}
\DoxyCodeLine{19069                 \textcolor{comment}{// Since we cannot move const Keys, re-\/construct them in place}}
\DoxyCodeLine{19070                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} next = it; ++next != this-\/>end(); ++it)}
\DoxyCodeLine{19071                 \{}
\DoxyCodeLine{19072                     it-\/>\string~value\_type(); \textcolor{comment}{// Destroy but keep allocation}}
\DoxyCodeLine{19073                     \textcolor{keyword}{new} (\&*it) value\_type\{std::move(*next)\};}
\DoxyCodeLine{19074                 \}}
\DoxyCodeLine{19075                 Container::pop\_back();}
\DoxyCodeLine{19076                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{19077             \}}
\DoxyCodeLine{19078         \}}
\DoxyCodeLine{19079         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{19080     \}}
\DoxyCodeLine{19081 }
\DoxyCodeLine{19082     iterator erase(iterator pos)}
\DoxyCodeLine{19083     \{}
\DoxyCodeLine{19084         \textcolor{keywordflow}{return} erase(pos, std::next(pos));}
\DoxyCodeLine{19085     \}}
\DoxyCodeLine{19086 }
\DoxyCodeLine{19087     iterator erase(iterator first, iterator last)}
\DoxyCodeLine{19088     \{}
\DoxyCodeLine{19089         \textcolor{keywordflow}{if} (first == last)}
\DoxyCodeLine{19090         \{}
\DoxyCodeLine{19091             \textcolor{keywordflow}{return} first;}
\DoxyCodeLine{19092         \}}
\DoxyCodeLine{19093 }
\DoxyCodeLine{19094         \textcolor{keyword}{const} \textcolor{keyword}{auto} elements\_affected = std::distance(first, last);}
\DoxyCodeLine{19095         \textcolor{keyword}{const} \textcolor{keyword}{auto} offset = std::distance(Container::begin(), first);}
\DoxyCodeLine{19096 }
\DoxyCodeLine{19097         \textcolor{comment}{// This is the start situation. We need to delete elements\_affected}}
\DoxyCodeLine{19098         \textcolor{comment}{// elements (3 in this example: e, f, g), and need to return an}}
\DoxyCodeLine{19099         \textcolor{comment}{// iterator past the last deleted element (h in this example).}}
\DoxyCodeLine{19100         \textcolor{comment}{// Note that offset is the distance from the start of the vector}}
\DoxyCodeLine{19101         \textcolor{comment}{// to first. We will need this later.}}
\DoxyCodeLine{19102 }
\DoxyCodeLine{19103         \textcolor{comment}{// [ a, b, c, d, e, f, g, h, i, j ]}}
\DoxyCodeLine{19104         \textcolor{comment}{//               \string^        \string^}}
\DoxyCodeLine{19105         \textcolor{comment}{//             first    last}}
\DoxyCodeLine{19106 }
\DoxyCodeLine{19107         \textcolor{comment}{// Since we cannot move const Keys, we re-\/construct them in place.}}
\DoxyCodeLine{19108         \textcolor{comment}{// We start at first and re-\/construct (viz. copy) the elements from}}
\DoxyCodeLine{19109         \textcolor{comment}{// the back of the vector. Example for first iteration:}}
\DoxyCodeLine{19110 }
\DoxyCodeLine{19111         \textcolor{comment}{//               ,-\/-\/-\/-\/-\/-\/-\/-\/.}}
\DoxyCodeLine{19112         \textcolor{comment}{//               v        |   destroy e and re-\/construct with h}}
\DoxyCodeLine{19113         \textcolor{comment}{// [ a, b, c, d, e, f, g, h, i, j ]}}
\DoxyCodeLine{19114         \textcolor{comment}{//               \string^        \string^}}
\DoxyCodeLine{19115         \textcolor{comment}{//               it       it + elements\_affected}}
\DoxyCodeLine{19116 }
\DoxyCodeLine{19117         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; std::next(it, elements\_affected) != Container::end(); ++it)}
\DoxyCodeLine{19118         \{}
\DoxyCodeLine{19119             it-\/>\string~value\_type(); \textcolor{comment}{// destroy but keep allocation}}
\DoxyCodeLine{19120             \textcolor{keyword}{new} (\&*it) value\_type\{std::move(*std::next(it, elements\_affected))\}; \textcolor{comment}{// "{}move"{} next element to it}}
\DoxyCodeLine{19121         \}}
\DoxyCodeLine{19122 }
\DoxyCodeLine{19123         \textcolor{comment}{// [ a, b, c, d, h, i, j, h, i, j ]}}
\DoxyCodeLine{19124         \textcolor{comment}{//               \string^        \string^}}
\DoxyCodeLine{19125         \textcolor{comment}{//             first    last}}
\DoxyCodeLine{19126 }
\DoxyCodeLine{19127         \textcolor{comment}{// remove the unneeded elements at the end of the vector}}
\DoxyCodeLine{19128         Container::resize(this-\/>size() -\/ \textcolor{keyword}{static\_cast<}size\_type\textcolor{keyword}{>}(elements\_affected));}
\DoxyCodeLine{19129 }
\DoxyCodeLine{19130         \textcolor{comment}{// [ a, b, c, d, h, i, j ]}}
\DoxyCodeLine{19131         \textcolor{comment}{//               \string^        \string^}}
\DoxyCodeLine{19132         \textcolor{comment}{//             first    last}}
\DoxyCodeLine{19133 }
\DoxyCodeLine{19134         \textcolor{comment}{// first is now pointing past the last deleted element, but we cannot}}
\DoxyCodeLine{19135         \textcolor{comment}{// use this iterator, because it may have been invalidated by the}}
\DoxyCodeLine{19136         \textcolor{comment}{// resize call. Instead, we can return begin() + offset.}}
\DoxyCodeLine{19137         \textcolor{keywordflow}{return} Container::begin() + offset;}
\DoxyCodeLine{19138     \}}
\DoxyCodeLine{19139 }
\DoxyCodeLine{19140     size\_type count(\textcolor{keyword}{const} key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{19141 \textcolor{keyword}{    }\{}
\DoxyCodeLine{19142         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19143         \{}
\DoxyCodeLine{19144             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{19145             \{}
\DoxyCodeLine{19146                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{19147             \}}
\DoxyCodeLine{19148         \}}
\DoxyCodeLine{19149         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{19150     \}}
\DoxyCodeLine{19151 }
\DoxyCodeLine{19152     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{19153                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{19154     size\_type count(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{19155 \textcolor{keyword}{    }\{}
\DoxyCodeLine{19156         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19157         \{}
\DoxyCodeLine{19158             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{19159             \{}
\DoxyCodeLine{19160                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{19161             \}}
\DoxyCodeLine{19162         \}}
\DoxyCodeLine{19163         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{19164     \}}
\DoxyCodeLine{19165 }
\DoxyCodeLine{19166     iterator find(\textcolor{keyword}{const} key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{19167     \{}
\DoxyCodeLine{19168         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19169         \{}
\DoxyCodeLine{19170             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{19171             \{}
\DoxyCodeLine{19172                 \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{19173             \}}
\DoxyCodeLine{19174         \}}
\DoxyCodeLine{19175         \textcolor{keywordflow}{return} Container::end();}
\DoxyCodeLine{19176     \}}
\DoxyCodeLine{19177 }
\DoxyCodeLine{19178     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{19179                  detail::is\_usable\_as\_key\_type<key\_compare, key\_type, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{19180     iterator find(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{19181     \{}
\DoxyCodeLine{19182         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19183         \{}
\DoxyCodeLine{19184             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{19185             \{}
\DoxyCodeLine{19186                 \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{19187             \}}
\DoxyCodeLine{19188         \}}
\DoxyCodeLine{19189         \textcolor{keywordflow}{return} Container::end();}
\DoxyCodeLine{19190     \}}
\DoxyCodeLine{19191 }
\DoxyCodeLine{19192     const\_iterator find(\textcolor{keyword}{const} key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{19193 \textcolor{keyword}{    }\{}
\DoxyCodeLine{19194         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19195         \{}
\DoxyCodeLine{19196             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}))}
\DoxyCodeLine{19197             \{}
\DoxyCodeLine{19198                 \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{19199             \}}
\DoxyCodeLine{19200         \}}
\DoxyCodeLine{19201         \textcolor{keywordflow}{return} Container::end();}
\DoxyCodeLine{19202     \}}
\DoxyCodeLine{19203 }
\DoxyCodeLine{19204     std::pair<iterator, bool> insert( value\_type\&\& value )}
\DoxyCodeLine{19205     \{}
\DoxyCodeLine{19206         \textcolor{keywordflow}{return} emplace(value.first, std::move(value.second));}
\DoxyCodeLine{19207     \}}
\DoxyCodeLine{19208 }
\DoxyCodeLine{19209     std::pair<iterator, bool> insert( \textcolor{keyword}{const} value\_type\& value )}
\DoxyCodeLine{19210     \{}
\DoxyCodeLine{19211         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = this-\/>begin(); it != this-\/>end(); ++it)}
\DoxyCodeLine{19212         \{}
\DoxyCodeLine{19213             \textcolor{keywordflow}{if} (m\_compare(it-\/>first, value.first))}
\DoxyCodeLine{19214             \{}
\DoxyCodeLine{19215                 \textcolor{keywordflow}{return} \{it, \textcolor{keyword}{false}\};}
\DoxyCodeLine{19216             \}}
\DoxyCodeLine{19217         \}}
\DoxyCodeLine{19218         Container::push\_back(value);}
\DoxyCodeLine{19219         \textcolor{keywordflow}{return} \{-\/-\/this-\/>end(), \textcolor{keyword}{true}\};}
\DoxyCodeLine{19220     \}}
\DoxyCodeLine{19221 }
\DoxyCodeLine{19222     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIt>}
\DoxyCodeLine{19223     \textcolor{keyword}{using }require\_input\_iter = \textcolor{keyword}{typename} std::enable\_if<std::is\_convertible<typename std::iterator\_traits<InputIt>::iterator\_category,}
\DoxyCodeLine{19224             std::input\_iterator\_tag>::value>::type;}
\DoxyCodeLine{19225 }
\DoxyCodeLine{19226     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIt, \textcolor{keyword}{typename} = require\_input\_iter<InputIt>>}
\DoxyCodeLine{19227     \textcolor{keywordtype}{void} insert(InputIt first, InputIt last)}
\DoxyCodeLine{19228     \{}
\DoxyCodeLine{19229         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; it != last; ++it)}
\DoxyCodeLine{19230         \{}
\DoxyCodeLine{19231             insert(*it);}
\DoxyCodeLine{19232         \}}
\DoxyCodeLine{19233     \}}
\DoxyCodeLine{19234 }
\DoxyCodeLine{19235 \textcolor{keyword}{private}:}
\DoxyCodeLine{19236     JSON\_NO\_UNIQUE\_ADDRESS key\_compare m\_compare = key\_compare();}
\DoxyCodeLine{19237 \};}
\DoxyCodeLine{19238 }
\DoxyCodeLine{19239 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{19240 }
\DoxyCodeLine{19241 }
\DoxyCodeLine{19242 \textcolor{preprocessor}{\#if defined(JSON\_HAS\_CPP\_17)}}
\DoxyCodeLine{19243 \textcolor{preprocessor}{    \#include <any>}}
\DoxyCodeLine{19244 \textcolor{preprocessor}{    \#include <string\_view>}}
\DoxyCodeLine{19245 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19246 }
\DoxyCodeLine{19252 NLOHMANN\_JSON\_NAMESPACE\_BEGIN}
\DoxyCodeLine{19253 }
\DoxyCodeLine{19272 NLOHMANN\_BASIC\_JSON\_TPL\_DECLARATION}
\DoxyCodeLine{19273 \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__json}{basic\_json}} \textcolor{comment}{// NOLINT(cppcoreguidelines-\/special-\/member-\/functions,hicpp-\/special-\/member-\/functions)}}
\DoxyCodeLine{19274 \{}
\DoxyCodeLine{19275   \textcolor{keyword}{private}:}
\DoxyCodeLine{19276     \textcolor{keyword}{template}<detail::value\_t> \textcolor{keyword}{friend} \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1external__constructor}{detail::external\_constructor}};}
\DoxyCodeLine{19277 }
\DoxyCodeLine{19278     \textcolor{keyword}{template}<\textcolor{keyword}{typename}>}
\DoxyCodeLine{19279     \textcolor{keyword}{friend} class ::nlohmann::json\_pointer;}
\DoxyCodeLine{19280     \textcolor{comment}{// can be restored when json\_pointer backwards compatibility is removed}}
\DoxyCodeLine{19281     \textcolor{comment}{// friend ::nlohmann::json\_pointer<StringType>;}}
\DoxyCodeLine{19282 }
\DoxyCodeLine{19283     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} InputType>}
\DoxyCodeLine{19284     \textcolor{keyword}{friend} class ::nlohmann::detail::parser;}
\DoxyCodeLine{19285     friend ::nlohmann::detail::serializer<basic\_json>;}
\DoxyCodeLine{19286     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{19287     \textcolor{keyword}{friend} class ::nlohmann::detail::iter\_impl;}
\DoxyCodeLine{19288     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{19289     \textcolor{keyword}{friend} class ::nlohmann::detail::binary\_writer;}
\DoxyCodeLine{19290     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType, \textcolor{keyword}{typename} InputType, \textcolor{keyword}{typename} SAX>}
\DoxyCodeLine{19291     \textcolor{keyword}{friend} class ::nlohmann::detail::binary\_reader;}
\DoxyCodeLine{19292     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{19293     \textcolor{keyword}{friend} class ::nlohmann::detail::json\_sax\_dom\_parser;}
\DoxyCodeLine{19294     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{19295     \textcolor{keyword}{friend} class ::nlohmann::detail::json\_sax\_dom\_callback\_parser;}
\DoxyCodeLine{19296     \textcolor{keyword}{friend} class ::nlohmann::detail::exception;}
\DoxyCodeLine{19297 }
\DoxyCodeLine{19299     \textcolor{keyword}{using }basic\_json\_t = NLOHMANN\_BASIC\_JSON\_TPL;}
\DoxyCodeLine{19300 }
\DoxyCodeLine{19301   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{19302     \textcolor{comment}{// convenience aliases for types residing in namespace detail;}}
\DoxyCodeLine{19303     \textcolor{keyword}{using }lexer = ::nlohmann::detail::lexer\_base<basic\_json>;}
\DoxyCodeLine{19304 }
\DoxyCodeLine{19305     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputAdapterType>}
\DoxyCodeLine{19306     static ::nlohmann::detail::parser<basic\_json, InputAdapterType> parser(}
\DoxyCodeLine{19307         InputAdapterType adapter,}
\DoxyCodeLine{19308         detail::parser\_callback\_t<basic\_json>cb = \textcolor{keyword}{nullptr},}
\DoxyCodeLine{19309         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true},}
\DoxyCodeLine{19310         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ignore\_comments = \textcolor{keyword}{false}}
\DoxyCodeLine{19311                                  )}
\DoxyCodeLine{19312     \{}
\DoxyCodeLine{19313         return ::nlohmann::detail::parser<basic\_json, InputAdapterType>(std::move(adapter),}
\DoxyCodeLine{19314                 std::move(cb), allow\_exceptions, ignore\_comments);}
\DoxyCodeLine{19315     \}}
\DoxyCodeLine{19316 }
\DoxyCodeLine{19317   \textcolor{keyword}{private}:}
\DoxyCodeLine{19318     \textcolor{keyword}{using }primitive\_iterator\_t = ::nlohmann::detail::primitive\_iterator\_t;}
\DoxyCodeLine{19319     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{19320     \textcolor{keyword}{using }internal\_iterator = ::nlohmann::detail::internal\_iterator<BasicJsonType>;}
\DoxyCodeLine{19321     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType>}
\DoxyCodeLine{19322     \textcolor{keyword}{using }iter\_impl = ::nlohmann::detail::iter\_impl<BasicJsonType>;}
\DoxyCodeLine{19323     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{19324     \textcolor{keyword}{using }iteration\_proxy = ::nlohmann::detail::iteration\_proxy<Iterator>;}
\DoxyCodeLine{19325     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Base> \textcolor{keyword}{using }json\_reverse\_iterator = ::nlohmann::detail::json\_reverse\_iterator<Base>;}
\DoxyCodeLine{19326 }
\DoxyCodeLine{19327     \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{19328     \textcolor{keyword}{using }output\_adapter\_t = ::nlohmann::detail::output\_adapter\_t<CharType>;}
\DoxyCodeLine{19329 }
\DoxyCodeLine{19330     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>}
\DoxyCodeLine{19331     \textcolor{keyword}{using }binary\_reader = ::nlohmann::detail::binary\_reader<basic\_json, InputType>;}
\DoxyCodeLine{19332     \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharType> \textcolor{keyword}{using }binary\_writer = ::nlohmann::detail::binary\_writer<basic\_json, CharType>;}
\DoxyCodeLine{19333 }
\DoxyCodeLine{19334   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{19335     \textcolor{keyword}{using }serializer = ::nlohmann::detail::serializer<basic\_json>;}
\DoxyCodeLine{19336 }
\DoxyCodeLine{19337   \textcolor{keyword}{public}:}
\DoxyCodeLine{19338     \textcolor{keyword}{using }\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} = \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{detail::value\_t}};}
\DoxyCodeLine{19340     \textcolor{keyword}{using }\mbox{\hyperlink{classjson__pointer}{json\_pointer}} = ::nlohmann::json\_pointer<StringType>;}
\DoxyCodeLine{19341     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} SFINAE>}
\DoxyCodeLine{19342     \textcolor{keyword}{using }json\_serializer = JSONSerializer<T, SFINAE>;}
\DoxyCodeLine{19344     \textcolor{keyword}{using }\mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298}{error\_handler\_t}} = \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298}{detail::error\_handler\_t}};}
\DoxyCodeLine{19346     \textcolor{keyword}{using }\mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}} = \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{detail::cbor\_tag\_handler\_t}};}
\DoxyCodeLine{19348     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a2063ed828cd027216c549ac48527a562}{initializer\_list\_t}} = std::initializer\_list<detail::json\_ref<basic\_json>>;}
\DoxyCodeLine{19349 }
\DoxyCodeLine{19350     \textcolor{keyword}{using }\mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} = \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{detail::input\_format\_t}};}
\DoxyCodeLine{19352     \textcolor{keyword}{using }\mbox{\hyperlink{structjson__sax}{json\_sax\_t}} = \mbox{\hyperlink{structjson__sax}{json\_sax<basic\_json>}};}
\DoxyCodeLine{19353 }
\DoxyCodeLine{19355     \textcolor{comment}{// exceptions //}}
\DoxyCodeLine{19357 \textcolor{comment}{}}
\DoxyCodeLine{19361 }
\DoxyCodeLine{19362     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1exception}{exception}} = \mbox{\hyperlink{classdetail_1_1exception}{detail::exception}};}
\DoxyCodeLine{19363     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1parse__error}{parse\_error}} = \mbox{\hyperlink{classdetail_1_1parse__error}{detail::parse\_error}};}
\DoxyCodeLine{19364     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1invalid__iterator}{invalid\_iterator}} = \mbox{\hyperlink{classdetail_1_1invalid__iterator}{detail::invalid\_iterator}};}
\DoxyCodeLine{19365     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1type__error}{type\_error}} = \mbox{\hyperlink{classdetail_1_1type__error}{detail::type\_error}};}
\DoxyCodeLine{19366     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1out__of__range}{out\_of\_range}} = \mbox{\hyperlink{classdetail_1_1out__of__range}{detail::out\_of\_range}};}
\DoxyCodeLine{19367     \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1other__error}{other\_error}} = \mbox{\hyperlink{classdetail_1_1other__error}{detail::other\_error}};}
\DoxyCodeLine{19368 }
\DoxyCodeLine{19370 }
\DoxyCodeLine{19371 }
\DoxyCodeLine{19373     \textcolor{comment}{// container types //}}
\DoxyCodeLine{19375 \textcolor{comment}{}}
\DoxyCodeLine{19380 }
\DoxyCodeLine{19382     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json}{value\_type}} = \mbox{\hyperlink{classbasic__json}{basic\_json}};}
\DoxyCodeLine{19383 }
\DoxyCodeLine{19385     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json}{reference}} = \mbox{\hyperlink{classbasic__json}{value\_type}}\&;}
\DoxyCodeLine{19387     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json}{const\_reference}} = \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{value\_type}}\&;}
\DoxyCodeLine{19388 }
\DoxyCodeLine{19390     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a2fe32d636c1b78861884dde9716b22b6}{difference\_type}} = std::ptrdiff\_t;}
\DoxyCodeLine{19392     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} = std::size\_t;}
\DoxyCodeLine{19393 }
\DoxyCodeLine{19395     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a485873eed243b6ca7e30c96130a5ec2d}{allocator\_type}} = AllocatorType<basic\_json>;}
\DoxyCodeLine{19396 }
\DoxyCodeLine{19398     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_ac02a5d1bf4e9cd1bdec90e97f4ea6f95}{pointer}} = \textcolor{keyword}{typename} std::allocator\_traits<allocator\_type>::pointer;}
\DoxyCodeLine{19400     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a28ac2566e6ab084c5c1e044d132aa4a3}{const\_pointer}} = \textcolor{keyword}{typename} std::allocator\_traits<allocator\_type>::const\_pointer;}
\DoxyCodeLine{19401 }
\DoxyCodeLine{19403     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a2935c91b82c8e586b1dd68ad665075a6}{iterator}} = iter\_impl<basic\_json>;}
\DoxyCodeLine{19405     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} = iter\_impl<const basic\_json>;}
\DoxyCodeLine{19407     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_ac639cd1b4238d158286e7e21b5829709}{reverse\_iterator}} = json\_reverse\_iterator<typename basic\_json::iterator>;}
\DoxyCodeLine{19409     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a2aa7d4c7719ab82aa8c77a83642c843f}{const\_reverse\_iterator}} = json\_reverse\_iterator<typename basic\_json::const\_iterator>;}
\DoxyCodeLine{19410 }
\DoxyCodeLine{19412 }
\DoxyCodeLine{19413 }
\DoxyCodeLine{19416     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json_a485873eed243b6ca7e30c96130a5ec2d}{allocator\_type}} \mbox{\hyperlink{classbasic__json_a1aaddd9686fb1dd50203c2138858df7e}{get\_allocator}}()}
\DoxyCodeLine{19417     \{}
\DoxyCodeLine{19418         \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__json_a485873eed243b6ca7e30c96130a5ec2d}{allocator\_type}}();}
\DoxyCodeLine{19419     \}}
\DoxyCodeLine{19420 }
\DoxyCodeLine{19423     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{19424     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a08303da85f75965764bb0c8d8b79a449}{meta}}()}
\DoxyCodeLine{19425     \{}
\DoxyCodeLine{19426         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{19427 }
\DoxyCodeLine{19428         result[\textcolor{stringliteral}{"{}copyright"{}}] = \textcolor{stringliteral}{"{}(C) 2013-\/2022 Niels Lohmann"{}};}
\DoxyCodeLine{19429         result[\textcolor{stringliteral}{"{}name"{}}] = \textcolor{stringliteral}{"{}JSON for Modern C++"{}};}
\DoxyCodeLine{19430         result[\textcolor{stringliteral}{"{}url"{}}] = \textcolor{stringliteral}{"{}https://github.com/nlohmann/json"{}};}
\DoxyCodeLine{19431         result[\textcolor{stringliteral}{"{}version"{}}][\textcolor{stringliteral}{"{}string"{}}] =}
\DoxyCodeLine{19432             detail::concat(std::to\_string(NLOHMANN\_JSON\_VERSION\_MAJOR), \textcolor{charliteral}{'.'},}
\DoxyCodeLine{19433                            std::to\_string(NLOHMANN\_JSON\_VERSION\_MINOR), \textcolor{charliteral}{'.'},}
\DoxyCodeLine{19434                            std::to\_string(NLOHMANN\_JSON\_VERSION\_PATCH));}
\DoxyCodeLine{19435         result[\textcolor{stringliteral}{"{}version"{}}][\textcolor{stringliteral}{"{}major"{}}] = NLOHMANN\_JSON\_VERSION\_MAJOR;}
\DoxyCodeLine{19436         result[\textcolor{stringliteral}{"{}version"{}}][\textcolor{stringliteral}{"{}minor"{}}] = NLOHMANN\_JSON\_VERSION\_MINOR;}
\DoxyCodeLine{19437         result[\textcolor{stringliteral}{"{}version"{}}][\textcolor{stringliteral}{"{}patch"{}}] = NLOHMANN\_JSON\_VERSION\_PATCH;}
\DoxyCodeLine{19438 }
\DoxyCodeLine{19439 \textcolor{preprocessor}{\#ifdef \_WIN32}}
\DoxyCodeLine{19440         result[\textcolor{stringliteral}{"{}platform"{}}] = \textcolor{stringliteral}{"{}win32"{}};}
\DoxyCodeLine{19441 \textcolor{preprocessor}{\#elif defined \_\_linux\_\_}}
\DoxyCodeLine{19442         result[\textcolor{stringliteral}{"{}platform"{}}] = \textcolor{stringliteral}{"{}linux"{}};}
\DoxyCodeLine{19443 \textcolor{preprocessor}{\#elif defined \_\_APPLE\_\_}}
\DoxyCodeLine{19444         result[\textcolor{stringliteral}{"{}platform"{}}] = \textcolor{stringliteral}{"{}apple"{}};}
\DoxyCodeLine{19445 \textcolor{preprocessor}{\#elif defined \_\_unix\_\_}}
\DoxyCodeLine{19446         result[\textcolor{stringliteral}{"{}platform"{}}] = \textcolor{stringliteral}{"{}unix"{}};}
\DoxyCodeLine{19447 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{19448         result[\textcolor{stringliteral}{"{}platform"{}}] = \textcolor{stringliteral}{"{}unknown"{}};}
\DoxyCodeLine{19449 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19450 }
\DoxyCodeLine{19451 \textcolor{preprocessor}{\#if defined(\_\_ICC) || defined(\_\_INTEL\_COMPILER)}}
\DoxyCodeLine{19452         result[\textcolor{stringliteral}{"{}compiler"{}}] = \{\{\textcolor{stringliteral}{"{}family"{}}, \textcolor{stringliteral}{"{}icc"{}}\}, \{\textcolor{stringliteral}{"{}version"{}}, \_\_INTEL\_COMPILER\}\};}
\DoxyCodeLine{19453 \textcolor{preprocessor}{\#elif defined(\_\_clang\_\_)}}
\DoxyCodeLine{19454         result[\textcolor{stringliteral}{"{}compiler"{}}] = \{\{\textcolor{stringliteral}{"{}family"{}}, \textcolor{stringliteral}{"{}clang"{}}\}, \{\textcolor{stringliteral}{"{}version"{}}, \_\_clang\_version\_\_\}\};}
\DoxyCodeLine{19455 \textcolor{preprocessor}{\#elif defined(\_\_GNUC\_\_) || defined(\_\_GNUG\_\_)}}
\DoxyCodeLine{19456         result[\textcolor{stringliteral}{"{}compiler"{}}] = \{\{\textcolor{stringliteral}{"{}family"{}}, \textcolor{stringliteral}{"{}gcc"{}}\}, \{\textcolor{stringliteral}{"{}version"{}}, detail::concat(}
\DoxyCodeLine{19457                     std::to\_string(\_\_GNUC\_\_), \textcolor{charliteral}{'.'},}
\DoxyCodeLine{19458                     std::to\_string(\_\_GNUC\_MINOR\_\_), \textcolor{charliteral}{'.'},}
\DoxyCodeLine{19459                     std::to\_string(\_\_GNUC\_PATCHLEVEL\_\_))}
\DoxyCodeLine{19460             \}}
\DoxyCodeLine{19461         \};}
\DoxyCodeLine{19462 \textcolor{preprocessor}{\#elif defined(\_\_HP\_cc) || defined(\_\_HP\_aCC)}}
\DoxyCodeLine{19463         result[\textcolor{stringliteral}{"{}compiler"{}}] = \textcolor{stringliteral}{"{}hp"{}}}
\DoxyCodeLine{19464 \textcolor{preprocessor}{\#elif defined(\_\_IBMCPP\_\_)}}
\DoxyCodeLine{19465         result[\textcolor{stringliteral}{"{}compiler"{}}] = \{\{\textcolor{stringliteral}{"{}family"{}}, \textcolor{stringliteral}{"{}ilecpp"{}}\}, \{\textcolor{stringliteral}{"{}version"{}}, \_\_IBMCPP\_\_\}\};}
\DoxyCodeLine{19466 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{19467         result[\textcolor{stringliteral}{"{}compiler"{}}] = \{\{\textcolor{stringliteral}{"{}family"{}}, \textcolor{stringliteral}{"{}msvc"{}}\}, \{\textcolor{stringliteral}{"{}version"{}}, \_MSC\_VER\}\};}
\DoxyCodeLine{19468 \textcolor{preprocessor}{\#elif defined(\_\_PGI)}}
\DoxyCodeLine{19469         result[\textcolor{stringliteral}{"{}compiler"{}}] = \{\{\textcolor{stringliteral}{"{}family"{}}, \textcolor{stringliteral}{"{}pgcpp"{}}\}, \{\textcolor{stringliteral}{"{}version"{}}, \_\_PGI\}\};}
\DoxyCodeLine{19470 \textcolor{preprocessor}{\#elif defined(\_\_SUNPRO\_CC)}}
\DoxyCodeLine{19471         result[\textcolor{stringliteral}{"{}compiler"{}}] = \{\{\textcolor{stringliteral}{"{}family"{}}, \textcolor{stringliteral}{"{}sunpro"{}}\}, \{\textcolor{stringliteral}{"{}version"{}}, \_\_SUNPRO\_CC\}\};}
\DoxyCodeLine{19472 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{19473         result[\textcolor{stringliteral}{"{}compiler"{}}] = \{\{\textcolor{stringliteral}{"{}family"{}}, \textcolor{stringliteral}{"{}unknown"{}}\}, \{\textcolor{stringliteral}{"{}version"{}}, \textcolor{stringliteral}{"{}unknown"{}}\}\};}
\DoxyCodeLine{19474 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19475 }
\DoxyCodeLine{19476 }
\DoxyCodeLine{19477 \textcolor{preprocessor}{\#if defined(\_MSVC\_LANG)}}
\DoxyCodeLine{19478         result[\textcolor{stringliteral}{"{}compiler"{}}][\textcolor{stringliteral}{"{}c++"{}}] = std::to\_string(\_MSVC\_LANG);}
\DoxyCodeLine{19479 \textcolor{preprocessor}{\#elif defined(\_\_cplusplus)}}
\DoxyCodeLine{19480         result[\textcolor{stringliteral}{"{}compiler"{}}][\textcolor{stringliteral}{"{}c++"{}}] = std::to\_string(\_\_cplusplus);}
\DoxyCodeLine{19481 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{19482         result[\textcolor{stringliteral}{"{}compiler"{}}][\textcolor{stringliteral}{"{}c++"{}}] = \textcolor{stringliteral}{"{}unknown"{}};}
\DoxyCodeLine{19483 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19484         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{19485     \}}
\DoxyCodeLine{19486 }
\DoxyCodeLine{19487 }
\DoxyCodeLine{19489     \textcolor{comment}{// JSON value data types //}}
\DoxyCodeLine{19491 \textcolor{comment}{}}
\DoxyCodeLine{19496 }
\DoxyCodeLine{19501 \textcolor{preprocessor}{\#if defined(JSON\_HAS\_CPP\_14)}}
\DoxyCodeLine{19502     \textcolor{comment}{// use of transparent comparator avoids unnecessary repeated construction of temporaries}}
\DoxyCodeLine{19503     \textcolor{comment}{// in functions involving lookup by key with types other than object\_t::key\_type (aka. StringType)}}
\DoxyCodeLine{19504     \textcolor{keyword}{using }default\_object\_comparator\_t = std::less<>;}
\DoxyCodeLine{19505 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{19506     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_af2fea7b2039e4308b8e8c22a0dd5b570}{default\_object\_comparator\_t}} = std::less<StringType>;}
\DoxyCodeLine{19507 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19508 }
\DoxyCodeLine{19511     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a770279b71f788fe3f76411eedf5b1956}{object\_t}} = ObjectType<StringType,}
\DoxyCodeLine{19512           \mbox{\hyperlink{classbasic__json}{basic\_json}},}
\DoxyCodeLine{19513           \mbox{\hyperlink{classbasic__json_af2fea7b2039e4308b8e8c22a0dd5b570}{default\_object\_comparator\_t}},}
\DoxyCodeLine{19514           AllocatorType<std::pair<\textcolor{keyword}{const} StringType,}
\DoxyCodeLine{19515           \mbox{\hyperlink{classbasic__json}{basic\_json}}>>>;}
\DoxyCodeLine{19516 }
\DoxyCodeLine{19519     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a7cf28eb944e7c06aa47f0bc3a9d6f454}{array\_t}} = ArrayType<basic\_json, AllocatorType<basic\_json>>;}
\DoxyCodeLine{19520 }
\DoxyCodeLine{19523     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a807932caebf0d62abc8642b9d1a2e5ef}{string\_t}} = StringType;}
\DoxyCodeLine{19524 }
\DoxyCodeLine{19527     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_af396ac808d774d4ea0db4c7da11ce569}{boolean\_t}} = BooleanType;}
\DoxyCodeLine{19528 }
\DoxyCodeLine{19531     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a8b702448867b892700c768db4208a670}{number\_integer\_t}} = NumberIntegerType;}
\DoxyCodeLine{19532 }
\DoxyCodeLine{19535     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_aebb9c6a13e947a86e2a13fbe6ebd77f4}{number\_unsigned\_t}} = NumberUnsignedType;}
\DoxyCodeLine{19536 }
\DoxyCodeLine{19539     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a1fd24dfabbdd1dc35513c82244633ca4}{number\_float\_t}} = NumberFloatType;}
\DoxyCodeLine{19540 }
\DoxyCodeLine{19543     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_aabedd827d4943302a4cf0413956341db}{binary\_t}} = nlohmann::byte\_container\_with\_subtype<BinaryType>;}
\DoxyCodeLine{19544 }
\DoxyCodeLine{19547     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a7866de66dd6c55590efa7cf0ef79e74f}{object\_comparator\_t}} = detail::actual\_object\_comparator\_t<basic\_json>;}
\DoxyCodeLine{19548 }
\DoxyCodeLine{19550 }
\DoxyCodeLine{19551   \textcolor{keyword}{private}:}
\DoxyCodeLine{19552 }
\DoxyCodeLine{19554     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{19555     JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{19556     \textcolor{keyword}{static} T* create(Args\&\& ... args)}
\DoxyCodeLine{19557     \{}
\DoxyCodeLine{19558         AllocatorType<T> alloc;}
\DoxyCodeLine{19559         \textcolor{keyword}{using }AllocatorTraits = std::allocator\_traits<AllocatorType<T>>;}
\DoxyCodeLine{19560 }
\DoxyCodeLine{19561         \textcolor{keyword}{auto} deleter = [\&](T * obj)}
\DoxyCodeLine{19562         \{}
\DoxyCodeLine{19563             AllocatorTraits::deallocate(alloc, obj, 1);}
\DoxyCodeLine{19564         \};}
\DoxyCodeLine{19565         std::unique\_ptr<T, \textcolor{keyword}{decltype}(deleter)> obj(AllocatorTraits::allocate(alloc, 1), deleter);}
\DoxyCodeLine{19566         AllocatorTraits::construct(alloc, obj.get(), std::forward<Args>(args)...);}
\DoxyCodeLine{19567         JSON\_ASSERT(obj != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{19568         \textcolor{keywordflow}{return} obj.release();}
\DoxyCodeLine{19569     \}}
\DoxyCodeLine{19570 }
\DoxyCodeLine{19572     \textcolor{comment}{// JSON value storage //}}
\DoxyCodeLine{19574 \textcolor{comment}{}}
\DoxyCodeLine{19575   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{19601     \textcolor{keyword}{union }json\_value}
\DoxyCodeLine{19602     \{}
\DoxyCodeLine{19604         object\_t* object;}
\DoxyCodeLine{19606         array\_t* array;}
\DoxyCodeLine{19608         string\_t* \mbox{\hyperlink{structjson__sax_a3da9ee0c61f1a37e6c6a3d2dccb16765}{string}};}
\DoxyCodeLine{19610         binary\_t* \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}};}
\DoxyCodeLine{19612         boolean\_t \mbox{\hyperlink{structjson__sax_ab89f75382c0fd7fe81c95fc84cfa3150}{boolean}};}
\DoxyCodeLine{19614         number\_integer\_t \mbox{\hyperlink{structjson__sax_a46cc306b7677553d8f6bd8c9592eb1bd}{number\_integer}};}
\DoxyCodeLine{19616         number\_unsigned\_t \mbox{\hyperlink{structjson__sax_a32f8a32794cb384f0de3d3a96a6bb696}{number\_unsigned}};}
\DoxyCodeLine{19618         number\_float\_t \mbox{\hyperlink{structjson__sax_a19eafa3a92fc75e0258a842283396aa9}{number\_float}};}
\DoxyCodeLine{19619 }
\DoxyCodeLine{19621         json\_value() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{19623         json\_value(boolean\_t v) noexcept : \mbox{\hyperlink{structjson__sax_ab89f75382c0fd7fe81c95fc84cfa3150}{boolean}}(v) \{\}}
\DoxyCodeLine{19625         json\_value(number\_integer\_t v) noexcept : \mbox{\hyperlink{structjson__sax_a46cc306b7677553d8f6bd8c9592eb1bd}{number\_integer}}(v) \{\}}
\DoxyCodeLine{19627         json\_value(number\_unsigned\_t v) noexcept : \mbox{\hyperlink{structjson__sax_a32f8a32794cb384f0de3d3a96a6bb696}{number\_unsigned}}(v) \{\}}
\DoxyCodeLine{19629         json\_value(number\_float\_t v) noexcept : \mbox{\hyperlink{structjson__sax_a19eafa3a92fc75e0258a842283396aa9}{number\_float}}(v) \{\}}
\DoxyCodeLine{19631         json\_value(value\_t t)}
\DoxyCodeLine{19632         \{}
\DoxyCodeLine{19633             \textcolor{keywordflow}{switch} (t)}
\DoxyCodeLine{19634             \{}
\DoxyCodeLine{19635                 \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{19636                 \{}
\DoxyCodeLine{19637                     \textcolor{keywordtype}{object} = create<object\_t>();}
\DoxyCodeLine{19638                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19639                 \}}
\DoxyCodeLine{19640 }
\DoxyCodeLine{19641                 \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{19642                 \{}
\DoxyCodeLine{19643                     \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}} = create<array\_t>();}
\DoxyCodeLine{19644                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19645                 \}}
\DoxyCodeLine{19646 }
\DoxyCodeLine{19647                 \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{19648                 \{}
\DoxyCodeLine{19649                     \textcolor{keywordtype}{string} = create<string\_t>(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{19650                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19651                 \}}
\DoxyCodeLine{19652 }
\DoxyCodeLine{19653                 \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{19654                 \{}
\DoxyCodeLine{19655                     \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}} = create<binary\_t>();}
\DoxyCodeLine{19656                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19657                 \}}
\DoxyCodeLine{19658 }
\DoxyCodeLine{19659                 \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{19660                 \{}
\DoxyCodeLine{19661                     \textcolor{keywordtype}{boolean} = \textcolor{keyword}{static\_cast<}boolean\_t\textcolor{keyword}{>}(\textcolor{keyword}{false});}
\DoxyCodeLine{19662                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19663                 \}}
\DoxyCodeLine{19664 }
\DoxyCodeLine{19665                 \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{19666                 \{}
\DoxyCodeLine{19667                     \mbox{\hyperlink{structjson__sax_a46cc306b7677553d8f6bd8c9592eb1bd}{number\_integer}} = \textcolor{keyword}{static\_cast<}number\_integer\_t\textcolor{keyword}{>}(0);}
\DoxyCodeLine{19668                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19669                 \}}
\DoxyCodeLine{19670 }
\DoxyCodeLine{19671                 \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{19672                 \{}
\DoxyCodeLine{19673                     \mbox{\hyperlink{structjson__sax_a32f8a32794cb384f0de3d3a96a6bb696}{number\_unsigned}} = \textcolor{keyword}{static\_cast<}number\_unsigned\_t\textcolor{keyword}{>}(0);}
\DoxyCodeLine{19674                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19675                 \}}
\DoxyCodeLine{19676 }
\DoxyCodeLine{19677                 \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{19678                 \{}
\DoxyCodeLine{19679                     \mbox{\hyperlink{structjson__sax_a19eafa3a92fc75e0258a842283396aa9}{number\_float}} = \textcolor{keyword}{static\_cast<}number\_float\_t\textcolor{keyword}{>}(0.0);}
\DoxyCodeLine{19680                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19681                 \}}
\DoxyCodeLine{19682 }
\DoxyCodeLine{19683                 \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{19684                 \{}
\DoxyCodeLine{19685                     \textcolor{keywordtype}{object} = \textcolor{keyword}{nullptr};  \textcolor{comment}{// silence warning, see \#821}}
\DoxyCodeLine{19686                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19687                 \}}
\DoxyCodeLine{19688 }
\DoxyCodeLine{19689                 \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{19690                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{19691                 \{}
\DoxyCodeLine{19692                     \textcolor{keywordtype}{object} = \textcolor{keyword}{nullptr};  \textcolor{comment}{// silence warning, see \#821}}
\DoxyCodeLine{19693                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(t == value\_t::null))}
\DoxyCodeLine{19694                     \{}
\DoxyCodeLine{19695                         JSON\_THROW(other\_error::create(500, \textcolor{stringliteral}{"{}961c151d2e87f2686a955a9be24d316f1362bf21 3.11.2"{}}, \textcolor{keyword}{nullptr})); \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{19696                     \}}
\DoxyCodeLine{19697                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19698                 \}}
\DoxyCodeLine{19699             \}}
\DoxyCodeLine{19700         \}}
\DoxyCodeLine{19701 }
\DoxyCodeLine{19703         json\_value(\textcolor{keyword}{const} string\_t\& value) : \mbox{\hyperlink{structjson__sax_a3da9ee0c61f1a37e6c6a3d2dccb16765}{string}}(create<string\_t>(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}})) \{\}}
\DoxyCodeLine{19704 }
\DoxyCodeLine{19706         json\_value(string\_t\&\& value) : \mbox{\hyperlink{structjson__sax_a3da9ee0c61f1a37e6c6a3d2dccb16765}{string}}(create<string\_t>(std::move(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}))) \{\}}
\DoxyCodeLine{19707 }
\DoxyCodeLine{19709         json\_value(\textcolor{keyword}{const} object\_t\& value) : \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{object}}(create<object\_t>(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}})) \{\}}
\DoxyCodeLine{19710 }
\DoxyCodeLine{19712         json\_value(object\_t\&\& value) : \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{object}}(create<object\_t>(std::move(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}))) \{\}}
\DoxyCodeLine{19713 }
\DoxyCodeLine{19715         json\_value(\textcolor{keyword}{const} array\_t\& value) : \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}}(create<array\_t>(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}})) \{\}}
\DoxyCodeLine{19716 }
\DoxyCodeLine{19718         json\_value(array\_t\&\& value) : \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}}(create<array\_t>(std::move(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}))) \{\}}
\DoxyCodeLine{19719 }
\DoxyCodeLine{19721         json\_value(\textcolor{keyword}{const} \textcolor{keyword}{typename} binary\_t::container\_type\& value) : \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}}(create<binary\_t>(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}})) \{\}}
\DoxyCodeLine{19722 }
\DoxyCodeLine{19724         json\_value(\textcolor{keyword}{typename} binary\_t::container\_type\&\& value) : \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}}(create<binary\_t>(std::move(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}))) \{\}}
\DoxyCodeLine{19725 }
\DoxyCodeLine{19727         json\_value(\textcolor{keyword}{const} binary\_t\& value) : \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}}(create<binary\_t>(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}})) \{\}}
\DoxyCodeLine{19728 }
\DoxyCodeLine{19730         json\_value(binary\_t\&\& value) : \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}}(create<binary\_t>(std::move(\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312efa2063c1608d6e0baf80249c42e2be5804}{value}}))) \{\}}
\DoxyCodeLine{19731 }
\DoxyCodeLine{19732         \textcolor{keywordtype}{void} destroy(value\_t t)}
\DoxyCodeLine{19733         \{}
\DoxyCodeLine{19734             \textcolor{keywordflow}{if} (t == value\_t::array || t == value\_t::object)}
\DoxyCodeLine{19735             \{}
\DoxyCodeLine{19736                 \textcolor{comment}{// flatten the current json\_value to a heap-\/allocated stack}}
\DoxyCodeLine{19737                 std::vector<basic\_json> stack;}
\DoxyCodeLine{19738 }
\DoxyCodeLine{19739                 \textcolor{comment}{// move the top-\/level items to stack}}
\DoxyCodeLine{19740                 \textcolor{keywordflow}{if} (t == value\_t::array)}
\DoxyCodeLine{19741                 \{}
\DoxyCodeLine{19742                     stack.reserve(\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}}-\/>size());}
\DoxyCodeLine{19743                     std::move(\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}}-\/>begin(), \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5}{array}}-\/>end(), std::back\_inserter(stack));}
\DoxyCodeLine{19744                 \}}
\DoxyCodeLine{19745                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{19746                 \{}
\DoxyCodeLine{19747                     stack.reserve(\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632aa8cfde6331bd59eb2ac96f8911c4b666}{object}}-\/>size());}
\DoxyCodeLine{19748                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& it : *\textcolor{keywordtype}{object})}
\DoxyCodeLine{19749                     \{}
\DoxyCodeLine{19750                         stack.push\_back(std::move(it.second));}
\DoxyCodeLine{19751                     \}}
\DoxyCodeLine{19752                 \}}
\DoxyCodeLine{19753 }
\DoxyCodeLine{19754                 \textcolor{keywordflow}{while} (!stack.empty())}
\DoxyCodeLine{19755                 \{}
\DoxyCodeLine{19756                     \textcolor{comment}{// move the last item to local variable to be processed}}
\DoxyCodeLine{19757                     \mbox{\hyperlink{classbasic__json}{basic\_json}} current\_item(std::move(stack.back()));}
\DoxyCodeLine{19758                     stack.pop\_back();}
\DoxyCodeLine{19759 }
\DoxyCodeLine{19760                     \textcolor{comment}{// if current\_item is array/object, move}}
\DoxyCodeLine{19761                     \textcolor{comment}{// its children to the stack to be processed later}}
\DoxyCodeLine{19762                     \textcolor{keywordflow}{if} (current\_item.is\_array())}
\DoxyCodeLine{19763                     \{}
\DoxyCodeLine{19764                         std::move(current\_item.m\_value.array-\/>begin(), current\_item.m\_value.array-\/>end(), std::back\_inserter(stack));}
\DoxyCodeLine{19765 }
\DoxyCodeLine{19766                         current\_item.m\_value.array-\/>clear();}
\DoxyCodeLine{19767                     \}}
\DoxyCodeLine{19768                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (current\_item.is\_object())}
\DoxyCodeLine{19769                     \{}
\DoxyCodeLine{19770                         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\&\& it : *current\_item.m\_value.object)}
\DoxyCodeLine{19771                         \{}
\DoxyCodeLine{19772                             stack.push\_back(std::move(it.second));}
\DoxyCodeLine{19773                         \}}
\DoxyCodeLine{19774 }
\DoxyCodeLine{19775                         current\_item.m\_value.object-\/>clear();}
\DoxyCodeLine{19776                     \}}
\DoxyCodeLine{19777 }
\DoxyCodeLine{19778                     \textcolor{comment}{// it's now safe that current\_item get destructed}}
\DoxyCodeLine{19779                     \textcolor{comment}{// since it doesn't have any children}}
\DoxyCodeLine{19780                 \}}
\DoxyCodeLine{19781             \}}
\DoxyCodeLine{19782 }
\DoxyCodeLine{19783             \textcolor{keywordflow}{switch} (t)}
\DoxyCodeLine{19784             \{}
\DoxyCodeLine{19785                 \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{19786                 \{}
\DoxyCodeLine{19787                     AllocatorType<object\_t> alloc;}
\DoxyCodeLine{19788                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::destroy(alloc, \textcolor{keywordtype}{object});}
\DoxyCodeLine{19789                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::deallocate(alloc, \textcolor{keywordtype}{object}, 1);}
\DoxyCodeLine{19790                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19791                 \}}
\DoxyCodeLine{19792 }
\DoxyCodeLine{19793                 \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{19794                 \{}
\DoxyCodeLine{19795                     AllocatorType<array\_t> alloc;}
\DoxyCodeLine{19796                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::destroy(alloc, array);}
\DoxyCodeLine{19797                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::deallocate(alloc, array, 1);}
\DoxyCodeLine{19798                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19799                 \}}
\DoxyCodeLine{19800 }
\DoxyCodeLine{19801                 \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{19802                 \{}
\DoxyCodeLine{19803                     AllocatorType<string\_t> alloc;}
\DoxyCodeLine{19804                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::destroy(alloc, \textcolor{keywordtype}{string});}
\DoxyCodeLine{19805                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::deallocate(alloc, \textcolor{keywordtype}{string}, 1);}
\DoxyCodeLine{19806                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19807                 \}}
\DoxyCodeLine{19808 }
\DoxyCodeLine{19809                 \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{19810                 \{}
\DoxyCodeLine{19811                     AllocatorType<binary\_t> alloc;}
\DoxyCodeLine{19812                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::destroy(alloc, \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}});}
\DoxyCodeLine{19813                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::deallocate(alloc, \mbox{\hyperlink{structjson__sax_a15d6c5d0dcaceb906405f427faf9b34e}{binary}}, 1);}
\DoxyCodeLine{19814                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19815                 \}}
\DoxyCodeLine{19816 }
\DoxyCodeLine{19817                 \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{19818                 \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{19819                 \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{19820                 \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{19821                 \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{19822                 \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{19823                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{19824                 \{}
\DoxyCodeLine{19825                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{19826                 \}}
\DoxyCodeLine{19827             \}}
\DoxyCodeLine{19828         \}}
\DoxyCodeLine{19829     \};}
\DoxyCodeLine{19830 }
\DoxyCodeLine{19831   \textcolor{keyword}{private}:}
\DoxyCodeLine{19850     \textcolor{keywordtype}{void} assert\_invariant(\textcolor{keywordtype}{bool} check\_parents = \textcolor{keyword}{true}) const noexcept}
\DoxyCodeLine{19851     \{}
\DoxyCodeLine{19852         JSON\_ASSERT(m\_type != value\_t::object || m\_value.object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{19853         JSON\_ASSERT(m\_type != value\_t::array || m\_value.array != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{19854         JSON\_ASSERT(m\_type != value\_t::string || m\_value.string != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{19855         JSON\_ASSERT(m\_type != value\_t::binary || m\_value.binary != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{19856 }
\DoxyCodeLine{19857 \textcolor{preprocessor}{\#if JSON\_DIAGNOSTICS}}
\DoxyCodeLine{19858         JSON\_TRY}
\DoxyCodeLine{19859         \{}
\DoxyCodeLine{19860             \textcolor{comment}{// cppcheck-\/suppress assertWithSideEffect}}
\DoxyCodeLine{19861             JSON\_ASSERT(!check\_parents || !is\_structured() || std::all\_of(begin(), end(), [\textcolor{keyword}{this}](\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}} \& j)}
\DoxyCodeLine{19862             \{}
\DoxyCodeLine{19863                 \textcolor{keywordflow}{return} j.m\_parent == \textcolor{keyword}{this};}
\DoxyCodeLine{19864             \}));}
\DoxyCodeLine{19865         \}}
\DoxyCodeLine{19866         JSON\_CATCH(...) \{\} \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{19867 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19868         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(check\_parents);}
\DoxyCodeLine{19869     \}}
\DoxyCodeLine{19870 }
\DoxyCodeLine{19871     \textcolor{keywordtype}{void} set\_parents()}
\DoxyCodeLine{19872     \{}
\DoxyCodeLine{19873 \textcolor{preprocessor}{\#if JSON\_DIAGNOSTICS}}
\DoxyCodeLine{19874         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{19875         \{}
\DoxyCodeLine{19876             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{19877             \{}
\DoxyCodeLine{19878                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& element : *m\_value.array)}
\DoxyCodeLine{19879                 \{}
\DoxyCodeLine{19880                     element.m\_parent = \textcolor{keyword}{this};}
\DoxyCodeLine{19881                 \}}
\DoxyCodeLine{19882                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{19883             \}}
\DoxyCodeLine{19884 }
\DoxyCodeLine{19885             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{19886             \{}
\DoxyCodeLine{19887                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& element : *m\_value.object)}
\DoxyCodeLine{19888                 \{}
\DoxyCodeLine{19889                     element.second.m\_parent = \textcolor{keyword}{this};}
\DoxyCodeLine{19890                 \}}
\DoxyCodeLine{19891                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{19892             \}}
\DoxyCodeLine{19893 }
\DoxyCodeLine{19894             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{19895             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{19896             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{19897             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{19898             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{19899             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{19900             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{19901             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{19902             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{19903                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{19904         \}}
\DoxyCodeLine{19905 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19906     \}}
\DoxyCodeLine{19907 }
\DoxyCodeLine{19908     iterator set\_parents(iterator it, \textcolor{keyword}{typename} iterator::difference\_type count\_set\_parents)}
\DoxyCodeLine{19909     \{}
\DoxyCodeLine{19910 \textcolor{preprocessor}{\#if JSON\_DIAGNOSTICS}}
\DoxyCodeLine{19911         \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} iterator::difference\_type i = 0; i < count\_set\_parents; ++i)}
\DoxyCodeLine{19912         \{}
\DoxyCodeLine{19913             (it + i)-\/>m\_parent = \textcolor{keyword}{this};}
\DoxyCodeLine{19914         \}}
\DoxyCodeLine{19915 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{19916         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(count\_set\_parents);}
\DoxyCodeLine{19917 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19918         \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{19919     \}}
\DoxyCodeLine{19920 }
\DoxyCodeLine{19921     reference set\_parent(reference j, std::size\_t old\_capacity = \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))}
\DoxyCodeLine{19922     \{}
\DoxyCodeLine{19923 \textcolor{preprocessor}{\#if JSON\_DIAGNOSTICS}}
\DoxyCodeLine{19924         \textcolor{keywordflow}{if} (old\_capacity != \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(-\/1))}
\DoxyCodeLine{19925         \{}
\DoxyCodeLine{19926             \textcolor{comment}{// see https://github.com/nlohmann/json/issues/2838}}
\DoxyCodeLine{19927             JSON\_ASSERT(type() == value\_t::array);}
\DoxyCodeLine{19928             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(m\_value.array-\/>capacity() != old\_capacity))}
\DoxyCodeLine{19929             \{}
\DoxyCodeLine{19930                 \textcolor{comment}{// capacity has changed: update all parents}}
\DoxyCodeLine{19931                 set\_parents();}
\DoxyCodeLine{19932                 \textcolor{keywordflow}{return} j;}
\DoxyCodeLine{19933             \}}
\DoxyCodeLine{19934         \}}
\DoxyCodeLine{19935 }
\DoxyCodeLine{19936         \textcolor{comment}{// ordered\_json uses a vector internally, so pointers could have}}
\DoxyCodeLine{19937         \textcolor{comment}{// been invalidated; see https://github.com/nlohmann/json/issues/2962}}
\DoxyCodeLine{19938 \textcolor{preprocessor}{\#ifdef JSON\_HEDLEY\_MSVC\_VERSION}}
\DoxyCodeLine{19939 \textcolor{preprocessor}{\#pragma warning(push )}}
\DoxyCodeLine{19940 \textcolor{preprocessor}{\#pragma warning(disable : 4127) }\textcolor{comment}{// ignore warning to replace if with if constexpr}}
\DoxyCodeLine{19941 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19942         \textcolor{keywordflow}{if} (\mbox{\hyperlink{structdetail_1_1is__ordered__map}{detail::is\_ordered\_map<object\_t>::value}})}
\DoxyCodeLine{19943         \{}
\DoxyCodeLine{19944             set\_parents();}
\DoxyCodeLine{19945             \textcolor{keywordflow}{return} j;}
\DoxyCodeLine{19946         \}}
\DoxyCodeLine{19947 \textcolor{preprocessor}{\#ifdef JSON\_HEDLEY\_MSVC\_VERSION}}
\DoxyCodeLine{19948 \textcolor{preprocessor}{\#pragma warning( pop )}}
\DoxyCodeLine{19949 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19950 }
\DoxyCodeLine{19951         j.m\_parent = \textcolor{keyword}{this};}
\DoxyCodeLine{19952 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{19953         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(j);}
\DoxyCodeLine{19954         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(old\_capacity);}
\DoxyCodeLine{19955 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19956         \textcolor{keywordflow}{return} j;}
\DoxyCodeLine{19957     \}}
\DoxyCodeLine{19958 }
\DoxyCodeLine{19959   \textcolor{keyword}{public}:}
\DoxyCodeLine{19961     \textcolor{comment}{// JSON parser callback //}}
\DoxyCodeLine{19963 \textcolor{comment}{}}
\DoxyCodeLine{19966     \textcolor{keyword}{using }\mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312ef}{parse\_event\_t}} = \mbox{\hyperlink{namespacedetail_a47b1bb0bbd3596589ed9187059c312ef}{detail::parse\_event\_t}};}
\DoxyCodeLine{19967 }
\DoxyCodeLine{19970     \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__json_a144c201819ed5c9d9f58b59eb64fb454}{parser\_callback\_t}} = detail::parser\_callback\_t<basic\_json>;}
\DoxyCodeLine{19971 }
\DoxyCodeLine{19973     \textcolor{comment}{// constructors //}}
\DoxyCodeLine{19975 \textcolor{comment}{}}
\DoxyCodeLine{19980 }
\DoxyCodeLine{19983     \mbox{\hyperlink{classbasic__json_aee75ecbdc67fc5faa1228c949c59ff27}{basic\_json}}(\textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} v)}
\DoxyCodeLine{19984         : m\_type(v), m\_value(v)}
\DoxyCodeLine{19985     \{}
\DoxyCodeLine{19986         assert\_invariant();}
\DoxyCodeLine{19987     \}}
\DoxyCodeLine{19988 }
\DoxyCodeLine{19991     \mbox{\hyperlink{classbasic__json_ac6f1bad4745ddb574540f71cdbcd532f}{basic\_json}}(std::nullptr\_t = \textcolor{keyword}{nullptr}) noexcept \textcolor{comment}{// NOLINT(bugprone-\/exception-\/escape)}}
\DoxyCodeLine{19992         : \mbox{\hyperlink{classbasic__json}{basic\_json}}(\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}::\mbox{\hyperlink{structjson__sax_acbcc09c0ada2782cd73cc4135823181d}{null}})}
\DoxyCodeLine{19993     \{}
\DoxyCodeLine{19994         assert\_invariant();}
\DoxyCodeLine{19995     \}}
\DoxyCodeLine{19996 }
\DoxyCodeLine{19999     \textcolor{keyword}{template} < \textcolor{keyword}{typename} CompatibleType,}
\DoxyCodeLine{20000                \textcolor{keyword}{typename} U = detail::uncvref\_t<CompatibleType>,}
\DoxyCodeLine{20001                detail::enable\_if\_t <}
\DoxyCodeLine{20002                    !\mbox{\hyperlink{structdetail_1_1is__basic__json}{detail::is\_basic\_json<U>::value}} \&\& \mbox{\hyperlink{structdetail_1_1is__compatible__type}{detail::is\_compatible\_type<basic\_json\_t, U>::value}}, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{20003     \mbox{\hyperlink{classbasic__json_a9b1f9ac7c7ebcff72d00869e974a6249}{basic\_json}}(CompatibleType \&\& val) \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}( \textcolor{comment}{// NOLINT(bugprone-\/forwarding-\/reference-\/overload,bugprone-\/exception-\/escape)}}
\DoxyCodeLine{20004                 JSONSerializer<U>::to\_json(std::declval<basic\_json\_t\&>(),}
\DoxyCodeLine{20005                                            std::forward<CompatibleType>(val))))}
\DoxyCodeLine{20006     \{}
\DoxyCodeLine{20007         JSONSerializer<U>::to\_json(*\textcolor{keyword}{this}, std::forward<CompatibleType>(val));}
\DoxyCodeLine{20008         set\_parents();}
\DoxyCodeLine{20009         assert\_invariant();}
\DoxyCodeLine{20010     \}}
\DoxyCodeLine{20011 }
\DoxyCodeLine{20014     \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType,}
\DoxyCodeLine{20015                detail::enable\_if\_t <}
\DoxyCodeLine{20016                    \mbox{\hyperlink{structdetail_1_1is__basic__json}{detail::is\_basic\_json<BasicJsonType>::value}}\&\& !std::is\_same<basic\_json, BasicJsonType>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{20017     \mbox{\hyperlink{classbasic__json_a94560a1edd72d60310c54c9b2d9f1ad2}{basic\_json}}(\textcolor{keyword}{const} BasicJsonType\& val)}
\DoxyCodeLine{20018     \{}
\DoxyCodeLine{20019         \textcolor{keyword}{using }other\_boolean\_t = \textcolor{keyword}{typename} BasicJsonType::boolean\_t;}
\DoxyCodeLine{20020         \textcolor{keyword}{using }other\_number\_float\_t = \textcolor{keyword}{typename} BasicJsonType::number\_float\_t;}
\DoxyCodeLine{20021         \textcolor{keyword}{using }other\_number\_integer\_t = \textcolor{keyword}{typename} BasicJsonType::number\_integer\_t;}
\DoxyCodeLine{20022         \textcolor{keyword}{using }other\_number\_unsigned\_t = \textcolor{keyword}{typename} BasicJsonType::number\_unsigned\_t;}
\DoxyCodeLine{20023         \textcolor{keyword}{using }other\_string\_t = \textcolor{keyword}{typename} BasicJsonType::string\_t;}
\DoxyCodeLine{20024         \textcolor{keyword}{using }other\_object\_t = \textcolor{keyword}{typename} BasicJsonType::object\_t;}
\DoxyCodeLine{20025         \textcolor{keyword}{using }other\_array\_t = \textcolor{keyword}{typename} BasicJsonType::array\_t;}
\DoxyCodeLine{20026         \textcolor{keyword}{using }other\_binary\_t = \textcolor{keyword}{typename} BasicJsonType::binary\_t;}
\DoxyCodeLine{20027 }
\DoxyCodeLine{20028         \textcolor{keywordflow}{switch} (val.type())}
\DoxyCodeLine{20029         \{}
\DoxyCodeLine{20030             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{20031                 JSONSerializer<other\_boolean\_t>::to\_json(*\textcolor{keyword}{this}, val.template get<other\_boolean\_t>());}
\DoxyCodeLine{20032                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20033             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{20034                 JSONSerializer<other\_number\_float\_t>::to\_json(*\textcolor{keyword}{this}, val.template get<other\_number\_float\_t>());}
\DoxyCodeLine{20035                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20036             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{20037                 JSONSerializer<other\_number\_integer\_t>::to\_json(*\textcolor{keyword}{this}, val.template get<other\_number\_integer\_t>());}
\DoxyCodeLine{20038                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20039             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{20040                 JSONSerializer<other\_number\_unsigned\_t>::to\_json(*\textcolor{keyword}{this}, val.template get<other\_number\_unsigned\_t>());}
\DoxyCodeLine{20041                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20042             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{20043                 JSONSerializer<other\_string\_t>::to\_json(*\textcolor{keyword}{this}, val.template get\_ref<const other\_string\_t\&>());}
\DoxyCodeLine{20044                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20045             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{20046                 JSONSerializer<other\_object\_t>::to\_json(*\textcolor{keyword}{this}, val.template get\_ref<const other\_object\_t\&>());}
\DoxyCodeLine{20047                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20048             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{20049                 JSONSerializer<other\_array\_t>::to\_json(*\textcolor{keyword}{this}, val.template get\_ref<const other\_array\_t\&>());}
\DoxyCodeLine{20050                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20051             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{20052                 JSONSerializer<other\_binary\_t>::to\_json(*\textcolor{keyword}{this}, val.template get\_ref<const other\_binary\_t\&>());}
\DoxyCodeLine{20053                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20054             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{20055                 *\textcolor{keyword}{this} = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20056                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20057             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{20058                 m\_type = value\_t::discarded;}
\DoxyCodeLine{20059                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20060             \textcolor{keywordflow}{default}:            \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{20061                 JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{20062         \}}
\DoxyCodeLine{20063         JSON\_ASSERT(m\_type == val.type());}
\DoxyCodeLine{20064         set\_parents();}
\DoxyCodeLine{20065         assert\_invariant();}
\DoxyCodeLine{20066     \}}
\DoxyCodeLine{20067 }
\DoxyCodeLine{20070     \mbox{\hyperlink{classbasic__json_aec3d71dec8062753efb67860b7cca1a1}{basic\_json}}(\mbox{\hyperlink{classbasic__json_a2063ed828cd027216c549ac48527a562}{initializer\_list\_t}} init,}
\DoxyCodeLine{20071                \textcolor{keywordtype}{bool} type\_deduction = \textcolor{keyword}{true},}
\DoxyCodeLine{20072                \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} manual\_type = value\_t::array)}
\DoxyCodeLine{20073     \{}
\DoxyCodeLine{20074         \textcolor{comment}{// check if each element is an array with two elements whose first}}
\DoxyCodeLine{20075         \textcolor{comment}{// element is a string}}
\DoxyCodeLine{20076         \textcolor{keywordtype}{bool} is\_an\_object = std::all\_of(init.begin(), init.end(),}
\DoxyCodeLine{20077                                         [](\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1json__ref}{detail::json\_ref<basic\_json>}}\& element\_ref)}
\DoxyCodeLine{20078         \{}
\DoxyCodeLine{20079             return element\_ref-\/>is\_array() \&\& element\_ref-\/>size() == 2 \&\& (*element\_ref)[0].is\_string();}
\DoxyCodeLine{20080         \});}
\DoxyCodeLine{20081 }
\DoxyCodeLine{20082         \textcolor{comment}{// adjust type if type deduction is not wanted}}
\DoxyCodeLine{20083         \textcolor{keywordflow}{if} (!type\_deduction)}
\DoxyCodeLine{20084         \{}
\DoxyCodeLine{20085             \textcolor{comment}{// if array is wanted, do not create an object though possible}}
\DoxyCodeLine{20086             \textcolor{keywordflow}{if} (manual\_type == value\_t::array)}
\DoxyCodeLine{20087             \{}
\DoxyCodeLine{20088                 is\_an\_object = \textcolor{keyword}{false};}
\DoxyCodeLine{20089             \}}
\DoxyCodeLine{20090 }
\DoxyCodeLine{20091             \textcolor{comment}{// if object is wanted but impossible, throw an exception}}
\DoxyCodeLine{20092             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(manual\_type == value\_t::object \&\& !is\_an\_object))}
\DoxyCodeLine{20093             \{}
\DoxyCodeLine{20094                 JSON\_THROW(type\_error::create(301, \textcolor{stringliteral}{"{}cannot create object from initializer list"{}}, \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{20095             \}}
\DoxyCodeLine{20096         \}}
\DoxyCodeLine{20097 }
\DoxyCodeLine{20098         \textcolor{keywordflow}{if} (is\_an\_object)}
\DoxyCodeLine{20099         \{}
\DoxyCodeLine{20100             \textcolor{comment}{// the initializer list is a list of pairs -\/> create object}}
\DoxyCodeLine{20101             m\_type = value\_t::object;}
\DoxyCodeLine{20102             m\_value = value\_t::object;}
\DoxyCodeLine{20103 }
\DoxyCodeLine{20104             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& element\_ref : init)}
\DoxyCodeLine{20105             \{}
\DoxyCodeLine{20106                 \textcolor{keyword}{auto} element = element\_ref.moved\_or\_copied();}
\DoxyCodeLine{20107                 m\_value.object-\/>emplace(}
\DoxyCodeLine{20108                     std::move(*((*element.m\_value.array)[0].m\_value.string)),}
\DoxyCodeLine{20109                     std::move((*element.m\_value.array)[1]));}
\DoxyCodeLine{20110             \}}
\DoxyCodeLine{20111         \}}
\DoxyCodeLine{20112         \textcolor{keywordflow}{else}}
\DoxyCodeLine{20113         \{}
\DoxyCodeLine{20114             \textcolor{comment}{// the initializer list describes an array -\/> create array}}
\DoxyCodeLine{20115             m\_type = value\_t::array;}
\DoxyCodeLine{20116             m\_value.array = create<array\_t>(init.begin(), init.end());}
\DoxyCodeLine{20117         \}}
\DoxyCodeLine{20118 }
\DoxyCodeLine{20119         set\_parents();}
\DoxyCodeLine{20120         assert\_invariant();}
\DoxyCodeLine{20121     \}}
\DoxyCodeLine{20122 }
\DoxyCodeLine{20125     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{20126     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a8d25b7a4a6f6ee355193ee6b461ab3bd}{binary}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} binary\_t::container\_type\& init)}
\DoxyCodeLine{20127     \{}
\DoxyCodeLine{20128         \textcolor{keyword}{auto} res = \mbox{\hyperlink{classbasic__json}{basic\_json}}();}
\DoxyCodeLine{20129         res.m\_type = value\_t::binary;}
\DoxyCodeLine{20130         res.m\_value = init;}
\DoxyCodeLine{20131         \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{20132     \}}
\DoxyCodeLine{20133 }
\DoxyCodeLine{20136     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{20137     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a9a92f5028b858b39e0c49c722ba09793}{binary}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} binary\_t::container\_type\& init, \textcolor{keyword}{typename} binary\_t::subtype\_type subtype)}
\DoxyCodeLine{20138     \{}
\DoxyCodeLine{20139         \textcolor{keyword}{auto} res = \mbox{\hyperlink{classbasic__json}{basic\_json}}();}
\DoxyCodeLine{20140         res.m\_type = value\_t::binary;}
\DoxyCodeLine{20141         res.m\_value = \mbox{\hyperlink{classbasic__json_aabedd827d4943302a4cf0413956341db}{binary\_t}}(init, subtype);}
\DoxyCodeLine{20142         \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{20143     \}}
\DoxyCodeLine{20144 }
\DoxyCodeLine{20147     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{20148     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a0767ec4050ecfb4e4852db24cc939b2b}{binary}}(\textcolor{keyword}{typename} binary\_t::container\_type\&\& init)}
\DoxyCodeLine{20149     \{}
\DoxyCodeLine{20150         \textcolor{keyword}{auto} res = \mbox{\hyperlink{classbasic__json}{basic\_json}}();}
\DoxyCodeLine{20151         res.m\_type = value\_t::binary;}
\DoxyCodeLine{20152         res.m\_value = std::move(init);}
\DoxyCodeLine{20153         \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{20154     \}}
\DoxyCodeLine{20155 }
\DoxyCodeLine{20158     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{20159     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a6ad9ba515c5f51d9c5609583e3d0ada0}{binary}}(\textcolor{keyword}{typename} binary\_t::container\_type\&\& init, \textcolor{keyword}{typename} binary\_t::subtype\_type subtype)}
\DoxyCodeLine{20160     \{}
\DoxyCodeLine{20161         \textcolor{keyword}{auto} res = \mbox{\hyperlink{classbasic__json}{basic\_json}}();}
\DoxyCodeLine{20162         res.m\_type = value\_t::binary;}
\DoxyCodeLine{20163         res.m\_value = \mbox{\hyperlink{classbasic__json_aabedd827d4943302a4cf0413956341db}{binary\_t}}(std::move(init), subtype);}
\DoxyCodeLine{20164         \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{20165     \}}
\DoxyCodeLine{20166 }
\DoxyCodeLine{20169     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{20170     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a08a68350d457af1f6ea7f27b6e0a5baf}{array}}(\mbox{\hyperlink{classbasic__json_a2063ed828cd027216c549ac48527a562}{initializer\_list\_t}} init = \{\})}
\DoxyCodeLine{20171     \{}
\DoxyCodeLine{20172         \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__json}{basic\_json}}(init, \textcolor{keyword}{false}, value\_t::array);}
\DoxyCodeLine{20173     \}}
\DoxyCodeLine{20174 }
\DoxyCodeLine{20177     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{20178     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a10aa3ec9e58f6852709913408519c01c}{object}}(\mbox{\hyperlink{classbasic__json_a2063ed828cd027216c549ac48527a562}{initializer\_list\_t}} init = \{\})}
\DoxyCodeLine{20179     \{}
\DoxyCodeLine{20180         \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__json}{basic\_json}}(init, \textcolor{keyword}{false}, value\_t::object);}
\DoxyCodeLine{20181     \}}
\DoxyCodeLine{20182 }
\DoxyCodeLine{20185     \mbox{\hyperlink{classbasic__json_ad382c9c9e03c410004150c9d6b9f0bd9}{basic\_json}}(\mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} cnt, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& val)}
\DoxyCodeLine{20186         : m\_type(\mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}::array)}
\DoxyCodeLine{20187     \{}
\DoxyCodeLine{20188         m\_value.array = create<array\_t>(cnt, val);}
\DoxyCodeLine{20189         set\_parents();}
\DoxyCodeLine{20190         assert\_invariant();}
\DoxyCodeLine{20191     \}}
\DoxyCodeLine{20192 }
\DoxyCodeLine{20195     \textcolor{keyword}{template} < \textcolor{keyword}{class }InputIT, \textcolor{keyword}{typename} std::enable\_if <}
\DoxyCodeLine{20196                    std::is\_same<InputIT, typename basic\_json\_t::iterator>::value ||}
\DoxyCodeLine{20197                    std::is\_same<InputIT, typename basic\_json\_t::const\_iterator>::value, \textcolor{keywordtype}{int} >::type = 0 >}
\DoxyCodeLine{20198     \mbox{\hyperlink{classbasic__json_a12f2c1a11dd6e84196132ea77a99572a}{basic\_json}}(InputIT first, InputIT last)}
\DoxyCodeLine{20199     \{}
\DoxyCodeLine{20200         JSON\_ASSERT(first.m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{20201         JSON\_ASSERT(last.m\_object != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{20202 }
\DoxyCodeLine{20203         \textcolor{comment}{// make sure iterator fits the current value}}
\DoxyCodeLine{20204         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(first.m\_object != last.m\_object))}
\DoxyCodeLine{20205         \{}
\DoxyCodeLine{20206             JSON\_THROW(invalid\_iterator::create(201, \textcolor{stringliteral}{"{}iterators are not compatible"{}}, \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{20207         \}}
\DoxyCodeLine{20208 }
\DoxyCodeLine{20209         \textcolor{comment}{// copy type from first iterator}}
\DoxyCodeLine{20210         m\_type = first.m\_object-\/>m\_type;}
\DoxyCodeLine{20211 }
\DoxyCodeLine{20212         \textcolor{comment}{// check if iterator range is complete for primitive values}}
\DoxyCodeLine{20213         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{20214         \{}
\DoxyCodeLine{20215             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{20216             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{20217             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{20218             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{20219             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{20220             \{}
\DoxyCodeLine{20221                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!first.m\_it.primitive\_iterator.is\_begin()}
\DoxyCodeLine{20222                                          || !last.m\_it.primitive\_iterator.is\_end()))}
\DoxyCodeLine{20223                 \{}
\DoxyCodeLine{20224                     JSON\_THROW(invalid\_iterator::create(204, \textcolor{stringliteral}{"{}iterators out of range"{}}, first.m\_object));}
\DoxyCodeLine{20225                 \}}
\DoxyCodeLine{20226                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20227             \}}
\DoxyCodeLine{20228 }
\DoxyCodeLine{20229             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{20230             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{20231             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{20232             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{20233             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{20234             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{20235                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20236         \}}
\DoxyCodeLine{20237 }
\DoxyCodeLine{20238         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{20239         \{}
\DoxyCodeLine{20240             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{20241             \{}
\DoxyCodeLine{20242                 m\_value.number\_integer = first.m\_object-\/>m\_value.number\_integer;}
\DoxyCodeLine{20243                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20244             \}}
\DoxyCodeLine{20245 }
\DoxyCodeLine{20246             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{20247             \{}
\DoxyCodeLine{20248                 m\_value.number\_unsigned = first.m\_object-\/>m\_value.number\_unsigned;}
\DoxyCodeLine{20249                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20250             \}}
\DoxyCodeLine{20251 }
\DoxyCodeLine{20252             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{20253             \{}
\DoxyCodeLine{20254                 m\_value.number\_float = first.m\_object-\/>m\_value.number\_float;}
\DoxyCodeLine{20255                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20256             \}}
\DoxyCodeLine{20257 }
\DoxyCodeLine{20258             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{20259             \{}
\DoxyCodeLine{20260                 m\_value.boolean = first.m\_object-\/>m\_value.boolean;}
\DoxyCodeLine{20261                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20262             \}}
\DoxyCodeLine{20263 }
\DoxyCodeLine{20264             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{20265             \{}
\DoxyCodeLine{20266                 m\_value = *first.m\_object-\/>m\_value.string;}
\DoxyCodeLine{20267                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20268             \}}
\DoxyCodeLine{20269 }
\DoxyCodeLine{20270             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{20271             \{}
\DoxyCodeLine{20272                 m\_value.object = create<object\_t>(first.m\_it.object\_iterator,}
\DoxyCodeLine{20273                                                   last.m\_it.object\_iterator);}
\DoxyCodeLine{20274                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20275             \}}
\DoxyCodeLine{20276 }
\DoxyCodeLine{20277             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{20278             \{}
\DoxyCodeLine{20279                 m\_value.array = create<array\_t>(first.m\_it.array\_iterator,}
\DoxyCodeLine{20280                                                 last.m\_it.array\_iterator);}
\DoxyCodeLine{20281                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20282             \}}
\DoxyCodeLine{20283 }
\DoxyCodeLine{20284             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{20285             \{}
\DoxyCodeLine{20286                 m\_value = *first.m\_object-\/>m\_value.binary;}
\DoxyCodeLine{20287                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20288             \}}
\DoxyCodeLine{20289 }
\DoxyCodeLine{20290             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{20291             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{20292             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{20293                 JSON\_THROW(invalid\_iterator::create(206, detail::concat(\textcolor{stringliteral}{"{}cannot construct with iterators from "{}}, first.m\_object-\/>type\_name()), first.m\_object));}
\DoxyCodeLine{20294         \}}
\DoxyCodeLine{20295 }
\DoxyCodeLine{20296         set\_parents();}
\DoxyCodeLine{20297         assert\_invariant();}
\DoxyCodeLine{20298     \}}
\DoxyCodeLine{20299 }
\DoxyCodeLine{20300 }
\DoxyCodeLine{20302     \textcolor{comment}{// other constructors and destructor //}}
\DoxyCodeLine{20304 \textcolor{comment}{}}
\DoxyCodeLine{20305     \textcolor{keyword}{template}<\textcolor{keyword}{typename} JsonRef,}
\DoxyCodeLine{20306              detail::enable\_if\_t<detail::conjunction<detail::is\_json\_ref<JsonRef>,}
\DoxyCodeLine{20307                                  std::is\_same<typename JsonRef::value\_type, basic\_json>>::value, \textcolor{keywordtype}{int}> = 0 >}
\DoxyCodeLine{20308     \mbox{\hyperlink{classbasic__json}{basic\_json}}(\textcolor{keyword}{const} JsonRef\& ref) : \mbox{\hyperlink{classbasic__json}{basic\_json}}(ref.moved\_or\_copied()) \{\}}
\DoxyCodeLine{20309 }
\DoxyCodeLine{20312     \mbox{\hyperlink{classbasic__json_ac62e476c88b91f1f4329bb4901cafc4c}{basic\_json}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& other)}
\DoxyCodeLine{20313         : m\_type(other.m\_type)}
\DoxyCodeLine{20314     \{}
\DoxyCodeLine{20315         \textcolor{comment}{// check of passed value is valid}}
\DoxyCodeLine{20316         other.assert\_invariant();}
\DoxyCodeLine{20317 }
\DoxyCodeLine{20318         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{20319         \{}
\DoxyCodeLine{20320             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{20321             \{}
\DoxyCodeLine{20322                 m\_value = *other.\mbox{\hyperlink{classbasic__json_a34bc6074bd3f9ac2bdab12ebc02d70f5}{m\_value}}.object;}
\DoxyCodeLine{20323                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20324             \}}
\DoxyCodeLine{20325 }
\DoxyCodeLine{20326             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{20327             \{}
\DoxyCodeLine{20328                 m\_value = *other.\mbox{\hyperlink{classbasic__json_a34bc6074bd3f9ac2bdab12ebc02d70f5}{m\_value}}.array;}
\DoxyCodeLine{20329                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20330             \}}
\DoxyCodeLine{20331 }
\DoxyCodeLine{20332             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{20333             \{}
\DoxyCodeLine{20334                 m\_value = *other.\mbox{\hyperlink{classbasic__json_a34bc6074bd3f9ac2bdab12ebc02d70f5}{m\_value}}.string;}
\DoxyCodeLine{20335                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20336             \}}
\DoxyCodeLine{20337 }
\DoxyCodeLine{20338             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{20339             \{}
\DoxyCodeLine{20340                 m\_value = other.\mbox{\hyperlink{classbasic__json_a34bc6074bd3f9ac2bdab12ebc02d70f5}{m\_value}}.boolean;}
\DoxyCodeLine{20341                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20342             \}}
\DoxyCodeLine{20343 }
\DoxyCodeLine{20344             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{20345             \{}
\DoxyCodeLine{20346                 m\_value = other.\mbox{\hyperlink{classbasic__json_a34bc6074bd3f9ac2bdab12ebc02d70f5}{m\_value}}.number\_integer;}
\DoxyCodeLine{20347                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20348             \}}
\DoxyCodeLine{20349 }
\DoxyCodeLine{20350             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{20351             \{}
\DoxyCodeLine{20352                 m\_value = other.\mbox{\hyperlink{classbasic__json_a34bc6074bd3f9ac2bdab12ebc02d70f5}{m\_value}}.number\_unsigned;}
\DoxyCodeLine{20353                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20354             \}}
\DoxyCodeLine{20355 }
\DoxyCodeLine{20356             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{20357             \{}
\DoxyCodeLine{20358                 m\_value = other.\mbox{\hyperlink{classbasic__json_a34bc6074bd3f9ac2bdab12ebc02d70f5}{m\_value}}.number\_float;}
\DoxyCodeLine{20359                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20360             \}}
\DoxyCodeLine{20361 }
\DoxyCodeLine{20362             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{20363             \{}
\DoxyCodeLine{20364                 m\_value = *other.\mbox{\hyperlink{classbasic__json_a34bc6074bd3f9ac2bdab12ebc02d70f5}{m\_value}}.binary;}
\DoxyCodeLine{20365                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20366             \}}
\DoxyCodeLine{20367 }
\DoxyCodeLine{20368             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{20369             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{20370             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{20371                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{20372         \}}
\DoxyCodeLine{20373 }
\DoxyCodeLine{20374         set\_parents();}
\DoxyCodeLine{20375         assert\_invariant();}
\DoxyCodeLine{20376     \}}
\DoxyCodeLine{20377 }
\DoxyCodeLine{20380     \mbox{\hyperlink{classbasic__json_aa269ba998ca2e15b2f596a8c074d125f}{basic\_json}}(\mbox{\hyperlink{classbasic__json}{basic\_json}}\&\& other) noexcept}
\DoxyCodeLine{20381         : m\_type(std::move(other.m\_type)),}
\DoxyCodeLine{20382           m\_value(std::move(other.m\_value))}
\DoxyCodeLine{20383     \{}
\DoxyCodeLine{20384         \textcolor{comment}{// check that passed value is valid}}
\DoxyCodeLine{20385         other.assert\_invariant(\textcolor{keyword}{false});}
\DoxyCodeLine{20386 }
\DoxyCodeLine{20387         \textcolor{comment}{// invalidate payload}}
\DoxyCodeLine{20388         other.m\_type = value\_t::null;}
\DoxyCodeLine{20389         other.m\_value = \{\};}
\DoxyCodeLine{20390 }
\DoxyCodeLine{20391         set\_parents();}
\DoxyCodeLine{20392         assert\_invariant();}
\DoxyCodeLine{20393     \}}
\DoxyCodeLine{20394 }
\DoxyCodeLine{20397     \mbox{\hyperlink{classbasic__json}{basic\_json}}\& \mbox{\hyperlink{classbasic__json_a8cb70d0ea0c23ac40f1f3b67d40c174f}{operator=}}(\mbox{\hyperlink{classbasic__json}{basic\_json}} other) \textcolor{keyword}{noexcept} (}
\DoxyCodeLine{20398         std::is\_nothrow\_move\_constructible<value\_t>::value\&\&}
\DoxyCodeLine{20399         std::is\_nothrow\_move\_assignable<value\_t>::value\&\&}
\DoxyCodeLine{20400         std::is\_nothrow\_move\_constructible<json\_value>::value\&\&}
\DoxyCodeLine{20401         std::is\_nothrow\_move\_assignable<json\_value>::value}
\DoxyCodeLine{20402     )}
\DoxyCodeLine{20403     \{}
\DoxyCodeLine{20404         \textcolor{comment}{// check that passed value is valid}}
\DoxyCodeLine{20405         other.assert\_invariant();}
\DoxyCodeLine{20406 }
\DoxyCodeLine{20407         \textcolor{keyword}{using }std::swap;}
\DoxyCodeLine{20408         swap(m\_type, other.m\_type);}
\DoxyCodeLine{20409         swap(m\_value, other.m\_value);}
\DoxyCodeLine{20410 }
\DoxyCodeLine{20411         set\_parents();}
\DoxyCodeLine{20412         assert\_invariant();}
\DoxyCodeLine{20413         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{20414     \}}
\DoxyCodeLine{20415 }
\DoxyCodeLine{20418     \mbox{\hyperlink{classbasic__json_ad0209408ec1ed66ea5f89a7d72e57e43}{\string~basic\_json}}() noexcept}
\DoxyCodeLine{20419     \{}
\DoxyCodeLine{20420         assert\_invariant(\textcolor{keyword}{false});}
\DoxyCodeLine{20421         m\_value.destroy(m\_type);}
\DoxyCodeLine{20422     \}}
\DoxyCodeLine{20423 }
\DoxyCodeLine{20425 }
\DoxyCodeLine{20426   \textcolor{keyword}{public}:}
\DoxyCodeLine{20428     \textcolor{comment}{// object inspection //}}
\DoxyCodeLine{20430 \textcolor{comment}{}}
\DoxyCodeLine{20434 }
\DoxyCodeLine{20437     \mbox{\hyperlink{classbasic__json_a807932caebf0d62abc8642b9d1a2e5ef}{string\_t}} \mbox{\hyperlink{classbasic__json_ac38b5f79c16205efb771e99be206b345}{dump}}(\textcolor{keyword}{const} \textcolor{keywordtype}{int} indent = -\/1,}
\DoxyCodeLine{20438                   \textcolor{keyword}{const} \textcolor{keywordtype}{char} indent\_char = \textcolor{charliteral}{' '},}
\DoxyCodeLine{20439                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ensure\_ascii = \textcolor{keyword}{false},}
\DoxyCodeLine{20440                   \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298}{error\_handler\_t}} error\_handler = error\_handler\_t::strict)\textcolor{keyword}{ const}}
\DoxyCodeLine{20441 \textcolor{keyword}{    }\{}
\DoxyCodeLine{20442         \mbox{\hyperlink{classbasic__json_a807932caebf0d62abc8642b9d1a2e5ef}{string\_t}} result;}
\DoxyCodeLine{20443         serializer s(\mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<char, string\_t>}}(result), indent\_char, error\_handler);}
\DoxyCodeLine{20444 }
\DoxyCodeLine{20445         \textcolor{keywordflow}{if} (indent >= 0)}
\DoxyCodeLine{20446         \{}
\DoxyCodeLine{20447             s.dump(*\textcolor{keyword}{this}, \textcolor{keyword}{true}, ensure\_ascii, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(indent));}
\DoxyCodeLine{20448         \}}
\DoxyCodeLine{20449         \textcolor{keywordflow}{else}}
\DoxyCodeLine{20450         \{}
\DoxyCodeLine{20451             s.dump(*\textcolor{keyword}{this}, \textcolor{keyword}{false}, ensure\_ascii, 0);}
\DoxyCodeLine{20452         \}}
\DoxyCodeLine{20453 }
\DoxyCodeLine{20454         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{20455     \}}
\DoxyCodeLine{20456 }
\DoxyCodeLine{20459     \textcolor{keyword}{constexpr} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}} \mbox{\hyperlink{classbasic__json_a1338e4eef7282cd57a4a57e034531029}{type}}() const noexcept}
\DoxyCodeLine{20460     \{}
\DoxyCodeLine{20461         \textcolor{keywordflow}{return} m\_type;}
\DoxyCodeLine{20462     \}}
\DoxyCodeLine{20463 }
\DoxyCodeLine{20466     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_a7fa8bc506b1519193a7bbc09f8a0f095}{is\_primitive}}() const noexcept}
\DoxyCodeLine{20467     \{}
\DoxyCodeLine{20468         \textcolor{keywordflow}{return} is\_null() || is\_string() || is\_boolean() || is\_number() || is\_binary();}
\DoxyCodeLine{20469     \}}
\DoxyCodeLine{20470 }
\DoxyCodeLine{20473     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_aded85ec1014821c21b8a47bc816a6917}{is\_structured}}() const noexcept}
\DoxyCodeLine{20474     \{}
\DoxyCodeLine{20475         \textcolor{keywordflow}{return} is\_array() || is\_object();}
\DoxyCodeLine{20476     \}}
\DoxyCodeLine{20477 }
\DoxyCodeLine{20480     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_a6ed948b2c2e71ce5f5c03b5eeb575df4}{is\_null}}() const noexcept}
\DoxyCodeLine{20481     \{}
\DoxyCodeLine{20482         \textcolor{keywordflow}{return} m\_type == value\_t::null;}
\DoxyCodeLine{20483     \}}
\DoxyCodeLine{20484 }
\DoxyCodeLine{20487     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_a814771ab0add0def16119c157b44003a}{is\_boolean}}() const noexcept}
\DoxyCodeLine{20488     \{}
\DoxyCodeLine{20489         \textcolor{keywordflow}{return} m\_type == value\_t::boolean;}
\DoxyCodeLine{20490     \}}
\DoxyCodeLine{20491 }
\DoxyCodeLine{20494     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_ab84294fe5d1a2822e2f67685f6e8c735}{is\_number}}() const noexcept}
\DoxyCodeLine{20495     \{}
\DoxyCodeLine{20496         \textcolor{keywordflow}{return} is\_number\_integer() || is\_number\_float();}
\DoxyCodeLine{20497     \}}
\DoxyCodeLine{20498 }
\DoxyCodeLine{20501     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_ad14438fe7c1f5a2f750eb56b8e73e538}{is\_number\_integer}}() const noexcept}
\DoxyCodeLine{20502     \{}
\DoxyCodeLine{20503         \textcolor{keywordflow}{return} m\_type == value\_t::number\_integer || m\_type == value\_t::number\_unsigned;}
\DoxyCodeLine{20504     \}}
\DoxyCodeLine{20505 }
\DoxyCodeLine{20508     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_aa5744d3f2404f2376ab0dbe531e4d3bc}{is\_number\_unsigned}}() const noexcept}
\DoxyCodeLine{20509     \{}
\DoxyCodeLine{20510         \textcolor{keywordflow}{return} m\_type == value\_t::number\_unsigned;}
\DoxyCodeLine{20511     \}}
\DoxyCodeLine{20512 }
\DoxyCodeLine{20515     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_aa8c885a9182fd22b05826ab2a9548f60}{is\_number\_float}}() const noexcept}
\DoxyCodeLine{20516     \{}
\DoxyCodeLine{20517         \textcolor{keywordflow}{return} m\_type == value\_t::number\_float;}
\DoxyCodeLine{20518     \}}
\DoxyCodeLine{20519 }
\DoxyCodeLine{20522     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_af758a912346776b086abb82487b1d73b}{is\_object}}() const noexcept}
\DoxyCodeLine{20523     \{}
\DoxyCodeLine{20524         \textcolor{keywordflow}{return} m\_type == value\_t::object;}
\DoxyCodeLine{20525     \}}
\DoxyCodeLine{20526 }
\DoxyCodeLine{20529     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_a89ea48a4e802ef81783c0c7ce89aa7bb}{is\_array}}() const noexcept}
\DoxyCodeLine{20530     \{}
\DoxyCodeLine{20531         \textcolor{keywordflow}{return} m\_type == value\_t::array;}
\DoxyCodeLine{20532     \}}
\DoxyCodeLine{20533 }
\DoxyCodeLine{20536     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_a3d4378552d27c9f15e4cb4ff4c075c94}{is\_string}}() const noexcept}
\DoxyCodeLine{20537     \{}
\DoxyCodeLine{20538         \textcolor{keywordflow}{return} m\_type == value\_t::string;}
\DoxyCodeLine{20539     \}}
\DoxyCodeLine{20540 }
\DoxyCodeLine{20543     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_aa25e81e71e2a263c0431f02f3245a8aa}{is\_binary}}() const noexcept}
\DoxyCodeLine{20544     \{}
\DoxyCodeLine{20545         \textcolor{keywordflow}{return} m\_type == value\_t::binary;}
\DoxyCodeLine{20546     \}}
\DoxyCodeLine{20547 }
\DoxyCodeLine{20550     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_abcc7082bb9fa07704c659f6be7c41bc9}{is\_discarded}}() const noexcept}
\DoxyCodeLine{20551     \{}
\DoxyCodeLine{20552         \textcolor{keywordflow}{return} m\_type == value\_t::discarded;}
\DoxyCodeLine{20553     \}}
\DoxyCodeLine{20554 }
\DoxyCodeLine{20557     \textcolor{keyword}{constexpr} \textcolor{keyword}{operator} \mbox{\hyperlink{namespacedetail_a917c3efabea8a20dc72d9ae2c673d632}{value\_t}}() const noexcept}
\DoxyCodeLine{20558     \{}
\DoxyCodeLine{20559         \textcolor{keywordflow}{return} m\_type;}
\DoxyCodeLine{20560     \}}
\DoxyCodeLine{20561 }
\DoxyCodeLine{20563 }
\DoxyCodeLine{20564   \textcolor{keyword}{private}:}
\DoxyCodeLine{20566     \textcolor{comment}{// value access //}}
\DoxyCodeLine{20568 \textcolor{comment}{}}
\DoxyCodeLine{20570     boolean\_t get\_impl(boolean\_t* \textcolor{comment}{/*unused*/})\textcolor{keyword}{ const}}
\DoxyCodeLine{20571 \textcolor{keyword}{    }\{}
\DoxyCodeLine{20572         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_boolean()))}
\DoxyCodeLine{20573         \{}
\DoxyCodeLine{20574             \textcolor{keywordflow}{return} m\_value.boolean;}
\DoxyCodeLine{20575         \}}
\DoxyCodeLine{20576 }
\DoxyCodeLine{20577         JSON\_THROW(type\_error::create(302, detail::concat(\textcolor{stringliteral}{"{}type must be boolean, but is "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{20578     \}}
\DoxyCodeLine{20579 }
\DoxyCodeLine{20581     object\_t* get\_impl\_ptr(object\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20582     \{}
\DoxyCodeLine{20583         \textcolor{keywordflow}{return} is\_object() ? m\_value.object : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20584     \}}
\DoxyCodeLine{20585 }
\DoxyCodeLine{20587     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} object\_t* get\_impl\_ptr(\textcolor{keyword}{const} object\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20588     \{}
\DoxyCodeLine{20589         \textcolor{keywordflow}{return} is\_object() ? m\_value.object : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20590     \}}
\DoxyCodeLine{20591 }
\DoxyCodeLine{20593     array\_t* get\_impl\_ptr(array\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20594     \{}
\DoxyCodeLine{20595         \textcolor{keywordflow}{return} is\_array() ? m\_value.array : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20596     \}}
\DoxyCodeLine{20597 }
\DoxyCodeLine{20599     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} array\_t* get\_impl\_ptr(\textcolor{keyword}{const} array\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20600     \{}
\DoxyCodeLine{20601         \textcolor{keywordflow}{return} is\_array() ? m\_value.array : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20602     \}}
\DoxyCodeLine{20603 }
\DoxyCodeLine{20605     string\_t* get\_impl\_ptr(string\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20606     \{}
\DoxyCodeLine{20607         \textcolor{keywordflow}{return} is\_string() ? m\_value.string : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20608     \}}
\DoxyCodeLine{20609 }
\DoxyCodeLine{20611     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} string\_t* get\_impl\_ptr(\textcolor{keyword}{const} string\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20612     \{}
\DoxyCodeLine{20613         \textcolor{keywordflow}{return} is\_string() ? m\_value.string : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20614     \}}
\DoxyCodeLine{20615 }
\DoxyCodeLine{20617     boolean\_t* get\_impl\_ptr(boolean\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20618     \{}
\DoxyCodeLine{20619         \textcolor{keywordflow}{return} is\_boolean() ? \&m\_value.boolean : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20620     \}}
\DoxyCodeLine{20621 }
\DoxyCodeLine{20623     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} boolean\_t* get\_impl\_ptr(\textcolor{keyword}{const} boolean\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20624     \{}
\DoxyCodeLine{20625         \textcolor{keywordflow}{return} is\_boolean() ? \&m\_value.boolean : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20626     \}}
\DoxyCodeLine{20627 }
\DoxyCodeLine{20629     number\_integer\_t* get\_impl\_ptr(number\_integer\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20630     \{}
\DoxyCodeLine{20631         \textcolor{keywordflow}{return} is\_number\_integer() ? \&m\_value.number\_integer : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20632     \}}
\DoxyCodeLine{20633 }
\DoxyCodeLine{20635     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} number\_integer\_t* get\_impl\_ptr(\textcolor{keyword}{const} number\_integer\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20636     \{}
\DoxyCodeLine{20637         \textcolor{keywordflow}{return} is\_number\_integer() ? \&m\_value.number\_integer : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20638     \}}
\DoxyCodeLine{20639 }
\DoxyCodeLine{20641     number\_unsigned\_t* get\_impl\_ptr(number\_unsigned\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20642     \{}
\DoxyCodeLine{20643         \textcolor{keywordflow}{return} is\_number\_unsigned() ? \&m\_value.number\_unsigned : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20644     \}}
\DoxyCodeLine{20645 }
\DoxyCodeLine{20647     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} number\_unsigned\_t* get\_impl\_ptr(\textcolor{keyword}{const} number\_unsigned\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20648     \{}
\DoxyCodeLine{20649         \textcolor{keywordflow}{return} is\_number\_unsigned() ? \&m\_value.number\_unsigned : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20650     \}}
\DoxyCodeLine{20651 }
\DoxyCodeLine{20653     number\_float\_t* get\_impl\_ptr(number\_float\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20654     \{}
\DoxyCodeLine{20655         \textcolor{keywordflow}{return} is\_number\_float() ? \&m\_value.number\_float : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20656     \}}
\DoxyCodeLine{20657 }
\DoxyCodeLine{20659     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} number\_float\_t* get\_impl\_ptr(\textcolor{keyword}{const} number\_float\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20660     \{}
\DoxyCodeLine{20661         \textcolor{keywordflow}{return} is\_number\_float() ? \&m\_value.number\_float : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20662     \}}
\DoxyCodeLine{20663 }
\DoxyCodeLine{20665     binary\_t* get\_impl\_ptr(binary\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20666     \{}
\DoxyCodeLine{20667         \textcolor{keywordflow}{return} is\_binary() ? m\_value.binary : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20668     \}}
\DoxyCodeLine{20669 }
\DoxyCodeLine{20671     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} binary\_t* get\_impl\_ptr(\textcolor{keyword}{const} binary\_t* \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20672     \{}
\DoxyCodeLine{20673         \textcolor{keywordflow}{return} is\_binary() ? m\_value.binary : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{20674     \}}
\DoxyCodeLine{20675 }
\DoxyCodeLine{20687     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReferenceType, \textcolor{keyword}{typename} ThisType>}
\DoxyCodeLine{20688     \textcolor{keyword}{static} ReferenceType get\_ref\_impl(ThisType\& obj)}
\DoxyCodeLine{20689     \{}
\DoxyCodeLine{20690         \textcolor{comment}{// delegate the call to get\_ptr<>()}}
\DoxyCodeLine{20691         \textcolor{keyword}{auto}* ptr = obj.template get\_ptr<typename std::add\_pointer<ReferenceType>::type>();}
\DoxyCodeLine{20692 }
\DoxyCodeLine{20693         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(ptr != \textcolor{keyword}{nullptr}))}
\DoxyCodeLine{20694         \{}
\DoxyCodeLine{20695             \textcolor{keywordflow}{return} *ptr;}
\DoxyCodeLine{20696         \}}
\DoxyCodeLine{20697 }
\DoxyCodeLine{20698         JSON\_THROW(type\_error::create(303, detail::concat(\textcolor{stringliteral}{"{}incompatible ReferenceType for get\_ref, actual type is "{}}, obj.type\_name()), \&obj));}
\DoxyCodeLine{20699     \}}
\DoxyCodeLine{20700 }
\DoxyCodeLine{20701   \textcolor{keyword}{public}:}
\DoxyCodeLine{20705 }
\DoxyCodeLine{20708     \textcolor{keyword}{template}<\textcolor{keyword}{typename} PointerType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{20709                  std::is\_pointer<PointerType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{20710     \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__json_a206a3748ff1fc676f64f753e203388dd}{get\_ptr}}() noexcept -\/> decltype(std::declval<basic\_json\_t\&>().get\_impl\_ptr(std::declval<PointerType>()))}
\DoxyCodeLine{20711     \{}
\DoxyCodeLine{20712         \textcolor{comment}{// delegate the call to get\_impl\_ptr<>()}}
\DoxyCodeLine{20713         \textcolor{keywordflow}{return} get\_impl\_ptr(\textcolor{keyword}{static\_cast<}PointerType\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{20714     \}}
\DoxyCodeLine{20715 }
\DoxyCodeLine{20718     \textcolor{keyword}{template} < \textcolor{keyword}{typename} PointerType, \textcolor{keyword}{typename} std::enable\_if <}
\DoxyCodeLine{20719                    std::is\_pointer<PointerType>::value\&\&}
\DoxyCodeLine{20720                    std::is\_const<typename std::remove\_pointer<PointerType>::type>::value, \textcolor{keywordtype}{int} >::type = 0 >}
\DoxyCodeLine{20721     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__json_a2055fcc0c999d3cb4c211f258695faff}{get\_ptr}}() const noexcept -\/> decltype(std::declval<const basic\_json\_t\&>().get\_impl\_ptr(std::declval<PointerType>()))}
\DoxyCodeLine{20722     \{}
\DoxyCodeLine{20723         \textcolor{comment}{// delegate the call to get\_impl\_ptr<>() const}}
\DoxyCodeLine{20724         \textcolor{keywordflow}{return} get\_impl\_ptr(\textcolor{keyword}{static\_cast<}PointerType\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{20725     \}}
\DoxyCodeLine{20726 }
\DoxyCodeLine{20727   \textcolor{keyword}{private}:}
\DoxyCodeLine{20766     \textcolor{keyword}{template} < \textcolor{keyword}{typename} ValueType,}
\DoxyCodeLine{20767                detail::enable\_if\_t <}
\DoxyCodeLine{20768                    \mbox{\hyperlink{structdetail_1_1is__default__constructible}{detail::is\_default\_constructible<ValueType>::value}}\&\&}
\DoxyCodeLine{20769                    \mbox{\hyperlink{structdetail_1_1has__from__json}{detail::has\_from\_json<basic\_json\_t, ValueType>::value}},}
\DoxyCodeLine{20770                    \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{20771     ValueType get\_impl(\mbox{\hyperlink{structdetail_1_1priority__tag_3_010_01_4}{detail::priority\_tag<0>}} \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(}
\DoxyCodeLine{20772                 JSONSerializer<ValueType>::from\_json(std::declval<const basic\_json\_t\&>(), std::declval<ValueType\&>())))}
\DoxyCodeLine{20773     \{}
\DoxyCodeLine{20774         \textcolor{keyword}{auto} ret = ValueType();}
\DoxyCodeLine{20775         JSONSerializer<ValueType>::from\_json(*\textcolor{keyword}{this}, ret);}
\DoxyCodeLine{20776         \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{20777     \}}
\DoxyCodeLine{20778 }
\DoxyCodeLine{20809     \textcolor{keyword}{template} < \textcolor{keyword}{typename} ValueType,}
\DoxyCodeLine{20810                detail::enable\_if\_t <}
\DoxyCodeLine{20811                    \mbox{\hyperlink{structdetail_1_1has__non__default__from__json}{detail::has\_non\_default\_from\_json<basic\_json\_t, ValueType>::value}},}
\DoxyCodeLine{20812                    \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{20813     ValueType get\_impl(\mbox{\hyperlink{structdetail_1_1priority__tag}{detail::priority\_tag<1>}} \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(}
\DoxyCodeLine{20814                 JSONSerializer<ValueType>::from\_json(std::declval<const basic\_json\_t\&>())))}
\DoxyCodeLine{20815     \{}
\DoxyCodeLine{20816         \textcolor{keywordflow}{return} JSONSerializer<ValueType>::from\_json(*\textcolor{keyword}{this});}
\DoxyCodeLine{20817     \}}
\DoxyCodeLine{20818 }
\DoxyCodeLine{20834     \textcolor{keyword}{template} < \textcolor{keyword}{typename} BasicJsonType,}
\DoxyCodeLine{20835                detail::enable\_if\_t <}
\DoxyCodeLine{20836                    \mbox{\hyperlink{structdetail_1_1is__basic__json}{detail::is\_basic\_json<BasicJsonType>::value}},}
\DoxyCodeLine{20837                    \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{20838     BasicJsonType get\_impl(\mbox{\hyperlink{structdetail_1_1priority__tag}{detail::priority\_tag<2>}} \textcolor{comment}{/*unused*/})\textcolor{keyword}{ const}}
\DoxyCodeLine{20839 \textcolor{keyword}{    }\{}
\DoxyCodeLine{20840         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{20841     \}}
\DoxyCodeLine{20842 }
\DoxyCodeLine{20857     \textcolor{keyword}{template}<\textcolor{keyword}{typename} BasicJsonType,}
\DoxyCodeLine{20858              detail::enable\_if\_t<}
\DoxyCodeLine{20859                  std::is\_same<BasicJsonType, basic\_json\_t>::value,}
\DoxyCodeLine{20860                  \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{20861     \mbox{\hyperlink{classbasic__json}{basic\_json}} get\_impl(\mbox{\hyperlink{structdetail_1_1priority__tag}{detail::priority\_tag<3>}} \textcolor{comment}{/*unused*/})\textcolor{keyword}{ const}}
\DoxyCodeLine{20862 \textcolor{keyword}{    }\{}
\DoxyCodeLine{20863         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{20864     \}}
\DoxyCodeLine{20865 }
\DoxyCodeLine{20870     \textcolor{keyword}{template}<\textcolor{keyword}{typename} PointerType,}
\DoxyCodeLine{20871              detail::enable\_if\_t<}
\DoxyCodeLine{20872                  std::is\_pointer<PointerType>::value,}
\DoxyCodeLine{20873                  \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{20874     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} get\_impl(\mbox{\hyperlink{structdetail_1_1priority__tag}{detail::priority\_tag<4>}} \textcolor{comment}{/*unused*/}) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{20875     -\/> \textcolor{keyword}{decltype}(std::declval<const basic\_json\_t\&>().template get\_ptr<PointerType>())}
\DoxyCodeLine{20876     \{}
\DoxyCodeLine{20877         \textcolor{comment}{// delegate the call to get\_ptr}}
\DoxyCodeLine{20878         \textcolor{keywordflow}{return} get\_ptr<PointerType>();}
\DoxyCodeLine{20879     \}}
\DoxyCodeLine{20880 }
\DoxyCodeLine{20881   \textcolor{keyword}{public}:}
\DoxyCodeLine{20905     \textcolor{keyword}{template} < \textcolor{keyword}{typename} ValueTypeCV, \textcolor{keyword}{typename} ValueType = detail::uncvref\_t<ValueTypeCV>>}
\DoxyCodeLine{20906 \textcolor{preprocessor}{\#if defined(JSON\_HAS\_CPP\_14)}}
\DoxyCodeLine{20907     \textcolor{keyword}{constexpr}}
\DoxyCodeLine{20908 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{20909     \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__json_ab11bff397526e8255d151066caeba48e}{get}}() const noexcept(}
\DoxyCodeLine{20910     noexcept(std::declval<const basic\_json\_t\&>().template get\_impl<ValueType>(\mbox{\hyperlink{namespacedetail}{detail}}::priority\_tag<4> \{\})))}
\DoxyCodeLine{20911     -\/> \textcolor{keyword}{decltype}(std::declval<const basic\_json\_t\&>().template get\_impl<ValueType>(\mbox{\hyperlink{structdetail_1_1priority__tag}{detail::priority\_tag<4>}} \{\}))}
\DoxyCodeLine{20912     \{}
\DoxyCodeLine{20913         \textcolor{comment}{// we cannot static\_assert on ValueTypeCV being non-\/const, because}}
\DoxyCodeLine{20914         \textcolor{comment}{// there is support for get<const basic\_json\_t>(), which is why we}}
\DoxyCodeLine{20915         \textcolor{comment}{// still need the uncvref}}
\DoxyCodeLine{20916         \textcolor{keyword}{static\_assert}(!std::is\_reference<ValueTypeCV>::value,}
\DoxyCodeLine{20917                       \textcolor{stringliteral}{"{}get() cannot be used with reference types, you might want to use get\_ref()"{}});}
\DoxyCodeLine{20918         \textcolor{keywordflow}{return} get\_impl<ValueType>(\mbox{\hyperlink{structdetail_1_1priority__tag}{detail::priority\_tag<4>}} \{\});}
\DoxyCodeLine{20919     \}}
\DoxyCodeLine{20920 }
\DoxyCodeLine{20948     \textcolor{keyword}{template}<\textcolor{keyword}{typename} PointerType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{20949                  std::is\_pointer<PointerType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{20950     \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__json_a35fa19a3f6193409abe4bd9014712105}{get}}() noexcept -\/> decltype(std::declval<basic\_json\_t\&>().template get\_ptr<PointerType>())}
\DoxyCodeLine{20951     \{}
\DoxyCodeLine{20952         \textcolor{comment}{// delegate the call to get\_ptr}}
\DoxyCodeLine{20953         \textcolor{keywordflow}{return} get\_ptr<PointerType>();}
\DoxyCodeLine{20954     \}}
\DoxyCodeLine{20955 }
\DoxyCodeLine{20958     \textcolor{keyword}{template} < \textcolor{keyword}{typename} ValueType,}
\DoxyCodeLine{20959                detail::enable\_if\_t <}
\DoxyCodeLine{20960                    !\mbox{\hyperlink{structdetail_1_1is__basic__json}{detail::is\_basic\_json<ValueType>::value}}\&\&}
\DoxyCodeLine{20961                    \mbox{\hyperlink{structdetail_1_1has__from__json}{detail::has\_from\_json<basic\_json\_t, ValueType>::value}},}
\DoxyCodeLine{20962                    \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{20963     ValueType \& \mbox{\hyperlink{classbasic__json_a251b2b7f275328615aed5a0f827e7710}{get\_to}}(ValueType\& v) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(}
\DoxyCodeLine{20964                 JSONSerializer<ValueType>::from\_json(std::declval<const basic\_json\_t\&>(), v)))}
\DoxyCodeLine{20965     \{}
\DoxyCodeLine{20966         JSONSerializer<ValueType>::from\_json(*\textcolor{keyword}{this}, v);}
\DoxyCodeLine{20967         \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{20968     \}}
\DoxyCodeLine{20969 }
\DoxyCodeLine{20970     \textcolor{comment}{// specialization to allow calling get\_to with a basic\_json value}}
\DoxyCodeLine{20971     \textcolor{comment}{// see https://github.com/nlohmann/json/issues/2175}}
\DoxyCodeLine{20972     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ValueType,}
\DoxyCodeLine{20973              detail::enable\_if\_t <}
\DoxyCodeLine{20974                  \mbox{\hyperlink{structdetail_1_1is__basic__json}{detail::is\_basic\_json<ValueType>::value}},}
\DoxyCodeLine{20975                  \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{20976     ValueType \& get\_to(ValueType\& v)\textcolor{keyword}{ const}}
\DoxyCodeLine{20977 \textcolor{keyword}{    }\{}
\DoxyCodeLine{20978         v = *\textcolor{keyword}{this};}
\DoxyCodeLine{20979         \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{20980     \}}
\DoxyCodeLine{20981 }
\DoxyCodeLine{20982     \textcolor{keyword}{template} <}
\DoxyCodeLine{20983         \textcolor{keyword}{typename} T, std::size\_t N,}
\DoxyCodeLine{20984         \textcolor{keyword}{typename} Array = T (\&)[N], \textcolor{comment}{// NOLINT(cppcoreguidelines-\/avoid-\/c-\/arrays,hicpp-\/avoid-\/c-\/arrays,modernize-\/avoid-\/c-\/arrays)}}
\DoxyCodeLine{20985         detail::enable\_if\_t <}
\DoxyCodeLine{20986             \mbox{\hyperlink{structdetail_1_1has__from__json}{detail::has\_from\_json<basic\_json\_t, Array>::value}}, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{20987     Array get\_to(T (\&v)[N]) \textcolor{keyword}{const} \textcolor{comment}{// NOLINT(cppcoreguidelines-\/avoid-\/c-\/arrays,hicpp-\/avoid-\/c-\/arrays,modernize-\/avoid-\/c-\/arrays)}}
\DoxyCodeLine{20988     \textcolor{keyword}{noexcept}(\textcolor{keyword}{noexcept}(JSONSerializer<Array>::from\_json(}
\DoxyCodeLine{20989                           std::declval<const basic\_json\_t\&>(), v)))}
\DoxyCodeLine{20990     \{}
\DoxyCodeLine{20991         JSONSerializer<Array>::from\_json(*\textcolor{keyword}{this}, v);}
\DoxyCodeLine{20992         \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{20993     \}}
\DoxyCodeLine{20994 }
\DoxyCodeLine{20997     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReferenceType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{20998                  std::is\_reference<ReferenceType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{20999     ReferenceType \mbox{\hyperlink{classbasic__json_a7bfdaa5014da75e18dd07cc76e53b237}{get\_ref}}()}
\DoxyCodeLine{21000     \{}
\DoxyCodeLine{21001         \textcolor{comment}{// delegate call to get\_ref\_impl}}
\DoxyCodeLine{21002         \textcolor{keywordflow}{return} get\_ref\_impl<ReferenceType>(*\textcolor{keyword}{this});}
\DoxyCodeLine{21003     \}}
\DoxyCodeLine{21004 }
\DoxyCodeLine{21007     \textcolor{keyword}{template} < \textcolor{keyword}{typename} ReferenceType, \textcolor{keyword}{typename} std::enable\_if <}
\DoxyCodeLine{21008                    std::is\_reference<ReferenceType>::value\&\&}
\DoxyCodeLine{21009                    std::is\_const<typename std::remove\_reference<ReferenceType>::type>::value, \textcolor{keywordtype}{int} >::type = 0 >}
\DoxyCodeLine{21010     ReferenceType \mbox{\hyperlink{classbasic__json_a42f1f9cf90ed5254e38e6b587fce237d}{get\_ref}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{21011 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21012         \textcolor{comment}{// delegate call to get\_ref\_impl}}
\DoxyCodeLine{21013         \textcolor{keywordflow}{return} get\_ref\_impl<ReferenceType>(*\textcolor{keyword}{this});}
\DoxyCodeLine{21014     \}}
\DoxyCodeLine{21015 }
\DoxyCodeLine{21045     \textcolor{keyword}{template} < \textcolor{keyword}{typename} ValueType, \textcolor{keyword}{typename} std::enable\_if <}
\DoxyCodeLine{21046                    \mbox{\hyperlink{structdetail_1_1conjunction}{detail::conjunction}} <}
\DoxyCodeLine{21047                        \mbox{\hyperlink{structdetail_1_1negation}{detail::negation<std::is\_pointer<ValueType>}}>,}
\DoxyCodeLine{21048                        \mbox{\hyperlink{structdetail_1_1negation}{detail::negation<std::is\_same<ValueType, std::nullptr\_t>}}>,}
\DoxyCodeLine{21049                        \mbox{\hyperlink{structdetail_1_1negation}{detail::negation<std::is\_same<ValueType, detail::json\_ref<basic\_json>}}>>,}
\DoxyCodeLine{21050                                         \mbox{\hyperlink{structdetail_1_1negation}{detail::negation<std::is\_same<ValueType, typename string\_t::value\_type>}}>,}
\DoxyCodeLine{21051                                         \mbox{\hyperlink{structdetail_1_1negation}{detail::negation<detail::is\_basic\_json<ValueType>}}>,}
\DoxyCodeLine{21052                                         \mbox{\hyperlink{structdetail_1_1negation}{detail::negation<std::is\_same<ValueType, std::initializer\_list<typename string\_t::value\_type>}}>>,}
\DoxyCodeLine{21053 \textcolor{preprocessor}{\#if defined(JSON\_HAS\_CPP\_17) \&\& (defined(\_\_GNUC\_\_) || (defined(\_MSC\_VER) \&\& \_MSC\_VER >= 1910 \&\& \_MSC\_VER <= 1914))}}
\DoxyCodeLine{21054                                                 \mbox{\hyperlink{structdetail_1_1negation}{detail::negation<std::is\_same<ValueType, std::string\_view>}}>,}
\DoxyCodeLine{21055 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{21056 \textcolor{preprocessor}{\#if defined(JSON\_HAS\_CPP\_17)}}
\DoxyCodeLine{21057                                                 \mbox{\hyperlink{structdetail_1_1negation}{detail::negation<std::is\_same<ValueType, std::any>}}>,}
\DoxyCodeLine{21058 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{21059                                                 \mbox{\hyperlink{structdetail_1_1is__detected__lazy}{detail::is\_detected\_lazy<detail::get\_template\_function, const basic\_json\_t\&, ValueType>}}}
\DoxyCodeLine{21060                                                 >::value, \textcolor{keywordtype}{int} >::type = 0 >}
\DoxyCodeLine{21061                                         JSON\_EXPLICIT \textcolor{keyword}{operator} ValueType()\textcolor{keyword}{ const}}
\DoxyCodeLine{21062 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21063         \textcolor{comment}{// delegate the call to get<>() const}}
\DoxyCodeLine{21064         \textcolor{keywordflow}{return} get<ValueType>();}
\DoxyCodeLine{21065     \}}
\DoxyCodeLine{21066 }
\DoxyCodeLine{21069     \mbox{\hyperlink{classbasic__json_aabedd827d4943302a4cf0413956341db}{binary\_t}}\& \mbox{\hyperlink{classbasic__json_aa4401911681258520903f3c374a9e994}{get\_binary}}()}
\DoxyCodeLine{21070     \{}
\DoxyCodeLine{21071         \textcolor{keywordflow}{if} (!is\_binary())}
\DoxyCodeLine{21072         \{}
\DoxyCodeLine{21073             JSON\_THROW(type\_error::create(302, detail::concat(\textcolor{stringliteral}{"{}type must be binary, but is "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21074         \}}
\DoxyCodeLine{21075 }
\DoxyCodeLine{21076         \textcolor{keywordflow}{return} *get\_ptr<binary\_t*>();}
\DoxyCodeLine{21077     \}}
\DoxyCodeLine{21078 }
\DoxyCodeLine{21081     \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json_aabedd827d4943302a4cf0413956341db}{binary\_t}}\& \mbox{\hyperlink{classbasic__json_a44b4244ff0e901156adfad7b027232de}{get\_binary}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{21082 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21083         \textcolor{keywordflow}{if} (!is\_binary())}
\DoxyCodeLine{21084         \{}
\DoxyCodeLine{21085             JSON\_THROW(type\_error::create(302, detail::concat(\textcolor{stringliteral}{"{}type must be binary, but is "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21086         \}}
\DoxyCodeLine{21087 }
\DoxyCodeLine{21088         \textcolor{keywordflow}{return} *get\_ptr<const binary\_t*>();}
\DoxyCodeLine{21089     \}}
\DoxyCodeLine{21090 }
\DoxyCodeLine{21092 }
\DoxyCodeLine{21093 }
\DoxyCodeLine{21095     \textcolor{comment}{// element access //}}
\DoxyCodeLine{21097 \textcolor{comment}{}}
\DoxyCodeLine{21101 }
\DoxyCodeLine{21104     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_a603779687f401ad11de45f8397f92296}{at}}(\mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} idx)}
\DoxyCodeLine{21105     \{}
\DoxyCodeLine{21106         \textcolor{comment}{// at only works for arrays}}
\DoxyCodeLine{21107         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_array()))}
\DoxyCodeLine{21108         \{}
\DoxyCodeLine{21109             JSON\_TRY}
\DoxyCodeLine{21110             \{}
\DoxyCodeLine{21111                 \textcolor{keywordflow}{return} set\_parent(m\_value.array-\/>at(idx));}
\DoxyCodeLine{21112             \}}
\DoxyCodeLine{21113             JSON\_CATCH (std::out\_of\_range\&)}
\DoxyCodeLine{21114             \{}
\DoxyCodeLine{21115                 \textcolor{comment}{// create better exception explanation}}
\DoxyCodeLine{21116                 JSON\_THROW(out\_of\_range::create(401, detail::concat(\textcolor{stringliteral}{"{}array index "{}}, std::to\_string(idx), \textcolor{stringliteral}{"{} is out of range"{}}), \textcolor{keyword}{this}));}
\DoxyCodeLine{21117             \}}
\DoxyCodeLine{21118         \}}
\DoxyCodeLine{21119         \textcolor{keywordflow}{else}}
\DoxyCodeLine{21120         \{}
\DoxyCodeLine{21121             JSON\_THROW(type\_error::create(304, detail::concat(\textcolor{stringliteral}{"{}cannot use at() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21122         \}}
\DoxyCodeLine{21123     \}}
\DoxyCodeLine{21124 }
\DoxyCodeLine{21127     \mbox{\hyperlink{classbasic__json}{const\_reference}} \mbox{\hyperlink{classbasic__json_a98e6b7245d17021327eb3962d73ccc54}{at}}(\mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} idx)\textcolor{keyword}{ const}}
\DoxyCodeLine{21128 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21129         \textcolor{comment}{// at only works for arrays}}
\DoxyCodeLine{21130         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_array()))}
\DoxyCodeLine{21131         \{}
\DoxyCodeLine{21132             JSON\_TRY}
\DoxyCodeLine{21133             \{}
\DoxyCodeLine{21134                 \textcolor{keywordflow}{return} m\_value.array-\/>at(idx);}
\DoxyCodeLine{21135             \}}
\DoxyCodeLine{21136             JSON\_CATCH (std::out\_of\_range\&)}
\DoxyCodeLine{21137             \{}
\DoxyCodeLine{21138                 \textcolor{comment}{// create better exception explanation}}
\DoxyCodeLine{21139                 JSON\_THROW(out\_of\_range::create(401, detail::concat(\textcolor{stringliteral}{"{}array index "{}}, std::to\_string(idx), \textcolor{stringliteral}{"{} is out of range"{}}), \textcolor{keyword}{this}));}
\DoxyCodeLine{21140             \}}
\DoxyCodeLine{21141         \}}
\DoxyCodeLine{21142         \textcolor{keywordflow}{else}}
\DoxyCodeLine{21143         \{}
\DoxyCodeLine{21144             JSON\_THROW(type\_error::create(304, detail::concat(\textcolor{stringliteral}{"{}cannot use at() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21145         \}}
\DoxyCodeLine{21146     \}}
\DoxyCodeLine{21147 }
\DoxyCodeLine{21150     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_aedf1894e1b70a4caebd95adec60e845a}{at}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21151     \{}
\DoxyCodeLine{21152         \textcolor{comment}{// at only works for objects}}
\DoxyCodeLine{21153         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!is\_object()))}
\DoxyCodeLine{21154         \{}
\DoxyCodeLine{21155             JSON\_THROW(type\_error::create(304, detail::concat(\textcolor{stringliteral}{"{}cannot use at() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21156         \}}
\DoxyCodeLine{21157 }
\DoxyCodeLine{21158         \textcolor{keyword}{auto} it = m\_value.object-\/>find(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}});}
\DoxyCodeLine{21159         \textcolor{keywordflow}{if} (it == m\_value.object-\/>end())}
\DoxyCodeLine{21160         \{}
\DoxyCodeLine{21161             JSON\_THROW(out\_of\_range::create(403, detail::concat(\textcolor{stringliteral}{"{}key '"{}}, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, \textcolor{stringliteral}{"{}' not found"{}}), \textcolor{keyword}{this}));}
\DoxyCodeLine{21162         \}}
\DoxyCodeLine{21163         \textcolor{keywordflow}{return} set\_parent(it-\/>second);}
\DoxyCodeLine{21164     \}}
\DoxyCodeLine{21165 }
\DoxyCodeLine{21168     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{21169                  detail::is\_usable\_as\_basic\_json\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{21170     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_afc69e86b65aa8b571ccad9d581ca5a2b}{at}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21171     \{}
\DoxyCodeLine{21172         \textcolor{comment}{// at only works for objects}}
\DoxyCodeLine{21173         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!is\_object()))}
\DoxyCodeLine{21174         \{}
\DoxyCodeLine{21175             JSON\_THROW(type\_error::create(304, detail::concat(\textcolor{stringliteral}{"{}cannot use at() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21176         \}}
\DoxyCodeLine{21177 }
\DoxyCodeLine{21178         \textcolor{keyword}{auto} it = m\_value.object-\/>find(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21179         \textcolor{keywordflow}{if} (it == m\_value.object-\/>end())}
\DoxyCodeLine{21180         \{}
\DoxyCodeLine{21181             JSON\_THROW(out\_of\_range::create(403, detail::concat(\textcolor{stringliteral}{"{}key '"{}}, \mbox{\hyperlink{classbasic__json_a807932caebf0d62abc8642b9d1a2e5ef}{string\_t}}(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})), \textcolor{stringliteral}{"{}' not found"{}}), \textcolor{keyword}{this}));}
\DoxyCodeLine{21182         \}}
\DoxyCodeLine{21183         \textcolor{keywordflow}{return} set\_parent(it-\/>second);}
\DoxyCodeLine{21184     \}}
\DoxyCodeLine{21185 }
\DoxyCodeLine{21188     \mbox{\hyperlink{classbasic__json}{const\_reference}} \mbox{\hyperlink{classbasic__json_afc32b953a4e343dc7f8ab3465743f399}{at}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21189 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21190         \textcolor{comment}{// at only works for objects}}
\DoxyCodeLine{21191         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!is\_object()))}
\DoxyCodeLine{21192         \{}
\DoxyCodeLine{21193             JSON\_THROW(type\_error::create(304, detail::concat(\textcolor{stringliteral}{"{}cannot use at() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21194         \}}
\DoxyCodeLine{21195 }
\DoxyCodeLine{21196         \textcolor{keyword}{auto} it = m\_value.object-\/>find(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}});}
\DoxyCodeLine{21197         \textcolor{keywordflow}{if} (it == m\_value.object-\/>end())}
\DoxyCodeLine{21198         \{}
\DoxyCodeLine{21199             JSON\_THROW(out\_of\_range::create(403, detail::concat(\textcolor{stringliteral}{"{}key '"{}}, \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, \textcolor{stringliteral}{"{}' not found"{}}), \textcolor{keyword}{this}));}
\DoxyCodeLine{21200         \}}
\DoxyCodeLine{21201         \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{21202     \}}
\DoxyCodeLine{21203 }
\DoxyCodeLine{21206     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{21207                  detail::is\_usable\_as\_basic\_json\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{21208     \mbox{\hyperlink{classbasic__json}{const\_reference}} \mbox{\hyperlink{classbasic__json_aee87279fb115f6d57967e6e8f5542faa}{at}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21209 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21210         \textcolor{comment}{// at only works for objects}}
\DoxyCodeLine{21211         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!is\_object()))}
\DoxyCodeLine{21212         \{}
\DoxyCodeLine{21213             JSON\_THROW(type\_error::create(304, detail::concat(\textcolor{stringliteral}{"{}cannot use at() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21214         \}}
\DoxyCodeLine{21215 }
\DoxyCodeLine{21216         \textcolor{keyword}{auto} it = m\_value.object-\/>find(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21217         \textcolor{keywordflow}{if} (it == m\_value.object-\/>end())}
\DoxyCodeLine{21218         \{}
\DoxyCodeLine{21219             JSON\_THROW(out\_of\_range::create(403, detail::concat(\textcolor{stringliteral}{"{}key '"{}}, \mbox{\hyperlink{classbasic__json_a807932caebf0d62abc8642b9d1a2e5ef}{string\_t}}(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})), \textcolor{stringliteral}{"{}' not found"{}}), \textcolor{keyword}{this}));}
\DoxyCodeLine{21220         \}}
\DoxyCodeLine{21221         \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{21222     \}}
\DoxyCodeLine{21223 }
\DoxyCodeLine{21226     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_aa3dfeae16fa9a8ec1390a27d6a4a58b3}{operator[]}}(\mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} idx)}
\DoxyCodeLine{21227     \{}
\DoxyCodeLine{21228         \textcolor{comment}{// implicitly convert null value to an empty array}}
\DoxyCodeLine{21229         \textcolor{keywordflow}{if} (is\_null())}
\DoxyCodeLine{21230         \{}
\DoxyCodeLine{21231             m\_type = value\_t::array;}
\DoxyCodeLine{21232             m\_value.array = create<array\_t>();}
\DoxyCodeLine{21233             assert\_invariant();}
\DoxyCodeLine{21234         \}}
\DoxyCodeLine{21235 }
\DoxyCodeLine{21236         \textcolor{comment}{// operator[] only works for arrays}}
\DoxyCodeLine{21237         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_array()))}
\DoxyCodeLine{21238         \{}
\DoxyCodeLine{21239             \textcolor{comment}{// fill up array with null values if given idx is outside range}}
\DoxyCodeLine{21240             \textcolor{keywordflow}{if} (idx >= m\_value.array-\/>size())}
\DoxyCodeLine{21241             \{}
\DoxyCodeLine{21242 \textcolor{preprocessor}{\#if JSON\_DIAGNOSTICS}}
\DoxyCodeLine{21243                 \textcolor{comment}{// remember array size \& capacity before resizing}}
\DoxyCodeLine{21244                 \textcolor{keyword}{const} \textcolor{keyword}{auto} old\_size = m\_value.array-\/>size();}
\DoxyCodeLine{21245                 \textcolor{keyword}{const} \textcolor{keyword}{auto} old\_capacity = m\_value.array-\/>capacity();}
\DoxyCodeLine{21246 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{21247                 m\_value.array-\/>resize(idx + 1);}
\DoxyCodeLine{21248 }
\DoxyCodeLine{21249 \textcolor{preprocessor}{\#if JSON\_DIAGNOSTICS}}
\DoxyCodeLine{21250                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(m\_value.array-\/>capacity() != old\_capacity))}
\DoxyCodeLine{21251                 \{}
\DoxyCodeLine{21252                     \textcolor{comment}{// capacity has changed: update all parents}}
\DoxyCodeLine{21253                     set\_parents();}
\DoxyCodeLine{21254                 \}}
\DoxyCodeLine{21255                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{21256                 \{}
\DoxyCodeLine{21257                     \textcolor{comment}{// set parent for values added above}}
\DoxyCodeLine{21258                     set\_parents(begin() + \textcolor{keyword}{static\_cast<}typename iterator::difference\_type\textcolor{keyword}{>}(old\_size), \textcolor{keyword}{static\_cast<}typename iterator::difference\_type\textcolor{keyword}{>}(idx + 1 -\/ old\_size));}
\DoxyCodeLine{21259                 \}}
\DoxyCodeLine{21260 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{21261                 assert\_invariant();}
\DoxyCodeLine{21262             \}}
\DoxyCodeLine{21263 }
\DoxyCodeLine{21264             \textcolor{keywordflow}{return} m\_value.array-\/>operator[](idx);}
\DoxyCodeLine{21265         \}}
\DoxyCodeLine{21266 }
\DoxyCodeLine{21267         JSON\_THROW(type\_error::create(305, detail::concat(\textcolor{stringliteral}{"{}cannot use operator[] with a numeric argument with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21268     \}}
\DoxyCodeLine{21269 }
\DoxyCodeLine{21272     \mbox{\hyperlink{classbasic__json}{const\_reference}} \mbox{\hyperlink{classbasic__json_a61677841384622af7c3174f3f10df621}{operator[]}}(\mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} idx)\textcolor{keyword}{ const}}
\DoxyCodeLine{21273 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21274         \textcolor{comment}{// const operator[] only works for arrays}}
\DoxyCodeLine{21275         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_array()))}
\DoxyCodeLine{21276         \{}
\DoxyCodeLine{21277             \textcolor{keywordflow}{return} m\_value.array-\/>operator[](idx);}
\DoxyCodeLine{21278         \}}
\DoxyCodeLine{21279 }
\DoxyCodeLine{21280         JSON\_THROW(type\_error::create(305, detail::concat(\textcolor{stringliteral}{"{}cannot use operator[] with a numeric argument with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21281     \}}
\DoxyCodeLine{21282 }
\DoxyCodeLine{21285     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_a272177c4eb206c70f41e35146915b710}{operator[]}}(\textcolor{keyword}{typename} object\_t::key\_type \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21286     \{}
\DoxyCodeLine{21287         \textcolor{comment}{// implicitly convert null value to an empty object}}
\DoxyCodeLine{21288         \textcolor{keywordflow}{if} (is\_null())}
\DoxyCodeLine{21289         \{}
\DoxyCodeLine{21290             m\_type = value\_t::object;}
\DoxyCodeLine{21291             m\_value.\mbox{\hyperlink{classbasic__json_a10aa3ec9e58f6852709913408519c01c}{object}} = create<object\_t>();}
\DoxyCodeLine{21292             assert\_invariant();}
\DoxyCodeLine{21293         \}}
\DoxyCodeLine{21294 }
\DoxyCodeLine{21295         \textcolor{comment}{// operator[] only works for objects}}
\DoxyCodeLine{21296         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{21297         \{}
\DoxyCodeLine{21298             \textcolor{keyword}{auto} result = m\_value.object-\/>emplace(std::move(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}), \textcolor{keyword}{nullptr});}
\DoxyCodeLine{21299             \textcolor{keywordflow}{return} set\_parent(result.first-\/>second);}
\DoxyCodeLine{21300         \}}
\DoxyCodeLine{21301 }
\DoxyCodeLine{21302         JSON\_THROW(type\_error::create(305, detail::concat(\textcolor{stringliteral}{"{}cannot use operator[] with a string argument with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21303     \}}
\DoxyCodeLine{21304 }
\DoxyCodeLine{21307     \mbox{\hyperlink{classbasic__json}{const\_reference}} \mbox{\hyperlink{classbasic__json_af57b78559cad28275bc515bb2a072605}{operator[]}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21308 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21309         \textcolor{comment}{// const operator[] only works for objects}}
\DoxyCodeLine{21310         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{21311         \{}
\DoxyCodeLine{21312             \textcolor{keyword}{auto} it = m\_value.\mbox{\hyperlink{classbasic__json_a10aa3ec9e58f6852709913408519c01c}{object}}-\/>\mbox{\hyperlink{classbasic__json_a8ed11f83edce392fd94659b1102d078e}{find}}(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}});}
\DoxyCodeLine{21313             JSON\_ASSERT(it != m\_value.object-\/>end());}
\DoxyCodeLine{21314             \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{21315         \}}
\DoxyCodeLine{21316 }
\DoxyCodeLine{21317         JSON\_THROW(type\_error::create(305, detail::concat(\textcolor{stringliteral}{"{}cannot use operator[] with a string argument with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21318     \}}
\DoxyCodeLine{21319 }
\DoxyCodeLine{21320     \textcolor{comment}{// these two functions resolve a (const) char * ambiguity affecting Clang and MSVC}}
\DoxyCodeLine{21321     \textcolor{comment}{// (they seemingly cannot be constrained to resolve the ambiguity)}}
\DoxyCodeLine{21322     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{21323     reference operator[](T* \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21324     \{}
\DoxyCodeLine{21325         \textcolor{keywordflow}{return} operator[](\textcolor{keyword}{typename} object\_t::key\_type(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21326     \}}
\DoxyCodeLine{21327 }
\DoxyCodeLine{21328     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{21329     const\_reference operator[](T* \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21330 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21331         \textcolor{keywordflow}{return} operator[](\textcolor{keyword}{typename} object\_t::key\_type(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21332     \}}
\DoxyCodeLine{21333 }
\DoxyCodeLine{21336     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{21337                  detail::is\_usable\_as\_basic\_json\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21338     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_a5a7e1bd642902ec90f118f00d48c024d}{operator[]}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21339     \{}
\DoxyCodeLine{21340         \textcolor{comment}{// implicitly convert null value to an empty object}}
\DoxyCodeLine{21341         \textcolor{keywordflow}{if} (is\_null())}
\DoxyCodeLine{21342         \{}
\DoxyCodeLine{21343             m\_type = value\_t::object;}
\DoxyCodeLine{21344             m\_value.\mbox{\hyperlink{classbasic__json_a10aa3ec9e58f6852709913408519c01c}{object}} = create<object\_t>();}
\DoxyCodeLine{21345             assert\_invariant();}
\DoxyCodeLine{21346         \}}
\DoxyCodeLine{21347 }
\DoxyCodeLine{21348         \textcolor{comment}{// operator[] only works for objects}}
\DoxyCodeLine{21349         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{21350         \{}
\DoxyCodeLine{21351             \textcolor{keyword}{auto} result = m\_value.object-\/>emplace(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}), \textcolor{keyword}{nullptr});}
\DoxyCodeLine{21352             \textcolor{keywordflow}{return} set\_parent(result.first-\/>second);}
\DoxyCodeLine{21353         \}}
\DoxyCodeLine{21354 }
\DoxyCodeLine{21355         JSON\_THROW(type\_error::create(305, detail::concat(\textcolor{stringliteral}{"{}cannot use operator[] with a string argument with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21356     \}}
\DoxyCodeLine{21357 }
\DoxyCodeLine{21360     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{21361                  detail::is\_usable\_as\_basic\_json\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21362     \mbox{\hyperlink{classbasic__json}{const\_reference}} \mbox{\hyperlink{classbasic__json_afb04aaee2ee66a6c822aaad827123314}{operator[]}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21363 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21364         \textcolor{comment}{// const operator[] only works for objects}}
\DoxyCodeLine{21365         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{21366         \{}
\DoxyCodeLine{21367             \textcolor{keyword}{auto} it = m\_value.\mbox{\hyperlink{classbasic__json_a10aa3ec9e58f6852709913408519c01c}{object}}-\/>\mbox{\hyperlink{classbasic__json_a8ed11f83edce392fd94659b1102d078e}{find}}(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21368             JSON\_ASSERT(it != m\_value.object-\/>end());}
\DoxyCodeLine{21369             \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{21370         \}}
\DoxyCodeLine{21371 }
\DoxyCodeLine{21372         JSON\_THROW(type\_error::create(305, detail::concat(\textcolor{stringliteral}{"{}cannot use operator[] with a string argument with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21373     \}}
\DoxyCodeLine{21374 }
\DoxyCodeLine{21375   \textcolor{keyword}{private}:}
\DoxyCodeLine{21376     \textcolor{keyword}{template}<\textcolor{keyword}{typename} KeyType>}
\DoxyCodeLine{21377     \textcolor{keyword}{using }is\_comparable\_with\_object\_key = \mbox{\hyperlink{structdetail_1_1is__comparable}{detail::is\_comparable}} <}
\DoxyCodeLine{21378         object\_comparator\_t, \textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\&, KeyType >;}
\DoxyCodeLine{21379 }
\DoxyCodeLine{21380     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ValueType>}
\DoxyCodeLine{21381     \textcolor{keyword}{using }value\_return\_type = std::conditional <}
\DoxyCodeLine{21382         \mbox{\hyperlink{structdetail_1_1is__c__string}{detail::is\_c\_string\_uncvref<ValueType>::value}},}
\DoxyCodeLine{21383         string\_t, \textcolor{keyword}{typename} std::decay<ValueType>::type >;}
\DoxyCodeLine{21384 }
\DoxyCodeLine{21385   \textcolor{keyword}{public}:}
\DoxyCodeLine{21388     \textcolor{keyword}{template} < \textcolor{keyword}{class }ValueType, detail::enable\_if\_t <}
\DoxyCodeLine{21389                    !\mbox{\hyperlink{structdetail_1_1is__transparent}{detail::is\_transparent<object\_comparator\_t>::value}}}
\DoxyCodeLine{21390                    \&\& \mbox{\hyperlink{structdetail_1_1is__getable}{detail::is\_getable<basic\_json\_t, ValueType>::value}}}
\DoxyCodeLine{21391                    \&\& !std::is\_same<value\_t, detail::uncvref\_t<ValueType>>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21392     ValueType \mbox{\hyperlink{classbasic__json_a3fb507ac4a659d45a9ccdfb67a0646ec}{value}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, \textcolor{keyword}{const} ValueType\& default\_value)\textcolor{keyword}{ const}}
\DoxyCodeLine{21393 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21394         \textcolor{comment}{// value only works for objects}}
\DoxyCodeLine{21395         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{21396         \{}
\DoxyCodeLine{21397             \textcolor{comment}{// if key is found, return value and given default value otherwise}}
\DoxyCodeLine{21398             \textcolor{keyword}{const} \textcolor{keyword}{auto} it = find(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}});}
\DoxyCodeLine{21399             \textcolor{keywordflow}{if} (it != end())}
\DoxyCodeLine{21400             \{}
\DoxyCodeLine{21401                 \textcolor{keywordflow}{return} it-\/>template get<ValueType>();}
\DoxyCodeLine{21402             \}}
\DoxyCodeLine{21403 }
\DoxyCodeLine{21404             \textcolor{keywordflow}{return} default\_value;}
\DoxyCodeLine{21405         \}}
\DoxyCodeLine{21406 }
\DoxyCodeLine{21407         JSON\_THROW(type\_error::create(306, detail::concat(\textcolor{stringliteral}{"{}cannot use value() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21408     \}}
\DoxyCodeLine{21409 }
\DoxyCodeLine{21412     template < class ValueType, class ReturnType = typename value\_return\_type<ValueType>::type,}
\DoxyCodeLine{21413                detail::enable\_if\_t <}
\DoxyCodeLine{21414                    !\mbox{\hyperlink{structdetail_1_1is__transparent}{detail::is\_transparent<object\_comparator\_t>::value}}}
\DoxyCodeLine{21415                    \&\& \mbox{\hyperlink{structdetail_1_1is__getable}{detail::is\_getable<basic\_json\_t, ReturnType>::value}}}
\DoxyCodeLine{21416                    \&\& !std::is\_same<value\_t, detail::uncvref\_t<ValueType>>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21417     ReturnType \mbox{\hyperlink{classbasic__json_a1460a0f28bedca9050f2259ec6bf86e6}{value}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, ValueType \&\& default\_value)\textcolor{keyword}{ const}}
\DoxyCodeLine{21418 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21419         \textcolor{comment}{// value only works for objects}}
\DoxyCodeLine{21420         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{21421         \{}
\DoxyCodeLine{21422             \textcolor{comment}{// if key is found, return value and given default value otherwise}}
\DoxyCodeLine{21423             \textcolor{keyword}{const} \textcolor{keyword}{auto} it = find(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}});}
\DoxyCodeLine{21424             \textcolor{keywordflow}{if} (it != end())}
\DoxyCodeLine{21425             \{}
\DoxyCodeLine{21426                 \textcolor{keywordflow}{return} it-\/>template get<ReturnType>();}
\DoxyCodeLine{21427             \}}
\DoxyCodeLine{21428 }
\DoxyCodeLine{21429             \textcolor{keywordflow}{return} std::forward<ValueType>(default\_value);}
\DoxyCodeLine{21430         \}}
\DoxyCodeLine{21431 }
\DoxyCodeLine{21432         JSON\_THROW(type\_error::create(306, detail::concat(\textcolor{stringliteral}{"{}cannot use value() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21433     \}}
\DoxyCodeLine{21434 }
\DoxyCodeLine{21437     \textcolor{keyword}{template} < \textcolor{keyword}{class }ValueType, \textcolor{keyword}{class }KeyType, detail::enable\_if\_t <}
\DoxyCodeLine{21438                    \mbox{\hyperlink{structdetail_1_1is__transparent}{detail::is\_transparent<object\_comparator\_t>::value}}}
\DoxyCodeLine{21439                    \&\& !\mbox{\hyperlink{structdetail_1_1is__specialization__of}{detail::is\_json\_pointer<KeyType>::value}}}
\DoxyCodeLine{21440                    \&\& is\_comparable\_with\_object\_key<KeyType>::value}
\DoxyCodeLine{21441                    \&\& \mbox{\hyperlink{structdetail_1_1is__getable}{detail::is\_getable<basic\_json\_t, ValueType>::value}}}
\DoxyCodeLine{21442                    \&\& !std::is\_same<value\_t, detail::uncvref\_t<ValueType>>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21443     ValueType \mbox{\hyperlink{classbasic__json_a58469bce489ece80e50e7ed59fa09484}{value}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, \textcolor{keyword}{const} ValueType\& default\_value)\textcolor{keyword}{ const}}
\DoxyCodeLine{21444 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21445         \textcolor{comment}{// value only works for objects}}
\DoxyCodeLine{21446         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{21447         \{}
\DoxyCodeLine{21448             \textcolor{comment}{// if key is found, return value and given default value otherwise}}
\DoxyCodeLine{21449             \textcolor{keyword}{const} \textcolor{keyword}{auto} it = find(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21450             \textcolor{keywordflow}{if} (it != end())}
\DoxyCodeLine{21451             \{}
\DoxyCodeLine{21452                 \textcolor{keywordflow}{return} it-\/>template get<ValueType>();}
\DoxyCodeLine{21453             \}}
\DoxyCodeLine{21454 }
\DoxyCodeLine{21455             \textcolor{keywordflow}{return} default\_value;}
\DoxyCodeLine{21456         \}}
\DoxyCodeLine{21457 }
\DoxyCodeLine{21458         JSON\_THROW(type\_error::create(306, detail::concat(\textcolor{stringliteral}{"{}cannot use value() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21459     \}}
\DoxyCodeLine{21460 }
\DoxyCodeLine{21463     template < class ValueType, class KeyType, class ReturnType = typename value\_return\_type<ValueType>::type,}
\DoxyCodeLine{21464                detail::enable\_if\_t <}
\DoxyCodeLine{21465                    \mbox{\hyperlink{structdetail_1_1is__transparent}{detail::is\_transparent<object\_comparator\_t>::value}}}
\DoxyCodeLine{21466                    \&\& !\mbox{\hyperlink{structdetail_1_1is__specialization__of}{detail::is\_json\_pointer<KeyType>::value}}}
\DoxyCodeLine{21467                    \&\& is\_comparable\_with\_object\_key<KeyType>::value}
\DoxyCodeLine{21468                    \&\& \mbox{\hyperlink{structdetail_1_1is__getable}{detail::is\_getable<basic\_json\_t, ReturnType>::value}}}
\DoxyCodeLine{21469                    \&\& !std::is\_same<value\_t, detail::uncvref\_t<ValueType>>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21470     ReturnType \mbox{\hyperlink{classbasic__json_ac7d24993dea7dcd5442465e43b0554cb}{value}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}, ValueType \&\& default\_value)\textcolor{keyword}{ const}}
\DoxyCodeLine{21471 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21472         \textcolor{comment}{// value only works for objects}}
\DoxyCodeLine{21473         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{21474         \{}
\DoxyCodeLine{21475             \textcolor{comment}{// if key is found, return value and given default value otherwise}}
\DoxyCodeLine{21476             \textcolor{keyword}{const} \textcolor{keyword}{auto} it = find(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21477             \textcolor{keywordflow}{if} (it != end())}
\DoxyCodeLine{21478             \{}
\DoxyCodeLine{21479                 \textcolor{keywordflow}{return} it-\/>template get<ReturnType>();}
\DoxyCodeLine{21480             \}}
\DoxyCodeLine{21481 }
\DoxyCodeLine{21482             \textcolor{keywordflow}{return} std::forward<ValueType>(default\_value);}
\DoxyCodeLine{21483         \}}
\DoxyCodeLine{21484 }
\DoxyCodeLine{21485         JSON\_THROW(type\_error::create(306, detail::concat(\textcolor{stringliteral}{"{}cannot use value() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21486     \}}
\DoxyCodeLine{21487 }
\DoxyCodeLine{21490     \textcolor{keyword}{template} < \textcolor{keyword}{class }ValueType, detail::enable\_if\_t <}
\DoxyCodeLine{21491                    \mbox{\hyperlink{structdetail_1_1is__getable}{detail::is\_getable<basic\_json\_t, ValueType>::value}}}
\DoxyCodeLine{21492                    \&\& !std::is\_same<value\_t, detail::uncvref\_t<ValueType>>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21493     ValueType \mbox{\hyperlink{classbasic__json_a8e07f0a0e66b05e7b77b95f623cbfac1}{value}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& ptr, \textcolor{keyword}{const} ValueType\& default\_value)\textcolor{keyword}{ const}}
\DoxyCodeLine{21494 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21495         \textcolor{comment}{// value only works for objects}}
\DoxyCodeLine{21496         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{21497         \{}
\DoxyCodeLine{21498             \textcolor{comment}{// if pointer resolves a value, return it or use default value}}
\DoxyCodeLine{21499             JSON\_TRY}
\DoxyCodeLine{21500             \{}
\DoxyCodeLine{21501                 \textcolor{keywordflow}{return} ptr.get\_checked(\textcolor{keyword}{this}).template get<ValueType>();}
\DoxyCodeLine{21502             \}}
\DoxyCodeLine{21503             JSON\_INTERNAL\_CATCH (\mbox{\hyperlink{classdetail_1_1out__of__range}{out\_of\_range}}\&)}
\DoxyCodeLine{21504             \{}
\DoxyCodeLine{21505                 \textcolor{keywordflow}{return} default\_value;}
\DoxyCodeLine{21506             \}}
\DoxyCodeLine{21507         \}}
\DoxyCodeLine{21508 }
\DoxyCodeLine{21509         JSON\_THROW(type\_error::create(306, detail::concat(\textcolor{stringliteral}{"{}cannot use value() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21510     \}}
\DoxyCodeLine{21511 }
\DoxyCodeLine{21514     template < class ValueType, class ReturnType = typename value\_return\_type<ValueType>::type,}
\DoxyCodeLine{21515                detail::enable\_if\_t <}
\DoxyCodeLine{21516                    \mbox{\hyperlink{structdetail_1_1is__getable}{detail::is\_getable<basic\_json\_t, ReturnType>::value}}}
\DoxyCodeLine{21517                    \&\& !std::is\_same<value\_t, detail::uncvref\_t<ValueType>>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21518     ReturnType \mbox{\hyperlink{classbasic__json_af435aab4d160572776d7e66c3809e4b1}{value}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& ptr, ValueType \&\& default\_value)\textcolor{keyword}{ const}}
\DoxyCodeLine{21519 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21520         \textcolor{comment}{// value only works for objects}}
\DoxyCodeLine{21521         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{21522         \{}
\DoxyCodeLine{21523             \textcolor{comment}{// if pointer resolves a value, return it or use default value}}
\DoxyCodeLine{21524             JSON\_TRY}
\DoxyCodeLine{21525             \{}
\DoxyCodeLine{21526                 \textcolor{keywordflow}{return} ptr.get\_checked(\textcolor{keyword}{this}).template get<ReturnType>();}
\DoxyCodeLine{21527             \}}
\DoxyCodeLine{21528             JSON\_INTERNAL\_CATCH (\mbox{\hyperlink{classdetail_1_1out__of__range}{out\_of\_range}}\&)}
\DoxyCodeLine{21529             \{}
\DoxyCodeLine{21530                 \textcolor{keywordflow}{return} std::forward<ValueType>(default\_value);}
\DoxyCodeLine{21531             \}}
\DoxyCodeLine{21532         \}}
\DoxyCodeLine{21533 }
\DoxyCodeLine{21534         JSON\_THROW(type\_error::create(306, detail::concat(\textcolor{stringliteral}{"{}cannot use value() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21535     \}}
\DoxyCodeLine{21536 }
\DoxyCodeLine{21537     \textcolor{keyword}{template} < \textcolor{keyword}{class }ValueType, \textcolor{keyword}{class }BasicJsonType, detail::enable\_if\_t <}
\DoxyCodeLine{21538                    \mbox{\hyperlink{structdetail_1_1is__basic__json}{detail::is\_basic\_json<BasicJsonType>::value}}}
\DoxyCodeLine{21539                    \&\& \mbox{\hyperlink{structdetail_1_1is__getable}{detail::is\_getable<basic\_json\_t, ValueType>::value}}}
\DoxyCodeLine{21540                    \&\& !std::is\_same<value\_t, detail::uncvref\_t<ValueType>>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21541     \mbox{\hyperlink{classbasic__json_a29c1ab02ab3b9d508d3aab74f07d12de}{JSON\_HEDLEY\_DEPRECATED\_FOR}}(3.11.0, \mbox{\hyperlink{classbasic__json_a7c7e3533ab09b9e9d24a516379961a93}{basic\_json::json\_pointer}} or nlohmann::json\_pointer<basic\_json::string\_t>) \textcolor{comment}{// NOLINT(readability/alt\_tokens)}}
\DoxyCodeLine{21542     ValueType value(const ::nlohmann::json\_pointer<BasicJsonType>\& ptr, \textcolor{keyword}{const} ValueType\& default\_value)\textcolor{keyword}{ const}}
\DoxyCodeLine{21543 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21544         \textcolor{keywordflow}{return} value(ptr.convert(), default\_value);}
\DoxyCodeLine{21545     \}}
\DoxyCodeLine{21546 }
\DoxyCodeLine{21547     template < class ValueType, class BasicJsonType, class ReturnType = typename value\_return\_type<ValueType>::type,}
\DoxyCodeLine{21548                detail::enable\_if\_t <}
\DoxyCodeLine{21549                    \mbox{\hyperlink{structdetail_1_1is__basic__json}{detail::is\_basic\_json<BasicJsonType>::value}}}
\DoxyCodeLine{21550                    \&\& \mbox{\hyperlink{structdetail_1_1is__getable}{detail::is\_getable<basic\_json\_t, ReturnType>::value}}}
\DoxyCodeLine{21551                    \&\& !std::is\_same<value\_t, detail::uncvref\_t<ValueType>>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21552     JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.0, \mbox{\hyperlink{classbasic__json_a7c7e3533ab09b9e9d24a516379961a93}{basic\_json::json\_pointer}} or nlohmann::json\_pointer<basic\_json::string\_t>) \textcolor{comment}{// NOLINT(readability/alt\_tokens)}}
\DoxyCodeLine{21553     ReturnType value(const ::nlohmann::json\_pointer<BasicJsonType>\& ptr, ValueType \&\& default\_value)\textcolor{keyword}{ const}}
\DoxyCodeLine{21554 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21555         \textcolor{keywordflow}{return} value(ptr.convert(), std::forward<ValueType>(default\_value));}
\DoxyCodeLine{21556     \}}
\DoxyCodeLine{21557 }
\DoxyCodeLine{21560     reference front()}
\DoxyCodeLine{21561     \{}
\DoxyCodeLine{21562         \textcolor{keywordflow}{return} *begin();}
\DoxyCodeLine{21563     \}}
\DoxyCodeLine{21564 }
\DoxyCodeLine{21567     \mbox{\hyperlink{classbasic__json}{const\_reference}} \mbox{\hyperlink{classbasic__json_a85577855985468abef750d5265e23c2a}{front}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{21568 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21569         \textcolor{keywordflow}{return} *cbegin();}
\DoxyCodeLine{21570     \}}
\DoxyCodeLine{21571 }
\DoxyCodeLine{21574     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_adafea743a0a74f86433b8b7cc5bb24bf}{back}}()}
\DoxyCodeLine{21575     \{}
\DoxyCodeLine{21576         \textcolor{keyword}{auto} tmp = end();}
\DoxyCodeLine{21577         -\/-\/tmp;}
\DoxyCodeLine{21578         \textcolor{keywordflow}{return} *tmp;}
\DoxyCodeLine{21579     \}}
\DoxyCodeLine{21580 }
\DoxyCodeLine{21583     \mbox{\hyperlink{classbasic__json}{const\_reference}} \mbox{\hyperlink{classbasic__json_a1bf48c36e00720e01f8f6bbd3df0bf5b}{back}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{21584 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21585         \textcolor{keyword}{auto} tmp = cend();}
\DoxyCodeLine{21586         -\/-\/tmp;}
\DoxyCodeLine{21587         \textcolor{keywordflow}{return} *tmp;}
\DoxyCodeLine{21588     \}}
\DoxyCodeLine{21589 }
\DoxyCodeLine{21592     \textcolor{keyword}{template} < \textcolor{keyword}{class }IteratorType, detail::enable\_if\_t <}
\DoxyCodeLine{21593                    std::is\_same<IteratorType, typename basic\_json\_t::iterator>::value ||}
\DoxyCodeLine{21594                    std::is\_same<IteratorType, typename basic\_json\_t::const\_iterator>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21595     IteratorType \mbox{\hyperlink{classbasic__json_a7a5ed019983b582705ef5ee43d15ca24}{erase}}(IteratorType pos)}
\DoxyCodeLine{21596     \{}
\DoxyCodeLine{21597         \textcolor{comment}{// make sure iterator fits the current value}}
\DoxyCodeLine{21598         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(\textcolor{keyword}{this} != pos.m\_object))}
\DoxyCodeLine{21599         \{}
\DoxyCodeLine{21600             JSON\_THROW(invalid\_iterator::create(202, \textcolor{stringliteral}{"{}iterator does not fit current value"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{21601         \}}
\DoxyCodeLine{21602 }
\DoxyCodeLine{21603         IteratorType result = end();}
\DoxyCodeLine{21604 }
\DoxyCodeLine{21605         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{21606         \{}
\DoxyCodeLine{21607             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{21608             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{21609             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{21610             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{21611             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{21612             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{21613             \{}
\DoxyCodeLine{21614                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!pos.m\_it.primitive\_iterator.is\_begin()))}
\DoxyCodeLine{21615                 \{}
\DoxyCodeLine{21616                     JSON\_THROW(invalid\_iterator::create(205, \textcolor{stringliteral}{"{}iterator out of range"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{21617                 \}}
\DoxyCodeLine{21618 }
\DoxyCodeLine{21619                 \textcolor{keywordflow}{if} (is\_string())}
\DoxyCodeLine{21620                 \{}
\DoxyCodeLine{21621                     AllocatorType<string\_t> alloc;}
\DoxyCodeLine{21622                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::destroy(alloc, m\_value.string);}
\DoxyCodeLine{21623                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::deallocate(alloc, m\_value.string, 1);}
\DoxyCodeLine{21624                     m\_value.string = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{21625                 \}}
\DoxyCodeLine{21626                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (is\_binary())}
\DoxyCodeLine{21627                 \{}
\DoxyCodeLine{21628                     AllocatorType<binary\_t> alloc;}
\DoxyCodeLine{21629                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::destroy(alloc, m\_value.binary);}
\DoxyCodeLine{21630                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::deallocate(alloc, m\_value.binary, 1);}
\DoxyCodeLine{21631                     m\_value.binary = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{21632                 \}}
\DoxyCodeLine{21633 }
\DoxyCodeLine{21634                 m\_type = value\_t::null;}
\DoxyCodeLine{21635                 assert\_invariant();}
\DoxyCodeLine{21636                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{21637             \}}
\DoxyCodeLine{21638 }
\DoxyCodeLine{21639             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{21640             \{}
\DoxyCodeLine{21641                 result.m\_it.object\_iterator = m\_value.object-\/>erase(pos.m\_it.object\_iterator);}
\DoxyCodeLine{21642                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{21643             \}}
\DoxyCodeLine{21644 }
\DoxyCodeLine{21645             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{21646             \{}
\DoxyCodeLine{21647                 result.m\_it.array\_iterator = m\_value.array-\/>erase(pos.m\_it.array\_iterator);}
\DoxyCodeLine{21648                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{21649             \}}
\DoxyCodeLine{21650 }
\DoxyCodeLine{21651             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{21652             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{21653             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{21654                 JSON\_THROW(type\_error::create(307, detail::concat(\textcolor{stringliteral}{"{}cannot use erase() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21655         \}}
\DoxyCodeLine{21656 }
\DoxyCodeLine{21657         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{21658     \}}
\DoxyCodeLine{21659 }
\DoxyCodeLine{21662     \textcolor{keyword}{template} < \textcolor{keyword}{class }IteratorType, detail::enable\_if\_t <}
\DoxyCodeLine{21663                    std::is\_same<IteratorType, typename basic\_json\_t::iterator>::value ||}
\DoxyCodeLine{21664                    std::is\_same<IteratorType, typename basic\_json\_t::const\_iterator>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21665     IteratorType \mbox{\hyperlink{classbasic__json_a151124c5b91ecb1278c7e191053ce9ca}{erase}}(IteratorType first, IteratorType last)}
\DoxyCodeLine{21666     \{}
\DoxyCodeLine{21667         \textcolor{comment}{// make sure iterator fits the current value}}
\DoxyCodeLine{21668         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(\textcolor{keyword}{this} != first.m\_object || \textcolor{keyword}{this} != last.m\_object))}
\DoxyCodeLine{21669         \{}
\DoxyCodeLine{21670             JSON\_THROW(invalid\_iterator::create(203, \textcolor{stringliteral}{"{}iterators do not fit current value"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{21671         \}}
\DoxyCodeLine{21672 }
\DoxyCodeLine{21673         IteratorType result = end();}
\DoxyCodeLine{21674 }
\DoxyCodeLine{21675         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{21676         \{}
\DoxyCodeLine{21677             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{21678             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{21679             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{21680             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{21681             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{21682             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{21683             \{}
\DoxyCodeLine{21684                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(!first.m\_it.primitive\_iterator.is\_begin()}
\DoxyCodeLine{21685                                        || !last.m\_it.primitive\_iterator.is\_end()))}
\DoxyCodeLine{21686                 \{}
\DoxyCodeLine{21687                     JSON\_THROW(invalid\_iterator::create(204, \textcolor{stringliteral}{"{}iterators out of range"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{21688                 \}}
\DoxyCodeLine{21689 }
\DoxyCodeLine{21690                 \textcolor{keywordflow}{if} (is\_string())}
\DoxyCodeLine{21691                 \{}
\DoxyCodeLine{21692                     AllocatorType<string\_t> alloc;}
\DoxyCodeLine{21693                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::destroy(alloc, m\_value.string);}
\DoxyCodeLine{21694                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::deallocate(alloc, m\_value.string, 1);}
\DoxyCodeLine{21695                     m\_value.string = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{21696                 \}}
\DoxyCodeLine{21697                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (is\_binary())}
\DoxyCodeLine{21698                 \{}
\DoxyCodeLine{21699                     AllocatorType<binary\_t> alloc;}
\DoxyCodeLine{21700                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::destroy(alloc, m\_value.binary);}
\DoxyCodeLine{21701                     std::allocator\_traits<\textcolor{keyword}{decltype}(alloc)>::deallocate(alloc, m\_value.binary, 1);}
\DoxyCodeLine{21702                     m\_value.binary = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{21703                 \}}
\DoxyCodeLine{21704 }
\DoxyCodeLine{21705                 m\_type = value\_t::null;}
\DoxyCodeLine{21706                 assert\_invariant();}
\DoxyCodeLine{21707                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{21708             \}}
\DoxyCodeLine{21709 }
\DoxyCodeLine{21710             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{21711             \{}
\DoxyCodeLine{21712                 result.m\_it.object\_iterator = m\_value.object-\/>erase(first.m\_it.object\_iterator,}
\DoxyCodeLine{21713                                               last.m\_it.object\_iterator);}
\DoxyCodeLine{21714                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{21715             \}}
\DoxyCodeLine{21716 }
\DoxyCodeLine{21717             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{21718             \{}
\DoxyCodeLine{21719                 result.m\_it.array\_iterator = m\_value.array-\/>erase(first.m\_it.array\_iterator,}
\DoxyCodeLine{21720                                              last.m\_it.array\_iterator);}
\DoxyCodeLine{21721                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{21722             \}}
\DoxyCodeLine{21723 }
\DoxyCodeLine{21724             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{21725             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{21726             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{21727                 JSON\_THROW(type\_error::create(307, detail::concat(\textcolor{stringliteral}{"{}cannot use erase() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21728         \}}
\DoxyCodeLine{21729 }
\DoxyCodeLine{21730         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{21731     \}}
\DoxyCodeLine{21732 }
\DoxyCodeLine{21733   \textcolor{keyword}{private}:}
\DoxyCodeLine{21734     \textcolor{keyword}{template} < \textcolor{keyword}{typename} KeyType, detail::enable\_if\_t <}
\DoxyCodeLine{21735                    detail::has\_erase\_with\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21736     size\_type erase\_internal(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21737     \{}
\DoxyCodeLine{21738         \textcolor{comment}{// this erase only works for objects}}
\DoxyCodeLine{21739         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!is\_object()))}
\DoxyCodeLine{21740         \{}
\DoxyCodeLine{21741             JSON\_THROW(type\_error::create(307, detail::concat(\textcolor{stringliteral}{"{}cannot use erase() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21742         \}}
\DoxyCodeLine{21743 }
\DoxyCodeLine{21744         \textcolor{keywordflow}{return} m\_value.object-\/>erase(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21745     \}}
\DoxyCodeLine{21746 }
\DoxyCodeLine{21747     \textcolor{keyword}{template} < \textcolor{keyword}{typename} KeyType, detail::enable\_if\_t <}
\DoxyCodeLine{21748                    !detail::has\_erase\_with\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int} > = 0 >}
\DoxyCodeLine{21749     size\_type erase\_internal(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21750     \{}
\DoxyCodeLine{21751         \textcolor{comment}{// this erase only works for objects}}
\DoxyCodeLine{21752         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!is\_object()))}
\DoxyCodeLine{21753         \{}
\DoxyCodeLine{21754             JSON\_THROW(type\_error::create(307, detail::concat(\textcolor{stringliteral}{"{}cannot use erase() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21755         \}}
\DoxyCodeLine{21756 }
\DoxyCodeLine{21757         \textcolor{keyword}{const} \textcolor{keyword}{auto} it = m\_value.object-\/>find(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21758         \textcolor{keywordflow}{if} (it != m\_value.object-\/>end())}
\DoxyCodeLine{21759         \{}
\DoxyCodeLine{21760             m\_value.object-\/>erase(it);}
\DoxyCodeLine{21761             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{21762         \}}
\DoxyCodeLine{21763         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{21764     \}}
\DoxyCodeLine{21765 }
\DoxyCodeLine{21766   \textcolor{keyword}{public}:}
\DoxyCodeLine{21767 }
\DoxyCodeLine{21770     \mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} \mbox{\hyperlink{classbasic__json_a8d29d171d8941523a937bb6b5132b5a7}{erase}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21771     \{}
\DoxyCodeLine{21772         \textcolor{comment}{// the indirection via erase\_internal() is added to avoid making this}}
\DoxyCodeLine{21773         \textcolor{comment}{// function a template and thus de-\/rank it during overload resolution}}
\DoxyCodeLine{21774         \textcolor{keywordflow}{return} erase\_internal(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}});}
\DoxyCodeLine{21775     \}}
\DoxyCodeLine{21776 }
\DoxyCodeLine{21779     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{21780                  detail::is\_usable\_as\_basic\_json\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{21781     \mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} \mbox{\hyperlink{classbasic__json_a3054e673f67fa325fbdcd0bf73d03c7b}{erase}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21782     \{}
\DoxyCodeLine{21783         \textcolor{keywordflow}{return} erase\_internal(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21784     \}}
\DoxyCodeLine{21785 }
\DoxyCodeLine{21788     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a0e480e9d2391485c79747bb756628f61}{erase}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} idx)}
\DoxyCodeLine{21789     \{}
\DoxyCodeLine{21790         \textcolor{comment}{// this erase only works for arrays}}
\DoxyCodeLine{21791         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_array()))}
\DoxyCodeLine{21792         \{}
\DoxyCodeLine{21793             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(idx >= size()))}
\DoxyCodeLine{21794             \{}
\DoxyCodeLine{21795                 JSON\_THROW(out\_of\_range::create(401, detail::concat(\textcolor{stringliteral}{"{}array index "{}}, std::to\_string(idx), \textcolor{stringliteral}{"{} is out of range"{}}), \textcolor{keyword}{this}));}
\DoxyCodeLine{21796             \}}
\DoxyCodeLine{21797 }
\DoxyCodeLine{21798             m\_value.array-\/>erase(m\_value.array-\/>begin() + \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classbasic__json_a2fe32d636c1b78861884dde9716b22b6}{difference\_type}}\textcolor{keyword}{>}(idx));}
\DoxyCodeLine{21799         \}}
\DoxyCodeLine{21800         \textcolor{keywordflow}{else}}
\DoxyCodeLine{21801         \{}
\DoxyCodeLine{21802             JSON\_THROW(type\_error::create(307, detail::concat(\textcolor{stringliteral}{"{}cannot use erase() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{21803         \}}
\DoxyCodeLine{21804     \}}
\DoxyCodeLine{21805 }
\DoxyCodeLine{21807 }
\DoxyCodeLine{21808 }
\DoxyCodeLine{21810     \textcolor{comment}{// lookup //}}
\DoxyCodeLine{21812 \textcolor{comment}{}}
\DoxyCodeLine{21815 }
\DoxyCodeLine{21818     \mbox{\hyperlink{classbasic__json_a2935c91b82c8e586b1dd68ad665075a6}{iterator}} \mbox{\hyperlink{classbasic__json_a8ed11f83edce392fd94659b1102d078e}{find}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21819     \{}
\DoxyCodeLine{21820         \textcolor{keyword}{auto} result = end();}
\DoxyCodeLine{21821 }
\DoxyCodeLine{21822         \textcolor{keywordflow}{if} (is\_object())}
\DoxyCodeLine{21823         \{}
\DoxyCodeLine{21824             result.m\_it.object\_iterator = m\_value.object-\/>find(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}});}
\DoxyCodeLine{21825         \}}
\DoxyCodeLine{21826 }
\DoxyCodeLine{21827         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{21828     \}}
\DoxyCodeLine{21829 }
\DoxyCodeLine{21832     \mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} \mbox{\hyperlink{classbasic__json_a8d8085b05e9a2e6f187708bca5e22d04}{find}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21833 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21834         \textcolor{keyword}{auto} result = cend();}
\DoxyCodeLine{21835 }
\DoxyCodeLine{21836         \textcolor{keywordflow}{if} (is\_object())}
\DoxyCodeLine{21837         \{}
\DoxyCodeLine{21838             result.m\_it.object\_iterator = m\_value.object-\/>find(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}});}
\DoxyCodeLine{21839         \}}
\DoxyCodeLine{21840 }
\DoxyCodeLine{21841         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{21842     \}}
\DoxyCodeLine{21843 }
\DoxyCodeLine{21846     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{21847                  detail::is\_usable\_as\_basic\_json\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{21848     \mbox{\hyperlink{classbasic__json_a2935c91b82c8e586b1dd68ad665075a6}{iterator}} \mbox{\hyperlink{classbasic__json_a81e01eb7be2878873ba084c0a0b20442}{find}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})}
\DoxyCodeLine{21849     \{}
\DoxyCodeLine{21850         \textcolor{keyword}{auto} result = end();}
\DoxyCodeLine{21851 }
\DoxyCodeLine{21852         \textcolor{keywordflow}{if} (is\_object())}
\DoxyCodeLine{21853         \{}
\DoxyCodeLine{21854             result.m\_it.object\_iterator = m\_value.object-\/>find(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21855         \}}
\DoxyCodeLine{21856 }
\DoxyCodeLine{21857         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{21858     \}}
\DoxyCodeLine{21859 }
\DoxyCodeLine{21862     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{21863                  detail::is\_usable\_as\_basic\_json\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{21864     \mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} \mbox{\hyperlink{classbasic__json_a42890814a18f9c593f69218706113474}{find}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21865 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21866         \textcolor{keyword}{auto} result = cend();}
\DoxyCodeLine{21867 }
\DoxyCodeLine{21868         \textcolor{keywordflow}{if} (is\_object())}
\DoxyCodeLine{21869         \{}
\DoxyCodeLine{21870             result.m\_it.object\_iterator = m\_value.object-\/>find(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}));}
\DoxyCodeLine{21871         \}}
\DoxyCodeLine{21872 }
\DoxyCodeLine{21873         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{21874     \}}
\DoxyCodeLine{21875 }
\DoxyCodeLine{21878     \mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} \mbox{\hyperlink{classbasic__json_ac122e03d4d28d6a03c01abaa7229d4c7}{count}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21879 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21880         \textcolor{comment}{// return 0 for all nonobject types}}
\DoxyCodeLine{21881         \textcolor{keywordflow}{return} is\_object() ? m\_value.object-\/>count(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}) : 0;}
\DoxyCodeLine{21882     \}}
\DoxyCodeLine{21883 }
\DoxyCodeLine{21886     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{21887                  detail::is\_usable\_as\_basic\_json\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{21888     \mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} \mbox{\hyperlink{classbasic__json_a06e36a368cbf554fc817b0cb3e37e3a3}{count}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21889 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21890         \textcolor{comment}{// return 0 for all nonobject types}}
\DoxyCodeLine{21891         \textcolor{keywordflow}{return} is\_object() ? m\_value.object-\/>count(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})) : 0;}
\DoxyCodeLine{21892     \}}
\DoxyCodeLine{21893 }
\DoxyCodeLine{21896     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_a3815a53b61818c87cf677f4a1ea5b7e8}{contains}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::key\_type\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21897 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21898         \textcolor{keywordflow}{return} is\_object() \&\& m\_value.object-\/>find(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}) != m\_value.object-\/>end();}
\DoxyCodeLine{21899     \}}
\DoxyCodeLine{21900 }
\DoxyCodeLine{21903     \textcolor{keyword}{template}<\textcolor{keyword}{class }KeyType, detail::enable\_if\_t<}
\DoxyCodeLine{21904                  detail::is\_usable\_as\_basic\_json\_key\_type<basic\_json\_t, KeyType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{21905     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_a56dbcc61c27689659fa1d94a19bd2560}{contains}}(KeyType \&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})\textcolor{keyword}{ const}}
\DoxyCodeLine{21906 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21907         \textcolor{keywordflow}{return} is\_object() \&\& m\_value.object-\/>find(std::forward<KeyType>(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}})) != m\_value.object-\/>end();}
\DoxyCodeLine{21908     \}}
\DoxyCodeLine{21909 }
\DoxyCodeLine{21912     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classbasic__json_a0d7241e94ede5aacd7efca401cf0638a}{contains}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{21913 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21914         \textcolor{keywordflow}{return} ptr.contains(\textcolor{keyword}{this});}
\DoxyCodeLine{21915     \}}
\DoxyCodeLine{21916 }
\DoxyCodeLine{21917     template<typename BasicJsonType, detail::enable\_if\_t<detail::is\_basic\_json<BasicJsonType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{21918     JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.0, \mbox{\hyperlink{classbasic__json_a7c7e3533ab09b9e9d24a516379961a93}{basic\_json::json\_pointer}} or nlohmann::json\_pointer<basic\_json::string\_t>) \textcolor{comment}{// NOLINT(readability/alt\_tokens)}}
\DoxyCodeLine{21919     \textcolor{keywordtype}{bool} contains(\textcolor{keyword}{const} typename ::nlohmann::json\_pointer<BasicJsonType>\& ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{21920 \textcolor{keyword}{    }\{}
\DoxyCodeLine{21921         \textcolor{keywordflow}{return} ptr.contains(\textcolor{keyword}{this});}
\DoxyCodeLine{21922     \}}
\DoxyCodeLine{21923 }
\DoxyCodeLine{21925 }
\DoxyCodeLine{21926 }
\DoxyCodeLine{21928     \textcolor{comment}{// iterators //}}
\DoxyCodeLine{21930 \textcolor{comment}{}}
\DoxyCodeLine{21933 }
\DoxyCodeLine{21936     iterator begin() noexcept}
\DoxyCodeLine{21937     \{}
\DoxyCodeLine{21938         iterator result(\textcolor{keyword}{this});}
\DoxyCodeLine{21939         result.set\_begin();}
\DoxyCodeLine{21940         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{21941     \}}
\DoxyCodeLine{21942 }
\DoxyCodeLine{21945     const\_iterator begin() const noexcept}
\DoxyCodeLine{21946     \{}
\DoxyCodeLine{21947         \textcolor{keywordflow}{return} cbegin();}
\DoxyCodeLine{21948     \}}
\DoxyCodeLine{21949 }
\DoxyCodeLine{21952     const\_iterator cbegin() const noexcept}
\DoxyCodeLine{21953     \{}
\DoxyCodeLine{21954         const\_iterator result(\textcolor{keyword}{this});}
\DoxyCodeLine{21955         result.set\_begin();}
\DoxyCodeLine{21956         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{21957     \}}
\DoxyCodeLine{21958 }
\DoxyCodeLine{21961     iterator end() noexcept}
\DoxyCodeLine{21962     \{}
\DoxyCodeLine{21963         iterator result(\textcolor{keyword}{this});}
\DoxyCodeLine{21964         result.set\_end();}
\DoxyCodeLine{21965         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{21966     \}}
\DoxyCodeLine{21967 }
\DoxyCodeLine{21970     const\_iterator end() const noexcept}
\DoxyCodeLine{21971     \{}
\DoxyCodeLine{21972         \textcolor{keywordflow}{return} cend();}
\DoxyCodeLine{21973     \}}
\DoxyCodeLine{21974 }
\DoxyCodeLine{21977     const\_iterator cend() const noexcept}
\DoxyCodeLine{21978     \{}
\DoxyCodeLine{21979         const\_iterator result(\textcolor{keyword}{this});}
\DoxyCodeLine{21980         result.set\_end();}
\DoxyCodeLine{21981         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{21982     \}}
\DoxyCodeLine{21983 }
\DoxyCodeLine{21986     reverse\_iterator rbegin() noexcept}
\DoxyCodeLine{21987     \{}
\DoxyCodeLine{21988         \textcolor{keywordflow}{return} reverse\_iterator(end());}
\DoxyCodeLine{21989     \}}
\DoxyCodeLine{21990 }
\DoxyCodeLine{21993     const\_reverse\_iterator rbegin() const noexcept}
\DoxyCodeLine{21994     \{}
\DoxyCodeLine{21995         \textcolor{keywordflow}{return} crbegin();}
\DoxyCodeLine{21996     \}}
\DoxyCodeLine{21997 }
\DoxyCodeLine{22000     reverse\_iterator rend() noexcept}
\DoxyCodeLine{22001     \{}
\DoxyCodeLine{22002         \textcolor{keywordflow}{return} reverse\_iterator(begin());}
\DoxyCodeLine{22003     \}}
\DoxyCodeLine{22004 }
\DoxyCodeLine{22007     const\_reverse\_iterator rend() const noexcept}
\DoxyCodeLine{22008     \{}
\DoxyCodeLine{22009         \textcolor{keywordflow}{return} crend();}
\DoxyCodeLine{22010     \}}
\DoxyCodeLine{22011 }
\DoxyCodeLine{22014     const\_reverse\_iterator crbegin() const noexcept}
\DoxyCodeLine{22015     \{}
\DoxyCodeLine{22016         \textcolor{keywordflow}{return} const\_reverse\_iterator(cend());}
\DoxyCodeLine{22017     \}}
\DoxyCodeLine{22018 }
\DoxyCodeLine{22021     const\_reverse\_iterator crend() const noexcept}
\DoxyCodeLine{22022     \{}
\DoxyCodeLine{22023         \textcolor{keywordflow}{return} const\_reverse\_iterator(cbegin());}
\DoxyCodeLine{22024     \}}
\DoxyCodeLine{22025 }
\DoxyCodeLine{22026   \textcolor{keyword}{public}:}
\DoxyCodeLine{22032     JSON\_HEDLEY\_DEPRECATED\_FOR(3.1.0, items())}
\DoxyCodeLine{22033     static iteration\_proxy<iterator> iterator\_wrapper(reference ref) noexcept}
\DoxyCodeLine{22034     \{}
\DoxyCodeLine{22035         \textcolor{keywordflow}{return} ref.items();}
\DoxyCodeLine{22036     \}}
\DoxyCodeLine{22037 }
\DoxyCodeLine{22043     JSON\_HEDLEY\_DEPRECATED\_FOR(3.1.0, items())}
\DoxyCodeLine{22044     static iteration\_proxy<const\_iterator> iterator\_wrapper(const\_reference ref) noexcept}
\DoxyCodeLine{22045     \{}
\DoxyCodeLine{22046         \textcolor{keywordflow}{return} ref.items();}
\DoxyCodeLine{22047     \}}
\DoxyCodeLine{22048 }
\DoxyCodeLine{22051     iteration\_proxy<iterator> items() noexcept}
\DoxyCodeLine{22052     \{}
\DoxyCodeLine{22053         \textcolor{keywordflow}{return} iteration\_proxy<iterator>(*\textcolor{keyword}{this});}
\DoxyCodeLine{22054     \}}
\DoxyCodeLine{22055 }
\DoxyCodeLine{22058     iteration\_proxy<const\_iterator> items() const noexcept}
\DoxyCodeLine{22059     \{}
\DoxyCodeLine{22060         \textcolor{keywordflow}{return} iteration\_proxy<const\_iterator>(*\textcolor{keyword}{this});}
\DoxyCodeLine{22061     \}}
\DoxyCodeLine{22062 }
\DoxyCodeLine{22064 }
\DoxyCodeLine{22065 }
\DoxyCodeLine{22067     \textcolor{comment}{// capacity //}}
\DoxyCodeLine{22069 \textcolor{comment}{}}
\DoxyCodeLine{22072 }
\DoxyCodeLine{22075     \textcolor{keywordtype}{bool} empty() const noexcept}
\DoxyCodeLine{22076     \{}
\DoxyCodeLine{22077         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{22078         \{}
\DoxyCodeLine{22079             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{22080             \{}
\DoxyCodeLine{22081                 \textcolor{comment}{// null values are empty}}
\DoxyCodeLine{22082                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{22083             \}}
\DoxyCodeLine{22084 }
\DoxyCodeLine{22085             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{22086             \{}
\DoxyCodeLine{22087                 \textcolor{comment}{// delegate call to array\_t::empty()}}
\DoxyCodeLine{22088                 \textcolor{keywordflow}{return} m\_value.array-\/>empty();}
\DoxyCodeLine{22089             \}}
\DoxyCodeLine{22090 }
\DoxyCodeLine{22091             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{22092             \{}
\DoxyCodeLine{22093                 \textcolor{comment}{// delegate call to object\_t::empty()}}
\DoxyCodeLine{22094                 \textcolor{keywordflow}{return} m\_value.object-\/>empty();}
\DoxyCodeLine{22095             \}}
\DoxyCodeLine{22096 }
\DoxyCodeLine{22097             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{22098             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{22099             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{22100             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{22101             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{22102             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{22103             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{22104             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{22105             \{}
\DoxyCodeLine{22106                 \textcolor{comment}{// all other types are nonempty}}
\DoxyCodeLine{22107                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{22108             \}}
\DoxyCodeLine{22109         \}}
\DoxyCodeLine{22110     \}}
\DoxyCodeLine{22111 }
\DoxyCodeLine{22114     size\_type size() const noexcept}
\DoxyCodeLine{22115     \{}
\DoxyCodeLine{22116         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{22117         \{}
\DoxyCodeLine{22118             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{22119             \{}
\DoxyCodeLine{22120                 \textcolor{comment}{// null values are empty}}
\DoxyCodeLine{22121                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{22122             \}}
\DoxyCodeLine{22123 }
\DoxyCodeLine{22124             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{22125             \{}
\DoxyCodeLine{22126                 \textcolor{comment}{// delegate call to array\_t::size()}}
\DoxyCodeLine{22127                 \textcolor{keywordflow}{return} m\_value.array-\/>size();}
\DoxyCodeLine{22128             \}}
\DoxyCodeLine{22129 }
\DoxyCodeLine{22130             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{22131             \{}
\DoxyCodeLine{22132                 \textcolor{comment}{// delegate call to object\_t::size()}}
\DoxyCodeLine{22133                 \textcolor{keywordflow}{return} m\_value.object-\/>size();}
\DoxyCodeLine{22134             \}}
\DoxyCodeLine{22135 }
\DoxyCodeLine{22136             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{22137             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{22138             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{22139             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{22140             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{22141             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{22142             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{22143             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{22144             \{}
\DoxyCodeLine{22145                 \textcolor{comment}{// all other types have size 1}}
\DoxyCodeLine{22146                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{22147             \}}
\DoxyCodeLine{22148         \}}
\DoxyCodeLine{22149     \}}
\DoxyCodeLine{22150 }
\DoxyCodeLine{22153     size\_type max\_size() const noexcept}
\DoxyCodeLine{22154     \{}
\DoxyCodeLine{22155         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{22156         \{}
\DoxyCodeLine{22157             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{22158             \{}
\DoxyCodeLine{22159                 \textcolor{comment}{// delegate call to array\_t::max\_size()}}
\DoxyCodeLine{22160                 \textcolor{keywordflow}{return} m\_value.array-\/>max\_size();}
\DoxyCodeLine{22161             \}}
\DoxyCodeLine{22162 }
\DoxyCodeLine{22163             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{22164             \{}
\DoxyCodeLine{22165                 \textcolor{comment}{// delegate call to object\_t::max\_size()}}
\DoxyCodeLine{22166                 \textcolor{keywordflow}{return} m\_value.object-\/>max\_size();}
\DoxyCodeLine{22167             \}}
\DoxyCodeLine{22168 }
\DoxyCodeLine{22169             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{22170             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{22171             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{22172             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{22173             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{22174             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{22175             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{22176             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{22177             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{22178             \{}
\DoxyCodeLine{22179                 \textcolor{comment}{// all other types have max\_size() == size()}}
\DoxyCodeLine{22180                 \textcolor{keywordflow}{return} size();}
\DoxyCodeLine{22181             \}}
\DoxyCodeLine{22182         \}}
\DoxyCodeLine{22183     \}}
\DoxyCodeLine{22184 }
\DoxyCodeLine{22186 }
\DoxyCodeLine{22187 }
\DoxyCodeLine{22189     \textcolor{comment}{// modifiers //}}
\DoxyCodeLine{22191 \textcolor{comment}{}}
\DoxyCodeLine{22194 }
\DoxyCodeLine{22197     \textcolor{keywordtype}{void} clear() noexcept}
\DoxyCodeLine{22198     \{}
\DoxyCodeLine{22199         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{22200         \{}
\DoxyCodeLine{22201             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{22202             \{}
\DoxyCodeLine{22203                 m\_value.number\_integer = 0;}
\DoxyCodeLine{22204                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{22205             \}}
\DoxyCodeLine{22206 }
\DoxyCodeLine{22207             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{22208             \{}
\DoxyCodeLine{22209                 m\_value.number\_unsigned = 0;}
\DoxyCodeLine{22210                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{22211             \}}
\DoxyCodeLine{22212 }
\DoxyCodeLine{22213             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{22214             \{}
\DoxyCodeLine{22215                 m\_value.number\_float = 0.0;}
\DoxyCodeLine{22216                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{22217             \}}
\DoxyCodeLine{22218 }
\DoxyCodeLine{22219             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{22220             \{}
\DoxyCodeLine{22221                 m\_value.boolean = \textcolor{keyword}{false};}
\DoxyCodeLine{22222                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{22223             \}}
\DoxyCodeLine{22224 }
\DoxyCodeLine{22225             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{22226             \{}
\DoxyCodeLine{22227                 m\_value.string-\/>clear();}
\DoxyCodeLine{22228                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{22229             \}}
\DoxyCodeLine{22230 }
\DoxyCodeLine{22231             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{22232             \{}
\DoxyCodeLine{22233                 m\_value.binary-\/>clear();}
\DoxyCodeLine{22234                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{22235             \}}
\DoxyCodeLine{22236 }
\DoxyCodeLine{22237             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{22238             \{}
\DoxyCodeLine{22239                 m\_value.array-\/>clear();}
\DoxyCodeLine{22240                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{22241             \}}
\DoxyCodeLine{22242 }
\DoxyCodeLine{22243             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{22244             \{}
\DoxyCodeLine{22245                 m\_value.object-\/>clear();}
\DoxyCodeLine{22246                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{22247             \}}
\DoxyCodeLine{22248 }
\DoxyCodeLine{22249             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{22250             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{22251             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{22252                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{22253         \}}
\DoxyCodeLine{22254     \}}
\DoxyCodeLine{22255 }
\DoxyCodeLine{22258     \textcolor{keywordtype}{void} push\_back(\mbox{\hyperlink{classbasic__json}{basic\_json}}\&\& val)}
\DoxyCodeLine{22259     \{}
\DoxyCodeLine{22260         \textcolor{comment}{// push\_back only works for null objects or arrays}}
\DoxyCodeLine{22261         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(is\_null() || is\_array())))}
\DoxyCodeLine{22262         \{}
\DoxyCodeLine{22263             JSON\_THROW(type\_error::create(308, detail::concat(\textcolor{stringliteral}{"{}cannot use push\_back() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22264         \}}
\DoxyCodeLine{22265 }
\DoxyCodeLine{22266         \textcolor{comment}{// transform null object into an array}}
\DoxyCodeLine{22267         \textcolor{keywordflow}{if} (is\_null())}
\DoxyCodeLine{22268         \{}
\DoxyCodeLine{22269             m\_type = value\_t::array;}
\DoxyCodeLine{22270             m\_value = value\_t::array;}
\DoxyCodeLine{22271             assert\_invariant();}
\DoxyCodeLine{22272         \}}
\DoxyCodeLine{22273 }
\DoxyCodeLine{22274         \textcolor{comment}{// add element to array (move semantics)}}
\DoxyCodeLine{22275         \textcolor{keyword}{const} \textcolor{keyword}{auto} old\_capacity = m\_value.array-\/>capacity();}
\DoxyCodeLine{22276         m\_value.array-\/>push\_back(std::move(val));}
\DoxyCodeLine{22277         set\_parent(m\_value.array-\/>back(), old\_capacity);}
\DoxyCodeLine{22278         \textcolor{comment}{// if val is moved from, basic\_json move constructor marks it null, so we do not call the destructor}}
\DoxyCodeLine{22279     \}}
\DoxyCodeLine{22280 }
\DoxyCodeLine{22283     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_a042aa42f535d1dbf2176d159fd3d96eb}{operator+=}}(\mbox{\hyperlink{classbasic__json}{basic\_json}}\&\& val)}
\DoxyCodeLine{22284     \{}
\DoxyCodeLine{22285         push\_back(std::move(val));}
\DoxyCodeLine{22286         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{22287     \}}
\DoxyCodeLine{22288 }
\DoxyCodeLine{22291     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a102e459f1d163cea963ed6fdda595cd3}{push\_back}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& val)}
\DoxyCodeLine{22292     \{}
\DoxyCodeLine{22293         \textcolor{comment}{// push\_back only works for null objects or arrays}}
\DoxyCodeLine{22294         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(is\_null() || is\_array())))}
\DoxyCodeLine{22295         \{}
\DoxyCodeLine{22296             JSON\_THROW(type\_error::create(308, detail::concat(\textcolor{stringliteral}{"{}cannot use push\_back() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22297         \}}
\DoxyCodeLine{22298 }
\DoxyCodeLine{22299         \textcolor{comment}{// transform null object into an array}}
\DoxyCodeLine{22300         \textcolor{keywordflow}{if} (is\_null())}
\DoxyCodeLine{22301         \{}
\DoxyCodeLine{22302             m\_type = value\_t::array;}
\DoxyCodeLine{22303             m\_value = value\_t::array;}
\DoxyCodeLine{22304             assert\_invariant();}
\DoxyCodeLine{22305         \}}
\DoxyCodeLine{22306 }
\DoxyCodeLine{22307         \textcolor{comment}{// add element to array}}
\DoxyCodeLine{22308         \textcolor{keyword}{const} \textcolor{keyword}{auto} old\_capacity = m\_value.array-\/>capacity();}
\DoxyCodeLine{22309         m\_value.array-\/>push\_back(val);}
\DoxyCodeLine{22310         set\_parent(m\_value.array-\/>back(), old\_capacity);}
\DoxyCodeLine{22311     \}}
\DoxyCodeLine{22312 }
\DoxyCodeLine{22315     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_afbbf3e602301f1b9fc81c445c8f3bd1a}{operator+=}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& val)}
\DoxyCodeLine{22316     \{}
\DoxyCodeLine{22317         push\_back(val);}
\DoxyCodeLine{22318         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{22319     \}}
\DoxyCodeLine{22320 }
\DoxyCodeLine{22323     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a4efb88d640b634b77af5825321e6c4ba}{push\_back}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::value\_type\& val)}
\DoxyCodeLine{22324     \{}
\DoxyCodeLine{22325         \textcolor{comment}{// push\_back only works for null objects or objects}}
\DoxyCodeLine{22326         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(is\_null() || is\_object())))}
\DoxyCodeLine{22327         \{}
\DoxyCodeLine{22328             JSON\_THROW(type\_error::create(308, detail::concat(\textcolor{stringliteral}{"{}cannot use push\_back() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22329         \}}
\DoxyCodeLine{22330 }
\DoxyCodeLine{22331         \textcolor{comment}{// transform null object into an object}}
\DoxyCodeLine{22332         \textcolor{keywordflow}{if} (is\_null())}
\DoxyCodeLine{22333         \{}
\DoxyCodeLine{22334             m\_type = value\_t::object;}
\DoxyCodeLine{22335             m\_value = value\_t::object;}
\DoxyCodeLine{22336             assert\_invariant();}
\DoxyCodeLine{22337         \}}
\DoxyCodeLine{22338 }
\DoxyCodeLine{22339         \textcolor{comment}{// add element to object}}
\DoxyCodeLine{22340         \textcolor{keyword}{auto} res = m\_value.object-\/>insert(val);}
\DoxyCodeLine{22341         set\_parent(res.first-\/>second);}
\DoxyCodeLine{22342     \}}
\DoxyCodeLine{22343 }
\DoxyCodeLine{22346     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_a024a7d334069a60f8cb95c3f858fc9e6}{operator+=}}(\textcolor{keyword}{const} \textcolor{keyword}{typename} object\_t::value\_type\& val)}
\DoxyCodeLine{22347     \{}
\DoxyCodeLine{22348         push\_back(val);}
\DoxyCodeLine{22349         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{22350     \}}
\DoxyCodeLine{22351 }
\DoxyCodeLine{22354     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_adabd8c4eea861419dc2629610a922e97}{push\_back}}(\mbox{\hyperlink{classbasic__json_a2063ed828cd027216c549ac48527a562}{initializer\_list\_t}} init)}
\DoxyCodeLine{22355     \{}
\DoxyCodeLine{22356         \textcolor{keywordflow}{if} (is\_object() \&\& init.size() == 2 \&\& (*init.begin())-\/>is\_string())}
\DoxyCodeLine{22357         \{}
\DoxyCodeLine{22358             \mbox{\hyperlink{classbasic__json}{basic\_json}}\&\& \mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}} = init.begin()-\/>moved\_or\_copied();}
\DoxyCodeLine{22359             push\_back(\textcolor{keyword}{typename} object\_t::value\_type(}
\DoxyCodeLine{22360                           std::move(\mbox{\hyperlink{structjson__sax_a3355ecd7e3e9806dcb80b2f8842b82ce}{key}}.get\_ref<\mbox{\hyperlink{classbasic__json_a807932caebf0d62abc8642b9d1a2e5ef}{string\_t}}\&>()), (init.begin() + 1)-\/>moved\_or\_copied()));}
\DoxyCodeLine{22361         \}}
\DoxyCodeLine{22362         \textcolor{keywordflow}{else}}
\DoxyCodeLine{22363         \{}
\DoxyCodeLine{22364             push\_back(\mbox{\hyperlink{classbasic__json}{basic\_json}}(init));}
\DoxyCodeLine{22365         \}}
\DoxyCodeLine{22366     \}}
\DoxyCodeLine{22367 }
\DoxyCodeLine{22370     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_ae3350669b0628bf54a4771512a55f135}{operator+=}}(\mbox{\hyperlink{classbasic__json_a2063ed828cd027216c549ac48527a562}{initializer\_list\_t}} init)}
\DoxyCodeLine{22371     \{}
\DoxyCodeLine{22372         push\_back(init);}
\DoxyCodeLine{22373         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{22374     \}}
\DoxyCodeLine{22375 }
\DoxyCodeLine{22378     \textcolor{keyword}{template}<\textcolor{keyword}{class}... Args>}
\DoxyCodeLine{22379     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_a7ad89dd8715111483428ecf8534b9393}{emplace\_back}}(Args\&\& ... args)}
\DoxyCodeLine{22380     \{}
\DoxyCodeLine{22381         \textcolor{comment}{// emplace\_back only works for null objects or arrays}}
\DoxyCodeLine{22382         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(is\_null() || is\_array())))}
\DoxyCodeLine{22383         \{}
\DoxyCodeLine{22384             JSON\_THROW(type\_error::create(311, detail::concat(\textcolor{stringliteral}{"{}cannot use emplace\_back() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22385         \}}
\DoxyCodeLine{22386 }
\DoxyCodeLine{22387         \textcolor{comment}{// transform null object into an array}}
\DoxyCodeLine{22388         \textcolor{keywordflow}{if} (is\_null())}
\DoxyCodeLine{22389         \{}
\DoxyCodeLine{22390             m\_type = value\_t::array;}
\DoxyCodeLine{22391             m\_value = value\_t::array;}
\DoxyCodeLine{22392             assert\_invariant();}
\DoxyCodeLine{22393         \}}
\DoxyCodeLine{22394 }
\DoxyCodeLine{22395         \textcolor{comment}{// add element to array (perfect forwarding)}}
\DoxyCodeLine{22396         \textcolor{keyword}{const} \textcolor{keyword}{auto} old\_capacity = m\_value.array-\/>capacity();}
\DoxyCodeLine{22397         m\_value.array-\/>emplace\_back(std::forward<Args>(args)...);}
\DoxyCodeLine{22398         \textcolor{keywordflow}{return} set\_parent(m\_value.array-\/>back(), old\_capacity);}
\DoxyCodeLine{22399     \}}
\DoxyCodeLine{22400 }
\DoxyCodeLine{22403     \textcolor{keyword}{template}<\textcolor{keyword}{class}... Args>}
\DoxyCodeLine{22404     std::pair<iterator, bool> \mbox{\hyperlink{classbasic__json_a3e70795da670f11ad7925407d0a7d83c}{emplace}}(Args\&\& ... args)}
\DoxyCodeLine{22405     \{}
\DoxyCodeLine{22406         \textcolor{comment}{// emplace only works for null objects or arrays}}
\DoxyCodeLine{22407         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!(is\_null() || is\_object())))}
\DoxyCodeLine{22408         \{}
\DoxyCodeLine{22409             JSON\_THROW(type\_error::create(311, detail::concat(\textcolor{stringliteral}{"{}cannot use emplace() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22410         \}}
\DoxyCodeLine{22411 }
\DoxyCodeLine{22412         \textcolor{comment}{// transform null object into an object}}
\DoxyCodeLine{22413         \textcolor{keywordflow}{if} (is\_null())}
\DoxyCodeLine{22414         \{}
\DoxyCodeLine{22415             m\_type = value\_t::object;}
\DoxyCodeLine{22416             m\_value = value\_t::object;}
\DoxyCodeLine{22417             assert\_invariant();}
\DoxyCodeLine{22418         \}}
\DoxyCodeLine{22419 }
\DoxyCodeLine{22420         \textcolor{comment}{// add element to array (perfect forwarding)}}
\DoxyCodeLine{22421         \textcolor{keyword}{auto} res = m\_value.object-\/>emplace(std::forward<Args>(args)...);}
\DoxyCodeLine{22422         set\_parent(res.first-\/>second);}
\DoxyCodeLine{22423 }
\DoxyCodeLine{22424         \textcolor{comment}{// create result iterator and set iterator to the result of emplace}}
\DoxyCodeLine{22425         \textcolor{keyword}{auto} it = begin();}
\DoxyCodeLine{22426         it.m\_it.object\_iterator = res.first;}
\DoxyCodeLine{22427 }
\DoxyCodeLine{22428         \textcolor{comment}{// return pair of iterator and boolean}}
\DoxyCodeLine{22429         \textcolor{keywordflow}{return} \{it, res.second\};}
\DoxyCodeLine{22430     \}}
\DoxyCodeLine{22431 }
\DoxyCodeLine{22435     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{22436     \mbox{\hyperlink{classbasic__json_a2935c91b82c8e586b1dd68ad665075a6}{iterator}} \mbox{\hyperlink{classbasic__json_a6940b08bda32ce195a9e4508b8aa1126}{insert\_iterator}}(\mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} pos, Args\&\& ... args)}
\DoxyCodeLine{22437     \{}
\DoxyCodeLine{22438         \mbox{\hyperlink{classbasic__json_a2935c91b82c8e586b1dd68ad665075a6}{iterator}} result(\textcolor{keyword}{this});}
\DoxyCodeLine{22439         JSON\_ASSERT(m\_value.array != \textcolor{keyword}{nullptr});}
\DoxyCodeLine{22440 }
\DoxyCodeLine{22441         \textcolor{keyword}{auto} insert\_pos = std::distance(m\_value.array-\/>begin(), pos.m\_it.array\_iterator);}
\DoxyCodeLine{22442         m\_value.array-\/>insert(pos.m\_it.array\_iterator, std::forward<Args>(args)...);}
\DoxyCodeLine{22443         result.m\_it.array\_iterator = m\_value.array-\/>begin() + insert\_pos;}
\DoxyCodeLine{22444 }
\DoxyCodeLine{22445         \textcolor{comment}{// This could have been written as:}}
\DoxyCodeLine{22446         \textcolor{comment}{// result.m\_it.array\_iterator = m\_value.array-\/>insert(pos.m\_it.array\_iterator, cnt, val);}}
\DoxyCodeLine{22447         \textcolor{comment}{// but the return value of insert is missing in GCC 4.8, so it is written this way instead.}}
\DoxyCodeLine{22448 }
\DoxyCodeLine{22449         set\_parents();}
\DoxyCodeLine{22450         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{22451     \}}
\DoxyCodeLine{22452 }
\DoxyCodeLine{22455     \mbox{\hyperlink{classbasic__json_a2935c91b82c8e586b1dd68ad665075a6}{iterator}} \mbox{\hyperlink{classbasic__json_a4467ec0c7679150140f9d2f85e95bf4b}{insert}}(\mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} pos, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& val)}
\DoxyCodeLine{22456     \{}
\DoxyCodeLine{22457         \textcolor{comment}{// insert only works for arrays}}
\DoxyCodeLine{22458         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_array()))}
\DoxyCodeLine{22459         \{}
\DoxyCodeLine{22460             \textcolor{comment}{// check if iterator pos fits to this JSON value}}
\DoxyCodeLine{22461             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(pos.m\_object != \textcolor{keyword}{this}))}
\DoxyCodeLine{22462             \{}
\DoxyCodeLine{22463                 JSON\_THROW(invalid\_iterator::create(202, \textcolor{stringliteral}{"{}iterator does not fit current value"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{22464             \}}
\DoxyCodeLine{22465 }
\DoxyCodeLine{22466             \textcolor{comment}{// insert to array and return iterator}}
\DoxyCodeLine{22467             \textcolor{keywordflow}{return} insert\_iterator(pos, val);}
\DoxyCodeLine{22468         \}}
\DoxyCodeLine{22469 }
\DoxyCodeLine{22470         JSON\_THROW(type\_error::create(309, detail::concat(\textcolor{stringliteral}{"{}cannot use insert() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22471     \}}
\DoxyCodeLine{22472 }
\DoxyCodeLine{22475     \mbox{\hyperlink{classbasic__json_a2935c91b82c8e586b1dd68ad665075a6}{iterator}} \mbox{\hyperlink{classbasic__json_a5cd6ab85d95fa08d0fbce5f957834f28}{insert}}(\mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} pos, \mbox{\hyperlink{classbasic__json}{basic\_json}}\&\& val)}
\DoxyCodeLine{22476     \{}
\DoxyCodeLine{22477         \textcolor{keywordflow}{return} insert(pos, val);}
\DoxyCodeLine{22478     \}}
\DoxyCodeLine{22479 }
\DoxyCodeLine{22482     \mbox{\hyperlink{classbasic__json_a2935c91b82c8e586b1dd68ad665075a6}{iterator}} \mbox{\hyperlink{classbasic__json_a1d7b302f4e6249b8b28dcfbebd934600}{insert}}(\mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} pos, \mbox{\hyperlink{classbasic__json_a883ac4726a370dbf98474944ec0a0acc}{size\_type}} cnt, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& val)}
\DoxyCodeLine{22483     \{}
\DoxyCodeLine{22484         \textcolor{comment}{// insert only works for arrays}}
\DoxyCodeLine{22485         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_array()))}
\DoxyCodeLine{22486         \{}
\DoxyCodeLine{22487             \textcolor{comment}{// check if iterator pos fits to this JSON value}}
\DoxyCodeLine{22488             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(pos.m\_object != \textcolor{keyword}{this}))}
\DoxyCodeLine{22489             \{}
\DoxyCodeLine{22490                 JSON\_THROW(invalid\_iterator::create(202, \textcolor{stringliteral}{"{}iterator does not fit current value"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{22491             \}}
\DoxyCodeLine{22492 }
\DoxyCodeLine{22493             \textcolor{comment}{// insert to array and return iterator}}
\DoxyCodeLine{22494             \textcolor{keywordflow}{return} insert\_iterator(pos, cnt, val);}
\DoxyCodeLine{22495         \}}
\DoxyCodeLine{22496 }
\DoxyCodeLine{22497         JSON\_THROW(type\_error::create(309, detail::concat(\textcolor{stringliteral}{"{}cannot use insert() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22498     \}}
\DoxyCodeLine{22499 }
\DoxyCodeLine{22502     \mbox{\hyperlink{classbasic__json_a2935c91b82c8e586b1dd68ad665075a6}{iterator}} \mbox{\hyperlink{classbasic__json_af30d7fc224999adeaa9e4dcd81db0f05}{insert}}(\mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} pos, \mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} first, \mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} last)}
\DoxyCodeLine{22503     \{}
\DoxyCodeLine{22504         \textcolor{comment}{// insert only works for arrays}}
\DoxyCodeLine{22505         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!is\_array()))}
\DoxyCodeLine{22506         \{}
\DoxyCodeLine{22507             JSON\_THROW(type\_error::create(309, detail::concat(\textcolor{stringliteral}{"{}cannot use insert() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22508         \}}
\DoxyCodeLine{22509 }
\DoxyCodeLine{22510         \textcolor{comment}{// check if iterator pos fits to this JSON value}}
\DoxyCodeLine{22511         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(pos.m\_object != \textcolor{keyword}{this}))}
\DoxyCodeLine{22512         \{}
\DoxyCodeLine{22513             JSON\_THROW(invalid\_iterator::create(202, \textcolor{stringliteral}{"{}iterator does not fit current value"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{22514         \}}
\DoxyCodeLine{22515 }
\DoxyCodeLine{22516         \textcolor{comment}{// check if range iterators belong to the same JSON object}}
\DoxyCodeLine{22517         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(first.m\_object != last.m\_object))}
\DoxyCodeLine{22518         \{}
\DoxyCodeLine{22519             JSON\_THROW(invalid\_iterator::create(210, \textcolor{stringliteral}{"{}iterators do not fit"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{22520         \}}
\DoxyCodeLine{22521 }
\DoxyCodeLine{22522         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(first.m\_object == \textcolor{keyword}{this}))}
\DoxyCodeLine{22523         \{}
\DoxyCodeLine{22524             JSON\_THROW(invalid\_iterator::create(211, \textcolor{stringliteral}{"{}passed iterators may not belong to container"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{22525         \}}
\DoxyCodeLine{22526 }
\DoxyCodeLine{22527         \textcolor{comment}{// insert to array and return iterator}}
\DoxyCodeLine{22528         \textcolor{keywordflow}{return} insert\_iterator(pos, first.m\_it.array\_iterator, last.m\_it.array\_iterator);}
\DoxyCodeLine{22529     \}}
\DoxyCodeLine{22530 }
\DoxyCodeLine{22533     \mbox{\hyperlink{classbasic__json_a2935c91b82c8e586b1dd68ad665075a6}{iterator}} \mbox{\hyperlink{classbasic__json_a3b25eeb503c9f30322b966af0451da38}{insert}}(\mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} pos, \mbox{\hyperlink{classbasic__json_a2063ed828cd027216c549ac48527a562}{initializer\_list\_t}} ilist)}
\DoxyCodeLine{22534     \{}
\DoxyCodeLine{22535         \textcolor{comment}{// insert only works for arrays}}
\DoxyCodeLine{22536         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!is\_array()))}
\DoxyCodeLine{22537         \{}
\DoxyCodeLine{22538             JSON\_THROW(type\_error::create(309, detail::concat(\textcolor{stringliteral}{"{}cannot use insert() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22539         \}}
\DoxyCodeLine{22540 }
\DoxyCodeLine{22541         \textcolor{comment}{// check if iterator pos fits to this JSON value}}
\DoxyCodeLine{22542         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(pos.m\_object != \textcolor{keyword}{this}))}
\DoxyCodeLine{22543         \{}
\DoxyCodeLine{22544             JSON\_THROW(invalid\_iterator::create(202, \textcolor{stringliteral}{"{}iterator does not fit current value"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{22545         \}}
\DoxyCodeLine{22546 }
\DoxyCodeLine{22547         \textcolor{comment}{// insert to array and return iterator}}
\DoxyCodeLine{22548         \textcolor{keywordflow}{return} insert\_iterator(pos, ilist.begin(), ilist.end());}
\DoxyCodeLine{22549     \}}
\DoxyCodeLine{22550 }
\DoxyCodeLine{22553     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a797b7b5589862535c88b9604c88d8d3e}{insert}}(\mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} first, \mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} last)}
\DoxyCodeLine{22554     \{}
\DoxyCodeLine{22555         \textcolor{comment}{// insert only works for objects}}
\DoxyCodeLine{22556         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!is\_object()))}
\DoxyCodeLine{22557         \{}
\DoxyCodeLine{22558             JSON\_THROW(type\_error::create(309, detail::concat(\textcolor{stringliteral}{"{}cannot use insert() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22559         \}}
\DoxyCodeLine{22560 }
\DoxyCodeLine{22561         \textcolor{comment}{// check if range iterators belong to the same JSON object}}
\DoxyCodeLine{22562         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(first.m\_object != last.m\_object))}
\DoxyCodeLine{22563         \{}
\DoxyCodeLine{22564             JSON\_THROW(invalid\_iterator::create(210, \textcolor{stringliteral}{"{}iterators do not fit"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{22565         \}}
\DoxyCodeLine{22566 }
\DoxyCodeLine{22567         \textcolor{comment}{// passed iterators must belong to objects}}
\DoxyCodeLine{22568         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!first.m\_object-\/>is\_object()))}
\DoxyCodeLine{22569         \{}
\DoxyCodeLine{22570             JSON\_THROW(invalid\_iterator::create(202, \textcolor{stringliteral}{"{}iterators first and last must point to objects"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{22571         \}}
\DoxyCodeLine{22572 }
\DoxyCodeLine{22573         m\_value.object-\/>insert(first.m\_it.object\_iterator, last.m\_it.object\_iterator);}
\DoxyCodeLine{22574     \}}
\DoxyCodeLine{22575 }
\DoxyCodeLine{22578     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_aa1c13ddcc1eb615dc56ebd7cb44791bd}{update}}(\mbox{\hyperlink{classbasic__json}{const\_reference}} j, \textcolor{keywordtype}{bool} merge\_objects = \textcolor{keyword}{false})}
\DoxyCodeLine{22579     \{}
\DoxyCodeLine{22580         update(j.begin(), j.end(), merge\_objects);}
\DoxyCodeLine{22581     \}}
\DoxyCodeLine{22582 }
\DoxyCodeLine{22585     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a2db7c9bf454f893d156a7396d527873b}{update}}(\mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} first, \mbox{\hyperlink{classbasic__json_a8f3470194c24d964e40d9be0b177cbc3}{const\_iterator}} last, \textcolor{keywordtype}{bool} merge\_objects = \textcolor{keyword}{false})}
\DoxyCodeLine{22586     \{}
\DoxyCodeLine{22587         \textcolor{comment}{// implicitly convert null value to an empty object}}
\DoxyCodeLine{22588         \textcolor{keywordflow}{if} (is\_null())}
\DoxyCodeLine{22589         \{}
\DoxyCodeLine{22590             m\_type = value\_t::object;}
\DoxyCodeLine{22591             m\_value.object = create<object\_t>();}
\DoxyCodeLine{22592             assert\_invariant();}
\DoxyCodeLine{22593         \}}
\DoxyCodeLine{22594 }
\DoxyCodeLine{22595         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!is\_object()))}
\DoxyCodeLine{22596         \{}
\DoxyCodeLine{22597             JSON\_THROW(type\_error::create(312, detail::concat(\textcolor{stringliteral}{"{}cannot use update() with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22598         \}}
\DoxyCodeLine{22599 }
\DoxyCodeLine{22600         \textcolor{comment}{// check if range iterators belong to the same JSON object}}
\DoxyCodeLine{22601         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(first.m\_object != last.m\_object))}
\DoxyCodeLine{22602         \{}
\DoxyCodeLine{22603             JSON\_THROW(invalid\_iterator::create(210, \textcolor{stringliteral}{"{}iterators do not fit"{}}, \textcolor{keyword}{this}));}
\DoxyCodeLine{22604         \}}
\DoxyCodeLine{22605 }
\DoxyCodeLine{22606         \textcolor{comment}{// passed iterators must belong to objects}}
\DoxyCodeLine{22607         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!first.m\_object-\/>is\_object()))}
\DoxyCodeLine{22608         \{}
\DoxyCodeLine{22609             JSON\_THROW(type\_error::create(312, detail::concat(\textcolor{stringliteral}{"{}cannot use update() with "{}}, first.m\_object-\/>type\_name()), first.m\_object));}
\DoxyCodeLine{22610         \}}
\DoxyCodeLine{22611 }
\DoxyCodeLine{22612         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; it != last; ++it)}
\DoxyCodeLine{22613         \{}
\DoxyCodeLine{22614             \textcolor{keywordflow}{if} (merge\_objects \&\& it.value().is\_object())}
\DoxyCodeLine{22615             \{}
\DoxyCodeLine{22616                 \textcolor{keyword}{auto} it2 = m\_value.object-\/>find(it.key());}
\DoxyCodeLine{22617                 \textcolor{keywordflow}{if} (it2 != m\_value.object-\/>end())}
\DoxyCodeLine{22618                 \{}
\DoxyCodeLine{22619                     it2-\/>second.update(it.value(), \textcolor{keyword}{true});}
\DoxyCodeLine{22620                     \textcolor{keywordflow}{continue};}
\DoxyCodeLine{22621                 \}}
\DoxyCodeLine{22622             \}}
\DoxyCodeLine{22623             m\_value.object-\/>operator[](it.key()) = it.value();}
\DoxyCodeLine{22624 \textcolor{preprocessor}{\#if JSON\_DIAGNOSTICS}}
\DoxyCodeLine{22625             m\_value.object-\/>operator[](it.key()).m\_parent = \textcolor{keyword}{this};}
\DoxyCodeLine{22626 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{22627         \}}
\DoxyCodeLine{22628     \}}
\DoxyCodeLine{22629 }
\DoxyCodeLine{22632     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a57541a1c736f6ea94fe4a92dd61b3c37}{swap}}(\mbox{\hyperlink{classbasic__json}{reference}} other) \textcolor{keyword}{noexcept} (}
\DoxyCodeLine{22633         std::is\_nothrow\_move\_constructible<value\_t>::value\&\&}
\DoxyCodeLine{22634         std::is\_nothrow\_move\_assignable<value\_t>::value\&\&}
\DoxyCodeLine{22635         std::is\_nothrow\_move\_constructible<json\_value>::value\&\&}
\DoxyCodeLine{22636         std::is\_nothrow\_move\_assignable<json\_value>::value}
\DoxyCodeLine{22637     )}
\DoxyCodeLine{22638     \{}
\DoxyCodeLine{22639         std::swap(m\_type, other.m\_type);}
\DoxyCodeLine{22640         std::swap(m\_value, other.m\_value);}
\DoxyCodeLine{22641 }
\DoxyCodeLine{22642         set\_parents();}
\DoxyCodeLine{22643         other.set\_parents();}
\DoxyCodeLine{22644         assert\_invariant();}
\DoxyCodeLine{22645     \}}
\DoxyCodeLine{22646 }
\DoxyCodeLine{22649     \textcolor{keyword}{friend} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_aee0ae36cbfb0336832ebc0374c3c7679}{swap}}(\mbox{\hyperlink{classbasic__json}{reference}} left, \mbox{\hyperlink{classbasic__json}{reference}} right) \textcolor{keyword}{noexcept} (}
\DoxyCodeLine{22650         std::is\_nothrow\_move\_constructible<value\_t>::value\&\&}
\DoxyCodeLine{22651         std::is\_nothrow\_move\_assignable<value\_t>::value\&\&}
\DoxyCodeLine{22652         std::is\_nothrow\_move\_constructible<json\_value>::value\&\&}
\DoxyCodeLine{22653         std::is\_nothrow\_move\_assignable<json\_value>::value}
\DoxyCodeLine{22654     )}
\DoxyCodeLine{22655     \{}
\DoxyCodeLine{22656         left.swap(right);}
\DoxyCodeLine{22657     \}}
\DoxyCodeLine{22658 }
\DoxyCodeLine{22661     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_af1bc171c2ec496dcc63c9035354d1138}{swap}}(\mbox{\hyperlink{classbasic__json_a7cf28eb944e7c06aa47f0bc3a9d6f454}{array\_t}}\& other) \textcolor{comment}{// NOLINT(bugprone-\/exception-\/escape)}}
\DoxyCodeLine{22662     \{}
\DoxyCodeLine{22663         \textcolor{comment}{// swap only works for arrays}}
\DoxyCodeLine{22664         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_array()))}
\DoxyCodeLine{22665         \{}
\DoxyCodeLine{22666             \textcolor{keyword}{using }std::swap;}
\DoxyCodeLine{22667             swap(*(m\_value.array), other);}
\DoxyCodeLine{22668         \}}
\DoxyCodeLine{22669         \textcolor{keywordflow}{else}}
\DoxyCodeLine{22670         \{}
\DoxyCodeLine{22671             JSON\_THROW(type\_error::create(310, detail::concat(\textcolor{stringliteral}{"{}cannot use swap(array\_t\&) with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22672         \}}
\DoxyCodeLine{22673     \}}
\DoxyCodeLine{22674 }
\DoxyCodeLine{22677     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a2061fc20992f76b6fe4a7d2456391b8f}{swap}}(\mbox{\hyperlink{classbasic__json_a770279b71f788fe3f76411eedf5b1956}{object\_t}}\& other) \textcolor{comment}{// NOLINT(bugprone-\/exception-\/escape)}}
\DoxyCodeLine{22678     \{}
\DoxyCodeLine{22679         \textcolor{comment}{// swap only works for objects}}
\DoxyCodeLine{22680         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_object()))}
\DoxyCodeLine{22681         \{}
\DoxyCodeLine{22682             \textcolor{keyword}{using }std::swap;}
\DoxyCodeLine{22683             swap(*(m\_value.object), other);}
\DoxyCodeLine{22684         \}}
\DoxyCodeLine{22685         \textcolor{keywordflow}{else}}
\DoxyCodeLine{22686         \{}
\DoxyCodeLine{22687             JSON\_THROW(type\_error::create(310, detail::concat(\textcolor{stringliteral}{"{}cannot use swap(object\_t\&) with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22688         \}}
\DoxyCodeLine{22689     \}}
\DoxyCodeLine{22690 }
\DoxyCodeLine{22693     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_aa914de665383b10bdd6265e6b63b8d93}{swap}}(\mbox{\hyperlink{classbasic__json_a807932caebf0d62abc8642b9d1a2e5ef}{string\_t}}\& other) \textcolor{comment}{// NOLINT(bugprone-\/exception-\/escape)}}
\DoxyCodeLine{22694     \{}
\DoxyCodeLine{22695         \textcolor{comment}{// swap only works for strings}}
\DoxyCodeLine{22696         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_string()))}
\DoxyCodeLine{22697         \{}
\DoxyCodeLine{22698             \textcolor{keyword}{using }std::swap;}
\DoxyCodeLine{22699             swap(*(m\_value.string), other);}
\DoxyCodeLine{22700         \}}
\DoxyCodeLine{22701         \textcolor{keywordflow}{else}}
\DoxyCodeLine{22702         \{}
\DoxyCodeLine{22703             JSON\_THROW(type\_error::create(310, detail::concat(\textcolor{stringliteral}{"{}cannot use swap(string\_t\&) with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22704         \}}
\DoxyCodeLine{22705     \}}
\DoxyCodeLine{22706 }
\DoxyCodeLine{22709     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a23296c72c9f837e20cfdc28d8018dd57}{swap}}(\mbox{\hyperlink{classbasic__json_aabedd827d4943302a4cf0413956341db}{binary\_t}}\& other) \textcolor{comment}{// NOLINT(bugprone-\/exception-\/escape)}}
\DoxyCodeLine{22710     \{}
\DoxyCodeLine{22711         \textcolor{comment}{// swap only works for strings}}
\DoxyCodeLine{22712         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_binary()))}
\DoxyCodeLine{22713         \{}
\DoxyCodeLine{22714             \textcolor{keyword}{using }std::swap;}
\DoxyCodeLine{22715             swap(*(m\_value.binary), other);}
\DoxyCodeLine{22716         \}}
\DoxyCodeLine{22717         \textcolor{keywordflow}{else}}
\DoxyCodeLine{22718         \{}
\DoxyCodeLine{22719             JSON\_THROW(type\_error::create(310, detail::concat(\textcolor{stringliteral}{"{}cannot use swap(binary\_t\&) with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22720         \}}
\DoxyCodeLine{22721     \}}
\DoxyCodeLine{22722 }
\DoxyCodeLine{22725     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a636ae0a887a94436f43f26c94aa1f748}{swap}}(\textcolor{keyword}{typename} binary\_t::container\_type\& other) \textcolor{comment}{// NOLINT(bugprone-\/exception-\/escape)}}
\DoxyCodeLine{22726     \{}
\DoxyCodeLine{22727         \textcolor{comment}{// swap only works for strings}}
\DoxyCodeLine{22728         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(is\_binary()))}
\DoxyCodeLine{22729         \{}
\DoxyCodeLine{22730             \textcolor{keyword}{using }std::swap;}
\DoxyCodeLine{22731             swap(*(m\_value.binary), other);}
\DoxyCodeLine{22732         \}}
\DoxyCodeLine{22733         \textcolor{keywordflow}{else}}
\DoxyCodeLine{22734         \{}
\DoxyCodeLine{22735             JSON\_THROW(type\_error::create(310, detail::concat(\textcolor{stringliteral}{"{}cannot use swap(binary\_t::container\_type\&) with "{}}, type\_name()), \textcolor{keyword}{this}));}
\DoxyCodeLine{22736         \}}
\DoxyCodeLine{22737     \}}
\DoxyCodeLine{22738 }
\DoxyCodeLine{22740 }
\DoxyCodeLine{22742     \textcolor{comment}{// lexicographical comparison operators //}}
\DoxyCodeLine{22744 \textcolor{comment}{}}
\DoxyCodeLine{22747 }
\DoxyCodeLine{22748     \textcolor{comment}{// note parentheses around operands are necessary; see}}
\DoxyCodeLine{22749     \textcolor{comment}{// https://github.com/nlohmann/json/issues/1530}}
\DoxyCodeLine{22750 \textcolor{preprocessor}{\#define JSON\_IMPLEMENT\_OPERATOR(op, null\_result, unordered\_result, default\_result)                       \(\backslash\)}}
\DoxyCodeLine{22751 \textcolor{preprocessor}{    const auto lhs\_type = lhs.type();                                                                    \(\backslash\)}}
\DoxyCodeLine{22752 \textcolor{preprocessor}{    const auto rhs\_type = rhs.type();                                                                    \(\backslash\)}}
\DoxyCodeLine{22753 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{22754 \textcolor{preprocessor}{    if (lhs\_type == rhs\_type) }\textcolor{comment}{/* NOLINT(readability/braces) */}\textcolor{preprocessor}{                                           \(\backslash\)}}
\DoxyCodeLine{22755 \textcolor{preprocessor}{    \{                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22756 \textcolor{preprocessor}{        switch (lhs\_type)                                                                                \(\backslash\)}}
\DoxyCodeLine{22757 \textcolor{preprocessor}{        \{                                                                                                \(\backslash\)}}
\DoxyCodeLine{22758 \textcolor{preprocessor}{            case value\_t::array:                                                                         \(\backslash\)}}
\DoxyCodeLine{22759 \textcolor{preprocessor}{                return (*lhs.m\_value.array) op (*rhs.m\_value.array);                                     \(\backslash\)}}
\DoxyCodeLine{22760 \textcolor{preprocessor}{                \(\backslash\)}}
\DoxyCodeLine{22761 \textcolor{preprocessor}{            case value\_t::object:                                                                        \(\backslash\)}}
\DoxyCodeLine{22762 \textcolor{preprocessor}{                return (*lhs.m\_value.object) op (*rhs.m\_value.object);                                   \(\backslash\)}}
\DoxyCodeLine{22763 \textcolor{preprocessor}{                \(\backslash\)}}
\DoxyCodeLine{22764 \textcolor{preprocessor}{            case value\_t::null:                                                                          \(\backslash\)}}
\DoxyCodeLine{22765 \textcolor{preprocessor}{                return (null\_result);                                                                    \(\backslash\)}}
\DoxyCodeLine{22766 \textcolor{preprocessor}{                \(\backslash\)}}
\DoxyCodeLine{22767 \textcolor{preprocessor}{            case value\_t::string:                                                                        \(\backslash\)}}
\DoxyCodeLine{22768 \textcolor{preprocessor}{                return (*lhs.m\_value.string) op (*rhs.m\_value.string);                                   \(\backslash\)}}
\DoxyCodeLine{22769 \textcolor{preprocessor}{                \(\backslash\)}}
\DoxyCodeLine{22770 \textcolor{preprocessor}{            case value\_t::boolean:                                                                       \(\backslash\)}}
\DoxyCodeLine{22771 \textcolor{preprocessor}{                return (lhs.m\_value.boolean) op (rhs.m\_value.boolean);                                   \(\backslash\)}}
\DoxyCodeLine{22772 \textcolor{preprocessor}{                \(\backslash\)}}
\DoxyCodeLine{22773 \textcolor{preprocessor}{            case value\_t::number\_integer:                                                                \(\backslash\)}}
\DoxyCodeLine{22774 \textcolor{preprocessor}{                return (lhs.m\_value.number\_integer) op (rhs.m\_value.number\_integer);                     \(\backslash\)}}
\DoxyCodeLine{22775 \textcolor{preprocessor}{                \(\backslash\)}}
\DoxyCodeLine{22776 \textcolor{preprocessor}{            case value\_t::number\_unsigned:                                                               \(\backslash\)}}
\DoxyCodeLine{22777 \textcolor{preprocessor}{                return (lhs.m\_value.number\_unsigned) op (rhs.m\_value.number\_unsigned);                   \(\backslash\)}}
\DoxyCodeLine{22778 \textcolor{preprocessor}{                \(\backslash\)}}
\DoxyCodeLine{22779 \textcolor{preprocessor}{            case value\_t::number\_float:                                                                  \(\backslash\)}}
\DoxyCodeLine{22780 \textcolor{preprocessor}{                return (lhs.m\_value.number\_float) op (rhs.m\_value.number\_float);                         \(\backslash\)}}
\DoxyCodeLine{22781 \textcolor{preprocessor}{                \(\backslash\)}}
\DoxyCodeLine{22782 \textcolor{preprocessor}{            case value\_t::binary:                                                                        \(\backslash\)}}
\DoxyCodeLine{22783 \textcolor{preprocessor}{                return (*lhs.m\_value.binary) op (*rhs.m\_value.binary);                                   \(\backslash\)}}
\DoxyCodeLine{22784 \textcolor{preprocessor}{                \(\backslash\)}}
\DoxyCodeLine{22785 \textcolor{preprocessor}{            case value\_t::discarded:                                                                     \(\backslash\)}}
\DoxyCodeLine{22786 \textcolor{preprocessor}{            default:                                                                                     \(\backslash\)}}
\DoxyCodeLine{22787 \textcolor{preprocessor}{                return (unordered\_result);                                                               \(\backslash\)}}
\DoxyCodeLine{22788 \textcolor{preprocessor}{        \}                                                                                                \(\backslash\)}}
\DoxyCodeLine{22789 \textcolor{preprocessor}{    \}                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22790 \textcolor{preprocessor}{    else if (lhs\_type == value\_t::number\_integer \&\& rhs\_type == value\_t::number\_float)                   \(\backslash\)}}
\DoxyCodeLine{22791 \textcolor{preprocessor}{    \{                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22792 \textcolor{preprocessor}{        return static\_cast<number\_float\_t>(lhs.m\_value.number\_integer) op rhs.m\_value.number\_float;      \(\backslash\)}}
\DoxyCodeLine{22793 \textcolor{preprocessor}{    \}                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22794 \textcolor{preprocessor}{    else if (lhs\_type == value\_t::number\_float \&\& rhs\_type == value\_t::number\_integer)                   \(\backslash\)}}
\DoxyCodeLine{22795 \textcolor{preprocessor}{    \{                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22796 \textcolor{preprocessor}{        return lhs.m\_value.number\_float op static\_cast<number\_float\_t>(rhs.m\_value.number\_integer);      \(\backslash\)}}
\DoxyCodeLine{22797 \textcolor{preprocessor}{    \}                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22798 \textcolor{preprocessor}{    else if (lhs\_type == value\_t::number\_unsigned \&\& rhs\_type == value\_t::number\_float)                  \(\backslash\)}}
\DoxyCodeLine{22799 \textcolor{preprocessor}{    \{                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22800 \textcolor{preprocessor}{        return static\_cast<number\_float\_t>(lhs.m\_value.number\_unsigned) op rhs.m\_value.number\_float;     \(\backslash\)}}
\DoxyCodeLine{22801 \textcolor{preprocessor}{    \}                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22802 \textcolor{preprocessor}{    else if (lhs\_type == value\_t::number\_float \&\& rhs\_type == value\_t::number\_unsigned)                  \(\backslash\)}}
\DoxyCodeLine{22803 \textcolor{preprocessor}{    \{                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22804 \textcolor{preprocessor}{        return lhs.m\_value.number\_float op static\_cast<number\_float\_t>(rhs.m\_value.number\_unsigned);     \(\backslash\)}}
\DoxyCodeLine{22805 \textcolor{preprocessor}{    \}                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22806 \textcolor{preprocessor}{    else if (lhs\_type == value\_t::number\_unsigned \&\& rhs\_type == value\_t::number\_integer)                \(\backslash\)}}
\DoxyCodeLine{22807 \textcolor{preprocessor}{    \{                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22808 \textcolor{preprocessor}{        return static\_cast<number\_integer\_t>(lhs.m\_value.number\_unsigned) op rhs.m\_value.number\_integer; \(\backslash\)}}
\DoxyCodeLine{22809 \textcolor{preprocessor}{    \}                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22810 \textcolor{preprocessor}{    else if (lhs\_type == value\_t::number\_integer \&\& rhs\_type == value\_t::number\_unsigned)                \(\backslash\)}}
\DoxyCodeLine{22811 \textcolor{preprocessor}{    \{                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22812 \textcolor{preprocessor}{        return lhs.m\_value.number\_integer op static\_cast<number\_integer\_t>(rhs.m\_value.number\_unsigned); \(\backslash\)}}
\DoxyCodeLine{22813 \textcolor{preprocessor}{    \}                                                                                                    \(\backslash\)}}
\DoxyCodeLine{22814 \textcolor{preprocessor}{    else if(compares\_unordered(lhs, rhs))\(\backslash\)}}
\DoxyCodeLine{22815 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{22816 \textcolor{preprocessor}{        return (unordered\_result);\(\backslash\)}}
\DoxyCodeLine{22817 \textcolor{preprocessor}{    \}\(\backslash\)}}
\DoxyCodeLine{22818 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{22819 \textcolor{preprocessor}{    return (default\_result);}}
\DoxyCodeLine{22820 }
\DoxyCodeLine{22821   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{22822     \textcolor{comment}{// returns true if:}}
\DoxyCodeLine{22823     \textcolor{comment}{// -\/ any operand is NaN and the other operand is of number type}}
\DoxyCodeLine{22824     \textcolor{comment}{// -\/ any operand is discarded}}
\DoxyCodeLine{22825     \textcolor{comment}{// in legacy mode, discarded values are considered ordered if}}
\DoxyCodeLine{22826     \textcolor{comment}{// an operation is computed as an odd number of inverses of others}}
\DoxyCodeLine{22827     \textcolor{keyword}{static} \textcolor{keywordtype}{bool} compares\_unordered(const\_reference lhs, const\_reference rhs, \textcolor{keywordtype}{bool} inverse = \textcolor{keyword}{false}) noexcept}
\DoxyCodeLine{22828     \{}
\DoxyCodeLine{22829         \textcolor{keywordflow}{if} ((lhs.is\_number\_float() \&\& std::isnan(lhs.m\_value.number\_float) \&\& rhs.is\_number())}
\DoxyCodeLine{22830                 || (rhs.is\_number\_float() \&\& std::isnan(rhs.m\_value.number\_float) \&\& lhs.is\_number()))}
\DoxyCodeLine{22831         \{}
\DoxyCodeLine{22832             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{22833         \}}
\DoxyCodeLine{22834 \textcolor{preprocessor}{\#if JSON\_USE\_LEGACY\_DISCARDED\_VALUE\_COMPARISON}}
\DoxyCodeLine{22835         \textcolor{keywordflow}{return} (lhs.is\_discarded() || rhs.is\_discarded()) \&\& !inverse;}
\DoxyCodeLine{22836 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{22837         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(inverse);}
\DoxyCodeLine{22838         \textcolor{keywordflow}{return} lhs.is\_discarded() || rhs.is\_discarded();}
\DoxyCodeLine{22839 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{22840     \}}
\DoxyCodeLine{22841 }
\DoxyCodeLine{22842   \textcolor{keyword}{private}:}
\DoxyCodeLine{22843     \textcolor{keywordtype}{bool} compares\_unordered(const\_reference rhs, \textcolor{keywordtype}{bool} inverse = \textcolor{keyword}{false}) const noexcept}
\DoxyCodeLine{22844     \{}
\DoxyCodeLine{22845         \textcolor{keywordflow}{return} compares\_unordered(*\textcolor{keyword}{this}, rhs, inverse);}
\DoxyCodeLine{22846     \}}
\DoxyCodeLine{22847 }
\DoxyCodeLine{22848   \textcolor{keyword}{public}:}
\DoxyCodeLine{22849 \textcolor{preprocessor}{\#if JSON\_HAS\_THREE\_WAY\_COMPARISON}}
\DoxyCodeLine{22852     \textcolor{keywordtype}{bool} operator==(const\_reference rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22853     \{}
\DoxyCodeLine{22854 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{22855 \textcolor{preprocessor}{\#pragma GCC diagnostic push}}
\DoxyCodeLine{22856 \textcolor{preprocessor}{\#pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}}}
\DoxyCodeLine{22857 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{22858         const\_reference lhs = *\textcolor{keyword}{this};}
\DoxyCodeLine{22859         JSON\_IMPLEMENT\_OPERATOR( ==, \textcolor{keyword}{true}, \textcolor{keyword}{false}, \textcolor{keyword}{false})}
\DoxyCodeLine{22860 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{22861 \textcolor{preprocessor}{\#pragma GCC diagnostic pop}}
\DoxyCodeLine{22862 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{22863     \}}
\DoxyCodeLine{22864 }
\DoxyCodeLine{22867     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType>}
\DoxyCodeLine{22868     \textcolor{keyword}{requires} std::is\_scalar\_v<ScalarType>}
\DoxyCodeLine{22869     \textcolor{keywordtype}{bool} operator==(ScalarType rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22870     \{}
\DoxyCodeLine{22871         \textcolor{keywordflow}{return} *\textcolor{keyword}{this} == \mbox{\hyperlink{classbasic__json}{basic\_json}}(rhs);}
\DoxyCodeLine{22872     \}}
\DoxyCodeLine{22873 }
\DoxyCodeLine{22876     \textcolor{keywordtype}{bool} operator!=(const\_reference rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22877     \{}
\DoxyCodeLine{22878         \textcolor{keywordflow}{if} (compares\_unordered(rhs, \textcolor{keyword}{true}))}
\DoxyCodeLine{22879         \{}
\DoxyCodeLine{22880             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{22881         \}}
\DoxyCodeLine{22882         \textcolor{keywordflow}{return} !operator==(rhs);}
\DoxyCodeLine{22883     \}}
\DoxyCodeLine{22884 }
\DoxyCodeLine{22887     std::partial\_ordering operator<=>(const\_reference rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{22888     \{}
\DoxyCodeLine{22889         const\_reference lhs = *\textcolor{keyword}{this};}
\DoxyCodeLine{22890         \textcolor{comment}{// default\_result is used if we cannot compare values. In that case,}}
\DoxyCodeLine{22891         \textcolor{comment}{// we compare types.}}
\DoxyCodeLine{22892         JSON\_IMPLEMENT\_OPERATOR(<=>, \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{22893                                 std::partial\_ordering::equivalent,}
\DoxyCodeLine{22894                                 std::partial\_ordering::unordered,}
\DoxyCodeLine{22895                                 lhs\_type <=> rhs\_type) \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{22896     \}}
\DoxyCodeLine{22897 }
\DoxyCodeLine{22900     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType>}
\DoxyCodeLine{22901     \textcolor{keyword}{requires} std::is\_scalar\_v<ScalarType>}
\DoxyCodeLine{22902     std::partial\_ordering operator<=>(ScalarType rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{22903     \{}
\DoxyCodeLine{22904         \textcolor{keywordflow}{return} *this <=> \mbox{\hyperlink{classbasic__json}{basic\_json}}(rhs); \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{22905     \}}
\DoxyCodeLine{22906 }
\DoxyCodeLine{22907 \textcolor{preprocessor}{\#if JSON\_USE\_LEGACY\_DISCARDED\_VALUE\_COMPARISON}}
\DoxyCodeLine{22908     \textcolor{comment}{// all operators that are computed as an odd number of inverses of others}}
\DoxyCodeLine{22909     \textcolor{comment}{// need to be overloaded to emulate the legacy comparison behavior}}
\DoxyCodeLine{22910 }
\DoxyCodeLine{22913     JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.0, undef JSON\_USE\_LEGACY\_DISCARDED\_VALUE\_COMPARISON)}
\DoxyCodeLine{22914     \textcolor{keywordtype}{bool} operator<=(const\_reference rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22915     \{}
\DoxyCodeLine{22916         \textcolor{keywordflow}{if} (compares\_unordered(rhs, \textcolor{keyword}{true}))}
\DoxyCodeLine{22917         \{}
\DoxyCodeLine{22918             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{22919         \}}
\DoxyCodeLine{22920         \textcolor{keywordflow}{return} !(rhs < *\textcolor{keyword}{this});}
\DoxyCodeLine{22921     \}}
\DoxyCodeLine{22922 }
\DoxyCodeLine{22925     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType>}
\DoxyCodeLine{22926     \textcolor{keyword}{requires} std::is\_scalar\_v<ScalarType>}
\DoxyCodeLine{22927     \textcolor{keywordtype}{bool} operator<=(ScalarType rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22928     \{}
\DoxyCodeLine{22929         \textcolor{keywordflow}{return} *\textcolor{keyword}{this} <= \mbox{\hyperlink{classbasic__json}{basic\_json}}(rhs);}
\DoxyCodeLine{22930     \}}
\DoxyCodeLine{22931 }
\DoxyCodeLine{22934     JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.0, undef JSON\_USE\_LEGACY\_DISCARDED\_VALUE\_COMPARISON)}
\DoxyCodeLine{22935     \textcolor{keywordtype}{bool} operator>=(const\_reference rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22936     \{}
\DoxyCodeLine{22937         \textcolor{keywordflow}{if} (compares\_unordered(rhs, \textcolor{keyword}{true}))}
\DoxyCodeLine{22938         \{}
\DoxyCodeLine{22939             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{22940         \}}
\DoxyCodeLine{22941         \textcolor{keywordflow}{return} !(*\textcolor{keyword}{this} < rhs);}
\DoxyCodeLine{22942     \}}
\DoxyCodeLine{22943 }
\DoxyCodeLine{22946     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType>}
\DoxyCodeLine{22947     \textcolor{keyword}{requires} std::is\_scalar\_v<ScalarType>}
\DoxyCodeLine{22948     \textcolor{keywordtype}{bool} operator>=(ScalarType rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22949     \{}
\DoxyCodeLine{22950         \textcolor{keywordflow}{return} *\textcolor{keyword}{this} >= \mbox{\hyperlink{classbasic__json}{basic\_json}}(rhs);}
\DoxyCodeLine{22951     \}}
\DoxyCodeLine{22952 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{22953 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{22956     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(const\_reference lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22957     \{}
\DoxyCodeLine{22958 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{22959 \textcolor{preprocessor}{\#pragma GCC diagnostic push}}
\DoxyCodeLine{22960 \textcolor{preprocessor}{\#pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}}}
\DoxyCodeLine{22961 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{22962         JSON\_IMPLEMENT\_OPERATOR( ==, \textcolor{keyword}{true}, \textcolor{keyword}{false}, \textcolor{keyword}{false})}
\DoxyCodeLine{22963 \textcolor{preprocessor}{\#ifdef \_\_GNUC\_\_}}
\DoxyCodeLine{22964 \textcolor{preprocessor}{\#pragma GCC diagnostic pop}}
\DoxyCodeLine{22965 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{22966     \}}
\DoxyCodeLine{22967 }
\DoxyCodeLine{22970     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{22971                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{22972     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(const\_reference lhs, ScalarType rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22973     \{}
\DoxyCodeLine{22974         \textcolor{keywordflow}{return} lhs == \mbox{\hyperlink{classbasic__json}{basic\_json}}(rhs);}
\DoxyCodeLine{22975     \}}
\DoxyCodeLine{22976 }
\DoxyCodeLine{22979     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{22980                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{22981     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(ScalarType lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22982     \{}
\DoxyCodeLine{22983         \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__json}{basic\_json}}(lhs) == rhs;}
\DoxyCodeLine{22984     \}}
\DoxyCodeLine{22985 }
\DoxyCodeLine{22988     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(const\_reference lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{22989     \{}
\DoxyCodeLine{22990         \textcolor{keywordflow}{if} (compares\_unordered(lhs, rhs, \textcolor{keyword}{true}))}
\DoxyCodeLine{22991         \{}
\DoxyCodeLine{22992             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{22993         \}}
\DoxyCodeLine{22994         \textcolor{keywordflow}{return} !(lhs == rhs);}
\DoxyCodeLine{22995     \}}
\DoxyCodeLine{22996 }
\DoxyCodeLine{22999     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{23000                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{23001     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(const\_reference lhs, ScalarType rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23002     \{}
\DoxyCodeLine{23003         \textcolor{keywordflow}{return} lhs != \mbox{\hyperlink{classbasic__json}{basic\_json}}(rhs);}
\DoxyCodeLine{23004     \}}
\DoxyCodeLine{23005 }
\DoxyCodeLine{23008     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{23009                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{23010     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(ScalarType lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23011     \{}
\DoxyCodeLine{23012         \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__json}{basic\_json}}(lhs) != rhs;}
\DoxyCodeLine{23013     \}}
\DoxyCodeLine{23014 }
\DoxyCodeLine{23017     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_aac7ca91589afb0bad68baec5949daaa2}{operator<}}(const\_reference lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23018     \{}
\DoxyCodeLine{23019         \textcolor{comment}{// default\_result is used if we cannot compare values. In that case,}}
\DoxyCodeLine{23020         \textcolor{comment}{// we compare types. Note we have to call the operator explicitly,}}
\DoxyCodeLine{23021         \textcolor{comment}{// because MSVC has problems otherwise.}}
\DoxyCodeLine{23022         JSON\_IMPLEMENT\_OPERATOR( <, \textcolor{keyword}{false}, \textcolor{keyword}{false}, \textcolor{keyword}{operator}<(lhs\_type, rhs\_type))}
\DoxyCodeLine{23023     \}}
\DoxyCodeLine{23024 }
\DoxyCodeLine{23027     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{23028                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{23029     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_aac7ca91589afb0bad68baec5949daaa2}{operator<}}(const\_reference lhs, ScalarType rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23030     \{}
\DoxyCodeLine{23031         \textcolor{keywordflow}{return} lhs < \mbox{\hyperlink{classbasic__json}{basic\_json}}(rhs);}
\DoxyCodeLine{23032     \}}
\DoxyCodeLine{23033 }
\DoxyCodeLine{23036     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{23037                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{23038     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacedetail_aac7ca91589afb0bad68baec5949daaa2}{operator<}}(ScalarType lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23039     \{}
\DoxyCodeLine{23040         \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__json}{basic\_json}}(lhs) < rhs;}
\DoxyCodeLine{23041     \}}
\DoxyCodeLine{23042 }
\DoxyCodeLine{23045     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator<=(const\_reference lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23046     \{}
\DoxyCodeLine{23047         \textcolor{keywordflow}{if} (compares\_unordered(lhs, rhs, \textcolor{keyword}{true}))}
\DoxyCodeLine{23048         \{}
\DoxyCodeLine{23049             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{23050         \}}
\DoxyCodeLine{23051         \textcolor{keywordflow}{return} !(rhs < lhs);}
\DoxyCodeLine{23052     \}}
\DoxyCodeLine{23053 }
\DoxyCodeLine{23056     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{23057                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{23058     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator<=(const\_reference lhs, ScalarType rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23059     \{}
\DoxyCodeLine{23060         \textcolor{keywordflow}{return} lhs <= \mbox{\hyperlink{classbasic__json}{basic\_json}}(rhs);}
\DoxyCodeLine{23061     \}}
\DoxyCodeLine{23062 }
\DoxyCodeLine{23065     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{23066                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{23067     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator<=(ScalarType lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23068     \{}
\DoxyCodeLine{23069         \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__json}{basic\_json}}(lhs) <= rhs;}
\DoxyCodeLine{23070     \}}
\DoxyCodeLine{23071 }
\DoxyCodeLine{23074     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator>(const\_reference lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23075     \{}
\DoxyCodeLine{23076         \textcolor{comment}{// double inverse}}
\DoxyCodeLine{23077         \textcolor{keywordflow}{if} (compares\_unordered(lhs, rhs))}
\DoxyCodeLine{23078         \{}
\DoxyCodeLine{23079             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{23080         \}}
\DoxyCodeLine{23081         \textcolor{keywordflow}{return} !(lhs <= rhs);}
\DoxyCodeLine{23082     \}}
\DoxyCodeLine{23083 }
\DoxyCodeLine{23086     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{23087                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{23088     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator>(const\_reference lhs, ScalarType rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23089     \{}
\DoxyCodeLine{23090         \textcolor{keywordflow}{return} lhs > \mbox{\hyperlink{classbasic__json}{basic\_json}}(rhs);}
\DoxyCodeLine{23091     \}}
\DoxyCodeLine{23092 }
\DoxyCodeLine{23095     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{23096                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{23097     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator>(ScalarType lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23098     \{}
\DoxyCodeLine{23099         \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__json}{basic\_json}}(lhs) > rhs;}
\DoxyCodeLine{23100     \}}
\DoxyCodeLine{23101 }
\DoxyCodeLine{23104     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator>=(const\_reference lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23105     \{}
\DoxyCodeLine{23106         \textcolor{keywordflow}{if} (compares\_unordered(lhs, rhs, \textcolor{keyword}{true}))}
\DoxyCodeLine{23107         \{}
\DoxyCodeLine{23108             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{23109         \}}
\DoxyCodeLine{23110         \textcolor{keywordflow}{return} !(lhs < rhs);}
\DoxyCodeLine{23111     \}}
\DoxyCodeLine{23112 }
\DoxyCodeLine{23115     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{23116                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{23117     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator>=(const\_reference lhs, ScalarType rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23118     \{}
\DoxyCodeLine{23119         \textcolor{keywordflow}{return} lhs >= \mbox{\hyperlink{classbasic__json}{basic\_json}}(rhs);}
\DoxyCodeLine{23120     \}}
\DoxyCodeLine{23121 }
\DoxyCodeLine{23124     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarType, \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{23125                  std::is\_scalar<ScalarType>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{23126     \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator>=(ScalarType lhs, const\_reference rhs) \textcolor{keyword}{noexcept}}
\DoxyCodeLine{23127     \{}
\DoxyCodeLine{23128         \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__json}{basic\_json}}(lhs) >= rhs;}
\DoxyCodeLine{23129     \}}
\DoxyCodeLine{23130 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{23131 }
\DoxyCodeLine{23132 \textcolor{preprocessor}{\#undef JSON\_IMPLEMENT\_OPERATOR}}
\DoxyCodeLine{23133 }
\DoxyCodeLine{23135 }
\DoxyCodeLine{23137     \textcolor{comment}{// serialization //}}
\DoxyCodeLine{23139 \textcolor{comment}{}}
\DoxyCodeLine{23142 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{23145     \textcolor{keyword}{friend} std::ostream\& operator<<(std::ostream\& o, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j)}
\DoxyCodeLine{23146     \{}
\DoxyCodeLine{23147         \textcolor{comment}{// read width member and use it as indentation parameter if nonzero}}
\DoxyCodeLine{23148         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} pretty\_print = o.width() > 0;}
\DoxyCodeLine{23149         \textcolor{keyword}{const} \textcolor{keyword}{auto} indentation = pretty\_print ? o.width() : 0;}
\DoxyCodeLine{23150 }
\DoxyCodeLine{23151         \textcolor{comment}{// reset width to 0 for subsequent calls to this stream}}
\DoxyCodeLine{23152         o.width(0);}
\DoxyCodeLine{23153 }
\DoxyCodeLine{23154         \textcolor{comment}{// do the actual serialization}}
\DoxyCodeLine{23155         serializer s(\mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<char>}}(o), o.fill());}
\DoxyCodeLine{23156         s.dump(j, pretty\_print, \textcolor{keyword}{false}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(indentation));}
\DoxyCodeLine{23157         \textcolor{keywordflow}{return} o;}
\DoxyCodeLine{23158     \}}
\DoxyCodeLine{23159 }
\DoxyCodeLine{23166     JSON\_HEDLEY\_DEPRECATED\_FOR(3.0.0, \textcolor{keyword}{operator}<<(std::ostream\&, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\&))}
\DoxyCodeLine{23167     \textcolor{keyword}{friend} std::ostream\& operator>>(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, std::ostream\& o)}
\DoxyCodeLine{23168     \{}
\DoxyCodeLine{23169         \textcolor{keywordflow}{return} o << j;}
\DoxyCodeLine{23170     \}}
\DoxyCodeLine{23171 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{23173 \textcolor{comment}{}}
\DoxyCodeLine{23174 }
\DoxyCodeLine{23176     \textcolor{comment}{// deserialization //}}
\DoxyCodeLine{23178 \textcolor{comment}{}}
\DoxyCodeLine{23181 }
\DoxyCodeLine{23184     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>}
\DoxyCodeLine{23185     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23186     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} parse(InputType\&\& i,}
\DoxyCodeLine{23187                             \textcolor{keyword}{const} parser\_callback\_t cb = \textcolor{keyword}{nullptr},}
\DoxyCodeLine{23188                             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true},}
\DoxyCodeLine{23189                             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ignore\_comments = \textcolor{keyword}{false})}
\DoxyCodeLine{23190     \{}
\DoxyCodeLine{23191         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23192         parser(detail::input\_adapter(std::forward<InputType>(i)), cb, allow\_exceptions, ignore\_comments).parse(\textcolor{keyword}{true}, result);}
\DoxyCodeLine{23193         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{23194     \}}
\DoxyCodeLine{23195 }
\DoxyCodeLine{23198     \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{23199     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23200     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} parse(IteratorType first,}
\DoxyCodeLine{23201                             IteratorType last,}
\DoxyCodeLine{23202                             \textcolor{keyword}{const} parser\_callback\_t cb = \textcolor{keyword}{nullptr},}
\DoxyCodeLine{23203                             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true},}
\DoxyCodeLine{23204                             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ignore\_comments = \textcolor{keyword}{false})}
\DoxyCodeLine{23205     \{}
\DoxyCodeLine{23206         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23207         parser(detail::input\_adapter(std::move(first), std::move(last)), cb, allow\_exceptions, ignore\_comments).parse(\textcolor{keyword}{true}, result);}
\DoxyCodeLine{23208         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{23209     \}}
\DoxyCodeLine{23210 }
\DoxyCodeLine{23211     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23212     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, parse(ptr, ptr + len))}
\DoxyCodeLine{23213     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} parse(\mbox{\hyperlink{classdetail_1_1span__input__adapter}{detail::span\_input\_adapter}}\&\& i,}
\DoxyCodeLine{23214                             \textcolor{keyword}{const} parser\_callback\_t cb = \textcolor{keyword}{nullptr},}
\DoxyCodeLine{23215                             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true},}
\DoxyCodeLine{23216                             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ignore\_comments = \textcolor{keyword}{false})}
\DoxyCodeLine{23217     \{}
\DoxyCodeLine{23218         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23219         parser(i.get(), cb, allow\_exceptions, ignore\_comments).parse(\textcolor{keyword}{true}, result);}
\DoxyCodeLine{23220         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{23221     \}}
\DoxyCodeLine{23222 }
\DoxyCodeLine{23225     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>}
\DoxyCodeLine{23226     \textcolor{keyword}{static} \textcolor{keywordtype}{bool} accept(InputType\&\& i,}
\DoxyCodeLine{23227                        \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ignore\_comments = \textcolor{keyword}{false})}
\DoxyCodeLine{23228     \{}
\DoxyCodeLine{23229         \textcolor{keywordflow}{return} parser(detail::input\_adapter(std::forward<InputType>(i)), \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, ignore\_comments).accept(\textcolor{keyword}{true});}
\DoxyCodeLine{23230     \}}
\DoxyCodeLine{23231 }
\DoxyCodeLine{23234     \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{23235     \textcolor{keyword}{static} \textcolor{keywordtype}{bool} accept(IteratorType first, IteratorType last,}
\DoxyCodeLine{23236                        \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ignore\_comments = \textcolor{keyword}{false})}
\DoxyCodeLine{23237     \{}
\DoxyCodeLine{23238         \textcolor{keywordflow}{return} parser(detail::input\_adapter(std::move(first), std::move(last)), \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, ignore\_comments).accept(\textcolor{keyword}{true});}
\DoxyCodeLine{23239     \}}
\DoxyCodeLine{23240 }
\DoxyCodeLine{23241     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23242     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, accept(ptr, ptr + len))}
\DoxyCodeLine{23243     \textcolor{keyword}{static} \textcolor{keywordtype}{bool} accept(\mbox{\hyperlink{classdetail_1_1span__input__adapter}{detail::span\_input\_adapter}}\&\& i,}
\DoxyCodeLine{23244                        \textcolor{keyword}{const} \textcolor{keywordtype}{bool} ignore\_comments = \textcolor{keyword}{false})}
\DoxyCodeLine{23245     \{}
\DoxyCodeLine{23246         \textcolor{keywordflow}{return} parser(i.get(), \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, ignore\_comments).accept(\textcolor{keyword}{true});}
\DoxyCodeLine{23247     \}}
\DoxyCodeLine{23248 }
\DoxyCodeLine{23251     \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputType, \textcolor{keyword}{typename} SAX>}
\DoxyCodeLine{23252     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{23253     static \textcolor{keywordtype}{bool} sax\_parse(InputType\&\& i, SAX* sax,}
\DoxyCodeLine{23254                           input\_format\_t format = input\_format\_t::\mbox{\hyperlink{classbasic__json}{json}},}
\DoxyCodeLine{23255                           const \textcolor{keywordtype}{bool} strict = true,}
\DoxyCodeLine{23256                           const \textcolor{keywordtype}{bool} ignore\_comments = false)}
\DoxyCodeLine{23257     \{}
\DoxyCodeLine{23258         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::forward<InputType>(i));}
\DoxyCodeLine{23259         \textcolor{keywordflow}{return} format == input\_format\_t::json}
\DoxyCodeLine{23260                ? parser(std::move(ia), \textcolor{keyword}{nullptr}, \textcolor{keyword}{true}, ignore\_comments).sax\_parse(sax, strict)}
\DoxyCodeLine{23261                : \mbox{\hyperlink{classdetail_1_1binary__reader}{detail::binary\_reader<basic\_json, decltype(ia), SAX>}}(std::move(ia), format).\mbox{\hyperlink{classdetail_1_1binary__reader_a8e1b5452ae426e1d7b48761859e7f52d}{sax\_parse}}(format, sax, strict);}
\DoxyCodeLine{23262     \}}
\DoxyCodeLine{23263 }
\DoxyCodeLine{23266     \textcolor{keyword}{template}<\textcolor{keyword}{class} IteratorType, \textcolor{keyword}{class} SAX>}
\DoxyCodeLine{23267     JSON\_HEDLEY\_NON\_NULL(3)}
\DoxyCodeLine{23268     static \textcolor{keywordtype}{bool} sax\_parse(IteratorType first, IteratorType last, SAX* sax,}
\DoxyCodeLine{23269                           \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format = \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}}::\mbox{\hyperlink{classbasic__json}{json}},}
\DoxyCodeLine{23270                           const \textcolor{keywordtype}{bool} strict = true,}
\DoxyCodeLine{23271                           const \textcolor{keywordtype}{bool} ignore\_comments = false)}
\DoxyCodeLine{23272     \{}
\DoxyCodeLine{23273         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::move(first), std::move(last));}
\DoxyCodeLine{23274         \textcolor{keywordflow}{return} format == input\_format\_t::json}
\DoxyCodeLine{23275                ? parser(std::move(ia), \textcolor{keyword}{nullptr}, \textcolor{keyword}{true}, ignore\_comments).sax\_parse(sax, strict)}
\DoxyCodeLine{23276                : \mbox{\hyperlink{classdetail_1_1binary__reader}{detail::binary\_reader<basic\_json, decltype(ia), SAX>}}(std::move(ia), format).\mbox{\hyperlink{classdetail_1_1binary__reader_a8e1b5452ae426e1d7b48761859e7f52d}{sax\_parse}}(format, sax, strict);}
\DoxyCodeLine{23277     \}}
\DoxyCodeLine{23278 }
\DoxyCodeLine{23284     \textcolor{keyword}{template} <\textcolor{keyword}{typename} SAX>}
\DoxyCodeLine{23285     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, sax\_parse(ptr, ptr + len, ...))}
\DoxyCodeLine{23286     JSON\_HEDLEY\_NON\_NULL(2)}
\DoxyCodeLine{23287     static \textcolor{keywordtype}{bool} sax\_parse(\mbox{\hyperlink{namespacedetail}{detail}}::span\_input\_adapter\&\& i, SAX* sax,}
\DoxyCodeLine{23288                           \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}} format = \mbox{\hyperlink{namespacedetail_a0ab3b338d0eadc6890b72cccef0ea04f}{input\_format\_t}}::\mbox{\hyperlink{classbasic__json}{json}},}
\DoxyCodeLine{23289                           const \textcolor{keywordtype}{bool} strict = true,}
\DoxyCodeLine{23290                           const \textcolor{keywordtype}{bool} ignore\_comments = false)}
\DoxyCodeLine{23291     \{}
\DoxyCodeLine{23292         \textcolor{keyword}{auto} ia = i.get();}
\DoxyCodeLine{23293         \textcolor{keywordflow}{return} format == input\_format\_t::json}
\DoxyCodeLine{23294                \textcolor{comment}{// NOLINTNEXTLINE(hicpp-\/move-\/const-\/arg,performance-\/move-\/const-\/arg)}}
\DoxyCodeLine{23295                ? parser(std::move(ia), \textcolor{keyword}{nullptr}, \textcolor{keyword}{true}, ignore\_comments).sax\_parse(sax, strict)}
\DoxyCodeLine{23296                \textcolor{comment}{// NOLINTNEXTLINE(hicpp-\/move-\/const-\/arg,performance-\/move-\/const-\/arg)}}
\DoxyCodeLine{23297                : \mbox{\hyperlink{classdetail_1_1binary__reader}{detail::binary\_reader<basic\_json, decltype(ia), SAX>}}(std::move(ia), format).\mbox{\hyperlink{classdetail_1_1binary__reader_a8e1b5452ae426e1d7b48761859e7f52d}{sax\_parse}}(format, sax, strict);}
\DoxyCodeLine{23298     \}}
\DoxyCodeLine{23299 \textcolor{preprocessor}{\#ifndef JSON\_NO\_IO}}
\DoxyCodeLine{23306     JSON\_HEDLEY\_DEPRECATED\_FOR(3.0.0, \textcolor{keyword}{operator}>>(std::istream\&, \mbox{\hyperlink{classbasic__json}{basic\_json}}\&))}
\DoxyCodeLine{23307     friend std::istream\& operator<<(\mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, std::istream\& i)}
\DoxyCodeLine{23308     \{}
\DoxyCodeLine{23309         \textcolor{keywordflow}{return} operator>>(i, j);}
\DoxyCodeLine{23310     \}}
\DoxyCodeLine{23311 }
\DoxyCodeLine{23314     \textcolor{keyword}{friend} std::istream\& \mbox{\hyperlink{classbasic__json_aea0de29387d532e0bc5f2475cb83995d}{operator>>}}(std::istream\& i, \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j)}
\DoxyCodeLine{23315     \{}
\DoxyCodeLine{23316         parser(detail::input\_adapter(i)).parse(\textcolor{keyword}{false}, j);}
\DoxyCodeLine{23317         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{23318     \}}
\DoxyCodeLine{23319 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// JSON\_NO\_IO}}
\DoxyCodeLine{23321 \textcolor{comment}{}}
\DoxyCodeLine{23323     \textcolor{comment}{// convenience functions //}}
\DoxyCodeLine{23325 \textcolor{comment}{}}
\DoxyCodeLine{23328     JSON\_HEDLEY\_RETURNS\_NON\_NULL}
\DoxyCodeLine{23329     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \mbox{\hyperlink{classbasic__json_a7528ae3cfe082b3e6280eb5dfab4700b}{type\_name}}() const noexcept}
\DoxyCodeLine{23330     \{}
\DoxyCodeLine{23331         \textcolor{keywordflow}{switch} (m\_type)}
\DoxyCodeLine{23332         \{}
\DoxyCodeLine{23333             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{23334                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}null"{}};}
\DoxyCodeLine{23335             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{23336                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}object"{}};}
\DoxyCodeLine{23337             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{23338                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}array"{}};}
\DoxyCodeLine{23339             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{23340                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}string"{}};}
\DoxyCodeLine{23341             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{23342                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}boolean"{}};}
\DoxyCodeLine{23343             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{23344                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}binary"{}};}
\DoxyCodeLine{23345             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{23346                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}discarded"{}};}
\DoxyCodeLine{23347             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{23348             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{23349             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{23350             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{23351                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}number"{}};}
\DoxyCodeLine{23352         \}}
\DoxyCodeLine{23353     \}}
\DoxyCodeLine{23354 }
\DoxyCodeLine{23355 }
\DoxyCodeLine{23356   JSON\_PRIVATE\_UNLESS\_TESTED:}
\DoxyCodeLine{23358     \textcolor{comment}{// member variables //}}
\DoxyCodeLine{23360 \textcolor{comment}{}}
\DoxyCodeLine{23362     value\_t m\_type = value\_t::null;}
\DoxyCodeLine{23363 }
\DoxyCodeLine{23365     json\_value m\_value = \{\};}
\DoxyCodeLine{23366 }
\DoxyCodeLine{23367 \textcolor{preprocessor}{\#if JSON\_DIAGNOSTICS}}
\DoxyCodeLine{23369     \mbox{\hyperlink{classbasic__json}{basic\_json}}* m\_parent = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{23370 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{23371 }
\DoxyCodeLine{23373     \textcolor{comment}{// binary serialization/deserialization //}}
\DoxyCodeLine{23375 \textcolor{comment}{}}
\DoxyCodeLine{23378 }
\DoxyCodeLine{23379   \textcolor{keyword}{public}:}
\DoxyCodeLine{23382     \textcolor{keyword}{static} std::vector<std::uint8\_t> \mbox{\hyperlink{classbasic__json_a12a270a8c98f23f838837562ddde18a8}{to\_cbor}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j)}
\DoxyCodeLine{23383     \{}
\DoxyCodeLine{23384         std::vector<std::uint8\_t> result;}
\DoxyCodeLine{23385         to\_cbor(j, result);}
\DoxyCodeLine{23386         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{23387     \}}
\DoxyCodeLine{23388 }
\DoxyCodeLine{23391     \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a91e6116b577c4a402d0bf59ceb1ce3b6}{to\_cbor}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, \mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<std::uint8\_t>}} o)}
\DoxyCodeLine{23392     \{}
\DoxyCodeLine{23393         binary\_writer<std::uint8\_t>(o).write\_cbor(j);}
\DoxyCodeLine{23394     \}}
\DoxyCodeLine{23395 }
\DoxyCodeLine{23398     \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a4b49f22c2c0ed2c803c695f328ee5f4f}{to\_cbor}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, \mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<char>}} o)}
\DoxyCodeLine{23399     \{}
\DoxyCodeLine{23400         binary\_writer<char>(o).write\_cbor(j);}
\DoxyCodeLine{23401     \}}
\DoxyCodeLine{23402 }
\DoxyCodeLine{23405     \textcolor{keyword}{static} std::vector<std::uint8\_t> \mbox{\hyperlink{classbasic__json_a4d510f5c39b036deb96e61c8bef19f31}{to\_msgpack}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j)}
\DoxyCodeLine{23406     \{}
\DoxyCodeLine{23407         std::vector<std::uint8\_t> result;}
\DoxyCodeLine{23408         to\_msgpack(j, result);}
\DoxyCodeLine{23409         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{23410     \}}
\DoxyCodeLine{23411 }
\DoxyCodeLine{23414     \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_ad91a270a87e6aec97c18d44aaddf0d33}{to\_msgpack}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, \mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<std::uint8\_t>}} o)}
\DoxyCodeLine{23415     \{}
\DoxyCodeLine{23416         binary\_writer<std::uint8\_t>(o).write\_msgpack(j);}
\DoxyCodeLine{23417     \}}
\DoxyCodeLine{23418 }
\DoxyCodeLine{23421     \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a7e3ec809212107cb5809c386c5e3dce3}{to\_msgpack}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, \mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<char>}} o)}
\DoxyCodeLine{23422     \{}
\DoxyCodeLine{23423         binary\_writer<char>(o).write\_msgpack(j);}
\DoxyCodeLine{23424     \}}
\DoxyCodeLine{23425 }
\DoxyCodeLine{23428     \textcolor{keyword}{static} std::vector<std::uint8\_t> \mbox{\hyperlink{classbasic__json_a74a0e7569fb3170e0151e4aca3f4bf3b}{to\_ubjson}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j,}
\DoxyCodeLine{23429             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_size = \textcolor{keyword}{false},}
\DoxyCodeLine{23430             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_type = \textcolor{keyword}{false})}
\DoxyCodeLine{23431     \{}
\DoxyCodeLine{23432         std::vector<std::uint8\_t> result;}
\DoxyCodeLine{23433         to\_ubjson(j, result, use\_size, use\_type);}
\DoxyCodeLine{23434         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{23435     \}}
\DoxyCodeLine{23436 }
\DoxyCodeLine{23439     \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_ad7567f6b4b51d3bc1cbe6a80cd6ca9a8}{to\_ubjson}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, \mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<std::uint8\_t>}} o,}
\DoxyCodeLine{23440                           \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_size = \textcolor{keyword}{false}, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_type = \textcolor{keyword}{false})}
\DoxyCodeLine{23441     \{}
\DoxyCodeLine{23442         binary\_writer<std::uint8\_t>(o).write\_ubjson(j, use\_size, use\_type);}
\DoxyCodeLine{23443     \}}
\DoxyCodeLine{23444 }
\DoxyCodeLine{23447     \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a81aecae4901eb995b22ee6abccf94122}{to\_ubjson}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, \mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<char>}} o,}
\DoxyCodeLine{23448                           \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_size = \textcolor{keyword}{false}, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_type = \textcolor{keyword}{false})}
\DoxyCodeLine{23449     \{}
\DoxyCodeLine{23450         binary\_writer<char>(o).write\_ubjson(j, use\_size, use\_type);}
\DoxyCodeLine{23451     \}}
\DoxyCodeLine{23452 }
\DoxyCodeLine{23455     \textcolor{keyword}{static} std::vector<std::uint8\_t> \mbox{\hyperlink{classbasic__json_a2b222d92f075b0033a76a60ccb36269c}{to\_bjdata}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j,}
\DoxyCodeLine{23456             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_size = \textcolor{keyword}{false},}
\DoxyCodeLine{23457             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_type = \textcolor{keyword}{false})}
\DoxyCodeLine{23458     \{}
\DoxyCodeLine{23459         std::vector<std::uint8\_t> result;}
\DoxyCodeLine{23460         to\_bjdata(j, result, use\_size, use\_type);}
\DoxyCodeLine{23461         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{23462     \}}
\DoxyCodeLine{23463 }
\DoxyCodeLine{23466     \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a9b4a7117f98423b6d92e48951a7e3c55}{to\_bjdata}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, \mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<std::uint8\_t>}} o,}
\DoxyCodeLine{23467                           \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_size = \textcolor{keyword}{false}, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_type = \textcolor{keyword}{false})}
\DoxyCodeLine{23468     \{}
\DoxyCodeLine{23469         binary\_writer<std::uint8\_t>(o).write\_ubjson(j, use\_size, use\_type, \textcolor{keyword}{true}, \textcolor{keyword}{true});}
\DoxyCodeLine{23470     \}}
\DoxyCodeLine{23471 }
\DoxyCodeLine{23474     \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a9c66ff3a69ef4e4d0d1c136d4226c6af}{to\_bjdata}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, \mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<char>}} o,}
\DoxyCodeLine{23475                           \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_size = \textcolor{keyword}{false}, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} use\_type = \textcolor{keyword}{false})}
\DoxyCodeLine{23476     \{}
\DoxyCodeLine{23477         binary\_writer<char>(o).write\_ubjson(j, use\_size, use\_type, \textcolor{keyword}{true}, \textcolor{keyword}{true});}
\DoxyCodeLine{23478     \}}
\DoxyCodeLine{23479 }
\DoxyCodeLine{23482     \textcolor{keyword}{static} std::vector<std::uint8\_t> \mbox{\hyperlink{classbasic__json_a85f418313f92075a0ab72060bfe4de06}{to\_bson}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j)}
\DoxyCodeLine{23483     \{}
\DoxyCodeLine{23484         std::vector<std::uint8\_t> result;}
\DoxyCodeLine{23485         to\_bson(j, result);}
\DoxyCodeLine{23486         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{23487     \}}
\DoxyCodeLine{23488 }
\DoxyCodeLine{23491     \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_ad5ff725ab08638fbc83ed7e3c7c41396}{to\_bson}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, \mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<std::uint8\_t>}} o)}
\DoxyCodeLine{23492     \{}
\DoxyCodeLine{23493         binary\_writer<std::uint8\_t>(o).write\_bson(j);}
\DoxyCodeLine{23494     \}}
\DoxyCodeLine{23495 }
\DoxyCodeLine{23498     \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a62bb643538ab0e016a2f319e22bf4c4d}{to\_bson}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& j, \mbox{\hyperlink{classdetail_1_1output__adapter}{detail::output\_adapter<char>}} o)}
\DoxyCodeLine{23499     \{}
\DoxyCodeLine{23500         binary\_writer<char>(o).write\_bson(j);}
\DoxyCodeLine{23501     \}}
\DoxyCodeLine{23502 }
\DoxyCodeLine{23505     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>}
\DoxyCodeLine{23506     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23507     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a84e2d9cbd8a385017bb3d91c45a1753a}{from\_cbor}}(InputType\&\& i,}
\DoxyCodeLine{23508                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23509                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true},}
\DoxyCodeLine{23510                                 \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}} tag\_handler = cbor\_tag\_handler\_t::error)}
\DoxyCodeLine{23511     \{}
\DoxyCodeLine{23512         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23513         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23514         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::forward<InputType>(i));}
\DoxyCodeLine{23515         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::cbor).sax\_parse(input\_format\_t::cbor, \&sdp, strict, tag\_handler);}
\DoxyCodeLine{23516         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23517     \}}
\DoxyCodeLine{23518 }
\DoxyCodeLine{23521     \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{23522     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23523     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a93872bc620a9bbe028be81a3eaae21f3}{from\_cbor}}(IteratorType first, IteratorType last,}
\DoxyCodeLine{23524                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23525                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true},}
\DoxyCodeLine{23526                                 \textcolor{keyword}{const} \mbox{\hyperlink{namespacedetail_a7c070b2bf3d61e3d8b8013f6fb18d592}{cbor\_tag\_handler\_t}} tag\_handler = cbor\_tag\_handler\_t::error)}
\DoxyCodeLine{23527     \{}
\DoxyCodeLine{23528         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23529         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23530         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::move(first), std::move(last));}
\DoxyCodeLine{23531         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::cbor).sax\_parse(input\_format\_t::cbor, \&sdp, strict, tag\_handler);}
\DoxyCodeLine{23532         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23533     \}}
\DoxyCodeLine{23534 }
\DoxyCodeLine{23535     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{23536     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23537     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, from\_cbor(ptr, ptr + len))}
\DoxyCodeLine{23538     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} from\_cbor(\textcolor{keyword}{const} T* ptr, std::size\_t len,}
\DoxyCodeLine{23539                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23540                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true},}
\DoxyCodeLine{23541                                 \textcolor{keyword}{const} cbor\_tag\_handler\_t tag\_handler = cbor\_tag\_handler\_t::error)}
\DoxyCodeLine{23542     \{}
\DoxyCodeLine{23543         \textcolor{keywordflow}{return} from\_cbor(ptr, ptr + len, strict, allow\_exceptions, tag\_handler);}
\DoxyCodeLine{23544     \}}
\DoxyCodeLine{23545 }
\DoxyCodeLine{23546 }
\DoxyCodeLine{23547     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23548     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, from\_cbor(ptr, ptr + len))}
\DoxyCodeLine{23549     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} from\_cbor(\mbox{\hyperlink{classdetail_1_1span__input__adapter}{detail::span\_input\_adapter}}\&\& i,}
\DoxyCodeLine{23550                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23551                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true},}
\DoxyCodeLine{23552                                 \textcolor{keyword}{const} cbor\_tag\_handler\_t tag\_handler = cbor\_tag\_handler\_t::error)}
\DoxyCodeLine{23553     \{}
\DoxyCodeLine{23554         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23555         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23556         \textcolor{keyword}{auto} ia = i.get();}
\DoxyCodeLine{23557         \textcolor{comment}{// NOLINTNEXTLINE(hicpp-\/move-\/const-\/arg,performance-\/move-\/const-\/arg)}}
\DoxyCodeLine{23558         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::cbor).sax\_parse(input\_format\_t::cbor, \&sdp, strict, tag\_handler);}
\DoxyCodeLine{23559         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23560     \}}
\DoxyCodeLine{23561 }
\DoxyCodeLine{23564     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>}
\DoxyCodeLine{23565     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23566     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a96ba0ffab9429d589d658d3e053b8273}{from\_msgpack}}(InputType\&\& i,}
\DoxyCodeLine{23567                                    \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23568                                    \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23569     \{}
\DoxyCodeLine{23570         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23571         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23572         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::forward<InputType>(i));}
\DoxyCodeLine{23573         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::msgpack).sax\_parse(input\_format\_t::msgpack, \&sdp, strict);}
\DoxyCodeLine{23574         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23575     \}}
\DoxyCodeLine{23576 }
\DoxyCodeLine{23579     \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{23580     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23581     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a7f3794747f5b19e0504afa3585476e97}{from\_msgpack}}(IteratorType first, IteratorType last,}
\DoxyCodeLine{23582                                    \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23583                                    \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23584     \{}
\DoxyCodeLine{23585         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23586         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23587         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::move(first), std::move(last));}
\DoxyCodeLine{23588         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::msgpack).sax\_parse(input\_format\_t::msgpack, \&sdp, strict);}
\DoxyCodeLine{23589         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23590     \}}
\DoxyCodeLine{23591 }
\DoxyCodeLine{23592     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{23593     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23594     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, from\_msgpack(ptr, ptr + len))}
\DoxyCodeLine{23595     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} from\_msgpack(\textcolor{keyword}{const} T* ptr, std::size\_t len,}
\DoxyCodeLine{23596                                    \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23597                                    \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23598     \{}
\DoxyCodeLine{23599         \textcolor{keywordflow}{return} from\_msgpack(ptr, ptr + len, strict, allow\_exceptions);}
\DoxyCodeLine{23600     \}}
\DoxyCodeLine{23601 }
\DoxyCodeLine{23602     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23603     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, from\_msgpack(ptr, ptr + len))}
\DoxyCodeLine{23604     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} from\_msgpack(\mbox{\hyperlink{classdetail_1_1span__input__adapter}{detail::span\_input\_adapter}}\&\& i,}
\DoxyCodeLine{23605                                    \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23606                                    \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23607     \{}
\DoxyCodeLine{23608         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23609         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23610         \textcolor{keyword}{auto} ia = i.get();}
\DoxyCodeLine{23611         \textcolor{comment}{// NOLINTNEXTLINE(hicpp-\/move-\/const-\/arg,performance-\/move-\/const-\/arg)}}
\DoxyCodeLine{23612         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::msgpack).sax\_parse(input\_format\_t::msgpack, \&sdp, strict);}
\DoxyCodeLine{23613         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23614     \}}
\DoxyCodeLine{23615 }
\DoxyCodeLine{23618     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>}
\DoxyCodeLine{23619     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23620     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a662ee4905d8c2628b3018b378bbd4c9e}{from\_ubjson}}(InputType\&\& i,}
\DoxyCodeLine{23621                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23622                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23623     \{}
\DoxyCodeLine{23624         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23625         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23626         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::forward<InputType>(i));}
\DoxyCodeLine{23627         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::ubjson).sax\_parse(input\_format\_t::ubjson, \&sdp, strict);}
\DoxyCodeLine{23628         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23629     \}}
\DoxyCodeLine{23630 }
\DoxyCodeLine{23633     \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{23634     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23635     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_ad36123b583eaae095ee46413e4e380ef}{from\_ubjson}}(IteratorType first, IteratorType last,}
\DoxyCodeLine{23636                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23637                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23638     \{}
\DoxyCodeLine{23639         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23640         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23641         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::move(first), std::move(last));}
\DoxyCodeLine{23642         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::ubjson).sax\_parse(input\_format\_t::ubjson, \&sdp, strict);}
\DoxyCodeLine{23643         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23644     \}}
\DoxyCodeLine{23645 }
\DoxyCodeLine{23646     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{23647     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23648     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, from\_ubjson(ptr, ptr + len))}
\DoxyCodeLine{23649     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} from\_ubjson(\textcolor{keyword}{const} T* ptr, std::size\_t len,}
\DoxyCodeLine{23650                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23651                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23652     \{}
\DoxyCodeLine{23653         \textcolor{keywordflow}{return} from\_ubjson(ptr, ptr + len, strict, allow\_exceptions);}
\DoxyCodeLine{23654     \}}
\DoxyCodeLine{23655 }
\DoxyCodeLine{23656     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23657     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, from\_ubjson(ptr, ptr + len))}
\DoxyCodeLine{23658     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} from\_ubjson(\mbox{\hyperlink{classdetail_1_1span__input__adapter}{detail::span\_input\_adapter}}\&\& i,}
\DoxyCodeLine{23659                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23660                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23661     \{}
\DoxyCodeLine{23662         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23663         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23664         \textcolor{keyword}{auto} ia = i.get();}
\DoxyCodeLine{23665         \textcolor{comment}{// NOLINTNEXTLINE(hicpp-\/move-\/const-\/arg,performance-\/move-\/const-\/arg)}}
\DoxyCodeLine{23666         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::ubjson).sax\_parse(input\_format\_t::ubjson, \&sdp, strict);}
\DoxyCodeLine{23667         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23668     \}}
\DoxyCodeLine{23669 }
\DoxyCodeLine{23670 }
\DoxyCodeLine{23673     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>}
\DoxyCodeLine{23674     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23675     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_affeac471308bec4cfe026258f746cfcc}{from\_bjdata}}(InputType\&\& i,}
\DoxyCodeLine{23676                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23677                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23678     \{}
\DoxyCodeLine{23679         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23680         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23681         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::forward<InputType>(i));}
\DoxyCodeLine{23682         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::bjdata).sax\_parse(input\_format\_t::bjdata, \&sdp, strict);}
\DoxyCodeLine{23683         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23684     \}}
\DoxyCodeLine{23685 }
\DoxyCodeLine{23688     \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{23689     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23690     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a94c00d3023a03b37d9a362cdf61c17c1}{from\_bjdata}}(IteratorType first, IteratorType last,}
\DoxyCodeLine{23691                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23692                                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23693     \{}
\DoxyCodeLine{23694         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23695         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23696         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::move(first), std::move(last));}
\DoxyCodeLine{23697         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::bjdata).sax\_parse(input\_format\_t::bjdata, \&sdp, strict);}
\DoxyCodeLine{23698         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23699     \}}
\DoxyCodeLine{23700 }
\DoxyCodeLine{23703     \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputType>}
\DoxyCodeLine{23704     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23705     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a5ac8b0effce93dad2e3eec9c1a7ed129}{from\_bson}}(InputType\&\& i,}
\DoxyCodeLine{23706                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23707                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23708     \{}
\DoxyCodeLine{23709         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23710         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23711         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::forward<InputType>(i));}
\DoxyCodeLine{23712         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::bson).sax\_parse(input\_format\_t::bson, \&sdp, strict);}
\DoxyCodeLine{23713         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23714     \}}
\DoxyCodeLine{23715 }
\DoxyCodeLine{23718     \textcolor{keyword}{template}<\textcolor{keyword}{typename} IteratorType>}
\DoxyCodeLine{23719     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23720     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a06c87b306915435958b5e584dfb80ce4}{from\_bson}}(IteratorType first, IteratorType last,}
\DoxyCodeLine{23721                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23722                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23723     \{}
\DoxyCodeLine{23724         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23725         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23726         \textcolor{keyword}{auto} ia = detail::input\_adapter(std::move(first), std::move(last));}
\DoxyCodeLine{23727         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::bson).sax\_parse(input\_format\_t::bson, \&sdp, strict);}
\DoxyCodeLine{23728         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23729     \}}
\DoxyCodeLine{23730 }
\DoxyCodeLine{23731     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{23732     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23733     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, from\_bson(ptr, ptr + len))}
\DoxyCodeLine{23734     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} from\_bson(\textcolor{keyword}{const} T* ptr, std::size\_t len,}
\DoxyCodeLine{23735                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23736                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23737     \{}
\DoxyCodeLine{23738         \textcolor{keywordflow}{return} from\_bson(ptr, ptr + len, strict, allow\_exceptions);}
\DoxyCodeLine{23739     \}}
\DoxyCodeLine{23740 }
\DoxyCodeLine{23741     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{23742     JSON\_HEDLEY\_DEPRECATED\_FOR(3.8.0, from\_bson(ptr, ptr + len))}
\DoxyCodeLine{23743     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} from\_bson(\mbox{\hyperlink{classdetail_1_1span__input__adapter}{detail::span\_input\_adapter}}\&\& i,}
\DoxyCodeLine{23744                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} strict = \textcolor{keyword}{true},}
\DoxyCodeLine{23745                                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} allow\_exceptions = \textcolor{keyword}{true})}
\DoxyCodeLine{23746     \{}
\DoxyCodeLine{23747         \mbox{\hyperlink{classbasic__json}{basic\_json}} result;}
\DoxyCodeLine{23748         \mbox{\hyperlink{classdetail_1_1json__sax__dom__parser}{detail::json\_sax\_dom\_parser<basic\_json>}} sdp(result, allow\_exceptions);}
\DoxyCodeLine{23749         \textcolor{keyword}{auto} ia = i.get();}
\DoxyCodeLine{23750         \textcolor{comment}{// NOLINTNEXTLINE(hicpp-\/move-\/const-\/arg,performance-\/move-\/const-\/arg)}}
\DoxyCodeLine{23751         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} res = binary\_reader<decltype(ia)>(std::move(ia), input\_format\_t::bson).sax\_parse(input\_format\_t::bson, \&sdp, strict);}
\DoxyCodeLine{23752         \textcolor{keywordflow}{return} res ? result : \mbox{\hyperlink{classbasic__json}{basic\_json}}(value\_t::discarded);}
\DoxyCodeLine{23753     \}}
\DoxyCodeLine{23755 }
\DoxyCodeLine{23757     \textcolor{comment}{// JSON Pointer support //}}
\DoxyCodeLine{23759 \textcolor{comment}{}}
\DoxyCodeLine{23762 }
\DoxyCodeLine{23765     \mbox{\hyperlink{classbasic__json}{reference}} \mbox{\hyperlink{classbasic__json_a2f0b9af87d5c9c8bed6dc0e165af3147}{operator[]}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& ptr)}
\DoxyCodeLine{23766     \{}
\DoxyCodeLine{23767         \textcolor{keywordflow}{return} ptr.get\_unchecked(\textcolor{keyword}{this});}
\DoxyCodeLine{23768     \}}
\DoxyCodeLine{23769 }
\DoxyCodeLine{23770     template<typename BasicJsonType, detail::enable\_if\_t<detail::is\_basic\_json<BasicJsonType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{23771     JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.0, \mbox{\hyperlink{classbasic__json_a7c7e3533ab09b9e9d24a516379961a93}{basic\_json::json\_pointer}} or nlohmann::json\_pointer<basic\_json::string\_t>) \textcolor{comment}{// NOLINT(readability/alt\_tokens)}}
\DoxyCodeLine{23772     reference operator[](const ::nlohmann::json\_pointer<BasicJsonType>\& ptr)}
\DoxyCodeLine{23773     \{}
\DoxyCodeLine{23774         \textcolor{keywordflow}{return} ptr.get\_unchecked(\textcolor{keyword}{this});}
\DoxyCodeLine{23775     \}}
\DoxyCodeLine{23776 }
\DoxyCodeLine{23779     \mbox{\hyperlink{classbasic__json}{const\_reference}} \mbox{\hyperlink{classbasic__json_a9ba36b6659d266fd0299446a20b611d9}{operator[]}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{23780 \textcolor{keyword}{    }\{}
\DoxyCodeLine{23781         \textcolor{keywordflow}{return} ptr.get\_unchecked(\textcolor{keyword}{this});}
\DoxyCodeLine{23782     \}}
\DoxyCodeLine{23783 }
\DoxyCodeLine{23784     template<typename BasicJsonType, detail::enable\_if\_t<detail::is\_basic\_json<BasicJsonType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{23785     \mbox{\hyperlink{classbasic__json_a9bbd9e1d431316722cf550ffec328d39}{JSON\_HEDLEY\_DEPRECATED\_FOR}}(3.11.0, \mbox{\hyperlink{classbasic__json_a7c7e3533ab09b9e9d24a516379961a93}{basic\_json::json\_pointer}} or nlohmann::json\_pointer<basic\_json::string\_t>) \textcolor{comment}{// NOLINT(readability/alt\_tokens)}}
\DoxyCodeLine{23786     \mbox{\hyperlink{classbasic__json}{const\_reference}} operator[](const ::nlohmann::json\_pointer<BasicJsonType>\& ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{23787 \textcolor{keyword}{    }\{}
\DoxyCodeLine{23788         \textcolor{keywordflow}{return} ptr.get\_unchecked(\textcolor{keyword}{this});}
\DoxyCodeLine{23789     \}}
\DoxyCodeLine{23790 }
\DoxyCodeLine{23793     reference at(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& ptr)}
\DoxyCodeLine{23794     \{}
\DoxyCodeLine{23795         \textcolor{keywordflow}{return} ptr.get\_checked(\textcolor{keyword}{this});}
\DoxyCodeLine{23796     \}}
\DoxyCodeLine{23797 }
\DoxyCodeLine{23798     template<typename BasicJsonType, detail::enable\_if\_t<detail::is\_basic\_json<BasicJsonType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{23799     JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.0, \mbox{\hyperlink{classbasic__json_a7c7e3533ab09b9e9d24a516379961a93}{basic\_json::json\_pointer}} or nlohmann::json\_pointer<basic\_json::string\_t>) \textcolor{comment}{// NOLINT(readability/alt\_tokens)}}
\DoxyCodeLine{23800     reference at(const ::nlohmann::json\_pointer<BasicJsonType>\& ptr)}
\DoxyCodeLine{23801     \{}
\DoxyCodeLine{23802         \textcolor{keywordflow}{return} ptr.get\_checked(\textcolor{keyword}{this});}
\DoxyCodeLine{23803     \}}
\DoxyCodeLine{23804 }
\DoxyCodeLine{23807     \mbox{\hyperlink{classbasic__json}{const\_reference}} \mbox{\hyperlink{classbasic__json_ac7d4becb69fb528514395b46d123b69a}{at}}(\textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}}\& ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{23808 \textcolor{keyword}{    }\{}
\DoxyCodeLine{23809         \textcolor{keywordflow}{return} ptr.get\_checked(\textcolor{keyword}{this});}
\DoxyCodeLine{23810     \}}
\DoxyCodeLine{23811 }
\DoxyCodeLine{23812     template<typename BasicJsonType, detail::enable\_if\_t<detail::is\_basic\_json<BasicJsonType>::value, \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{23813     JSON\_HEDLEY\_DEPRECATED\_FOR(3.11.0, \mbox{\hyperlink{classbasic__json_a7c7e3533ab09b9e9d24a516379961a93}{basic\_json::json\_pointer}} or nlohmann::json\_pointer<basic\_json::string\_t>) \textcolor{comment}{// NOLINT(readability/alt\_tokens)}}
\DoxyCodeLine{23814     const\_reference at(const ::nlohmann::json\_pointer<BasicJsonType>\& ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{23815 \textcolor{keyword}{    }\{}
\DoxyCodeLine{23816         \textcolor{keywordflow}{return} ptr.get\_checked(\textcolor{keyword}{this});}
\DoxyCodeLine{23817     \}}
\DoxyCodeLine{23818 }
\DoxyCodeLine{23821     \mbox{\hyperlink{classbasic__json}{basic\_json}} flatten()\textcolor{keyword}{ const}}
\DoxyCodeLine{23822 \textcolor{keyword}{    }\{}
\DoxyCodeLine{23823         \mbox{\hyperlink{classbasic__json}{basic\_json}} result(value\_t::object);}
\DoxyCodeLine{23824         json\_pointer::flatten(\textcolor{stringliteral}{"{}"{}}, *\textcolor{keyword}{this}, result);}
\DoxyCodeLine{23825         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{23826     \}}
\DoxyCodeLine{23827 }
\DoxyCodeLine{23830     \mbox{\hyperlink{classbasic__json}{basic\_json}} unflatten()\textcolor{keyword}{ const}}
\DoxyCodeLine{23831 \textcolor{keyword}{    }\{}
\DoxyCodeLine{23832         \textcolor{keywordflow}{return} json\_pointer::unflatten(*\textcolor{keyword}{this});}
\DoxyCodeLine{23833     \}}
\DoxyCodeLine{23834 }
\DoxyCodeLine{23836 }
\DoxyCodeLine{23838     \textcolor{comment}{// JSON Patch functions //}}
\DoxyCodeLine{23840 \textcolor{comment}{}}
\DoxyCodeLine{23843 }
\DoxyCodeLine{23846     \textcolor{keywordtype}{void} patch\_inplace(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& json\_patch)}
\DoxyCodeLine{23847     \{}
\DoxyCodeLine{23848         \mbox{\hyperlink{classbasic__json}{basic\_json}}\& result = *\textcolor{keyword}{this};}
\DoxyCodeLine{23849         \textcolor{comment}{// the valid JSON Patch operations}}
\DoxyCodeLine{23850         \textcolor{keyword}{enum class} patch\_operations \{add, remove, \mbox{\hyperlink{namespacedetail_abe7cfa1fd8fa706ff4392bff9d1a8298a9dde360102c103867bd2f45872f1129c}{replace}}, move, copy, test, invalid\};}
\DoxyCodeLine{23851 }
\DoxyCodeLine{23852         \textcolor{keyword}{const} \textcolor{keyword}{auto} get\_op = [](\textcolor{keyword}{const} std::string \& op)}
\DoxyCodeLine{23853         \{}
\DoxyCodeLine{23854             \textcolor{keywordflow}{if} (op == \textcolor{stringliteral}{"{}add"{}})}
\DoxyCodeLine{23855             \{}
\DoxyCodeLine{23856                 \textcolor{keywordflow}{return} patch\_operations::add;}
\DoxyCodeLine{23857             \}}
\DoxyCodeLine{23858             \textcolor{keywordflow}{if} (op == \textcolor{stringliteral}{"{}remove"{}})}
\DoxyCodeLine{23859             \{}
\DoxyCodeLine{23860                 \textcolor{keywordflow}{return} patch\_operations::remove;}
\DoxyCodeLine{23861             \}}
\DoxyCodeLine{23862             \textcolor{keywordflow}{if} (op == \textcolor{stringliteral}{"{}replace"{}})}
\DoxyCodeLine{23863             \{}
\DoxyCodeLine{23864                 \textcolor{keywordflow}{return} patch\_operations::replace;}
\DoxyCodeLine{23865             \}}
\DoxyCodeLine{23866             \textcolor{keywordflow}{if} (op == \textcolor{stringliteral}{"{}move"{}})}
\DoxyCodeLine{23867             \{}
\DoxyCodeLine{23868                 \textcolor{keywordflow}{return} patch\_operations::move;}
\DoxyCodeLine{23869             \}}
\DoxyCodeLine{23870             \textcolor{keywordflow}{if} (op == \textcolor{stringliteral}{"{}copy"{}})}
\DoxyCodeLine{23871             \{}
\DoxyCodeLine{23872                 \textcolor{keywordflow}{return} patch\_operations::copy;}
\DoxyCodeLine{23873             \}}
\DoxyCodeLine{23874             \textcolor{keywordflow}{if} (op == \textcolor{stringliteral}{"{}test"{}})}
\DoxyCodeLine{23875             \{}
\DoxyCodeLine{23876                 \textcolor{keywordflow}{return} patch\_operations::test;}
\DoxyCodeLine{23877             \}}
\DoxyCodeLine{23878 }
\DoxyCodeLine{23879             \textcolor{keywordflow}{return} patch\_operations::invalid;}
\DoxyCodeLine{23880         \};}
\DoxyCodeLine{23881 }
\DoxyCodeLine{23882         \textcolor{comment}{// wrapper for "{}add"{} operation; add value at ptr}}
\DoxyCodeLine{23883         \textcolor{keyword}{const} \textcolor{keyword}{auto} operation\_add = [\&result](\mbox{\hyperlink{classjson__pointer}{json\_pointer}} \& ptr, \mbox{\hyperlink{classbasic__json}{basic\_json}} val)}
\DoxyCodeLine{23884         \{}
\DoxyCodeLine{23885             \textcolor{comment}{// adding to the root of the target document means replacing it}}
\DoxyCodeLine{23886             \textcolor{keywordflow}{if} (ptr.\mbox{\hyperlink{classjson__pointer_a5c3d08bd0a0e99c3377db33600c68a64}{empty}}())}
\DoxyCodeLine{23887             \{}
\DoxyCodeLine{23888                 result = val;}
\DoxyCodeLine{23889                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{23890             \}}
\DoxyCodeLine{23891 }
\DoxyCodeLine{23892             \textcolor{comment}{// make sure the top element of the pointer exists}}
\DoxyCodeLine{23893             \mbox{\hyperlink{classjson__pointer}{json\_pointer}} top\_pointer = ptr.top();}
\DoxyCodeLine{23894             \textcolor{keywordflow}{if} (top\_pointer != ptr)}
\DoxyCodeLine{23895             \{}
\DoxyCodeLine{23896                 result.\mbox{\hyperlink{classbasic__json_a603779687f401ad11de45f8397f92296}{at}}(top\_pointer);}
\DoxyCodeLine{23897             \}}
\DoxyCodeLine{23898 }
\DoxyCodeLine{23899             \textcolor{comment}{// get reference to parent of JSON pointer ptr}}
\DoxyCodeLine{23900             \textcolor{keyword}{const} \textcolor{keyword}{auto} last\_path = ptr.\mbox{\hyperlink{classjson__pointer_aba71e63e4032cfc46dd90aeb09e5cb0f}{back}}();}
\DoxyCodeLine{23901             ptr.\mbox{\hyperlink{classjson__pointer_a662118b470c87a1b564946c2602c49ce}{pop\_back}}();}
\DoxyCodeLine{23902             \textcolor{comment}{// parent must exist when performing patch add per RFC6902 specs}}
\DoxyCodeLine{23903             \mbox{\hyperlink{classbasic__json}{basic\_json}}\& parent = result.\mbox{\hyperlink{classbasic__json_a603779687f401ad11de45f8397f92296}{at}}(ptr);}
\DoxyCodeLine{23904 }
\DoxyCodeLine{23905             \textcolor{keywordflow}{switch} (parent.m\_type)}
\DoxyCodeLine{23906             \{}
\DoxyCodeLine{23907                 \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{23908                 \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{23909                 \{}
\DoxyCodeLine{23910                     \textcolor{comment}{// use operator[] to add value}}
\DoxyCodeLine{23911                     parent[last\_path] = val;}
\DoxyCodeLine{23912                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{23913                 \}}
\DoxyCodeLine{23914 }
\DoxyCodeLine{23915                 \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{23916                 \{}
\DoxyCodeLine{23917                     \textcolor{keywordflow}{if} (last\_path == \textcolor{stringliteral}{"{}-\/"{}})}
\DoxyCodeLine{23918                     \{}
\DoxyCodeLine{23919                         \textcolor{comment}{// special case: append to back}}
\DoxyCodeLine{23920                         parent.\mbox{\hyperlink{classbasic__json_a102e459f1d163cea963ed6fdda595cd3}{push\_back}}(val);}
\DoxyCodeLine{23921                     \}}
\DoxyCodeLine{23922                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{23923                     \{}
\DoxyCodeLine{23924                         \textcolor{keyword}{const} \textcolor{keyword}{auto} idx = json\_pointer::template array\_index<basic\_json\_t>(last\_path);}
\DoxyCodeLine{23925                         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(idx > parent.size()))}
\DoxyCodeLine{23926                         \{}
\DoxyCodeLine{23927                             \textcolor{comment}{// avoid undefined behavior}}
\DoxyCodeLine{23928                             JSON\_THROW(out\_of\_range::create(401, detail::concat(\textcolor{stringliteral}{"{}array index "{}}, std::to\_string(idx), \textcolor{stringliteral}{"{} is out of range"{}}), \&parent));}
\DoxyCodeLine{23929                         \}}
\DoxyCodeLine{23930 }
\DoxyCodeLine{23931                         \textcolor{comment}{// default case: insert add offset}}
\DoxyCodeLine{23932                         parent.\mbox{\hyperlink{classbasic__json_a4467ec0c7679150140f9d2f85e95bf4b}{insert}}(parent.begin() + \textcolor{keyword}{static\_cast<}difference\_type\textcolor{keyword}{>}(idx), val);}
\DoxyCodeLine{23933                     \}}
\DoxyCodeLine{23934                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{23935                 \}}
\DoxyCodeLine{23936 }
\DoxyCodeLine{23937                 \textcolor{comment}{// if there exists a parent it cannot be primitive}}
\DoxyCodeLine{23938                 \textcolor{keywordflow}{case} value\_t::string: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{23939                 \textcolor{keywordflow}{case} value\_t::boolean: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{23940                 \textcolor{keywordflow}{case} value\_t::number\_integer: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{23941                 \textcolor{keywordflow}{case} value\_t::number\_unsigned: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{23942                 \textcolor{keywordflow}{case} value\_t::number\_float: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{23943                 \textcolor{keywordflow}{case} value\_t::binary: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{23944                 \textcolor{keywordflow}{case} value\_t::discarded: \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{23945                 \textcolor{keywordflow}{default}:            \textcolor{comment}{// LCOV\_EXCL\_LINE}}
\DoxyCodeLine{23946                     JSON\_ASSERT(\textcolor{keyword}{false}); \textcolor{comment}{// NOLINT(cert-\/dcl03-\/c,hicpp-\/static-\/assert,misc-\/static-\/assert) LCOV\_EXCL\_LINE}}
\DoxyCodeLine{23947             \}}
\DoxyCodeLine{23948         \};}
\DoxyCodeLine{23949 }
\DoxyCodeLine{23950         \textcolor{comment}{// wrapper for "{}remove"{} operation; remove value at ptr}}
\DoxyCodeLine{23951         \textcolor{keyword}{const} \textcolor{keyword}{auto} operation\_remove = [\textcolor{keyword}{this}, \&result](\mbox{\hyperlink{classjson__pointer}{json\_pointer}} \& ptr)}
\DoxyCodeLine{23952         \{}
\DoxyCodeLine{23953             \textcolor{comment}{// get reference to parent of JSON pointer ptr}}
\DoxyCodeLine{23954             \textcolor{keyword}{const} \textcolor{keyword}{auto} last\_path = ptr.\mbox{\hyperlink{classjson__pointer_aba71e63e4032cfc46dd90aeb09e5cb0f}{back}}();}
\DoxyCodeLine{23955             ptr.\mbox{\hyperlink{classjson__pointer_a662118b470c87a1b564946c2602c49ce}{pop\_back}}();}
\DoxyCodeLine{23956             \mbox{\hyperlink{classbasic__json}{basic\_json}}\& parent = result.\mbox{\hyperlink{classbasic__json_a603779687f401ad11de45f8397f92296}{at}}(ptr);}
\DoxyCodeLine{23957 }
\DoxyCodeLine{23958             \textcolor{comment}{// remove child}}
\DoxyCodeLine{23959             \textcolor{keywordflow}{if} (parent.\mbox{\hyperlink{classbasic__json_af758a912346776b086abb82487b1d73b}{is\_object}}())}
\DoxyCodeLine{23960             \{}
\DoxyCodeLine{23961                 \textcolor{comment}{// perform range check}}
\DoxyCodeLine{23962                 \textcolor{keyword}{auto} it = parent.\mbox{\hyperlink{classbasic__json_a8ed11f83edce392fd94659b1102d078e}{find}}(last\_path);}
\DoxyCodeLine{23963                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_LIKELY(it != parent.end()))}
\DoxyCodeLine{23964                 \{}
\DoxyCodeLine{23965                     parent.\mbox{\hyperlink{classbasic__json_a7a5ed019983b582705ef5ee43d15ca24}{erase}}(it);}
\DoxyCodeLine{23966                 \}}
\DoxyCodeLine{23967                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{23968                 \{}
\DoxyCodeLine{23969                     JSON\_THROW(out\_of\_range::create(403, detail::concat(\textcolor{stringliteral}{"{}key '"{}}, last\_path, \textcolor{stringliteral}{"{}' not found"{}}), \textcolor{keyword}{this}));}
\DoxyCodeLine{23970                 \}}
\DoxyCodeLine{23971             \}}
\DoxyCodeLine{23972             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parent.\mbox{\hyperlink{classbasic__json_a89ea48a4e802ef81783c0c7ce89aa7bb}{is\_array}}())}
\DoxyCodeLine{23973             \{}
\DoxyCodeLine{23974                 \textcolor{comment}{// note erase performs range check}}
\DoxyCodeLine{23975                 parent.\mbox{\hyperlink{classbasic__json_a7a5ed019983b582705ef5ee43d15ca24}{erase}}(json\_pointer::template array\_index<basic\_json\_t>(last\_path));}
\DoxyCodeLine{23976             \}}
\DoxyCodeLine{23977         \};}
\DoxyCodeLine{23978 }
\DoxyCodeLine{23979         \textcolor{comment}{// type check: top level value must be an array}}
\DoxyCodeLine{23980         \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!json\_patch.\mbox{\hyperlink{classbasic__json_a89ea48a4e802ef81783c0c7ce89aa7bb}{is\_array}}()))}
\DoxyCodeLine{23981         \{}
\DoxyCodeLine{23982             JSON\_THROW(parse\_error::create(104, 0, \textcolor{stringliteral}{"{}JSON patch must be an array of objects"{}}, \&json\_patch));}
\DoxyCodeLine{23983         \}}
\DoxyCodeLine{23984 }
\DoxyCodeLine{23985         \textcolor{comment}{// iterate and apply the operations}}
\DoxyCodeLine{23986         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& val : json\_patch)}
\DoxyCodeLine{23987         \{}
\DoxyCodeLine{23988             \textcolor{comment}{// wrapper to get a value for an operation}}
\DoxyCodeLine{23989             \textcolor{keyword}{const} \textcolor{keyword}{auto} get\_value = [\&val](\textcolor{keyword}{const} std::string \& op,}
\DoxyCodeLine{23990                                           \textcolor{keyword}{const} std::string \& member,}
\DoxyCodeLine{23991                                           \textcolor{keywordtype}{bool} string\_type) -\/> \mbox{\hyperlink{classbasic__json}{basic\_json}} \&}
\DoxyCodeLine{23992             \{}
\DoxyCodeLine{23993                 \textcolor{comment}{// find value}}
\DoxyCodeLine{23994                 \textcolor{keyword}{auto} it = val.\mbox{\hyperlink{classbasic__json_a34bc6074bd3f9ac2bdab12ebc02d70f5}{m\_value}}.object-\/>find(member);}
\DoxyCodeLine{23995 }
\DoxyCodeLine{23996                 \textcolor{comment}{// context-\/sensitive error message}}
\DoxyCodeLine{23997                 \textcolor{keyword}{const} \textcolor{keyword}{auto} error\_msg = (op == \textcolor{stringliteral}{"{}op"{}}) ? \textcolor{stringliteral}{"{}operation"{}} : detail::concat(\textcolor{stringliteral}{"{}operation '"{}}, op, \textcolor{charliteral}{'\(\backslash\)''});}
\DoxyCodeLine{23998 }
\DoxyCodeLine{23999                 \textcolor{comment}{// check if desired value is present}}
\DoxyCodeLine{24000                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(it == val.m\_value.object-\/>end()))}
\DoxyCodeLine{24001                 \{}
\DoxyCodeLine{24002                     \textcolor{comment}{// NOLINTNEXTLINE(performance-\/inefficient-\/string-\/concatenation)}}
\DoxyCodeLine{24003                     JSON\_THROW(parse\_error::create(105, 0, detail::concat(error\_msg, \textcolor{stringliteral}{"{} must have member '"{}}, member, \textcolor{stringliteral}{"{}'"{}}), \&val));}
\DoxyCodeLine{24004                 \}}
\DoxyCodeLine{24005 }
\DoxyCodeLine{24006                 \textcolor{comment}{// check if result is of type string}}
\DoxyCodeLine{24007                 \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(string\_type \&\& !it-\/>second.is\_string()))}
\DoxyCodeLine{24008                 \{}
\DoxyCodeLine{24009                     \textcolor{comment}{// NOLINTNEXTLINE(performance-\/inefficient-\/string-\/concatenation)}}
\DoxyCodeLine{24010                     JSON\_THROW(parse\_error::create(105, 0, detail::concat(error\_msg, \textcolor{stringliteral}{"{} must have string member '"{}}, member, \textcolor{stringliteral}{"{}'"{}}), \&val));}
\DoxyCodeLine{24011                 \}}
\DoxyCodeLine{24012 }
\DoxyCodeLine{24013                 \textcolor{comment}{// no error: return value}}
\DoxyCodeLine{24014                 \textcolor{keywordflow}{return} it-\/>second;}
\DoxyCodeLine{24015             \};}
\DoxyCodeLine{24016 }
\DoxyCodeLine{24017             \textcolor{comment}{// type check: every element of the array must be an object}}
\DoxyCodeLine{24018             \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!val.is\_object()))}
\DoxyCodeLine{24019             \{}
\DoxyCodeLine{24020                 JSON\_THROW(parse\_error::create(104, 0, \textcolor{stringliteral}{"{}JSON patch must be an array of objects"{}}, \&val));}
\DoxyCodeLine{24021             \}}
\DoxyCodeLine{24022 }
\DoxyCodeLine{24023             \textcolor{comment}{// collect mandatory members}}
\DoxyCodeLine{24024             \textcolor{keyword}{const} \textcolor{keyword}{auto} op = get\_value(\textcolor{stringliteral}{"{}op"{}}, \textcolor{stringliteral}{"{}op"{}}, \textcolor{keyword}{true}).template get<std::string>();}
\DoxyCodeLine{24025             \textcolor{keyword}{const} \textcolor{keyword}{auto} path = get\_value(op, \textcolor{stringliteral}{"{}path"{}}, \textcolor{keyword}{true}).template get<std::string>();}
\DoxyCodeLine{24026             \mbox{\hyperlink{classjson__pointer}{json\_pointer}} ptr(path);}
\DoxyCodeLine{24027 }
\DoxyCodeLine{24028             \textcolor{keywordflow}{switch} (get\_op(op))}
\DoxyCodeLine{24029             \{}
\DoxyCodeLine{24030                 \textcolor{keywordflow}{case} patch\_operations::add:}
\DoxyCodeLine{24031                 \{}
\DoxyCodeLine{24032                     operation\_add(ptr, get\_value(\textcolor{stringliteral}{"{}add"{}}, \textcolor{stringliteral}{"{}value"{}}, \textcolor{keyword}{false}));}
\DoxyCodeLine{24033                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{24034                 \}}
\DoxyCodeLine{24035 }
\DoxyCodeLine{24036                 \textcolor{keywordflow}{case} patch\_operations::remove:}
\DoxyCodeLine{24037                 \{}
\DoxyCodeLine{24038                     operation\_remove(ptr);}
\DoxyCodeLine{24039                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{24040                 \}}
\DoxyCodeLine{24041 }
\DoxyCodeLine{24042                 \textcolor{keywordflow}{case} patch\_operations::replace:}
\DoxyCodeLine{24043                 \{}
\DoxyCodeLine{24044                     \textcolor{comment}{// the "{}path"{} location must exist -\/ use at()}}
\DoxyCodeLine{24045                     result.\mbox{\hyperlink{classbasic__json_a603779687f401ad11de45f8397f92296}{at}}(ptr) = get\_value(\textcolor{stringliteral}{"{}replace"{}}, \textcolor{stringliteral}{"{}value"{}}, \textcolor{keyword}{false});}
\DoxyCodeLine{24046                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{24047                 \}}
\DoxyCodeLine{24048 }
\DoxyCodeLine{24049                 \textcolor{keywordflow}{case} patch\_operations::move:}
\DoxyCodeLine{24050                 \{}
\DoxyCodeLine{24051                     \textcolor{keyword}{const} \textcolor{keyword}{auto} from\_path = get\_value(\textcolor{stringliteral}{"{}move"{}}, \textcolor{stringliteral}{"{}from"{}}, \textcolor{keyword}{true}).template get<std::string>();}
\DoxyCodeLine{24052                     \mbox{\hyperlink{classjson__pointer}{json\_pointer}} from\_ptr(from\_path);}
\DoxyCodeLine{24053 }
\DoxyCodeLine{24054                     \textcolor{comment}{// the "{}from"{} location must exist -\/ use at()}}
\DoxyCodeLine{24055                     \mbox{\hyperlink{classbasic__json}{basic\_json}} v = result.\mbox{\hyperlink{classbasic__json_a603779687f401ad11de45f8397f92296}{at}}(from\_ptr);}
\DoxyCodeLine{24056 }
\DoxyCodeLine{24057                     \textcolor{comment}{// The move operation is functionally identical to a}}
\DoxyCodeLine{24058                     \textcolor{comment}{// "{}remove"{} operation on the "{}from"{} location, followed}}
\DoxyCodeLine{24059                     \textcolor{comment}{// immediately by an "{}add"{} operation at the target}}
\DoxyCodeLine{24060                     \textcolor{comment}{// location with the value that was just removed.}}
\DoxyCodeLine{24061                     operation\_remove(from\_ptr);}
\DoxyCodeLine{24062                     operation\_add(ptr, v);}
\DoxyCodeLine{24063                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{24064                 \}}
\DoxyCodeLine{24065 }
\DoxyCodeLine{24066                 \textcolor{keywordflow}{case} patch\_operations::copy:}
\DoxyCodeLine{24067                 \{}
\DoxyCodeLine{24068                     \textcolor{keyword}{const} \textcolor{keyword}{auto} from\_path = get\_value(\textcolor{stringliteral}{"{}copy"{}}, \textcolor{stringliteral}{"{}from"{}}, \textcolor{keyword}{true}).template get<std::string>();}
\DoxyCodeLine{24069                     \textcolor{keyword}{const} \mbox{\hyperlink{classjson__pointer}{json\_pointer}} from\_ptr(from\_path);}
\DoxyCodeLine{24070 }
\DoxyCodeLine{24071                     \textcolor{comment}{// the "{}from"{} location must exist -\/ use at()}}
\DoxyCodeLine{24072                     \mbox{\hyperlink{classbasic__json}{basic\_json}} v = result.\mbox{\hyperlink{classbasic__json_a603779687f401ad11de45f8397f92296}{at}}(from\_ptr);}
\DoxyCodeLine{24073 }
\DoxyCodeLine{24074                     \textcolor{comment}{// The copy is functionally identical to an "{}add"{}}}
\DoxyCodeLine{24075                     \textcolor{comment}{// operation at the target location using the value}}
\DoxyCodeLine{24076                     \textcolor{comment}{// specified in the "{}from"{} member.}}
\DoxyCodeLine{24077                     operation\_add(ptr, v);}
\DoxyCodeLine{24078                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{24079                 \}}
\DoxyCodeLine{24080 }
\DoxyCodeLine{24081                 \textcolor{keywordflow}{case} patch\_operations::test:}
\DoxyCodeLine{24082                 \{}
\DoxyCodeLine{24083                     \textcolor{keywordtype}{bool} success = \textcolor{keyword}{false};}
\DoxyCodeLine{24084                     JSON\_TRY}
\DoxyCodeLine{24085                     \{}
\DoxyCodeLine{24086                         \textcolor{comment}{// check if "{}value"{} matches the one at "{}path"{}}}
\DoxyCodeLine{24087                         \textcolor{comment}{// the "{}path"{} location must exist -\/ use at()}}
\DoxyCodeLine{24088                         success = (result.\mbox{\hyperlink{classbasic__json_a603779687f401ad11de45f8397f92296}{at}}(ptr) == get\_value(\textcolor{stringliteral}{"{}test"{}}, \textcolor{stringliteral}{"{}value"{}}, \textcolor{keyword}{false}));}
\DoxyCodeLine{24089                     \}}
\DoxyCodeLine{24090                     JSON\_INTERNAL\_CATCH (out\_of\_range\&)}
\DoxyCodeLine{24091                     \{}
\DoxyCodeLine{24092                         \textcolor{comment}{// ignore out of range errors: success remains false}}
\DoxyCodeLine{24093                     \}}
\DoxyCodeLine{24094 }
\DoxyCodeLine{24095                     \textcolor{comment}{// throw an exception if test fails}}
\DoxyCodeLine{24096                     \textcolor{keywordflow}{if} (JSON\_HEDLEY\_UNLIKELY(!success))}
\DoxyCodeLine{24097                     \{}
\DoxyCodeLine{24098                         JSON\_THROW(other\_error::create(501, detail::concat(\textcolor{stringliteral}{"{}unsuccessful: "{}}, val.dump()), \&val));}
\DoxyCodeLine{24099                     \}}
\DoxyCodeLine{24100 }
\DoxyCodeLine{24101                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{24102                 \}}
\DoxyCodeLine{24103 }
\DoxyCodeLine{24104                 \textcolor{keywordflow}{case} patch\_operations::invalid:}
\DoxyCodeLine{24105                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{24106                 \{}
\DoxyCodeLine{24107                     \textcolor{comment}{// op must be "{}add"{}, "{}remove"{}, "{}replace"{}, "{}move"{}, "{}copy"{}, or}}
\DoxyCodeLine{24108                     \textcolor{comment}{// "{}test"{}}}
\DoxyCodeLine{24109                     JSON\_THROW(parse\_error::create(105, 0, detail::concat(\textcolor{stringliteral}{"{}operation value '"{}}, op, \textcolor{stringliteral}{"{}' is invalid"{}}), \&val));}
\DoxyCodeLine{24110                 \}}
\DoxyCodeLine{24111             \}}
\DoxyCodeLine{24112         \}}
\DoxyCodeLine{24113     \}}
\DoxyCodeLine{24114 }
\DoxyCodeLine{24117     \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_a5a009b55b9dcdb30352f5f62537931b7}{patch}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& json\_patch)\textcolor{keyword}{ const}}
\DoxyCodeLine{24118 \textcolor{keyword}{    }\{}
\DoxyCodeLine{24119         \mbox{\hyperlink{classbasic__json}{basic\_json}} result = *\textcolor{keyword}{this};}
\DoxyCodeLine{24120         result.patch\_inplace(json\_patch);}
\DoxyCodeLine{24121         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{24122     \}}
\DoxyCodeLine{24123 }
\DoxyCodeLine{24126     JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}
\DoxyCodeLine{24127     \textcolor{keyword}{static} \mbox{\hyperlink{classbasic__json}{basic\_json}} \mbox{\hyperlink{classbasic__json_aff2204c04cd35b2cef35f44b2b93ffc7}{diff}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& source, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& target,}
\DoxyCodeLine{24128                            \textcolor{keyword}{const} std::string\& path = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{24129     \{}
\DoxyCodeLine{24130         \textcolor{comment}{// the patch}}
\DoxyCodeLine{24131         \mbox{\hyperlink{classbasic__json}{basic\_json}} result(value\_t::array);}
\DoxyCodeLine{24132 }
\DoxyCodeLine{24133         \textcolor{comment}{// if the values are the same, return empty patch}}
\DoxyCodeLine{24134         \textcolor{keywordflow}{if} (source == target)}
\DoxyCodeLine{24135         \{}
\DoxyCodeLine{24136             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{24137         \}}
\DoxyCodeLine{24138 }
\DoxyCodeLine{24139         \textcolor{keywordflow}{if} (source.\mbox{\hyperlink{classbasic__json_a1338e4eef7282cd57a4a57e034531029}{type}}() != target.\mbox{\hyperlink{classbasic__json_a1338e4eef7282cd57a4a57e034531029}{type}}())}
\DoxyCodeLine{24140         \{}
\DoxyCodeLine{24141             \textcolor{comment}{// different types: replace value}}
\DoxyCodeLine{24142             result.\mbox{\hyperlink{classbasic__json_a102e459f1d163cea963ed6fdda595cd3}{push\_back}}(}
\DoxyCodeLine{24143             \{}
\DoxyCodeLine{24144                 \{\textcolor{stringliteral}{"{}op"{}}, \textcolor{stringliteral}{"{}replace"{}}\}, \{\textcolor{stringliteral}{"{}path"{}}, path\}, \{\textcolor{stringliteral}{"{}value"{}}, target\}}
\DoxyCodeLine{24145             \});}
\DoxyCodeLine{24146             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{24147         \}}
\DoxyCodeLine{24148 }
\DoxyCodeLine{24149         \textcolor{keywordflow}{switch} (source.\mbox{\hyperlink{classbasic__json_a1338e4eef7282cd57a4a57e034531029}{type}}())}
\DoxyCodeLine{24150         \{}
\DoxyCodeLine{24151             \textcolor{keywordflow}{case} value\_t::array:}
\DoxyCodeLine{24152             \{}
\DoxyCodeLine{24153                 \textcolor{comment}{// first pass: traverse common elements}}
\DoxyCodeLine{24154                 std::size\_t i = 0;}
\DoxyCodeLine{24155                 \textcolor{keywordflow}{while} (i < source.size() \&\& i < target.size())}
\DoxyCodeLine{24156                 \{}
\DoxyCodeLine{24157                     \textcolor{comment}{// recursive call to compare array values at index i}}
\DoxyCodeLine{24158                     \textcolor{keyword}{auto} temp\_diff = diff(source[i], target[i], detail::concat(path, \textcolor{charliteral}{'/'}, std::to\_string(i)));}
\DoxyCodeLine{24159                     result.\mbox{\hyperlink{classbasic__json_a4467ec0c7679150140f9d2f85e95bf4b}{insert}}(result.end(), temp\_diff.begin(), temp\_diff.end());}
\DoxyCodeLine{24160                     ++i;}
\DoxyCodeLine{24161                 \}}
\DoxyCodeLine{24162 }
\DoxyCodeLine{24163                 \textcolor{comment}{// We now reached the end of at least one array}}
\DoxyCodeLine{24164                 \textcolor{comment}{// in a second pass, traverse the remaining elements}}
\DoxyCodeLine{24165 }
\DoxyCodeLine{24166                 \textcolor{comment}{// remove my remaining elements}}
\DoxyCodeLine{24167                 \textcolor{keyword}{const} \textcolor{keyword}{auto} end\_index = \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classbasic__json_a2fe32d636c1b78861884dde9716b22b6}{difference\_type}}\textcolor{keyword}{>}(result.size());}
\DoxyCodeLine{24168                 \textcolor{keywordflow}{while} (i < source.size())}
\DoxyCodeLine{24169                 \{}
\DoxyCodeLine{24170                     \textcolor{comment}{// add operations in reverse order to avoid invalid}}
\DoxyCodeLine{24171                     \textcolor{comment}{// indices}}
\DoxyCodeLine{24172                     result.\mbox{\hyperlink{classbasic__json_a4467ec0c7679150140f9d2f85e95bf4b}{insert}}(result.begin() + end\_index, object(}
\DoxyCodeLine{24173                     \{}
\DoxyCodeLine{24174                         \{\textcolor{stringliteral}{"{}op"{}}, \textcolor{stringliteral}{"{}remove"{}}\},}
\DoxyCodeLine{24175                         \{\textcolor{stringliteral}{"{}path"{}}, detail::concat(path, \textcolor{charliteral}{'/'}, std::to\_string(i))\}}
\DoxyCodeLine{24176                     \}));}
\DoxyCodeLine{24177                     ++i;}
\DoxyCodeLine{24178                 \}}
\DoxyCodeLine{24179 }
\DoxyCodeLine{24180                 \textcolor{comment}{// add other remaining elements}}
\DoxyCodeLine{24181                 \textcolor{keywordflow}{while} (i < target.size())}
\DoxyCodeLine{24182                 \{}
\DoxyCodeLine{24183                     result.\mbox{\hyperlink{classbasic__json_a102e459f1d163cea963ed6fdda595cd3}{push\_back}}(}
\DoxyCodeLine{24184                     \{}
\DoxyCodeLine{24185                         \{\textcolor{stringliteral}{"{}op"{}}, \textcolor{stringliteral}{"{}add"{}}\},}
\DoxyCodeLine{24186                         \{\textcolor{stringliteral}{"{}path"{}}, detail::concat(path, \textcolor{stringliteral}{"{}/-\/"{}})\},}
\DoxyCodeLine{24187                         \{\textcolor{stringliteral}{"{}value"{}}, target[i]\}}
\DoxyCodeLine{24188                     \});}
\DoxyCodeLine{24189                     ++i;}
\DoxyCodeLine{24190                 \}}
\DoxyCodeLine{24191 }
\DoxyCodeLine{24192                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{24193             \}}
\DoxyCodeLine{24194 }
\DoxyCodeLine{24195             \textcolor{keywordflow}{case} value\_t::object:}
\DoxyCodeLine{24196             \{}
\DoxyCodeLine{24197                 \textcolor{comment}{// first pass: traverse this object's elements}}
\DoxyCodeLine{24198                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = source.cbegin(); it != source.cend(); ++it)}
\DoxyCodeLine{24199                 \{}
\DoxyCodeLine{24200                     \textcolor{comment}{// escape the key name to be used in a JSON patch}}
\DoxyCodeLine{24201                     \textcolor{keyword}{const} \textcolor{keyword}{auto} path\_key = detail::concat(path, \textcolor{charliteral}{'/'}, \mbox{\hyperlink{namespacedetail_af2a9ce4740e0b45d33129e2c8e53a0a8}{detail::escape}}(it.key()));}
\DoxyCodeLine{24202 }
\DoxyCodeLine{24203                     \textcolor{keywordflow}{if} (target.\mbox{\hyperlink{classbasic__json_a8ed11f83edce392fd94659b1102d078e}{find}}(it.key()) != target.end())}
\DoxyCodeLine{24204                     \{}
\DoxyCodeLine{24205                         \textcolor{comment}{// recursive call to compare object values at key it}}
\DoxyCodeLine{24206                         \textcolor{keyword}{auto} temp\_diff = diff(it.value(), target[it.key()], path\_key);}
\DoxyCodeLine{24207                         result.\mbox{\hyperlink{classbasic__json_a4467ec0c7679150140f9d2f85e95bf4b}{insert}}(result.end(), temp\_diff.begin(), temp\_diff.end());}
\DoxyCodeLine{24208                     \}}
\DoxyCodeLine{24209                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{24210                     \{}
\DoxyCodeLine{24211                         \textcolor{comment}{// found a key that is not in o -\/> remove it}}
\DoxyCodeLine{24212                         result.\mbox{\hyperlink{classbasic__json_a102e459f1d163cea963ed6fdda595cd3}{push\_back}}(\textcolor{keywordtype}{object}(}
\DoxyCodeLine{24213                         \{}
\DoxyCodeLine{24214                             \{\textcolor{stringliteral}{"{}op"{}}, \textcolor{stringliteral}{"{}remove"{}}\}, \{\textcolor{stringliteral}{"{}path"{}}, path\_key\}}
\DoxyCodeLine{24215                         \}));}
\DoxyCodeLine{24216                     \}}
\DoxyCodeLine{24217                 \}}
\DoxyCodeLine{24218 }
\DoxyCodeLine{24219                 \textcolor{comment}{// second pass: traverse other object's elements}}
\DoxyCodeLine{24220                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = target.cbegin(); it != target.cend(); ++it)}
\DoxyCodeLine{24221                 \{}
\DoxyCodeLine{24222                     \textcolor{keywordflow}{if} (source.\mbox{\hyperlink{classbasic__json_a8ed11f83edce392fd94659b1102d078e}{find}}(it.key()) == source.end())}
\DoxyCodeLine{24223                     \{}
\DoxyCodeLine{24224                         \textcolor{comment}{// found a key that is not in this -\/> add it}}
\DoxyCodeLine{24225                         \textcolor{keyword}{const} \textcolor{keyword}{auto} path\_key = detail::concat(path, \textcolor{charliteral}{'/'}, \mbox{\hyperlink{namespacedetail_af2a9ce4740e0b45d33129e2c8e53a0a8}{detail::escape}}(it.key()));}
\DoxyCodeLine{24226                         result.\mbox{\hyperlink{classbasic__json_a102e459f1d163cea963ed6fdda595cd3}{push\_back}}(}
\DoxyCodeLine{24227                         \{}
\DoxyCodeLine{24228                             \{\textcolor{stringliteral}{"{}op"{}}, \textcolor{stringliteral}{"{}add"{}}\}, \{\textcolor{stringliteral}{"{}path"{}}, path\_key\},}
\DoxyCodeLine{24229                             \{\textcolor{stringliteral}{"{}value"{}}, it.value()\}}
\DoxyCodeLine{24230                         \});}
\DoxyCodeLine{24231                     \}}
\DoxyCodeLine{24232                 \}}
\DoxyCodeLine{24233 }
\DoxyCodeLine{24234                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{24235             \}}
\DoxyCodeLine{24236 }
\DoxyCodeLine{24237             \textcolor{keywordflow}{case} value\_t::null:}
\DoxyCodeLine{24238             \textcolor{keywordflow}{case} value\_t::string:}
\DoxyCodeLine{24239             \textcolor{keywordflow}{case} value\_t::boolean:}
\DoxyCodeLine{24240             \textcolor{keywordflow}{case} value\_t::number\_integer:}
\DoxyCodeLine{24241             \textcolor{keywordflow}{case} value\_t::number\_unsigned:}
\DoxyCodeLine{24242             \textcolor{keywordflow}{case} value\_t::number\_float:}
\DoxyCodeLine{24243             \textcolor{keywordflow}{case} value\_t::binary:}
\DoxyCodeLine{24244             \textcolor{keywordflow}{case} value\_t::discarded:}
\DoxyCodeLine{24245             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{24246             \{}
\DoxyCodeLine{24247                 \textcolor{comment}{// both primitive type: replace value}}
\DoxyCodeLine{24248                 result.\mbox{\hyperlink{classbasic__json_a102e459f1d163cea963ed6fdda595cd3}{push\_back}}(}
\DoxyCodeLine{24249                 \{}
\DoxyCodeLine{24250                     \{\textcolor{stringliteral}{"{}op"{}}, \textcolor{stringliteral}{"{}replace"{}}\}, \{\textcolor{stringliteral}{"{}path"{}}, path\}, \{\textcolor{stringliteral}{"{}value"{}}, target\}}
\DoxyCodeLine{24251                 \});}
\DoxyCodeLine{24252                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{24253             \}}
\DoxyCodeLine{24254         \}}
\DoxyCodeLine{24255 }
\DoxyCodeLine{24256         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{24257     \}}
\DoxyCodeLine{24259 }
\DoxyCodeLine{24261     \textcolor{comment}{// JSON Merge Patch functions //}}
\DoxyCodeLine{24263 \textcolor{comment}{}}
\DoxyCodeLine{24266 }
\DoxyCodeLine{24269     \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__json_a1c7ab88eb6d043b434cd9e0b68ec7321}{merge\_patch}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__json}{basic\_json}}\& apply\_patch)}
\DoxyCodeLine{24270     \{}
\DoxyCodeLine{24271         \textcolor{keywordflow}{if} (apply\_patch.\mbox{\hyperlink{classbasic__json_af758a912346776b086abb82487b1d73b}{is\_object}}())}
\DoxyCodeLine{24272         \{}
\DoxyCodeLine{24273             \textcolor{keywordflow}{if} (!is\_object())}
\DoxyCodeLine{24274             \{}
\DoxyCodeLine{24275                 *\textcolor{keyword}{this} = object();}
\DoxyCodeLine{24276             \}}
\DoxyCodeLine{24277             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = apply\_patch.begin(); it != apply\_patch.end(); ++it)}
\DoxyCodeLine{24278             \{}
\DoxyCodeLine{24279                 \textcolor{keywordflow}{if} (it.value().is\_null())}
\DoxyCodeLine{24280                 \{}
\DoxyCodeLine{24281                     erase(it.key());}
\DoxyCodeLine{24282                 \}}
\DoxyCodeLine{24283                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{24284                 \{}
\DoxyCodeLine{24285                     operator[](it.key()).merge\_patch(it.value());}
\DoxyCodeLine{24286                 \}}
\DoxyCodeLine{24287             \}}
\DoxyCodeLine{24288         \}}
\DoxyCodeLine{24289         \textcolor{keywordflow}{else}}
\DoxyCodeLine{24290         \{}
\DoxyCodeLine{24291             *\textcolor{keyword}{this} = apply\_patch;}
\DoxyCodeLine{24292         \}}
\DoxyCodeLine{24293     \}}
\DoxyCodeLine{24294 }
\DoxyCodeLine{24296 \};}
\DoxyCodeLine{24297 }
\DoxyCodeLine{24300 NLOHMANN\_BASIC\_JSON\_TPL\_DECLARATION}
\DoxyCodeLine{24301 std::string to\_string(\textcolor{keyword}{const} NLOHMANN\_BASIC\_JSON\_TPL\& j)}
\DoxyCodeLine{24302 \{}
\DoxyCodeLine{24303     \textcolor{keywordflow}{return} j.dump();}
\DoxyCodeLine{24304 \}}
\DoxyCodeLine{24305 }
\DoxyCodeLine{24306 \textcolor{keyword}{inline} \textcolor{keyword}{namespace }literals}
\DoxyCodeLine{24307 \{}
\DoxyCodeLine{24308 \textcolor{keyword}{inline} \textcolor{keyword}{namespace }json\_literals}
\DoxyCodeLine{24309 \{}
\DoxyCodeLine{24310 }
\DoxyCodeLine{24313 JSON\_HEDLEY\_NON\_NULL(1)}
\DoxyCodeLine{24314 inline nlohmann::\mbox{\hyperlink{classbasic__json}{json}} operator "{}"{} \_json(const \textcolor{keywordtype}{char}* s, std::\textcolor{keywordtype}{size\_t} n)}
\DoxyCodeLine{24315 \{}
\DoxyCodeLine{24316     \textcolor{keywordflow}{return} nlohmann::json::parse(s, s + n);}
\DoxyCodeLine{24317 \}}
\DoxyCodeLine{24318 }
\DoxyCodeLine{24321 JSON\_HEDLEY\_NON\_NULL(1)}
\DoxyCodeLine{24322 inline nlohmann::\mbox{\hyperlink{classbasic__json}{json}}::\mbox{\hyperlink{classjson__pointer}{json\_pointer}} operator "{}"{} \_json\_pointer(const \textcolor{keywordtype}{char}* s, std::\textcolor{keywordtype}{size\_t} n)}
\DoxyCodeLine{24323 \{}
\DoxyCodeLine{24324     \textcolor{keywordflow}{return} nlohmann::json::json\_pointer(std::string(s, n));}
\DoxyCodeLine{24325 \}}
\DoxyCodeLine{24326 }
\DoxyCodeLine{24327 \}  \textcolor{comment}{// namespace json\_literals}}
\DoxyCodeLine{24328 \}  \textcolor{comment}{// namespace literals}}
\DoxyCodeLine{24329 NLOHMANN\_JSON\_NAMESPACE\_END}
\DoxyCodeLine{24330 }
\DoxyCodeLine{24332 \textcolor{comment}{// nonmember support //}}
\DoxyCodeLine{24334 \textcolor{comment}{}}
\DoxyCodeLine{24335 \textcolor{keyword}{namespace }std \textcolor{comment}{// NOLINT(cert-\/dcl58-\/cpp)}}
\DoxyCodeLine{24336 \{}
\DoxyCodeLine{24337 }
\DoxyCodeLine{24340 NLOHMANN\_BASIC\_JSON\_TPL\_DECLARATION}
\DoxyCodeLine{24341 \textcolor{keyword}{struct }hash<nlohmann::NLOHMANN\_BASIC\_JSON\_TPL>}
\DoxyCodeLine{24342 \{}
\DoxyCodeLine{24343     std::size\_t operator()(\textcolor{keyword}{const} nlohmann::NLOHMANN\_BASIC\_JSON\_TPL\& j)\textcolor{keyword}{ const}}
\DoxyCodeLine{24344 \textcolor{keyword}{    }\{}
\DoxyCodeLine{24345         \textcolor{keywordflow}{return} nlohmann::detail::hash(j);}
\DoxyCodeLine{24346     \}}
\DoxyCodeLine{24347 \};}
\DoxyCodeLine{24348 }
\DoxyCodeLine{24349 \textcolor{comment}{// specialization for std::less<value\_t>}}
\DoxyCodeLine{24350 \textcolor{keyword}{template}<>}
\DoxyCodeLine{24351 \textcolor{keyword}{struct }less< ::nlohmann::detail::value\_t> \textcolor{comment}{// do not remove the space after '<', see https://github.com/nlohmann/json/pull/679}}
\DoxyCodeLine{24352 \{}
\DoxyCodeLine{24357     \textcolor{keywordtype}{bool} \mbox{\hyperlink{structstd_1_1less_3_01_1_1nlohmann_1_1detail_1_1value__t_01_4_acb798e1a5706e5e08b18ca182cd17027}{operator()}}(::nlohmann::detail::value\_t lhs,}
\DoxyCodeLine{24358                     ::nlohmann::detail::value\_t rhs) \textcolor{keyword}{const} \textcolor{keyword}{noexcept}}
\DoxyCodeLine{24359     \{}
\DoxyCodeLine{24360 \textcolor{preprocessor}{\#if JSON\_HAS\_THREE\_WAY\_COMPARISON}}
\DoxyCodeLine{24361         \textcolor{keywordflow}{return} std::is\_lt(lhs <=> rhs); \textcolor{comment}{// *NOPAD*}}
\DoxyCodeLine{24362 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{24363         return ::nlohmann::detail::operator<(lhs, rhs);}
\DoxyCodeLine{24364 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{24365     \}}
\DoxyCodeLine{24366 \};}
\DoxyCodeLine{24367 }
\DoxyCodeLine{24368 \textcolor{comment}{// C++20 prohibit function specialization in the std namespace.}}
\DoxyCodeLine{24369 \textcolor{preprocessor}{\#ifndef JSON\_HAS\_CPP\_20}}
\DoxyCodeLine{24370 }
\DoxyCodeLine{24373 NLOHMANN\_BASIC\_JSON\_TPL\_DECLARATION}
\DoxyCodeLine{24374 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} swap(nlohmann::NLOHMANN\_BASIC\_JSON\_TPL\& j1, nlohmann::NLOHMANN\_BASIC\_JSON\_TPL\& j2) \textcolor{keyword}{noexcept}(  \textcolor{comment}{// NOLINT(readability-\/inconsistent-\/declaration-\/parameter-\/name)}}
\DoxyCodeLine{24375     is\_nothrow\_move\_constructible<nlohmann::NLOHMANN\_BASIC\_JSON\_TPL>::value\&\&                          \textcolor{comment}{// NOLINT(misc-\/redundant-\/expression)}}
\DoxyCodeLine{24376     is\_nothrow\_move\_assignable<nlohmann::NLOHMANN\_BASIC\_JSON\_TPL>::value)}
\DoxyCodeLine{24377 \{}
\DoxyCodeLine{24378     j1.swap(j2);}
\DoxyCodeLine{24379 \}}
\DoxyCodeLine{24380 }
\DoxyCodeLine{24381 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{24382 }
\DoxyCodeLine{24383 \}  \textcolor{comment}{// namespace std}}
\DoxyCodeLine{24384 }
\DoxyCodeLine{24385 \textcolor{preprocessor}{\#if JSON\_USE\_GLOBAL\_UDLS}}
\DoxyCodeLine{24386     \textcolor{keyword}{using }nlohmann::literals::json\_literals::operator \textcolor{stringliteral}{"{}"{}} \_json; \textcolor{comment}{// NOLINT(misc-\/unused-\/using-\/decls,google-\/global-\/names-\/in-\/headers)}}
\DoxyCodeLine{24387     \textcolor{keyword}{using }nlohmann::literals::json\_literals::operator \textcolor{stringliteral}{"{}"{}} \_json\_pointer; \textcolor{comment}{//NOLINT(misc-\/unused-\/using-\/decls,google-\/global-\/names-\/in-\/headers)}}
\DoxyCodeLine{24388 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{24389 }
\DoxyCodeLine{24390 \textcolor{comment}{// \#include <nlohmann/detail/macro\_unscope.hpp>}}
\DoxyCodeLine{24391 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{24392 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{24393 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{24394 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{24395 \textcolor{comment}{//}}
\DoxyCodeLine{24396 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{24397 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{24398 }
\DoxyCodeLine{24399 }
\DoxyCodeLine{24400 }
\DoxyCodeLine{24401 \textcolor{comment}{// restore clang diagnostic settings}}
\DoxyCodeLine{24402 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{24403 \textcolor{preprocessor}{    \#pragma clang diagnostic pop}}
\DoxyCodeLine{24404 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{24405 }
\DoxyCodeLine{24406 \textcolor{comment}{// clean up}}
\DoxyCodeLine{24407 \textcolor{preprocessor}{\#undef JSON\_ASSERT}}
\DoxyCodeLine{24408 \textcolor{preprocessor}{\#undef JSON\_INTERNAL\_CATCH}}
\DoxyCodeLine{24409 \textcolor{preprocessor}{\#undef JSON\_THROW}}
\DoxyCodeLine{24410 \textcolor{preprocessor}{\#undef JSON\_PRIVATE\_UNLESS\_TESTED}}
\DoxyCodeLine{24411 \textcolor{preprocessor}{\#undef NLOHMANN\_BASIC\_JSON\_TPL\_DECLARATION}}
\DoxyCodeLine{24412 \textcolor{preprocessor}{\#undef NLOHMANN\_BASIC\_JSON\_TPL}}
\DoxyCodeLine{24413 \textcolor{preprocessor}{\#undef JSON\_EXPLICIT}}
\DoxyCodeLine{24414 \textcolor{preprocessor}{\#undef NLOHMANN\_CAN\_CALL\_STD\_FUNC\_IMPL}}
\DoxyCodeLine{24415 \textcolor{preprocessor}{\#undef JSON\_INLINE\_VARIABLE}}
\DoxyCodeLine{24416 \textcolor{preprocessor}{\#undef JSON\_NO\_UNIQUE\_ADDRESS}}
\DoxyCodeLine{24417 \textcolor{preprocessor}{\#undef JSON\_DISABLE\_ENUM\_SERIALIZATION}}
\DoxyCodeLine{24418 \textcolor{preprocessor}{\#undef JSON\_USE\_GLOBAL\_UDLS}}
\DoxyCodeLine{24419 }
\DoxyCodeLine{24420 \textcolor{preprocessor}{\#ifndef JSON\_TEST\_KEEP\_MACROS}}
\DoxyCodeLine{24421 \textcolor{preprocessor}{    \#undef JSON\_CATCH}}
\DoxyCodeLine{24422 \textcolor{preprocessor}{    \#undef JSON\_TRY}}
\DoxyCodeLine{24423 \textcolor{preprocessor}{    \#undef JSON\_HAS\_CPP\_11}}
\DoxyCodeLine{24424 \textcolor{preprocessor}{    \#undef JSON\_HAS\_CPP\_14}}
\DoxyCodeLine{24425 \textcolor{preprocessor}{    \#undef JSON\_HAS\_CPP\_17}}
\DoxyCodeLine{24426 \textcolor{preprocessor}{    \#undef JSON\_HAS\_CPP\_20}}
\DoxyCodeLine{24427 \textcolor{preprocessor}{    \#undef JSON\_HAS\_FILESYSTEM}}
\DoxyCodeLine{24428 \textcolor{preprocessor}{    \#undef JSON\_HAS\_EXPERIMENTAL\_FILESYSTEM}}
\DoxyCodeLine{24429 \textcolor{preprocessor}{    \#undef JSON\_HAS\_THREE\_WAY\_COMPARISON}}
\DoxyCodeLine{24430 \textcolor{preprocessor}{    \#undef JSON\_HAS\_RANGES}}
\DoxyCodeLine{24431 \textcolor{preprocessor}{    \#undef JSON\_USE\_LEGACY\_DISCARDED\_VALUE\_COMPARISON}}
\DoxyCodeLine{24432 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{24433 }
\DoxyCodeLine{24434 \textcolor{comment}{// \#include <nlohmann/thirdparty/hedley/hedley\_undef.hpp>}}
\DoxyCodeLine{24435 \textcolor{comment}{//     \_\_ \_\_\_\_\_ \_\_\_\_\_ \_\_\_\_\_}}
\DoxyCodeLine{24436 \textcolor{comment}{//  \_\_|  |   \_\_|     |   | |  JSON for Modern C++}}
\DoxyCodeLine{24437 \textcolor{comment}{// |  |  |\_\_   |  |  | | | |  version 3.11.2}}
\DoxyCodeLine{24438 \textcolor{comment}{// |\_\_\_\_\_|\_\_\_\_\_|\_\_\_\_\_|\_|\_\_\_|  https://github.com/nlohmann/json}}
\DoxyCodeLine{24439 \textcolor{comment}{//}}
\DoxyCodeLine{24440 \textcolor{comment}{// SPDX-\/FileCopyrightText: 2013-\/2022 Niels Lohmann <https://nlohmann.me>}}
\DoxyCodeLine{24441 \textcolor{comment}{// SPDX-\/License-\/Identifier: MIT}}
\DoxyCodeLine{24442 }
\DoxyCodeLine{24443 }
\DoxyCodeLine{24444 }
\DoxyCodeLine{24445 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_ALWAYS\_INLINE}}
\DoxyCodeLine{24446 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_ARM\_VERSION}}
\DoxyCodeLine{24447 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_ARM\_VERSION\_CHECK}}
\DoxyCodeLine{24448 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_ARRAY\_PARAM}}
\DoxyCodeLine{24449 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_ASSUME}}
\DoxyCodeLine{24450 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_BEGIN\_C\_DECLS}}
\DoxyCodeLine{24451 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CLANG\_HAS\_ATTRIBUTE}}
\DoxyCodeLine{24452 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CLANG\_HAS\_BUILTIN}}
\DoxyCodeLine{24453 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CLANG\_HAS\_CPP\_ATTRIBUTE}}
\DoxyCodeLine{24454 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CLANG\_HAS\_DECLSPEC\_DECLSPEC\_ATTRIBUTE}}
\DoxyCodeLine{24455 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CLANG\_HAS\_EXTENSION}}
\DoxyCodeLine{24456 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CLANG\_HAS\_FEATURE}}
\DoxyCodeLine{24457 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CLANG\_HAS\_WARNING}}
\DoxyCodeLine{24458 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_COMPCERT\_VERSION}}
\DoxyCodeLine{24459 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_COMPCERT\_VERSION\_CHECK}}
\DoxyCodeLine{24460 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CONCAT}}
\DoxyCodeLine{24461 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CONCAT3}}
\DoxyCodeLine{24462 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CONCAT3\_EX}}
\DoxyCodeLine{24463 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CONCAT\_EX}}
\DoxyCodeLine{24464 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CONST}}
\DoxyCodeLine{24465 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CONSTEXPR}}
\DoxyCodeLine{24466 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CONST\_CAST}}
\DoxyCodeLine{24467 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CPP\_CAST}}
\DoxyCodeLine{24468 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CRAY\_VERSION}}
\DoxyCodeLine{24469 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_CRAY\_VERSION\_CHECK}}
\DoxyCodeLine{24470 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_C\_DECL}}
\DoxyCodeLine{24471 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DEPRECATED}}
\DoxyCodeLine{24472 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DEPRECATED\_FOR}}
\DoxyCodeLine{24473 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CAST\_QUAL}}
\DoxyCodeLine{24474 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_CPP98\_COMPAT\_WRAP\_}}
\DoxyCodeLine{24475 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_DEPRECATED}}
\DoxyCodeLine{24476 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_CPP\_ATTRIBUTES}}
\DoxyCodeLine{24477 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNKNOWN\_PRAGMAS}}
\DoxyCodeLine{24478 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DIAGNOSTIC\_DISABLE\_UNUSED\_FUNCTION}}
\DoxyCodeLine{24479 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DIAGNOSTIC\_POP}}
\DoxyCodeLine{24480 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DIAGNOSTIC\_PUSH}}
\DoxyCodeLine{24481 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DMC\_VERSION}}
\DoxyCodeLine{24482 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_DMC\_VERSION\_CHECK}}
\DoxyCodeLine{24483 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_EMPTY\_BASES}}
\DoxyCodeLine{24484 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_EMSCRIPTEN\_VERSION}}
\DoxyCodeLine{24485 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_EMSCRIPTEN\_VERSION\_CHECK}}
\DoxyCodeLine{24486 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_END\_C\_DECLS}}
\DoxyCodeLine{24487 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_FLAGS}}
\DoxyCodeLine{24488 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_FLAGS\_CAST}}
\DoxyCodeLine{24489 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GCC\_HAS\_ATTRIBUTE}}
\DoxyCodeLine{24490 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GCC\_HAS\_BUILTIN}}
\DoxyCodeLine{24491 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GCC\_HAS\_CPP\_ATTRIBUTE}}
\DoxyCodeLine{24492 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GCC\_HAS\_DECLSPEC\_ATTRIBUTE}}
\DoxyCodeLine{24493 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GCC\_HAS\_EXTENSION}}
\DoxyCodeLine{24494 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GCC\_HAS\_FEATURE}}
\DoxyCodeLine{24495 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GCC\_HAS\_WARNING}}
\DoxyCodeLine{24496 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GCC\_NOT\_CLANG\_VERSION\_CHECK}}
\DoxyCodeLine{24497 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GCC\_VERSION}}
\DoxyCodeLine{24498 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GCC\_VERSION\_CHECK}}
\DoxyCodeLine{24499 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GNUC\_HAS\_ATTRIBUTE}}
\DoxyCodeLine{24500 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GNUC\_HAS\_BUILTIN}}
\DoxyCodeLine{24501 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GNUC\_HAS\_CPP\_ATTRIBUTE}}
\DoxyCodeLine{24502 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GNUC\_HAS\_DECLSPEC\_ATTRIBUTE}}
\DoxyCodeLine{24503 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GNUC\_HAS\_EXTENSION}}
\DoxyCodeLine{24504 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GNUC\_HAS\_FEATURE}}
\DoxyCodeLine{24505 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GNUC\_HAS\_WARNING}}
\DoxyCodeLine{24506 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GNUC\_VERSION}}
\DoxyCodeLine{24507 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_GNUC\_VERSION\_CHECK}}
\DoxyCodeLine{24508 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_HAS\_ATTRIBUTE}}
\DoxyCodeLine{24509 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_HAS\_BUILTIN}}
\DoxyCodeLine{24510 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE}}
\DoxyCodeLine{24511 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_HAS\_CPP\_ATTRIBUTE\_NS}}
\DoxyCodeLine{24512 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_HAS\_DECLSPEC\_ATTRIBUTE}}
\DoxyCodeLine{24513 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_HAS\_EXTENSION}}
\DoxyCodeLine{24514 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_HAS\_FEATURE}}
\DoxyCodeLine{24515 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_HAS\_WARNING}}
\DoxyCodeLine{24516 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_IAR\_VERSION}}
\DoxyCodeLine{24517 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_IAR\_VERSION\_CHECK}}
\DoxyCodeLine{24518 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_IBM\_VERSION}}
\DoxyCodeLine{24519 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_IBM\_VERSION\_CHECK}}
\DoxyCodeLine{24520 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_IMPORT}}
\DoxyCodeLine{24521 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_INLINE}}
\DoxyCodeLine{24522 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_INTEL\_CL\_VERSION}}
\DoxyCodeLine{24523 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_INTEL\_CL\_VERSION\_CHECK}}
\DoxyCodeLine{24524 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_INTEL\_VERSION}}
\DoxyCodeLine{24525 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_INTEL\_VERSION\_CHECK}}
\DoxyCodeLine{24526 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_IS\_CONSTANT}}
\DoxyCodeLine{24527 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_IS\_CONSTEXPR\_}}
\DoxyCodeLine{24528 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_LIKELY}}
\DoxyCodeLine{24529 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_MALLOC}}
\DoxyCodeLine{24530 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_MCST\_LCC\_VERSION}}
\DoxyCodeLine{24531 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_MCST\_LCC\_VERSION\_CHECK}}
\DoxyCodeLine{24532 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_MESSAGE}}
\DoxyCodeLine{24533 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_MSVC\_VERSION}}
\DoxyCodeLine{24534 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_MSVC\_VERSION\_CHECK}}
\DoxyCodeLine{24535 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_NEVER\_INLINE}}
\DoxyCodeLine{24536 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_NON\_NULL}}
\DoxyCodeLine{24537 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_NO\_ESCAPE}}
\DoxyCodeLine{24538 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_NO\_RETURN}}
\DoxyCodeLine{24539 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_NO\_THROW}}
\DoxyCodeLine{24540 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_NULL}}
\DoxyCodeLine{24541 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_PELLES\_VERSION}}
\DoxyCodeLine{24542 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_PELLES\_VERSION\_CHECK}}
\DoxyCodeLine{24543 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_PGI\_VERSION}}
\DoxyCodeLine{24544 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_PGI\_VERSION\_CHECK}}
\DoxyCodeLine{24545 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_PREDICT}}
\DoxyCodeLine{24546 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_PRINTF\_FORMAT}}
\DoxyCodeLine{24547 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_PRIVATE}}
\DoxyCodeLine{24548 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_PUBLIC}}
\DoxyCodeLine{24549 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_PURE}}
\DoxyCodeLine{24550 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_REINTERPRET\_CAST}}
\DoxyCodeLine{24551 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_REQUIRE}}
\DoxyCodeLine{24552 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_REQUIRE\_CONSTEXPR}}
\DoxyCodeLine{24553 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_REQUIRE\_MSG}}
\DoxyCodeLine{24554 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_RESTRICT}}
\DoxyCodeLine{24555 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_RETURNS\_NON\_NULL}}
\DoxyCodeLine{24556 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_SENTINEL}}
\DoxyCodeLine{24557 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_STATIC\_ASSERT}}
\DoxyCodeLine{24558 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_STATIC\_CAST}}
\DoxyCodeLine{24559 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_STRINGIFY}}
\DoxyCodeLine{24560 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_STRINGIFY\_EX}}
\DoxyCodeLine{24561 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_SUNPRO\_VERSION}}
\DoxyCodeLine{24562 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_SUNPRO\_VERSION\_CHECK}}
\DoxyCodeLine{24563 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TINYC\_VERSION}}
\DoxyCodeLine{24564 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TINYC\_VERSION\_CHECK}}
\DoxyCodeLine{24565 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_ARMCL\_VERSION}}
\DoxyCodeLine{24566 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_ARMCL\_VERSION\_CHECK}}
\DoxyCodeLine{24567 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_CL2000\_VERSION}}
\DoxyCodeLine{24568 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_CL2000\_VERSION\_CHECK}}
\DoxyCodeLine{24569 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_CL430\_VERSION}}
\DoxyCodeLine{24570 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_CL430\_VERSION\_CHECK}}
\DoxyCodeLine{24571 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_CL6X\_VERSION}}
\DoxyCodeLine{24572 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_CL6X\_VERSION\_CHECK}}
\DoxyCodeLine{24573 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_CL7X\_VERSION}}
\DoxyCodeLine{24574 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_CL7X\_VERSION\_CHECK}}
\DoxyCodeLine{24575 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_CLPRU\_VERSION}}
\DoxyCodeLine{24576 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_CLPRU\_VERSION\_CHECK}}
\DoxyCodeLine{24577 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_VERSION}}
\DoxyCodeLine{24578 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_TI\_VERSION\_CHECK}}
\DoxyCodeLine{24579 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_UNAVAILABLE}}
\DoxyCodeLine{24580 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_UNLIKELY}}
\DoxyCodeLine{24581 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_UNPREDICTABLE}}
\DoxyCodeLine{24582 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_UNREACHABLE}}
\DoxyCodeLine{24583 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_UNREACHABLE\_RETURN}}
\DoxyCodeLine{24584 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_VERSION}}
\DoxyCodeLine{24585 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_VERSION\_DECODE\_MAJOR}}
\DoxyCodeLine{24586 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_VERSION\_DECODE\_MINOR}}
\DoxyCodeLine{24587 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_VERSION\_DECODE\_REVISION}}
\DoxyCodeLine{24588 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_VERSION\_ENCODE}}
\DoxyCodeLine{24589 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_WARNING}}
\DoxyCodeLine{24590 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_WARN\_UNUSED\_RESULT}}
\DoxyCodeLine{24591 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_WARN\_UNUSED\_RESULT\_MSG}}
\DoxyCodeLine{24592 \textcolor{preprocessor}{\#undef JSON\_HEDLEY\_FALL\_THROUGH}}
\DoxyCodeLine{24593 }
\DoxyCodeLine{24594 }
\DoxyCodeLine{24595 }
\DoxyCodeLine{24596 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// INCLUDE\_NLOHMANN\_JSON\_HPP\_}}

\end{DoxyCode}
